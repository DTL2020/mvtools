; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\sadfunctions_avx2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
PUBLIC	??$Sad16_avx2@$07$01G@@YAIPBEH0H@Z		; Sad16_avx2<8,2,unsigned short>
PUBLIC	??$Sad16_avx2@$07$03G@@YAIPBEH0H@Z		; Sad16_avx2<8,4,unsigned short>
PUBLIC	??$Sad16_avx2@$07$07G@@YAIPBEH0H@Z		; Sad16_avx2<8,8,unsigned short>
PUBLIC	??$Sad16_avx2@$07$0BA@G@@YAIPBEH0H@Z		; Sad16_avx2<8,16,unsigned short>
PUBLIC	??$Sad16_avx2@$0BA@$00G@@YAIPBEH0H@Z		; Sad16_avx2<16,1,unsigned short>
PUBLIC	??$Sad16_avx2@$0BA@$01G@@YAIPBEH0H@Z		; Sad16_avx2<16,2,unsigned short>
PUBLIC	??$Sad16_avx2@$0BA@$03G@@YAIPBEH0H@Z		; Sad16_avx2<16,4,unsigned short>
PUBLIC	??$Sad16_avx2@$0BA@$07G@@YAIPBEH0H@Z		; Sad16_avx2<16,8,unsigned short>
PUBLIC	??$Sad16_avx2@$0BA@$0BA@G@@YAIPBEH0H@Z		; Sad16_avx2<16,16,unsigned short>
PUBLIC	??$Sad16_avx2@$0BA@$0CA@G@@YAIPBEH0H@Z		; Sad16_avx2<16,32,unsigned short>
PUBLIC	??$Sad16_avx2@$0CA@$07G@@YAIPBEH0H@Z		; Sad16_avx2<32,8,unsigned short>
PUBLIC	??$Sad16_avx2@$0CA@$0BA@G@@YAIPBEH0H@Z		; Sad16_avx2<32,16,unsigned short>
PUBLIC	??$Sad16_avx2@$0CA@$0CA@G@@YAIPBEH0H@Z		; Sad16_avx2<32,32,unsigned short>
PUBLIC	?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_sad_avx2_C_function
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 16
$T3 = -44						; size = 16
$T4 = -44						; size = 16
$T5 = -44						; size = 16
$T6 = -44						; size = 16
$T7 = -44						; size = 16
$T8 = -44						; size = 16
$T9 = -44						; size = 16
$T10 = -44						; size = 16
$T11 = -44						; size = 16
$T12 = -44						; size = 16
$T13 = -44						; size = 16
$T14 = -44						; size = 16
$T15 = -44						; size = 16
$T16 = -44						; size = 16
$T17 = -44						; size = 16
$T18 = -44						; size = 16
$T19 = -44						; size = 16
$T20 = -44						; size = 16
$T21 = -44						; size = 16
$T22 = -44						; size = 16
$T23 = -44						; size = 16
$T24 = -44						; size = 16
$T25 = -44						; size = 16
$T26 = -44						; size = 16
$T27 = -44						; size = 16
$T28 = -44						; size = 16
$T29 = -44						; size = 16
$T30 = -44						; size = 16
$T31 = -44						; size = 16
$T32 = -44						; size = 16
$T33 = -44						; size = 16
$T34 = -44						; size = 16
$T35 = -44						; size = 16
$T36 = -44						; size = 16
$T37 = -44						; size = 16
$T38 = -44						; size = 16
$T39 = -44						; size = 16
$T40 = -44						; size = 16
$T41 = -44						; size = 16
$T42 = -44						; size = 16
$T43 = -44						; size = 16
$T44 = -44						; size = 16
_func_sad$ = -28					; size = 8
$T45 = -20						; size = 8
$T46 = -20						; size = 8
$T47 = -20						; size = 8
$T48 = -20						; size = 8
$T49 = -20						; size = 8
$T50 = -20						; size = 8
$T51 = -20						; size = 8
$T52 = -20						; size = 8
$T53 = -20						; size = 8
$T54 = -20						; size = 8
$T55 = -20						; size = 8
$T56 = -20						; size = 8
$T57 = -20						; size = 8
$T58 = -20						; size = 8
$T59 = -20						; size = 8
$T60 = -20						; size = 8
$T61 = -20						; size = 8
$T62 = -20						; size = 8
$T63 = -20						; size = 8
$T64 = -20						; size = 8
$T65 = -20						; size = 8
$T66 = -20						; size = 8
$T67 = -20						; size = 8
$T68 = -20						; size = 8
$T69 = -20						; size = 8
$T70 = -20						; size = 8
$T71 = -20						; size = 8
$T72 = -20						; size = 8
$T73 = -20						; size = 8
$T74 = -20						; size = 8
$T75 = -20						; size = 8
$T76 = -20						; size = 8
$T77 = -20						; size = 8
$T78 = -20						; size = 8
$T79 = -20						; size = 8
$T80 = -20						; size = 8
$T81 = -20						; size = 8
$T82 = -20						; size = 8
$T83 = -20						; size = 8
$T84 = -20						; size = 8
$T85 = -20						; size = 8
$T86 = -20						; size = 8
$T87 = -20						; size = 8
$T88 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pixelsize$ = 8						; size = 4
_arch$dead$ = 12					; size = 4
?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z PROC ; get_sad_avx2_C_function, COMDAT
; _BlockX$ = ecx
; _BlockY$ = edx

; 26   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi
	mov	esi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR _func_sad$[ebp], 0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 26   : {

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR _func_sad$[ebp+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR _func_sad$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T44[ebp]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 28   :     std::map<std::tuple<int, int, int, arch_t>, SADFunction*> func_sad;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	eax
	lea	eax, DWORD PTR $T87[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqu	XMMWORD PTR $T44[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 31   :     func_sad[make_tuple(32, 32, 1, NO_SIMD)] = Sad_AVX2_C<32, 32,uint8_t>;

	mov	eax, DWORD PTR $T87[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 31   :     func_sad[make_tuple(32, 32, 1, NO_SIMD)] = Sad_AVX2_C<32, 32,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0CA@$0CA@E@@YAIPBEH0H@Z ; Sad_AVX2_C<32,32,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T43[ebp]
	push	eax
	lea	eax, DWORD PTR $T86[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T43[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 32   :     func_sad[make_tuple(32, 16, 1, NO_SIMD)] = Sad_AVX2_C<32, 16,uint8_t>;

	mov	eax, DWORD PTR $T86[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000020000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 32   :     func_sad[make_tuple(32, 16, 1, NO_SIMD)] = Sad_AVX2_C<32, 16,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0CA@$0BA@E@@YAIPBEH0H@Z ; Sad_AVX2_C<32,16,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T42[ebp]
	push	eax
	lea	eax, DWORD PTR $T85[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T42[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 33   :     func_sad[make_tuple(32, 8 , 1, NO_SIMD)] = Sad_AVX2_C<32, 8,uint8_t>;

	mov	eax, DWORD PTR $T85[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000200000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 33   :     func_sad[make_tuple(32, 8 , 1, NO_SIMD)] = Sad_AVX2_C<32, 8,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0CA@$07E@@YAIPBEH0H@Z ; Sad_AVX2_C<32,8,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T41[ebp]
	push	eax
	lea	eax, DWORD PTR $T84[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T41[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 34   :     func_sad[make_tuple(16, 32, 1, NO_SIMD)] = Sad_AVX2_C<16, 32,uint8_t>;

	mov	eax, DWORD PTR $T84[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 34   :     func_sad[make_tuple(16, 32, 1, NO_SIMD)] = Sad_AVX2_C<16, 32,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$0CA@E@@YAIPBEH0H@Z ; Sad_AVX2_C<16,32,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T40[ebp]
	push	eax
	lea	eax, DWORD PTR $T83[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T40[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 35   :     func_sad[make_tuple(16, 16, 1, NO_SIMD)] = Sad_AVX2_C<16, 16,uint8_t>;

	mov	eax, DWORD PTR $T83[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 35   :     func_sad[make_tuple(16, 16, 1, NO_SIMD)] = Sad_AVX2_C<16, 16,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$0BA@E@@YAIPBEH0H@Z ; Sad_AVX2_C<16,16,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T39[ebp]
	push	eax
	lea	eax, DWORD PTR $T82[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T39[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 36   :     func_sad[make_tuple(16, 8 , 1, NO_SIMD)] = Sad_AVX2_C<16, 8,uint8_t>;

	mov	eax, DWORD PTR $T82[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000040000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 36   :     func_sad[make_tuple(16, 8 , 1, NO_SIMD)] = Sad_AVX2_C<16, 8,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$07E@@YAIPBEH0H@Z ; Sad_AVX2_C<16,8,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T38[ebp]
	push	eax
	lea	eax, DWORD PTR $T81[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T38[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 37   :     func_sad[make_tuple(16, 4 , 1, NO_SIMD)] = Sad_AVX2_C<16, 4,uint8_t>;

	mov	eax, DWORD PTR $T81[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000020000000100000000
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$03E@@YAIPBEH0H@Z ; Sad_AVX2_C<16,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T37[ebp]
	push	eax
	lea	eax, DWORD PTR $T80[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqu	XMMWORD PTR $T37[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 38   :     func_sad[make_tuple(16, 2 , 1, NO_SIMD)] = Sad_AVX2_C<16, 2,uint8_t>;

	mov	eax, DWORD PTR $T80[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 38   :     func_sad[make_tuple(16, 2 , 1, NO_SIMD)] = Sad_AVX2_C<16, 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$01E@@YAIPBEH0H@Z ; Sad_AVX2_C<16,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T36[ebp]
	push	eax
	lea	eax, DWORD PTR $T79[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T36[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 39   :     func_sad[make_tuple(16, 1 , 1, NO_SIMD)] = Sad_AVX2_C<16, 1,uint8_t>;

	mov	eax, DWORD PTR $T79[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 39   :     func_sad[make_tuple(16, 1 , 1, NO_SIMD)] = Sad_AVX2_C<16, 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$00E@@YAIPBEH0H@Z ; Sad_AVX2_C<16,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T35[ebp]
	push	eax
	lea	eax, DWORD PTR $T78[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T35[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 40   :     func_sad[make_tuple(8 , 16, 1, NO_SIMD)] = Sad_AVX2_C<8 , 16,uint8_t>;

	mov	eax, DWORD PTR $T78[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 40   :     func_sad[make_tuple(8 , 16, 1, NO_SIMD)] = Sad_AVX2_C<8 , 16,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$0BA@E@@YAIPBEH0H@Z ; Sad_AVX2_C<8,16,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T34[ebp]
	push	eax
	lea	eax, DWORD PTR $T77[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T34[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 41   :     func_sad[make_tuple(8 , 8 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 8,uint8_t>;

	mov	eax, DWORD PTR $T77[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 41   :     func_sad[make_tuple(8 , 8 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 8,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$07E@@YAIPBEH0H@Z ; Sad_AVX2_C<8,8,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T33[ebp]
	push	eax
	lea	eax, DWORD PTR $T76[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T33[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 42   :     func_sad[make_tuple(8 , 4 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 4,uint8_t>;

	mov	eax, DWORD PTR $T76[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000020000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 42   :     func_sad[make_tuple(8 , 4 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 4,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$03E@@YAIPBEH0H@Z ; Sad_AVX2_C<8,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	lea	eax, DWORD PTR $T75[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T32[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 43   :     func_sad[make_tuple(8 , 2 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 2,uint8_t>;

	mov	eax, DWORD PTR $T75[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 43   :     func_sad[make_tuple(8 , 2 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$01E@@YAIPBEH0H@Z ; Sad_AVX2_C<8,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T31[ebp]
	push	eax
	lea	eax, DWORD PTR $T74[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T31[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 44   :     func_sad[make_tuple(8 , 1 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 1,uint8_t>;

	mov	eax, DWORD PTR $T74[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 44   :     func_sad[make_tuple(8 , 1 , 1, NO_SIMD)] = Sad_AVX2_C<8 , 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$00E@@YAIPBEH0H@Z ; Sad_AVX2_C<8,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T30[ebp]
	push	eax
	lea	eax, DWORD PTR $T73[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T30[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 45   :     func_sad[make_tuple(4 , 8 , 1, NO_SIMD)] = Sad_AVX2_C<4 , 8,uint8_t>;

	mov	eax, DWORD PTR $T73[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000040000000100000000
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$07E@@YAIPBEH0H@Z ; Sad_AVX2_C<4,8,unsigned char>
	vmovdqu	XMMWORD PTR $T29[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	lea	eax, DWORD PTR $T72[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 46   :     func_sad[make_tuple(4 , 4 , 1, NO_SIMD)] = Sad_AVX2_C<4 , 4,uint8_t>;

	mov	eax, DWORD PTR $T72[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000020000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 46   :     func_sad[make_tuple(4 , 4 , 1, NO_SIMD)] = Sad_AVX2_C<4 , 4,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$03E@@YAIPBEH0H@Z ; Sad_AVX2_C<4,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T28[ebp]
	push	eax
	lea	eax, DWORD PTR $T71[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T28[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 47   :     func_sad[make_tuple(4 , 2 , 1, NO_SIMD)] = Sad_AVX2_C<4 , 2,uint8_t>;

	mov	eax, DWORD PTR $T71[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 47   :     func_sad[make_tuple(4 , 2 , 1, NO_SIMD)] = Sad_AVX2_C<4 , 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$01E@@YAIPBEH0H@Z ; Sad_AVX2_C<4,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	lea	eax, DWORD PTR $T70[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T27[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 48   :     func_sad[make_tuple(4 , 1 , 1, NO_SIMD)] = Sad_AVX2_C<4 , 1,uint8_t>;

	mov	eax, DWORD PTR $T70[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000002000000040000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 48   :     func_sad[make_tuple(4 , 1 , 1, NO_SIMD)] = Sad_AVX2_C<4 , 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$00E@@YAIPBEH0H@Z ; Sad_AVX2_C<4,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	lea	eax, DWORD PTR $T69[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T26[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 49   :     func_sad[make_tuple(2 , 4 , 1, NO_SIMD)] = Sad_AVX2_C<2 , 4,uint8_t>;

	mov	eax, DWORD PTR $T69[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000002000000020000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 49   :     func_sad[make_tuple(2 , 4 , 1, NO_SIMD)] = Sad_AVX2_C<2 , 4,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$01$03E@@YAIPBEH0H@Z ; Sad_AVX2_C<2,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T25[ebp]
	push	eax
	lea	eax, DWORD PTR $T68[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T25[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 50   :     func_sad[make_tuple(2 , 2 , 1, NO_SIMD)] = Sad_AVX2_C<2 , 2,uint8_t>;

	mov	eax, DWORD PTR $T68[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000002000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 50   :     func_sad[make_tuple(2 , 2 , 1, NO_SIMD)] = Sad_AVX2_C<2 , 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$01$01E@@YAIPBEH0H@Z ; Sad_AVX2_C<2,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T24[ebp]
	push	eax
	lea	eax, DWORD PTR $T67[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T24[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 51   :     func_sad[make_tuple(2 , 1 , 1, NO_SIMD)] = Sad_AVX2_C<2 , 1,uint8_t>;

	mov	eax, DWORD PTR $T67[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000020000000200000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 51   :     func_sad[make_tuple(2 , 1 , 1, NO_SIMD)] = Sad_AVX2_C<2 , 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$01$00E@@YAIPBEH0H@Z ; Sad_AVX2_C<2,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T23[ebp]
	push	eax
	lea	eax, DWORD PTR $T66[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T23[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 53   :     func_sad[make_tuple(32, 32, 2, NO_SIMD)] = Sad_AVX2_C<32, 32,uint16_t>;

	mov	eax, DWORD PTR $T66[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000020000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 53   :     func_sad[make_tuple(32, 32, 2, NO_SIMD)] = Sad_AVX2_C<32, 32,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0CA@$0CA@G@@YAIPBEH0H@Z ; Sad_AVX2_C<32,32,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T22[ebp]
	push	eax
	lea	eax, DWORD PTR $T65[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T22[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 54   :     func_sad[make_tuple(32, 16, 2, NO_SIMD)] = Sad_AVX2_C<32, 16,uint16_t>;

	mov	eax, DWORD PTR $T65[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000020000000080000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0CA@$0BA@G@@YAIPBEH0H@Z ; Sad_AVX2_C<32,16,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T21[ebp]
	vmovdqu	XMMWORD PTR $T21[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR $T64[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 55   :     func_sad[make_tuple(32, 8 , 2, NO_SIMD)] = Sad_AVX2_C<32, 8,uint16_t>;

	mov	eax, DWORD PTR $T64[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000200000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 55   :     func_sad[make_tuple(32, 8 , 2, NO_SIMD)] = Sad_AVX2_C<32, 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0CA@$07G@@YAIPBEH0H@Z ; Sad_AVX2_C<32,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T20[ebp]
	push	eax
	lea	eax, DWORD PTR $T63[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T20[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 56   :     func_sad[make_tuple(16, 32, 2, NO_SIMD)] = Sad_AVX2_C<16, 32,uint16_t>;

	mov	eax, DWORD PTR $T63[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 56   :     func_sad[make_tuple(16, 32, 2, NO_SIMD)] = Sad_AVX2_C<16, 32,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$0CA@G@@YAIPBEH0H@Z ; Sad_AVX2_C<16,32,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	lea	eax, DWORD PTR $T62[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T19[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 57   :     func_sad[make_tuple(16, 16, 2, NO_SIMD)] = Sad_AVX2_C<16, 16,uint16_t>;

	mov	eax, DWORD PTR $T62[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000080000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 57   :     func_sad[make_tuple(16, 16, 2, NO_SIMD)] = Sad_AVX2_C<16, 16,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$0BA@G@@YAIPBEH0H@Z ; Sad_AVX2_C<16,16,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	lea	eax, DWORD PTR $T61[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T18[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 58   :     func_sad[make_tuple(16, 8 , 2, NO_SIMD)] = Sad_AVX2_C<16, 8,uint16_t>;

	mov	eax, DWORD PTR $T61[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000040000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 58   :     func_sad[make_tuple(16, 8 , 2, NO_SIMD)] = Sad_AVX2_C<16, 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$07G@@YAIPBEH0H@Z ; Sad_AVX2_C<16,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	lea	eax, DWORD PTR $T60[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T17[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 59   :     func_sad[make_tuple(16, 4 , 2, NO_SIMD)] = Sad_AVX2_C<16, 4,uint16_t>;

	mov	eax, DWORD PTR $T60[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 59   :     func_sad[make_tuple(16, 4 , 2, NO_SIMD)] = Sad_AVX2_C<16, 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$03G@@YAIPBEH0H@Z ; Sad_AVX2_C<16,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	lea	eax, DWORD PTR $T59[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T16[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 60   :     func_sad[make_tuple(16, 2 , 2, NO_SIMD)] = Sad_AVX2_C<16, 2,uint16_t>;

	mov	eax, DWORD PTR $T59[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000010000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 60   :     func_sad[make_tuple(16, 2 , 2, NO_SIMD)] = Sad_AVX2_C<16, 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$01G@@YAIPBEH0H@Z ; Sad_AVX2_C<16,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	lea	eax, DWORD PTR $T58[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T15[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 61   :     func_sad[make_tuple(16, 1 , 2, NO_SIMD)] = Sad_AVX2_C<16, 1,uint16_t>;

	mov	eax, DWORD PTR $T58[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 61   :     func_sad[make_tuple(16, 1 , 2, NO_SIMD)] = Sad_AVX2_C<16, 1,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$0BA@$00G@@YAIPBEH0H@Z ; Sad_AVX2_C<16,1,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	lea	eax, DWORD PTR $T57[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T14[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 62   :     func_sad[make_tuple(8 , 16, 2, NO_SIMD)] = Sad_AVX2_C<8 , 16,uint16_t>;

	mov	eax, DWORD PTR $T57[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000080000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$0BA@G@@YAIPBEH0H@Z ; Sad_AVX2_C<8,16,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T13[ebp]
	vmovdqu	XMMWORD PTR $T13[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR $T56[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 63   :     func_sad[make_tuple(8 , 8 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 8,uint16_t>;

	mov	eax, DWORD PTR $T56[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000040000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 63   :     func_sad[make_tuple(8 , 8 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$07G@@YAIPBEH0H@Z ; Sad_AVX2_C<8,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	lea	eax, DWORD PTR $T55[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T12[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 64   :     func_sad[make_tuple(8 , 4 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 4,uint16_t>;

	mov	eax, DWORD PTR $T55[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 64   :     func_sad[make_tuple(8 , 4 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$03G@@YAIPBEH0H@Z ; Sad_AVX2_C<8,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	lea	eax, DWORD PTR $T54[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T11[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 65   :     func_sad[make_tuple(8 , 2 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 2,uint16_t>;

	mov	eax, DWORD PTR $T54[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000008000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 65   :     func_sad[make_tuple(8 , 2 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$01G@@YAIPBEH0H@Z ; Sad_AVX2_C<8,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	eax, DWORD PTR $T53[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T10[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 66   :     func_sad[make_tuple(8 , 1 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 1,uint16_t>;

	mov	eax, DWORD PTR $T53[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000080000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 66   :     func_sad[make_tuple(8 , 1 , 2, NO_SIMD)] = Sad_AVX2_C<8 , 1,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$07$00G@@YAIPBEH0H@Z ; Sad_AVX2_C<8,1,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	eax, DWORD PTR $T52[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T9[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 67   :     func_sad[make_tuple(4 , 8 , 2, NO_SIMD)] = Sad_AVX2_C<4 , 8,uint16_t>;

	mov	eax, DWORD PTR $T52[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000040000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 67   :     func_sad[make_tuple(4 , 8 , 2, NO_SIMD)] = Sad_AVX2_C<4 , 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$07G@@YAIPBEH0H@Z ; Sad_AVX2_C<4,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	eax, DWORD PTR $T51[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T8[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 68   :     func_sad[make_tuple(4 , 4 , 2, NO_SIMD)] = Sad_AVX2_C<4 , 4,uint16_t>;

	mov	eax, DWORD PTR $T51[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 68   :     func_sad[make_tuple(4 , 4 , 2, NO_SIMD)] = Sad_AVX2_C<4 , 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$03G@@YAIPBEH0H@Z ; Sad_AVX2_C<4,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	eax, DWORD PTR $T50[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T7[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 69   :     func_sad[make_tuple(4 , 2 , 2, NO_SIMD)] = Sad_AVX2_C<4 , 2,uint16_t>;

	mov	eax, DWORD PTR $T50[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000004000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 69   :     func_sad[make_tuple(4 , 2 , 2, NO_SIMD)] = Sad_AVX2_C<4 , 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$01G@@YAIPBEH0H@Z ; Sad_AVX2_C<4,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	eax, DWORD PTR $T49[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T6[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 70   :     func_sad[make_tuple(4 , 1 , 2, NO_SIMD)] = Sad_AVX2_C<4 , 1,uint16_t>;

	mov	eax, DWORD PTR $T49[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000002000000040000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$03$00G@@YAIPBEH0H@Z ; Sad_AVX2_C<4,1,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T5[ebp], xmm0
	lea	eax, DWORD PTR $T48[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 71   :     func_sad[make_tuple(2 , 4 , 2, NO_SIMD)] = Sad_AVX2_C<2 , 4,uint16_t>;

	mov	eax, DWORD PTR $T48[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000002000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 71   :     func_sad[make_tuple(2 , 4 , 2, NO_SIMD)] = Sad_AVX2_C<2 , 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$01$03G@@YAIPBEH0H@Z ; Sad_AVX2_C<2,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	eax, DWORD PTR $T47[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T4[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 72   :     func_sad[make_tuple(2 , 2 , 2, NO_SIMD)] = Sad_AVX2_C<2 , 2,uint16_t>;

	mov	eax, DWORD PTR $T47[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	vmovdqa	xmm0, XMMWORD PTR __xmm@00000002000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 72   :     func_sad[make_tuple(2 , 2 , 2, NO_SIMD)] = Sad_AVX2_C<2 , 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$01$01G@@YAIPBEH0H@Z ; Sad_AVX2_C<2,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T46[ebp]
	push	eax
	vmovdqu	XMMWORD PTR $T3[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 73   :     func_sad[make_tuple(2 , 1 , 2, NO_SIMD)] = Sad_AVX2_C<2 , 1,uint16_t>;

	mov	eax, DWORD PTR $T46[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 73   :     func_sad[make_tuple(2 , 1 , 2, NO_SIMD)] = Sad_AVX2_C<2 , 1,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_AVX2_C@$01$00G@@YAIPBEH0H@Z ; Sad_AVX2_C<2,1,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR _pixelsize$[ebp]
	mov	DWORD PTR $T2[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T45[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp+8], esi
	mov	DWORD PTR $T2[ebp+12], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 76   :     return result;

	mov	eax, DWORD PTR $T45[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2168 : 		erase(begin(), end());

	lea	ecx, DWORD PTR _func_sad$[ebp]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 76   :     return result;

	mov	esi, DWORD PTR [eax+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2168 : 		erase(begin(), end());

	mov	eax, DWORD PTR _func_sad$[ebp]
	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T88[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR _func_sad$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 77   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 76   :     return result;

	mov	eax, esi

; 77   : }

	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z$0:
	lea	ecx, DWORD PTR _func_sad$[ebp]
	jmp	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ
__ehhandler$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ENDP ; get_sad_avx2_C_function
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0CA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv681 = -12						; size = 4
tv677 = -8						; size = 4
tv678 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0CA@$0CA@G@@YAIPBEH0H@Z PROC		; Sad16_avx2<32,32,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	add	eax, eax

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	DWORD PTR tv681[esp+16], 16		; 00000010H
	mov	DWORD PTR tv678[esp+16], eax
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	add	eax, eax
	push	esi
	vpxor	xmm4, xmm4, xmm4
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv677[esp+24], eax
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm3, ymm4
$LL4@Sad16_avx2:

; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));
; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));
; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)

	mov	esi, edi
	mov	edx, eax
	sub	esi, eax
	mov	edi, 2
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
$LL7@Sad16_avx2:

; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+edx]
	lea	edx, DWORD PTR [edx+32]
	vmovdqu	ymm2, YMMWORD PTR [ecx]

; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));

	vmovdqu	ymm0, YMMWORD PTR [edx-32]

; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));

	vmovdqu	ymm2, YMMWORD PTR [ecx+eax]

; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	vmovdqu	ymm0, YMMWORD PTR [edx+ecx-32]

; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL7@Sad16_avx2

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))

	mov	eax, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _pSrc$[ebp]
	add	eax, DWORD PTR tv677[esp+24]
	add	edi, DWORD PTR tv678[esp+24]
	sub	DWORD PTR tv681[esp+24], 1
	mov	DWORD PTR _pRef$[ebp], eax
	mov	DWORD PTR _pSrc$[ebp], edi
	jne	$LL4@Sad16_avx2

; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm3, ymm4
	vpunpckldq ymm1, ymm3, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0CA@$0CA@G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<32,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0CA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv681 = -12						; size = 4
tv677 = -8						; size = 4
tv678 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0CA@$0BA@G@@YAIPBEH0H@Z PROC		; Sad16_avx2<32,16,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	add	eax, eax

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	DWORD PTR tv681[esp+16], 8
	mov	DWORD PTR tv678[esp+16], eax
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	add	eax, eax
	push	esi
	vpxor	xmm4, xmm4, xmm4
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv677[esp+24], eax
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm3, ymm4
$LL4@Sad16_avx2:

; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));
; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));
; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)

	mov	esi, edi
	mov	edx, eax
	sub	esi, eax
	mov	edi, 2
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
$LL7@Sad16_avx2:

; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+edx]
	lea	edx, DWORD PTR [edx+32]
	vmovdqu	ymm2, YMMWORD PTR [ecx]

; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));

	vmovdqu	ymm0, YMMWORD PTR [edx-32]

; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));

	vmovdqu	ymm2, YMMWORD PTR [ecx+eax]

; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	vmovdqu	ymm0, YMMWORD PTR [edx+ecx-32]

; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL7@Sad16_avx2

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))

	mov	eax, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _pSrc$[ebp]
	add	eax, DWORD PTR tv677[esp+24]
	add	edi, DWORD PTR tv678[esp+24]
	sub	DWORD PTR tv681[esp+24], 1
	mov	DWORD PTR _pRef$[ebp], eax
	mov	DWORD PTR _pSrc$[ebp], edi
	jne	$LL4@Sad16_avx2

; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm3, ymm4
	vpunpckldq ymm1, ymm3, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0CA@$0BA@G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<32,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0CA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv681 = -12						; size = 4
tv677 = -8						; size = 4
tv678 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0CA@$07G@@YAIPBEH0H@Z PROC		; Sad16_avx2<32,8,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	add	eax, eax

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	DWORD PTR tv681[esp+16], 4
	mov	DWORD PTR tv678[esp+16], eax
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	add	eax, eax
	push	esi
	vpxor	xmm4, xmm4, xmm4
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv677[esp+24], eax
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm3, ymm4
$LL4@Sad16_avx2:

; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));
; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));
; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)

	mov	esi, edi
	mov	edx, eax
	sub	esi, eax
	mov	edi, 2
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
$LL7@Sad16_avx2:

; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+edx]
	lea	edx, DWORD PTR [edx+32]
	vmovdqu	ymm2, YMMWORD PTR [ecx]

; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));

	vmovdqu	ymm0, YMMWORD PTR [edx-32]

; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));

	vmovdqu	ymm2, YMMWORD PTR [ecx+eax]

; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	vmovdqu	ymm0, YMMWORD PTR [edx+ecx-32]

; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL7@Sad16_avx2

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))

	mov	eax, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _pSrc$[ebp]
	add	eax, DWORD PTR tv677[esp+24]
	add	edi, DWORD PTR tv678[esp+24]
	sub	DWORD PTR tv681[esp+24], 1
	mov	DWORD PTR _pRef$[ebp], eax
	mov	DWORD PTR _pSrc$[ebp], edi
	jne	$LL4@Sad16_avx2

; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm3, ymm4
	vpunpckldq ymm1, ymm3, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0CA@$07G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<32,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0BA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv601 = -8						; size = 4
tv602 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0BA@$0CA@G@@YAIPBEH0H@Z PROC		; Sad16_avx2<16,32,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv602[esp+12], eax
	vpxor	xmm4, xmm4, xmm4
	lea	eax, DWORD PTR [esi+esi]
	push	edi
	mov	DWORD PTR tv601[esp+16], eax
	mov	edi, 16					; 00000010H
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm3, ymm4
$LL4@Sad16_avx2:

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));

	vmovdqu	ymm2, YMMWORD PTR [ecx]

; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));

	vmovdqu	ymm0, YMMWORD PTR [eax]

; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));

	vmovdqu	ymm2, YMMWORD PTR [ecx+edx]
	add	ecx, DWORD PTR tv602[esp+16]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1

; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));

	vmovdqu	ymm0, YMMWORD PTR [eax+esi]
	add	eax, DWORD PTR tv601[esp+16]

; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL4@Sad16_avx2

; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm3, ymm4
	vpunpckldq ymm1, ymm3, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0BA@$0CA@G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<16,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0BA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv601 = -8						; size = 4
tv602 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0BA@$0BA@G@@YAIPBEH0H@Z PROC		; Sad16_avx2<16,16,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv602[esp+12], eax
	vpxor	xmm4, xmm4, xmm4
	lea	eax, DWORD PTR [esi+esi]
	push	edi
	mov	DWORD PTR tv601[esp+16], eax
	mov	edi, 8
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm3, ymm4
$LL4@Sad16_avx2:

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));

	vmovdqu	ymm2, YMMWORD PTR [ecx]

; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));

	vmovdqu	ymm0, YMMWORD PTR [eax]

; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));

	vmovdqu	ymm2, YMMWORD PTR [ecx+edx]
	add	ecx, DWORD PTR tv602[esp+16]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1

; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));

	vmovdqu	ymm0, YMMWORD PTR [eax+esi]
	add	eax, DWORD PTR tv601[esp+16]

; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL4@Sad16_avx2

; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm3, ymm4
	vpunpckldq ymm1, ymm3, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0BA@$0BA@G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<16,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0BA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv601 = -8						; size = 4
tv602 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0BA@$07G@@YAIPBEH0H@Z PROC		; Sad16_avx2<16,8,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv602[esp+12], eax
	vpxor	xmm4, xmm4, xmm4
	lea	eax, DWORD PTR [esi+esi]
	push	edi
	mov	DWORD PTR tv601[esp+16], eax
	mov	edi, 4
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm3, ymm4
$LL4@Sad16_avx2:

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));

	vmovdqu	ymm2, YMMWORD PTR [ecx]

; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));

	vmovdqu	ymm0, YMMWORD PTR [eax]

; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));

	vmovdqu	ymm2, YMMWORD PTR [ecx+edx]
	add	ecx, DWORD PTR tv602[esp+16]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1

; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));

	vmovdqu	ymm0, YMMWORD PTR [eax+esi]
	add	eax, DWORD PTR tv601[esp+16]

; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL4@Sad16_avx2

; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm3, ymm4
	vpunpckldq ymm1, ymm3, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0BA@$07G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<16,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0BA@$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv601 = -8						; size = 4
tv602 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0BA@$03G@@YAIPBEH0H@Z PROC		; Sad16_avx2<16,4,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv602[esp+12], eax
	vpxor	xmm4, xmm4, xmm4
	lea	eax, DWORD PTR [esi+esi]
	push	edi
	mov	DWORD PTR tv601[esp+16], eax
	mov	edi, 2
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm3, ymm4
$LL4@Sad16_avx2:

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));

	vmovdqu	ymm2, YMMWORD PTR [ecx]

; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));

	vmovdqu	ymm0, YMMWORD PTR [eax]

; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));

	vmovdqu	ymm2, YMMWORD PTR [ecx+edx]
	add	ecx, DWORD PTR tv602[esp+16]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1

; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));

	vmovdqu	ymm0, YMMWORD PTR [eax+esi]
	add	eax, DWORD PTR tv601[esp+16]

; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm3, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL4@Sad16_avx2

; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm3, ymm4
	vpunpckldq ymm1, ymm3, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0BA@$03G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<16,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0BA@$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0BA@$01G@@YAIPBEH0H@Z PROC		; Sad16_avx2<16,2,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 
; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32
; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));

	mov	edx, DWORD PTR _pSrc$[ebp]

; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));

	mov	ecx, DWORD PTR _pRef$[ebp]

; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));

	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	vpxor	xmm4, xmm4, xmm4
	vmovdqu	ymm2, YMMWORD PTR [edx]
	vmovdqu	ymm0, YMMWORD PTR [ecx]
	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0
	vmovdqu	ymm2, YMMWORD PTR [edx+eax]

; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));

	mov	eax, DWORD PTR _nRefPitch$[ebp]
	vpor	ymm0, ymm0, ymm1
	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm3, ymm0, ymm1
	vmovdqu	ymm0, YMMWORD PTR [ecx+eax]

; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm4
	vpunpcklwd ymm0, ymm0, ymm4
	vpaddd	ymm0, ymm0, ymm3
	vpaddd	ymm0, ymm0, ymm1

; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0

	vpunpckldq ymm1, ymm0, ymm4

; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm0, ymm4

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0BA@$01G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<16,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$0BA@$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$0BA@$00G@@YAIPBEH0H@Z PROC		; Sad16_avx2<16,1,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 
; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32
; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));
; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));
; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));

	mov	eax, DWORD PTR _pSrc$[ebp]
	vpxor	xmm3, xmm3, xmm3
	vmovdqu	ymm2, YMMWORD PTR [eax]

; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));

	mov	eax, DWORD PTR _pRef$[ebp]
	vmovdqu	ymm0, YMMWORD PTR [eax]

; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm3
	vpunpcklwd ymm0, ymm0, ymm3
	vpaddd	ymm0, ymm0, ymm1

; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0

	vpunpckldq ymm1, ymm0, ymm3

; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm0, ymm3

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$0BA@$00G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<16,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$07$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv597 = -8						; size = 4
tv598 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$07$0BA@G@@YAIPBEH0H@Z PROC		; Sad16_avx2<8,16,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv598[esp+12], eax
	vpxor	xmm3, xmm3, xmm3
	lea	eax, DWORD PTR [esi+esi]
	push	edi
	mov	DWORD PTR tv597[esp+16], eax
	mov	edi, 8
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm4, ymm3
	npad	14
$LL4@Sad16_avx2:

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));

	vmovdqu	xmm0, XMMWORD PTR [ecx]
	vinsertf128 ymm2, ymm0, XMMWORD PTR [ecx+edx], 1

; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));

	vmovdqu	xmm0, XMMWORD PTR [eax]
	vinsertf128 ymm0, ymm0, XMMWORD PTR [eax+esi], 1
	add	eax, DWORD PTR tv597[esp+16]
	add	ecx, DWORD PTR tv598[esp+16]

; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm3
	vpunpcklwd ymm0, ymm0, ymm3
	vpaddd	ymm0, ymm0, ymm4
	vpaddd	ymm4, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL4@Sad16_avx2

; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));
; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));
; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm4, ymm3
	vpunpckldq ymm1, ymm4, ymm3

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$07$0BA@G@@YAIPBEH0H@Z ENDP		; Sad16_avx2<8,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$07$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv597 = -8						; size = 4
tv598 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$07$07G@@YAIPBEH0H@Z PROC			; Sad16_avx2<8,8,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv598[esp+12], eax
	vpxor	xmm3, xmm3, xmm3
	lea	eax, DWORD PTR [esi+esi]
	push	edi
	mov	DWORD PTR tv597[esp+16], eax
	mov	edi, 4
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm4, ymm3
	npad	14
$LL4@Sad16_avx2:

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));

	vmovdqu	xmm0, XMMWORD PTR [ecx]
	vinsertf128 ymm2, ymm0, XMMWORD PTR [ecx+edx], 1

; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));

	vmovdqu	xmm0, XMMWORD PTR [eax]
	vinsertf128 ymm0, ymm0, XMMWORD PTR [eax+esi], 1
	add	eax, DWORD PTR tv597[esp+16]
	add	ecx, DWORD PTR tv598[esp+16]

; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm3
	vpunpcklwd ymm0, ymm0, ymm3
	vpaddd	ymm0, ymm0, ymm4
	vpaddd	ymm4, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL4@Sad16_avx2

; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));
; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));
; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm4, ymm3
	vpunpckldq ymm1, ymm4, ymm3

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$07$07G@@YAIPBEH0H@Z ENDP			; Sad16_avx2<8,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$07$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv597 = -8						; size = 4
tv598 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$07$03G@@YAIPBEH0H@Z PROC			; Sad16_avx2<8,4,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 

	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv598[esp+12], eax
	vpxor	xmm3, xmm3, xmm3
	lea	eax, DWORD PTR [esi+esi]
	push	edi
	mov	DWORD PTR tv597[esp+16], eax
	mov	edi, 2
	mov	eax, DWORD PTR _pRef$[ebp]

; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32

	vmovdqu	ymm4, ymm3
	npad	14
$LL4@Sad16_avx2:

; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));

	vmovdqu	xmm0, XMMWORD PTR [ecx]
	vinsertf128 ymm2, ymm0, XMMWORD PTR [ecx+edx], 1

; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));

	vmovdqu	xmm0, XMMWORD PTR [eax]
	vinsertf128 ymm0, ymm0, XMMWORD PTR [eax+esi], 1
	add	eax, DWORD PTR tv597[esp+16]
	add	ecx, DWORD PTR tv598[esp+16]

; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm3
	vpunpcklwd ymm0, ymm0, ymm3
	vpaddd	ymm0, ymm0, ymm4
	vpaddd	ymm4, ymm0, ymm1
	sub	edi, 1
	jne	SHORT $LL4@Sad16_avx2

; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));
; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));
; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0
; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm4, ymm3
	vpunpckldq ymm1, ymm4, ymm3

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$07$03G@@YAIPBEH0H@Z ENDP			; Sad16_avx2<8,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad16_avx2@$07$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_avx2@$07$01G@@YAIPBEH0H@Z PROC			; Sad16_avx2<8,2,unsigned short>, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 104  : #if 0
; 105  :   // check AVX2 result against C
; 106  :   unsigned int result2 = Sad_AVX2_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 107  : #endif
; 108  : 
; 109  :   _mm256_zeroupper(); 
; 110  :   if ((sizeof(pixel_t) == 2 && nBlkWidth < 8) || (sizeof(pixel_t) == 1 && nBlkWidth <= 16)) {
; 111  :     assert("AVX2 not supported for uint16_t with BlockSize<8 or uint8_t with blocksize<16");
; 112  :     return 0;
; 113  :   }
; 114  : 
; 115  :   __m256i zero = _mm256_setzero_si256();
; 116  :   __m256i sum = _mm256_setzero_si256(); // 2x or 4x int is probably enough for 32x32
; 117  : 
; 118  :   bool two_16byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth == 8) || (sizeof(pixel_t) == 1 && nBlkWidth == 16);
; 119  :   if (two_16byte_rows && nBlkHeight==1) {
; 120  :     assert("AVX2 not supported BlockHeight==1 for uint16_t with BlockSize=8 or uint8_t with blocksize<16");
; 121  :     return 0;
; 122  :   }
; 123  :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) <= 32;
; 124  :   const bool unroll_by2 = !two_16byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 125  : 
; 126  :   for (int y = 0; y < nBlkHeight; y+= ((two_16byte_rows || unroll_by2) ? 2 : 1))
; 127  :   {
; 128  :     if (two_16byte_rows) {
; 129  :       __m256i src1, src2;
; 130  :       // two 16 byte rows at a time
; 131  :       src1 = _mm256_loadu2_m128i((const __m128i *) (pSrc + nSrcPitch), (const __m128i *) (pSrc));

	mov	ecx, DWORD PTR _pSrc$[ebp]
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	vpxor	xmm3, xmm3, xmm3
	vmovdqu	xmm0, XMMWORD PTR [ecx]
	vinsertf128 ymm2, ymm0, XMMWORD PTR [ecx+eax], 1

; 132  :       src2 = _mm256_loadu2_m128i((const __m128i *) (pRef + nRefPitch), (const __m128i *) (pRef));

	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	vmovdqu	xmm0, XMMWORD PTR [ecx]
	vinsertf128 ymm0, ymm0, XMMWORD PTR [ecx+eax], 1

; 133  :       if (sizeof(pixel_t) == 1) {
; 134  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 135  :         // result in four 32 bit areas at each 64 bytes
; 136  :       }
; 137  :       else {
; 138  :         // we have 16 words
; 139  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 140  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);

	vpsubusw ymm1, ymm0, ymm2
	vpsubusw ymm0, ymm2, ymm0

; 141  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	vpor	ymm0, ymm0, ymm1

; 142  :                                                                  // 16 x uint16 absolute differences
; 143  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 144  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));

	vpunpckhwd ymm1, ymm0, ymm3
	vpunpcklwd ymm0, ymm0, ymm3
	vpaddd	ymm0, ymm0, ymm1

; 145  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 146  :       }
; 147  :     }
; 148  :     else if (one_cycle) { // no x loop
; 149  :       __m256i src1, src2;
; 150  :       src1 = _mm256_loadu_si256((__m256i *) (pSrc));
; 151  :       src2 = _mm256_loadu_si256((__m256i *) (pRef));
; 152  :       if (sizeof(pixel_t) == 1) {
; 153  :         sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 154  :         // result in four 32 bit areas at each 64 bytes
; 155  :       }
; 156  :       else {
; 157  :         // we have 16 words
; 158  :         __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 159  :         __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 160  :         __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 161  :                                                                  // 16 x uint16 absolute differences
; 162  :         sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 163  :         sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 164  :         // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 165  :       }
; 166  :       if (unroll_by2) {
; 167  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc+nSrcPitch));
; 168  :         src2 = _mm256_loadu_si256((__m256i *) (pRef+nRefPitch));
; 169  :         if (sizeof(pixel_t) == 1) {
; 170  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 171  :           // result in four 32 bit areas at each 64 bytes
; 172  :         }
; 173  :         else {
; 174  :           // we have 16 words
; 175  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 176  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 177  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 178  :                                                                    // 16 x uint16 absolute differences
; 179  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 180  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 181  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 182  :         }
; 183  :       }
; 184  :     }
; 185  :     else {
; 186  :       for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 32)
; 187  :       {
; 188  :         __m256i src1, src2;
; 189  :         src1 = _mm256_loadu_si256((__m256i *) (pSrc + x));
; 190  :         src2 = _mm256_loadu_si256((__m256i *) (pRef + x));
; 191  :         if (sizeof(pixel_t) == 1) {
; 192  :           sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 193  :           // result in four 32 bit areas at each 64 bytes
; 194  :         }
; 195  :         else {
; 196  :           // we have 16 words
; 197  :           __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 198  :           __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 199  :           __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 200  :                                                                    // 16 x uint16 absolute differences
; 201  :           sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 202  :           sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 203  :           // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 204  :         }
; 205  :         if (unroll_by2) {
; 206  :           src1 = _mm256_loadu_si256((__m256i *) (pSrc + x + nSrcPitch));
; 207  :           src2 = _mm256_loadu_si256((__m256i *) (pRef + x + nRefPitch));
; 208  :           if (sizeof(pixel_t) == 1) {
; 209  :             sum = _mm256_add_epi32(sum, _mm256_sad_epu8(src1, src2));
; 210  :             // result in four 32 bit areas at each 64 bytes
; 211  :           }
; 212  :           else {
; 213  :             // we have 16 words
; 214  :             __m256i greater_t = _mm256_subs_epu16(src1, src2); // unsigned sub with saturation
; 215  :             __m256i smaller_t = _mm256_subs_epu16(src2, src1);
; 216  :             __m256i absdiff = _mm256_or_si256(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 217  :                                                                      // 16 x uint16 absolute differences
; 218  :             sum = _mm256_add_epi32(sum, _mm256_unpacklo_epi16(absdiff, zero));
; 219  :             sum = _mm256_add_epi32(sum, _mm256_unpackhi_epi16(absdiff, zero));
; 220  :             // sum1_32, sum2_32, sum3_32, sum4_32 .. sum8_32
; 221  :           }
; 222  :         }
; 223  :       }
; 224  :     }
; 225  :     if (two_16byte_rows || unroll_by2) {
; 226  :       pSrc += nSrcPitch * 2;
; 227  :       pRef += nRefPitch * 2;
; 228  :     }
; 229  :     else {
; 230  :       pSrc += nSrcPitch;
; 231  :       pRef += nRefPitch;
; 232  :     }
; 233  :   }
; 234  :   /*
; 235  :   [Low64, Hi64]
; 236  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 237  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 238  :   _mm_move_epi64(x)                           [x0, 0]
; 239  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 240  :   */
; 241  :   __m256i a03;
; 242  :   __m256i a47;
; 243  :   if(sizeof(pixel_t) == 2) {
; 244  :     // at 16 bits: we have 8 integers for sum: a0 a1 a2 a3 a4 a5 a6 a7
; 245  :     a03 = _mm256_unpacklo_epi32(sum, zero); // a0 0 a1 0 a2 0 a3 0

	vpunpckldq ymm1, ymm0, ymm3

; 246  :     a47 = _mm256_unpackhi_epi32(sum, zero); // a4 0 a5 0 a6 0 a7 0

	vpunpckhdq ymm0, ymm0, ymm3

; 247  :     a03 = _mm256_add_epi32(a03, a47); // a0+a4,0, a1+a5, 0, a2+a6, 0, a3+a7, 0

	vpaddd	ymm1, ymm0, ymm1

; 248  :                                       // sum here: sum1 0 sum2 0 sum3 0 sum4 0, as in uint8_t case
; 249  :   }
; 250  :   if(sizeof(pixel_t) == 1) {
; 251  :     a03 = sum;
; 252  :   }
; 253  : 
; 254  :   // add the low 128 bit to the high 128 bit
; 255  :   __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(a03),_mm256_extractf128_si256(a03, 1));

	vextractf128 xmm0, ymm1, 1
	vpaddd	xmm1, xmm0, xmm1
	vpxor	xmm0, xmm0, xmm0

; 256  :   // a0+a4+a2+a6, 0, a1+a5+a3+a7, 0,
; 257  : 
; 258  :   __m128i sum_hi = _mm_unpackhi_epi64(sum128, _mm_setzero_si128()); // a1+a5+a3+a7

	vpunpckhqdq xmm0, xmm1, xmm0

; 259  :   sum128 = _mm_add_epi32(sum128, sum_hi); // a0+a4+a2+a6 + a1+a5+a3+a7

	vpaddd	xmm0, xmm0, xmm1

; 260  : 
; 261  :   unsigned int result = _mm_cvtsi128_si32(sum128);

	vmovd	eax, xmm0

; 262  : 
; 263  : #if 0
; 264  :   // check AVX2 result against C
; 265  :   if (result != result2) {
; 266  :     result = result2;
; 267  :   }
; 268  : #endif
; 269  : 
; 270  :   _mm256_zeroupper();

	vzeroupper

; 271  :   /* Use VZEROUPPER to avoid the penalty of switching from AVX to SSE */
; 272  : 
; 273  :   return result;
; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_avx2@$07$01G@@YAIPBEH0H@Z ENDP			; Sad16_avx2<8,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0CA@$0CA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0CA@$0CA@E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<32,32,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nRefPitch$[esp+4]
	mov	ebx, 32					; 00000020H
	push	esi
	mov	esi, DWORD PTR _pRef$[esp+8]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	vmovdqu	ymm3, ymm2
	npad	3
$LL4@Sad_AVX2_C:

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	edi, ecx
	xor	edx, edx
	mov	eax, esi
	sub	edi, esi
	npad	8
$LL7@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [edi+eax]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [edx+ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
	add	edx, 16					; 00000010H
	lea	eax, DWORD PTR [eax+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm3, ymm0, ymm3
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	edx, 32					; 00000020H
	jl	SHORT $LL7@Sad_AVX2_C

; 18   :     pSrc += nSrcPitch;

	add	ecx, DWORD PTR _nSrcPitch$[esp+12]

; 19   :     pRef += nRefPitch;

	add	esi, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	pop	edi
	vextracti128 xmm0, ymm1, 1
	pop	esi
	vpaddd	xmm0, xmm1, xmm0
	pop	ebp
	vmovd	eax, xmm0
	pop	ebx
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0CA@$0CA@E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<32,32,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0CA@$0BA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0CA@$0BA@E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<32,16,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nRefPitch$[esp+4]
	mov	ebx, 16					; 00000010H
	push	esi
	mov	esi, DWORD PTR _pRef$[esp+8]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	vmovdqu	ymm3, ymm2
	npad	3
$LL4@Sad_AVX2_C:

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	edi, ecx
	xor	edx, edx
	mov	eax, esi
	sub	edi, esi
	npad	8
$LL7@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [edi+eax]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [edx+ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
	add	edx, 16					; 00000010H
	lea	eax, DWORD PTR [eax+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm3, ymm0, ymm3
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	edx, 32					; 00000020H
	jl	SHORT $LL7@Sad_AVX2_C

; 18   :     pSrc += nSrcPitch;

	add	ecx, DWORD PTR _nSrcPitch$[esp+12]

; 19   :     pRef += nRefPitch;

	add	esi, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	pop	edi
	vextracti128 xmm0, ymm1, 1
	pop	esi
	vpaddd	xmm0, xmm1, xmm0
	pop	ebp
	vmovd	eax, xmm0
	pop	ebx
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0CA@$0BA@E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<32,16,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0CA@$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0CA@$07E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<32,8,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nRefPitch$[esp+4]
	mov	ebx, 8
	push	esi
	mov	esi, DWORD PTR _pRef$[esp+8]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	vmovdqu	ymm3, ymm2
	npad	3
$LL4@Sad_AVX2_C:

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	edi, ecx
	xor	edx, edx
	mov	eax, esi
	sub	edi, esi
	npad	8
$LL7@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [edi+eax]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [edx+ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
	add	edx, 16					; 00000010H
	lea	eax, DWORD PTR [eax+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm3, ymm0, ymm3
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	edx, 32					; 00000020H
	jl	SHORT $LL7@Sad_AVX2_C

; 18   :     pSrc += nSrcPitch;

	add	ecx, DWORD PTR _nSrcPitch$[esp+12]

; 19   :     pRef += nRefPitch;

	add	esi, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	pop	edi
	vextracti128 xmm0, ymm1, 1
	pop	esi
	vpaddd	xmm0, xmm1, xmm0
	pop	ebp
	vmovd	eax, xmm0
	pop	ebx
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0CA@$07E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<32,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$0CA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$0CA@E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,32,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 32					; 00000020H
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$0CA@E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,32,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$0BA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$0BA@E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,16,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 16					; 00000010H
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$0BA@E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,16,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$07E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,8,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 8
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$07E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$03E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,4,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 4
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$03E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$01E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,2,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 2
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
	vmovq	xmm0, QWORD PTR [ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$01E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$00E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,1,unsigned char>, COMDAT

; 12   : {

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	mov	eax, DWORD PTR _pRef$[esp-4]
	vmovq	xmm0, QWORD PTR [ecx]

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm2, ymm0
	vmovq	xmm0, QWORD PTR [ecx+8]
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax+8]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm0, ymm0, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	eax, xmm0
	vzeroupper

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$00E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$0BA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$0BA@E@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<8,16,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 16					; 00000010H
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$0BA@E@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<8,16,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$07E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,8,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 8
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$07E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$03E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,4,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 4
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$03E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$01E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,2,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 2
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$01E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$00E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,1,unsigned char>, COMDAT

; 12   : {

	mov	eax, DWORD PTR _pSrc$[esp-4]
	vmovq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR _pRef$[esp-4]

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd ymm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxbd ymm0, xmm0
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	eax, xmm0
	vzeroupper

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$00E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$07E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,8,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 8
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	xmm0, DWORD PTR [ecx]
	vpmovzxbd xmm1, xmm0
	vmovd	xmm0, DWORD PTR [eax]
	vpmovzxbd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	xmm2, xmm0, xmm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	xmm0, xmm2, xmm2
	vphaddd	xmm0, xmm0, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$07E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$03E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,4,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 4
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	xmm0, DWORD PTR [ecx]
	vpmovzxbd xmm1, xmm0
	vmovd	xmm0, DWORD PTR [eax]
	vpmovzxbd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	xmm2, xmm0, xmm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	xmm0, xmm2, xmm2
	vphaddd	xmm0, xmm0, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$03E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$01E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,2,unsigned char>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 2
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	xmm0, DWORD PTR [ecx]
	vpmovzxbd xmm1, xmm0
	vmovd	xmm0, DWORD PTR [eax]
	vpmovzxbd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	xmm2, xmm0, xmm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	xmm0, xmm2, xmm2
	vphaddd	xmm0, xmm0, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$01E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$00E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,1,unsigned char>, COMDAT

; 12   : {

	mov	eax, DWORD PTR _pSrc$[esp-4]
	vmovd	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR _pRef$[esp-4]

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxbd xmm1, xmm0
	vmovd	xmm0, DWORD PTR [eax]
	vpmovzxbd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
	vphaddd	xmm0, xmm0, xmm0
	vphaddd	xmm0, xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	eax, xmm0

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$00E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$01$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$01$03E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<2,4,unsigned char>, COMDAT

; 12   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+16]

; 18   :     pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, BYTE PTR [esi+1]
	add	ebp, esi
	movzx	ecx, BYTE PTR [edi+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [edi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [esi]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
	sub	ebx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebx, eax
	movzx	eax, BYTE PTR [ebp+1]
	mov	DWORD PTR _sum$1$[esp+20], ebx

; 19   :     pRef += nRefPitch;

	mov	ebx, DWORD PTR _nRefPitch$[esp+16]
	add	ebx, edi
	movzx	ecx, BYTE PTR [ebx+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [ebx]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	edi, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 19   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+16]
	movzx	eax, BYTE PTR [ebp]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	edi, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ebp, DWORD PTR _nSrcPitch$[esp+16]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	edi, edx
	cdq
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, BYTE PTR [ebx+1]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, DWORD PTR _sum$1$[esp+20]
	add	edi, eax
	movzx	eax, BYTE PTR [ebp+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [ebx]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebp]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	edi, eax
	mov	eax, DWORD PTR _nRefPitch$[esp+16]
	add	edi, esi
	movzx	ecx, BYTE PTR [ebx+eax+1]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, BYTE PTR [eax+ebp+1]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	eax, DWORD PTR _nRefPitch$[esp+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, BYTE PTR [ebx+eax]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, BYTE PTR [eax+ebp]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, edi
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 20   :   }
; 21   :   return sum;
; 22   : }

	pop	ecx
	ret	0
??$Sad_AVX2_C@$01$03E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<2,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$01$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$01$01E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<2,2,unsigned char>, COMDAT

; 12   : {

	push	ebx

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	ebx, DWORD PTR _pRef$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, BYTE PTR [ebx+1]
	push	edi

; 18   :     pSrc += nSrcPitch;

	mov	edi, DWORD PTR _nSrcPitch$[esp+12]
	movzx	eax, BYTE PTR [esi+1]
	add	edi, esi
	sub	eax, ecx
	movzx	ecx, BYTE PTR [ebx]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebp, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [esi]

; 19   :     pRef += nRefPitch;

	mov	esi, DWORD PTR _nRefPitch$[esp+12]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebp, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 19   :     pRef += nRefPitch;

	add	esi, ebx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebp, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, BYTE PTR [esi+1]
	add	ebp, eax
	movzx	eax, BYTE PTR [edi+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [esi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebp
	pop	ebp
	add	eax, ebx
	pop	ebx

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$01$01E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<2,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$01$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$01$00E@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<2,1,unsigned char>, COMDAT

; 12   : {

	push	ebx
	push	esi

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pRef$[esp+4]
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, BYTE PTR [esi+1]
	movzx	eax, BYTE PTR [edi+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [esi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebx
	pop	ebx

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$01$00E@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<2,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0CA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0CA@$0CA@G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<32,32,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nRefPitch$[esp+4]
	mov	ebx, 32					; 00000020H
	push	esi
	mov	esi, DWORD PTR _pRef$[esp+8]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	vmovdqu	ymm3, ymm2
	npad	3
$LL4@Sad_AVX2_C:

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	edi, ecx
	lea	eax, DWORD PTR [esi+16]
	xor	edx, edx
	sub	edi, esi
	npad	7
$LL7@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx+edx*2]
	vpmovzxwd ymm0, XMMWORD PTR [eax-16]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [edi+eax]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	add	edx, 16					; 00000010H
	lea	eax, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm3, ymm0, ymm3
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	edx, 32					; 00000020H
	jl	SHORT $LL7@Sad_AVX2_C

; 18   :     pSrc += nSrcPitch;

	add	ecx, DWORD PTR _nSrcPitch$[esp+12]

; 19   :     pRef += nRefPitch;

	add	esi, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	pop	edi
	vextracti128 xmm0, ymm1, 1
	pop	esi
	vpaddd	xmm0, xmm1, xmm0
	pop	ebp
	vmovd	eax, xmm0
	pop	ebx
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0CA@$0CA@G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<32,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0CA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0CA@$0BA@G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<32,16,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nRefPitch$[esp+4]
	mov	ebx, 16					; 00000010H
	push	esi
	mov	esi, DWORD PTR _pRef$[esp+8]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	vmovdqu	ymm3, ymm2
	npad	3
$LL4@Sad_AVX2_C:

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	edi, ecx
	lea	eax, DWORD PTR [esi+16]
	xor	edx, edx
	sub	edi, esi
	npad	7
$LL7@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx+edx*2]
	vpmovzxwd ymm0, XMMWORD PTR [eax-16]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [edi+eax]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	add	edx, 16					; 00000010H
	lea	eax, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm3, ymm0, ymm3
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	edx, 32					; 00000020H
	jl	SHORT $LL7@Sad_AVX2_C

; 18   :     pSrc += nSrcPitch;

	add	ecx, DWORD PTR _nSrcPitch$[esp+12]

; 19   :     pRef += nRefPitch;

	add	esi, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	pop	edi
	vextracti128 xmm0, ymm1, 1
	pop	esi
	vpaddd	xmm0, xmm1, xmm0
	pop	ebp
	vmovd	eax, xmm0
	pop	ebx
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0CA@$0BA@G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<32,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0CA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0CA@$07G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<32,8,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nRefPitch$[esp+4]
	mov	ebx, 8
	push	esi
	mov	esi, DWORD PTR _pRef$[esp+8]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	vmovdqu	ymm3, ymm2
	npad	3
$LL4@Sad_AVX2_C:

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	edi, ecx
	lea	eax, DWORD PTR [esi+16]
	xor	edx, edx
	sub	edi, esi
	npad	7
$LL7@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx+edx*2]
	vpmovzxwd ymm0, XMMWORD PTR [eax-16]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [edi+eax]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	add	edx, 16					; 00000010H
	lea	eax, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm3, ymm0, ymm3
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 16   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	edx, 32					; 00000020H
	jl	SHORT $LL7@Sad_AVX2_C

; 18   :     pSrc += nSrcPitch;

	add	ecx, DWORD PTR _nSrcPitch$[esp+12]

; 19   :     pRef += nRefPitch;

	add	esi, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	pop	edi
	vextracti128 xmm0, ymm1, 1
	pop	esi
	vpaddd	xmm0, xmm1, xmm0
	pop	ebp
	vmovd	eax, xmm0
	pop	ebx
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0CA@$07G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<32,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$0CA@G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,32,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 32					; 00000020H
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx]
	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [ecx+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax+16]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$0CA@G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$0BA@G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,16,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 16					; 00000010H
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx]
	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [ecx+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax+16]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$0BA@G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$07G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,8,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 8
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx]
	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [ecx+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax+16]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$07G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$03G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,4,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 4
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx]
	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [ecx+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax+16]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$03G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$01G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,2,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 2
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	vpxor	xmm2, xmm2, xmm2
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vmovdqu	ymm3, ymm2
	npad	1
$LL4@Sad_AVX2_C:

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [ecx]
	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [ecx+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm2, ymm0, ymm2
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax+16]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	ymm3, ymm0, ymm3
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpaddd	ymm0, ymm3, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$01G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$0BA@$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$0BA@$00G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<16,1,unsigned short>, COMDAT

; 12   : {

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	ecx, DWORD PTR _pSrc$[esp-4]

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpmovzxwd ymm1, XMMWORD PTR [ecx]
	vpsubd	ymm0, ymm1, ymm0
	vpmovzxwd ymm1, XMMWORD PTR [ecx+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm2, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm0, XMMWORD PTR [eax+16]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vpaddd	ymm0, ymm0, ymm2
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	eax, xmm0
	vzeroupper

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$0BA@$00G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<16,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$0BA@G@@YAIPBEH0H@Z PROC		; Sad_AVX2_C<8,16,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 16					; 00000010H
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [eax]
	vpmovzxwd ymm0, XMMWORD PTR [ecx]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$0BA@G@@YAIPBEH0H@Z ENDP		; Sad_AVX2_C<8,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$07G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,8,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 8
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [eax]
	vpmovzxwd ymm0, XMMWORD PTR [ecx]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$07G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$03G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,4,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 4
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [eax]
	vpmovzxwd ymm0, XMMWORD PTR [ecx]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$03G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$01G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,2,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ecx, DWORD PTR _pRef$[esp-4]
	mov	edx, 2
	mov	eax, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [eax]
	vpmovzxwd ymm0, XMMWORD PTR [ecx]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	eax, edi

; 19   :     pRef += nRefPitch;

	add	ecx, esi
	vpaddd	ymm2, ymm0, ymm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	ymm0, ymm2, ymm2
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi
	vzeroupper

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$01G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$07$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$07$00G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<8,1,unsigned short>, COMDAT

; 12   : {

	mov	eax, DWORD PTR _pSrc$[esp-4]

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd ymm1, XMMWORD PTR [eax]
	mov	eax, DWORD PTR _pRef$[esp-4]
	vpmovzxwd ymm0, XMMWORD PTR [eax]
	vpsubd	ymm0, ymm1, ymm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	ymm0, ymm0
	vphaddd	ymm0, ymm0, ymm0
	vphaddd	ymm1, ymm0, ymm0
	vextracti128 xmm0, ymm1, 1
	vpaddd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	eax, xmm0
	vzeroupper

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$07$00G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<8,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$07G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,8,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 8
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxwd xmm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxwd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	xmm2, xmm0, xmm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	xmm0, xmm2, xmm2
	vphaddd	xmm0, xmm0, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$07G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$03G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,4,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 4
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxwd xmm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxwd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	xmm2, xmm0, xmm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	xmm0, xmm2, xmm2
	vphaddd	xmm0, xmm0, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$03G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$01G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,2,unsigned short>, COMDAT

; 13   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	eax, DWORD PTR _pRef$[esp-4]
	mov	edx, 2
	mov	ecx, DWORD PTR _pSrc$[esp-4]
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[esp]
	push	edi
	mov	edi, DWORD PTR _nSrcPitch$[esp+4]
	vpxor	xmm2, xmm2, xmm2
	npad	5
$LL4@Sad_AVX2_C:

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovq	xmm0, QWORD PTR [ecx]
	vpmovzxwd xmm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxwd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ecx, edi

; 19   :     pRef += nRefPitch;

	add	eax, esi
	vpaddd	xmm2, xmm0, xmm2
	sub	edx, 1
	jne	SHORT $LL4@Sad_AVX2_C

; 14   :   for ( int y = 0; y < nBlkHeight; y++ )
; 15   :   {
; 16   :     for ( int x = 0; x < nBlkWidth; x++ )
; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vphaddd	xmm0, xmm2, xmm2
	vphaddd	xmm0, xmm0, xmm0
	pop	edi
	vmovd	eax, xmm0
	pop	esi

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$01G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$03$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$03$00G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<4,1,unsigned short>, COMDAT

; 12   : {

	mov	eax, DWORD PTR _pSrc$[esp-4]
	vmovq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR _pRef$[esp-4]

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vpmovzxwd xmm1, xmm0
	vmovq	xmm0, QWORD PTR [eax]
	vpmovzxwd xmm0, xmm0
	vpsubd	xmm0, xmm1, xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	vpabsd	xmm0, xmm0
	vphaddd	xmm0, xmm0, xmm0
	vphaddd	xmm0, xmm0, xmm0
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	vmovd	eax, xmm0

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$03$00G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<4,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$01$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$01$03G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<2,4,unsigned short>, COMDAT

; 12   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+16]

; 18   :     pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, WORD PTR [esi+2]
	add	ebp, esi
	movzx	ecx, WORD PTR [edi+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [esi]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
	sub	ebx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebx, eax
	movzx	eax, WORD PTR [ebp+2]
	mov	DWORD PTR _sum$1$[esp+20], ebx

; 19   :     pRef += nRefPitch;

	mov	ebx, DWORD PTR _nRefPitch$[esp+16]
	add	ebx, edi
	movzx	ecx, WORD PTR [ebx+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [ebx]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	edi, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 19   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+16]
	movzx	eax, WORD PTR [ebp]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	edi, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 18   :     pSrc += nSrcPitch;

	add	ebp, DWORD PTR _nSrcPitch$[esp+16]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	edi, edx
	cdq
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, WORD PTR [ebx+2]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, DWORD PTR _sum$1$[esp+20]
	add	edi, eax
	movzx	eax, WORD PTR [ebp+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [ebx]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebp]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	edi, eax
	mov	eax, DWORD PTR _nRefPitch$[esp+16]
	add	edi, esi
	movzx	ecx, WORD PTR [ebx+eax+2]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, WORD PTR [eax+ebp+2]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	eax, DWORD PTR _nRefPitch$[esp+16]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, WORD PTR [eax+ebp]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, edi
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 20   :   }
; 21   :   return sum;
; 22   : }

	pop	ecx
	ret	0
??$Sad_AVX2_C@$01$03G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<2,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$01$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$01$01G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<2,2,unsigned short>, COMDAT

; 12   : {

	push	ebx

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	ebx, DWORD PTR _pRef$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, WORD PTR [ebx+2]
	push	edi

; 18   :     pSrc += nSrcPitch;

	mov	edi, DWORD PTR _nSrcPitch$[esp+12]
	movzx	eax, WORD PTR [esi+2]
	add	edi, esi
	sub	eax, ecx
	movzx	ecx, WORD PTR [ebx]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebp, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [esi]

; 19   :     pRef += nRefPitch;

	mov	esi, DWORD PTR _nRefPitch$[esp+12]
	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebp, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 19   :     pRef += nRefPitch;

	add	esi, ebx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebp, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, WORD PTR [esi+2]
	add	ebp, eax
	movzx	eax, WORD PTR [edi+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [esi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebp
	pop	ebp
	add	eax, ebx
	pop	ebx

; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$01$01G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<2,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp
;	COMDAT ??$Sad_AVX2_C@$01$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_AVX2_C@$01$00G@@YAIPBEH0H@Z PROC			; Sad_AVX2_C<2,1,unsigned short>, COMDAT

; 12   : {

	push	ebx
	push	esi

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pRef$[esp+4]
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, WORD PTR [esi+2]
	movzx	eax, WORD PTR [edi+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [esi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx
; File c:\github\mvtools\sources\sadfunctions.cpp

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi
; File c:\github\mvtools\sources\sadfunctions_avx2.cpp

; 17   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebx
	pop	ebx

; 18   :     pSrc += nSrcPitch;
; 19   :     pRef += nRefPitch;
; 20   :   }
; 21   :   return sum;
; 22   : }

	ret	0
??$Sad_AVX2_C@$01$00G@@YAIPBEH0H@Z ENDP			; Sad_AVX2_C<2,1,unsigned short>
_TEXT	ENDS
END
