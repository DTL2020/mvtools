; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\overlap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	_Overlaps16x16_sse2:PROC
EXTRN	_Overlaps2x2_sse2:PROC
EXTRN	_Overlaps8x16_sse2:PROC
EXTRN	_Overlaps16x4_sse2:PROC
EXTRN	_Overlaps8x1_sse2:PROC
EXTRN	_Overlaps8x2_sse2:PROC
EXTRN	_Overlaps32x32_sse2:PROC
EXTRN	_Overlaps8x8_sse2:PROC
EXTRN	_Overlaps32x16_sse2:PROC
EXTRN	_Overlaps16x2_sse2:PROC
EXTRN	_Overlaps2x4_sse2:PROC
EXTRN	_Overlaps16x32_sse2:PROC
EXTRN	_Overlaps4x4_sse2:PROC
EXTRN	_Overlaps16x8_sse2:PROC
EXTRN	_Overlaps32x8_sse2:PROC
EXTRN	_Overlaps4x8_sse2:PROC
EXTRN	_Overlaps4x2_sse2:PROC
EXTRN	_Overlaps8x4_sse2:PROC
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
PUBLIC	??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
PUBLIC	??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
PUBLIC	??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)><std::tuple<int,int,int,enum arch_t> &&>
PUBLIC	??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)><std::tuple<int,int,int,enum arch_t> &&>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::max_size
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_first
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_first
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::max_size
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator--
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator--
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Mysize
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Mysize
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::size
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Freenode0
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator--
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::size
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Freenode0
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator--
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
PUBLIC	?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Compare
PUBLIC	?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Compare
PUBLIC	??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>
PUBLIC	??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>
PUBLIC	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > &,bool,void,0>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool,void,0>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > &,bool,void,0>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool,void,0>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Kfn
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Kfn
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::lower_bound
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Key
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::lower_bound
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Key
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1><>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1><>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
PUBLIC	??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
PUBLIC	??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
PUBLIC	??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
PUBLIC	??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::try_emplace<>
PUBLIC	??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::try_emplace<>
PUBLIC	??$OverlapsLsb_C@$01$01@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<2,2>
PUBLIC	??$OverlapsLsb_C@$01$03@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<2,4>
PUBLIC	??$OverlapsLsb_C@$03$01@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<4,2>
PUBLIC	??$OverlapsLsb_C@$03$03@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<4,4>
PUBLIC	??$OverlapsLsb_C@$03$07@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<4,8>
PUBLIC	??$OverlapsLsb_C@$07$00@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<8,1>
PUBLIC	??$OverlapsLsb_C@$07$01@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<8,2>
PUBLIC	??$OverlapsLsb_C@$07$03@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<8,4>
PUBLIC	??$OverlapsLsb_C@$07$07@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<8,8>
PUBLIC	??$OverlapsLsb_C@$07$0BA@@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<8,16>
PUBLIC	??$OverlapsLsb_C@$0BA@$01@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<16,2>
PUBLIC	??$OverlapsLsb_C@$0BA@$03@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<16,4>
PUBLIC	??$OverlapsLsb_C@$0BA@$07@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<16,8>
PUBLIC	??$OverlapsLsb_C@$0BA@$0BA@@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<16,16>
PUBLIC	??$OverlapsLsb_C@$0BA@$0CA@@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<16,32>
PUBLIC	??$OverlapsLsb_C@$0CA@$07@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<32,8>
PUBLIC	??$OverlapsLsb_C@$0CA@$0BA@@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<32,16>
PUBLIC	??$OverlapsLsb_C@$0CA@$0CA@@@YAXPAHHPBE1HPAFH@Z	; OverlapsLsb_C<32,32>
PUBLIC	??$Overlaps_sse4@G$03$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,4,2>
PUBLIC	??$Overlaps_sse4@G$03$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,4,4>
PUBLIC	??$Overlaps_sse4@G$03$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,4,8>
PUBLIC	??$Overlaps_sse4@G$07$00@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,8,1>
PUBLIC	??$Overlaps_sse4@G$07$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,8,2>
PUBLIC	??$Overlaps_sse4@G$07$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,8,4>
PUBLIC	??$Overlaps_sse4@G$07$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,8,8>
PUBLIC	??$Overlaps_sse4@G$07$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,8,16>
PUBLIC	??$Overlaps_sse4@G$0BA@$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,16,2>
PUBLIC	??$Overlaps_sse4@G$0BA@$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,16,4>
PUBLIC	??$Overlaps_sse4@G$0BA@$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,16,8>
PUBLIC	??$Overlaps_sse4@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,16,16>
PUBLIC	??$Overlaps_sse4@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,16,32>
PUBLIC	??$Overlaps_sse4@G$0CA@$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,32,8>
PUBLIC	??$Overlaps_sse4@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,32,16>
PUBLIC	??$Overlaps_sse4@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_sse4<unsigned short,32,32>
PUBLIC	??$Overlaps_C@G$01$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,2,2>
PUBLIC	??$Overlaps_C@G$01$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,2,4>
PUBLIC	??$Overlaps_C@G$03$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,4,2>
PUBLIC	??$Overlaps_C@G$03$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,4,4>
PUBLIC	??$Overlaps_C@G$03$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,4,8>
PUBLIC	??$Overlaps_C@G$07$00@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,8,1>
PUBLIC	??$Overlaps_C@G$07$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,8,2>
PUBLIC	??$Overlaps_C@G$07$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,8,4>
PUBLIC	??$Overlaps_C@G$07$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,8,8>
PUBLIC	??$Overlaps_C@G$07$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,8,16>
PUBLIC	??$Overlaps_C@G$0BA@$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,16,2>
PUBLIC	??$Overlaps_C@G$0BA@$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,16,4>
PUBLIC	??$Overlaps_C@G$0BA@$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,16,8>
PUBLIC	??$Overlaps_C@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,16,16>
PUBLIC	??$Overlaps_C@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,16,32>
PUBLIC	??$Overlaps_C@G$0CA@$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,32,8>
PUBLIC	??$Overlaps_C@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,32,16>
PUBLIC	??$Overlaps_C@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned short,32,32>
PUBLIC	??$Overlaps_C@E$01$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,2,2>
PUBLIC	??$Overlaps_C@E$01$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,2,4>
PUBLIC	??$Overlaps_C@E$03$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,4,2>
PUBLIC	??$Overlaps_C@E$03$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,4,4>
PUBLIC	??$Overlaps_C@E$03$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,4,8>
PUBLIC	??$Overlaps_C@E$07$00@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,8,1>
PUBLIC	??$Overlaps_C@E$07$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,8,2>
PUBLIC	??$Overlaps_C@E$07$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,8,4>
PUBLIC	??$Overlaps_C@E$07$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,8,8>
PUBLIC	??$Overlaps_C@E$07$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,8,16>
PUBLIC	??$Overlaps_C@E$0BA@$01@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,16,2>
PUBLIC	??$Overlaps_C@E$0BA@$03@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,16,4>
PUBLIC	??$Overlaps_C@E$0BA@$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,16,8>
PUBLIC	??$Overlaps_C@E$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,16,16>
PUBLIC	??$Overlaps_C@E$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,16,32>
PUBLIC	??$Overlaps_C@E$0CA@$07@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,32,8>
PUBLIC	??$Overlaps_C@E$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,32,16>
PUBLIC	??$Overlaps_C@E$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z	; Overlaps_C<unsigned char,32,32>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::allocate
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::allocate
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Get_data
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::allocate
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Isnil
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Min
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Get_data
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::allocate
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Isnil
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Min
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
PUBLIC	?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Color
PUBLIC	?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Isnil
PUBLIC	?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myval
PUBLIC	?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Min
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myhead
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Mysize
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::deallocate
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Myval
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator++
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
PUBLIC	?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Color
PUBLIC	?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Isnil
PUBLIC	?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myval
PUBLIC	?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Min
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myhead
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Mysize
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::deallocate
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Myval
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator++
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Mynode
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Mynode
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::clear
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lmost
PUBLIC	?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Right
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Construct
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::deallocate
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::clear
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lmost
PUBLIC	?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Right
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Construct
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::deallocate
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::end
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Freeheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myhead
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator*
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::end
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Freeheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myhead
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator*
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@AAU32@@Z ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> *>::pointer_to
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@AAU32@@Z ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> *>::pointer_to
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tidy
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator->
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tidy
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator->
PUBLIC	??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >
PUBLIC	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >
PUBLIC	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAEAAP6AXPAHHPBE1HPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
PUBLIC	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >
PUBLIC	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >
PUBLIC	?cos@@YAOO@Z					; cos
PUBLIC	_cosl
PUBLIC	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z	; Short2Bytes_Int32toWord16
PUBLIC	?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_lsb_function
PUBLIC	?Short2Bytes@@YAXPAEHPAGHHH@Z			; Short2Bytes
PUBLIC	?Short2Bytes_FloatInInt32ArrayToFloat@@YAXPAMHPAHHHH@Z ; Short2Bytes_FloatInInt32ArrayToFloat
PUBLIC	?Short2BytesLsb@@YAXPAE0HPAHHHH@Z		; Short2BytesLsb
PUBLIC	??$LimitChanges_sse2_new@G@@YAXPAEHPBEHHHH@Z	; LimitChanges_sse2_new<unsigned short>
PUBLIC	??$LimitChanges_sse2_new@E@@YAXPAEHPBEHHHH@Z	; LimitChanges_sse2_new<unsigned char>
PUBLIC	??$LimitChanges_c@G@@YAXPAEHPBEHHHH@Z		; LimitChanges_c<unsigned short>
PUBLIC	??$LimitChanges_c@E@@YAXPAEHPBEHHHH@Z		; LimitChanges_c<unsigned char>
PUBLIC	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function
PUBLIC	??1OverlapWindows@@QAE@XZ			; OverlapWindows::~OverlapWindows
PUBLIC	??0OverlapWindows@@QAE@HHHH@Z			; OverlapWindows::OverlapWindows
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$120
__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$120 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$120
__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$120 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$71
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$71 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$71
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$71 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??0OverlapWindows@@QAE@HHHH@Z
_TEXT	SEGMENT
_winOverUVBR$1$ = -72					; size = 4
_winOverUVTL$1$ = -68					; size = 4
_winOverUVTR$1$ = -64					; size = 4
_winOverUVML$1$ = -60					; size = 4
_winOverUVMM$1$ = -56					; size = 4
_winOverUVMR$1$ = -52					; size = 4
_winOverUVBL$1$ = -48					; size = 4
_winOverUVBM$1$ = -44					; size = 4
_winOverUVTM$1$ = -40					; size = 4
tv1564 = -36						; size = 4
tv1563 = -32						; size = 4
tv1562 = -28						; size = 4
tv1561 = -24						; size = 4
tv1560 = -20						; size = 4
tv1559 = -16						; size = 4
tv1558 = -12						; size = 4
tv1557 = -8						; size = 4
tv1556 = -4						; size = 4
__nx$ = 8						; size = 4
__ny$ = 12						; size = 4
__ox$ = 16						; size = 4
__oy$ = 20						; size = 4
??0OverlapWindows@@QAE@HHHH@Z PROC			; OverlapWindows::OverlapWindows, COMDAT
; _this$ = ecx

; 39   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 40   : 	nx = _nx;
; 41   : 	ny = _ny;

	mov	edx, DWORD PTR __ny$[ebp]
	sub	esp, 76					; 0000004cH

; 42   : 	ox = _ox;

	mov	eax, DWORD PTR __ox$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __nx$[ebp]

; 43   : 	oy = _oy;
; 44   : 	size = nx*ny;
; 45   : 
; 46   : 	   //  windows
; 47   : 	   fWin1UVx = new float[nx];

	mov	ebx, 4
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR __oy$[ebp]
	mov	DWORD PTR [edi+12], ecx
	mov	ecx, esi
	imul	ecx, edx
	mov	DWORD PTR [edi+8], eax
	mov	eax, esi
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+16], ecx
	xor	ecx, ecx
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+24], eax

; 48   : 	   fWin1UVxfirst = new float[nx];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi]
	add	esp, 4
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+28], eax

; 49   : 	   fWin1UVxlast = new float[nx];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi]
	add	esp, 4
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 50   : 	   for (int i=0; i<ox; i++)

	movss	xmm1, DWORD PTR __real@3f000000
	xor	esi, esi
	movsd	xmm2, QWORD PTR __real@400921fb54442d18
	add	esp, 4
	mov	DWORD PTR [edi+32], eax
	cmp	DWORD PTR [edi+8], esi
	jle	SHORT $LN3@OverlapWin
$LL4@OverlapWin:

; 52   : 			fWin1UVx[i] = float (cos(PI*(i-ox+0.5f)/(ox*2)));

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, esi
	sub	eax, ecx
	movd	xmm0, eax
	lea	eax, DWORD PTR [ecx+ecx]
	cvtdq2ps xmm0, xmm0
	addss	xmm0, xmm1
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm2
	divsd	xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 813  :     return cos((double)_X);

	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\overlap.cpp

; 52   : 			fWin1UVx[i] = float (cos(PI*(i-ox+0.5f)/(ox*2)));

	mov	eax, DWORD PTR [edi+24]
	cvtsd2ss xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+esi*4], xmm0
	mov	eax, DWORD PTR [edi+24]
	movsd	xmm2, QWORD PTR __real@400921fb54442d18

; 53   : 			fWin1UVx[i] = fWin1UVx[i]*fWin1UVx[i];// left window (rised cosine)

	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0

; 54   : 			fWin1UVxfirst[i] = 1; // very first window

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+esi*4], 1065353216	; 3f800000H

; 55   : 			fWin1UVxlast[i] = fWin1UVx[i]; // very last

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	cmp	esi, DWORD PTR [edi+8]
	jl	SHORT $LL4@OverlapWin
$LN3@OverlapWin:

; 56   : 	   }
; 57   : 	   for (int i=ox; i<nx-ox; i++)

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi]
	sub	eax, ecx
	cmp	ecx, eax
	jge	SHORT $LN6@OverlapWin
	npad	11
$LL7@OverlapWin:

; 58   : 	   {
; 59   : 			fWin1UVx[i] = 1;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+ecx*4], 1065353216	; 3f800000H

; 60   : 			fWin1UVxfirst[i] = 1; // very first window

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+ecx*4], 1065353216	; 3f800000H

; 61   : 			fWin1UVxlast[i] = 1; // very last

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [eax+ecx*4], 1065353216	; 3f800000H
	inc	ecx
	mov	eax, DWORD PTR [edi]
	sub	eax, DWORD PTR [edi+8]
	cmp	ecx, eax
	jl	SHORT $LL7@OverlapWin
$LN6@OverlapWin:

; 62   : 	   }
; 63   : 	   for (int i=nx-ox; i<nx; i++)

	mov	esi, DWORD PTR [edi]
	sub	esi, DWORD PTR [edi+8]
	cmp	esi, DWORD PTR [edi]
	jge	SHORT $LN9@OverlapWin
$LL10@OverlapWin:

; 65   : 			fWin1UVx[i] = float (cos(PI*(i-nx+ox+0.5f)/(ox*2)));

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, ecx
	sub	eax, DWORD PTR [edi]
	add	eax, esi
	movd	xmm0, eax
	lea	eax, DWORD PTR [ecx+ecx]
	cvtdq2ps xmm0, xmm0
	addss	xmm0, xmm1
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm2
	divsd	xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 813  :     return cos((double)_X);

	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\overlap.cpp

; 65   : 			fWin1UVx[i] = float (cos(PI*(i-nx+ox+0.5f)/(ox*2)));

	mov	eax, DWORD PTR [edi+24]
	cvtsd2ss xmm0, xmm0
	movss	xmm1, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+esi*4], xmm0
	mov	eax, DWORD PTR [edi+24]
	movsd	xmm2, QWORD PTR __real@400921fb54442d18

; 66   : 			fWin1UVx[i] = fWin1UVx[i]*fWin1UVx[i];// right window (falled cosine)

	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0

; 67   : 			fWin1UVxfirst[i] = fWin1UVx[i]; // very first window

	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+esi*4], eax

; 68   : 			fWin1UVxlast[i] = 1; // very last

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [eax+esi*4], 1065353216	; 3f800000H
	inc	esi
	cmp	esi, DWORD PTR [edi]
	jl	SHORT $LL10@OverlapWin
$LN9@OverlapWin:

; 69   : 	   }
; 70   : 
; 71   : 	   fWin1UVy = new float[ny];

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+36], eax

; 72   : 	   fWin1UVyfirst = new float[ny];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+4]
	add	esp, 4
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+40], eax

; 73   : 	   fWin1UVylast = new float[ny];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+4]
	add	esp, 4
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 74   : 	   for (int i=0; i<oy; i++)

	xor	esi, esi
	mov	DWORD PTR [edi+44], eax
	add	esp, 4
	cmp	DWORD PTR [edi+12], esi
	jle	SHORT $LN12@OverlapWin
	npad	3
$LL13@OverlapWin:

; 76   : 			fWin1UVy[i] = float (cos(PI*(i-oy+0.5f)/(oy*2)));

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, esi
	sub	eax, ecx
	movd	xmm0, eax
	lea	eax, DWORD PTR [ecx+ecx]
	cvtdq2ps xmm0, xmm0
	movd	xmm1, eax
	addss	xmm0, DWORD PTR __real@3f000000
	cvtdq2pd xmm1, xmm1
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@400921fb54442d18
	divsd	xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 813  :     return cos((double)_X);

	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\overlap.cpp

; 76   : 			fWin1UVy[i] = float (cos(PI*(i-oy+0.5f)/(oy*2)));

	mov	eax, DWORD PTR [edi+36]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0
	mov	eax, DWORD PTR [edi+36]

; 77   : 			fWin1UVy[i] = fWin1UVy[i]*fWin1UVy[i];// left window (rised cosine)

	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0

; 78   : 			fWin1UVyfirst[i] = 1; // very first window

	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [eax+esi*4], 1065353216	; 3f800000H

; 79   : 			fWin1UVylast[i] = fWin1UVy[i]; // very last

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	cmp	esi, DWORD PTR [edi+12]
	jl	SHORT $LL13@OverlapWin
$LN12@OverlapWin:

; 80   : 	   }
; 81   : 	   for (int i=oy; i<ny-oy; i++)

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [edi+4]
	sub	eax, ecx
	cmp	ecx, eax
	jge	SHORT $LN15@OverlapWin
	npad	6
$LL16@OverlapWin:

; 82   : 	   {
; 83   : 			fWin1UVy[i] = 1;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+ecx*4], 1065353216	; 3f800000H

; 84   : 			fWin1UVyfirst[i] = 1; // very first window

	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [eax+ecx*4], 1065353216	; 3f800000H

; 85   : 			fWin1UVylast[i] = 1; // very last

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+ecx*4], 1065353216	; 3f800000H
	inc	ecx
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [edi+12]
	cmp	ecx, eax
	jl	SHORT $LL16@OverlapWin
$LN15@OverlapWin:

; 86   : 	   }
; 87   : 	   for (int i=ny-oy; i<ny; i++)

	mov	esi, DWORD PTR [edi+4]
	sub	esi, DWORD PTR [edi+12]
	cmp	esi, DWORD PTR [edi+4]
	jge	SHORT $LN18@OverlapWin
$LL19@OverlapWin:

; 89   : 			fWin1UVy[i] = float (cos(PI*(i-ny+oy+0.5f)/(oy*2)));

	mov	ecx, DWORD PTR [edi+12]
	mov	eax, ecx
	sub	eax, DWORD PTR [edi+4]
	add	eax, esi
	movd	xmm0, eax
	lea	eax, DWORD PTR [ecx+ecx]
	cvtdq2ps xmm0, xmm0
	movd	xmm1, eax
	addss	xmm0, DWORD PTR __real@3f000000
	cvtdq2pd xmm1, xmm1
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR __real@400921fb54442d18
	divsd	xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 813  :     return cos((double)_X);

	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\overlap.cpp

; 89   : 			fWin1UVy[i] = float (cos(PI*(i-ny+oy+0.5f)/(oy*2)));

	mov	eax, DWORD PTR [edi+36]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0
	mov	eax, DWORD PTR [edi+36]

; 90   : 			fWin1UVy[i] = fWin1UVy[i]*fWin1UVy[i];// right window (falled cosine)

	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm0
	movss	DWORD PTR [eax+esi*4], xmm0

; 91   : 			fWin1UVyfirst[i] = fWin1UVy[i]; // very first window

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [edi+40]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ecx+esi*4], eax

; 92   : 			fWin1UVylast[i] = 1; // very last

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+esi*4], 1065353216	; 3f800000H
	inc	esi
	cmp	esi, DWORD PTR [edi+4]
	jl	SHORT $LL19@OverlapWin
$LN18@OverlapWin:

; 93   : 	   }
; 94   : 
; 95   : 
; 96   : 		Overlap9Windows = new short[size*9];

	mov	eax, DWORD PTR [edi+16]
	xor	ecx, ecx
	mov	edx, 2
	lea	eax, DWORD PTR [eax+eax*8]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 97   : 
; 98   : 	   short *winOverUVTL = Overlap9Windows;
; 99   : 	   short *winOverUVTM = Overlap9Windows + size;

	mov	ecx, DWORD PTR [edi+16]
	mov	ebx, eax
	mov	DWORD PTR _winOverUVBR$1$[esp+92], ecx

; 100  : 	   short *winOverUVTR = Overlap9Windows + size*2;
; 101  : 	   short *winOverUVML = Overlap9Windows + size*3;
; 102  : 	   short *winOverUVMM = Overlap9Windows + size*4;
; 103  : 	   short *winOverUVMR = Overlap9Windows + size*5;
; 104  : 	   short *winOverUVBL = Overlap9Windows + size*6;
; 105  : 	   short *winOverUVBM = Overlap9Windows + size*7;
; 106  : 	   short *winOverUVBR = Overlap9Windows + size*8;
; 107  : 
; 108  : 	   for (int j=0; j<ny; j++)

	xor	esi, esi
	add	esp, 4
	mov	DWORD PTR _winOverUVTL$1$[esp+88], ebx
	mov	DWORD PTR [edi+20], ebx
	lea	eax, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR _winOverUVTR$1$[esp+88], eax
	lea	edx, DWORD PTR [ebx+ecx*2]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR _winOverUVTM$1$[esp+88], edx
	lea	eax, DWORD PTR [ebx+ecx*2]
	mov	ecx, DWORD PTR _winOverUVBR$1$[esp+88]
	mov	DWORD PTR _winOverUVML$1$[esp+88], eax
	lea	eax, DWORD PTR [ebx+ecx*8]
	mov	DWORD PTR _winOverUVMM$1$[esp+88], eax
	lea	eax, DWORD PTR [ecx+ecx*4]
	lea	eax, DWORD PTR [ebx+eax*2]
	mov	DWORD PTR _winOverUVMR$1$[esp+88], eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR _winOverUVBL$1$[esp+88], eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	ecx, 4
	add	ecx, ebx
	mov	DWORD PTR _winOverUVBR$1$[esp+88], ecx
	lea	eax, DWORD PTR [ebx+eax*2]
	mov	DWORD PTR _winOverUVBM$1$[esp+88], eax
	cmp	DWORD PTR [edi+4], esi
	jle	$LN79@OverlapWin
	movss	xmm2, DWORD PTR __real@45000000
	npad	9
$LL22@OverlapWin:

; 109  : 	   {
; 110  : 		   for (int i=0; i<nx; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi], ebx
	jle	$LN24@OverlapWin
	mov	eax, DWORD PTR _winOverUVTL$1$[esp+88]
	sub	eax, edx
	movss	xmm1, DWORD PTR __real@3f000000
	mov	DWORD PTR tv1563[esp+88], eax
	mov	eax, DWORD PTR _winOverUVTR$1$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1564[esp+88], edx
	mov	DWORD PTR tv1562[esp+88], eax
	mov	eax, DWORD PTR _winOverUVML$1$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1561[esp+88], eax
	mov	eax, DWORD PTR _winOverUVMM$1$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1560[esp+88], eax
	mov	eax, DWORD PTR _winOverUVMR$1$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1559[esp+88], eax
	mov	eax, DWORD PTR _winOverUVBL$1$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1558[esp+88], eax
	mov	eax, DWORD PTR _winOverUVBM$1$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1557[esp+88], eax
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR tv1556[esp+88], eax
$LL25@OverlapWin:

; 111  : 		   {
; 112  : 			   winOverUVTL[i] = (int)(fWin1UVyfirst[j]*fWin1UVxfirst[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [edi+28]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR tv1563[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 113  : 			   winOverUVTM[i] = (int)(fWin1UVyfirst[j]*fWin1UVx[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [edi+24]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, DWORD PTR [ecx+ebx*4]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [edx], ax

; 114  : 			   winOverUVTR[i] = (int)(fWin1UVyfirst[j]*fWin1UVxlast[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [edi+32]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR tv1562[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 115  : 			   winOverUVML[i] = (int)(fWin1UVy[j]*fWin1UVxfirst[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+36]
	movss	xmm0, DWORD PTR [eax+ebx*4]
	mulss	xmm0, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR tv1561[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 116  : 			   winOverUVMM[i] = (int)(fWin1UVy[j]*fWin1UVx[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [edi+24]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR tv1560[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 117  : 			   winOverUVMR[i] = (int)(fWin1UVy[j]*fWin1UVxlast[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR [edi+32]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR tv1559[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 118  : 			   winOverUVBL[i] = (int)(fWin1UVylast[j]*fWin1UVxfirst[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+44]
	movss	xmm0, DWORD PTR [eax+ebx*4]
	mulss	xmm0, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR tv1558[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 119  : 			   winOverUVBM[i] = (int)(fWin1UVylast[j]*fWin1UVx[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+24]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR tv1557[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 120  : 			   winOverUVBR[i] = (int)(fWin1UVylast[j]*fWin1UVxlast[i]*2048 + 0.5f);

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+32]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, DWORD PTR [ecx+ebx*4]
	inc	ebx
	mov	ecx, DWORD PTR tv1556[esp+88]
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	WORD PTR [ecx+edx], ax

; 109  : 	   {
; 110  : 		   for (int i=0; i<nx; i++)

	add	edx, 2
	cmp	ebx, DWORD PTR [edi]
	jl	$LL25@OverlapWin
	mov	edx, DWORD PTR _winOverUVTM$1$[esp+88]
	mov	ecx, DWORD PTR _winOverUVBR$1$[esp+88]
$LN24@OverlapWin:

; 121  : 		   }
; 122  : 		   winOverUVTL += nx;

	mov	eax, DWORD PTR [edi]
	inc	esi
	add	eax, eax
	add	DWORD PTR _winOverUVTL$1$[esp+88], eax

; 123  : 		   winOverUVTM += nx;

	add	edx, eax

; 124  : 		   winOverUVTR += nx;

	add	DWORD PTR _winOverUVTR$1$[esp+88], eax

; 125  : 		   winOverUVML += nx;
; 126  : 		   winOverUVMM += nx;
; 127  : 		   winOverUVMR += nx;
; 128  : 		   winOverUVBL += nx;
; 129  : 		   winOverUVBM += nx;
; 130  : 		   winOverUVBR += nx;

	add	ecx, eax
	add	DWORD PTR _winOverUVML$1$[esp+88], eax
	add	DWORD PTR _winOverUVMM$1$[esp+88], eax
	add	DWORD PTR _winOverUVMR$1$[esp+88], eax
	add	DWORD PTR _winOverUVBL$1$[esp+88], eax
	add	DWORD PTR _winOverUVBM$1$[esp+88], eax
	mov	DWORD PTR _winOverUVTM$1$[esp+88], edx
	mov	DWORD PTR _winOverUVBR$1$[esp+88], ecx
	cmp	esi, DWORD PTR [edi+4]
	jl	$LL22@OverlapWin
$LN79@OverlapWin:

; 131  : 	   }
; 132  : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0OverlapWindows@@QAE@HHHH@Z ENDP			; OverlapWindows::OverlapWindows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??1OverlapWindows@@QAE@XZ
_TEXT	SEGMENT
??1OverlapWindows@@QAE@XZ PROC				; OverlapWindows::~OverlapWindows, COMDAT
; _this$ = ecx

; 135  : {

	push	esi
	mov	esi, ecx

; 136  : 	delete [] Overlap9Windows;

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 137  : 	delete [] fWin1UVx;

	push	DWORD PTR [esi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 138  : 	delete [] fWin1UVxfirst;

	push	DWORD PTR [esi+28]
	call	??_V@YAXPAX@Z				; operator delete[]

; 139  : 	delete [] fWin1UVxlast;

	push	DWORD PTR [esi+32]
	call	??_V@YAXPAX@Z				; operator delete[]

; 140  : 	delete [] fWin1UVy;

	push	DWORD PTR [esi+36]
	call	??_V@YAXPAX@Z				; operator delete[]

; 141  : 	delete [] fWin1UVyfirst;

	push	DWORD PTR [esi+40]
	call	??_V@YAXPAX@Z				; operator delete[]

; 142  : 	delete [] fWin1UVylast;

	push	DWORD PTR [esi+44]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 28					; 0000001cH
	pop	esi

; 143  : }

	ret	0
??1OverlapWindows@@QAE@XZ ENDP				; OverlapWindows::~OverlapWindows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z
_TEXT	SEGMENT
_archlist$ = -84					; size = 20
$T2 = -64						; size = 16
$T3 = -64						; size = 16
$T4 = -64						; size = 16
$T5 = -64						; size = 16
$T6 = -64						; size = 16
$T7 = -64						; size = 16
$T8 = -64						; size = 16
$T9 = -64						; size = 16
$T10 = -64						; size = 16
$T11 = -64						; size = 16
$T12 = -64						; size = 16
$T13 = -64						; size = 16
$T14 = -64						; size = 16
$T15 = -64						; size = 16
$T16 = -64						; size = 16
$T17 = -64						; size = 16
$T18 = -64						; size = 16
$T19 = -64						; size = 16
$T20 = -64						; size = 16
$T21 = -64						; size = 16
$T22 = -64						; size = 16
$T23 = -64						; size = 16
$T24 = -64						; size = 16
$T25 = -64						; size = 16
$T26 = -64						; size = 16
$T27 = -64						; size = 16
$T28 = -64						; size = 16
$T29 = -64						; size = 16
$T30 = -64						; size = 16
$T31 = -64						; size = 16
$T32 = -64						; size = 16
$T33 = -64						; size = 16
$T34 = -64						; size = 16
$T35 = -64						; size = 16
$T36 = -64						; size = 16
$T37 = -64						; size = 16
$T38 = -64						; size = 16
$T39 = -64						; size = 16
$T40 = -64						; size = 16
$T41 = -64						; size = 16
$T42 = -64						; size = 16
$T43 = -64						; size = 16
$T44 = -64						; size = 16
$T45 = -64						; size = 16
$T46 = -64						; size = 16
$T47 = -64						; size = 16
$T48 = -64						; size = 16
$T49 = -64						; size = 16
$T50 = -64						; size = 16
$T51 = -64						; size = 16
$T52 = -64						; size = 16
$T53 = -64						; size = 16
$T54 = -64						; size = 16
$T55 = -64						; size = 16
$T56 = -64						; size = 16
$T57 = -64						; size = 16
$T58 = -64						; size = 16
$T59 = -64						; size = 16
$T60 = -64						; size = 16
$T61 = -64						; size = 16
$T62 = -64						; size = 16
$T63 = -64						; size = 16
$T64 = -64						; size = 16
$T65 = -64						; size = 16
$T66 = -64						; size = 16
$T67 = -64						; size = 16
$T68 = -64						; size = 16
$T69 = -64						; size = 16
$T70 = -64						; size = 16
$T71 = -64						; size = 16
$T72 = -64						; size = 16
_func_overlaps$ = -48					; size = 8
_BlockX$ = -40						; size = 4
_BlockY$ = -36						; size = 4
$T73 = -32						; size = 8
$T74 = -32						; size = 8
$T75 = -32						; size = 8
$T76 = -32						; size = 8
$T77 = -32						; size = 8
$T78 = -32						; size = 8
$T79 = -32						; size = 8
$T80 = -32						; size = 8
$T81 = -32						; size = 8
$T82 = -32						; size = 8
$T83 = -32						; size = 8
$T84 = -32						; size = 8
$T85 = -32						; size = 8
$T86 = -32						; size = 8
$T87 = -32						; size = 8
$T88 = -32						; size = 8
$T89 = -32						; size = 8
$T90 = -32						; size = 8
$T91 = -32						; size = 8
$T92 = -32						; size = 8
$T93 = -32						; size = 8
$T94 = -32						; size = 8
$T95 = -32						; size = 8
$T96 = -32						; size = 8
$T97 = -32						; size = 8
$T98 = -32						; size = 8
$T99 = -32						; size = 8
$T100 = -32						; size = 8
$T101 = -32						; size = 8
$T102 = -32						; size = 8
$T103 = -32						; size = 8
$T104 = -32						; size = 8
$T105 = -32						; size = 8
$T106 = -32						; size = 8
$T107 = -32						; size = 8
$T108 = -32						; size = 8
$T109 = -32						; size = 8
$T110 = -32						; size = 8
$T111 = -32						; size = 8
$T112 = -32						; size = 8
$T113 = -32						; size = 8
$T114 = -32						; size = 8
$T115 = -32						; size = 8
$T116 = -32						; size = 8
$T117 = -32						; size = 8
$T118 = -32						; size = 8
$T119 = -32						; size = 8
$T120 = -32						; size = 8
$T121 = -28						; size = 4
$T122 = -28						; size = 4
$T123 = -28						; size = 4
$T124 = -28						; size = 4
$T125 = -28						; size = 4
$T126 = -28						; size = 4
$T127 = -28						; size = 4
$T128 = -28						; size = 4
$T129 = -28						; size = 4
$T130 = -28						; size = 4
$T131 = -28						; size = 4
$T132 = -28						; size = 4
$T133 = -28						; size = 4
$T134 = -28						; size = 4
$T135 = -28						; size = 4
$T136 = -28						; size = 4
$T137 = -28						; size = 4
$T138 = -28						; size = 4
$T139 = -28						; size = 4
$T140 = -28						; size = 4
$T141 = -28						; size = 4
$T142 = -24						; size = 4
$T143 = -24						; size = 4
$T144 = -24						; size = 4
$T145 = -24						; size = 4
$T146 = -24						; size = 4
$T147 = -24						; size = 4
$T148 = -24						; size = 4
$T149 = -24						; size = 4
$T150 = -24						; size = 4
$T151 = -24						; size = 4
$T152 = -24						; size = 4
$T153 = -24						; size = 4
$T154 = -24						; size = 4
$T155 = -24						; size = 4
$T156 = -24						; size = 4
$T157 = -24						; size = 4
$T158 = -24						; size = 4
$T159 = -24						; size = 4
$T160 = -24						; size = 4
$T161 = -24						; size = 4
$T162 = -24						; size = 4
$T163 = -20						; size = 4
$T164 = -20						; size = 4
$T165 = -20						; size = 4
$T166 = -20						; size = 4
$T167 = -20						; size = 4
$T168 = -20						; size = 4
$T169 = -20						; size = 4
$T170 = -20						; size = 4
$T171 = -20						; size = 4
$T172 = -20						; size = 4
$T173 = -20						; size = 4
$T174 = -20						; size = 4
$T175 = -20						; size = 4
$T176 = -20						; size = 4
$T177 = -20						; size = 4
$T178 = -20						; size = 4
$T179 = -20						; size = 4
$T180 = -20						; size = 4
$T181 = -20						; size = 4
$T182 = -20						; size = 4
$T183 = -20						; size = 4
_current_arch_try$184 = -16				; size = 4
$T185 = -16						; size = 4
$T186 = -16						; size = 4
$T187 = -16						; size = 4
$T188 = -16						; size = 4
$T189 = -16						; size = 4
$T190 = -16						; size = 4
$T191 = -16						; size = 4
$T192 = -16						; size = 4
$T193 = -16						; size = 4
$T194 = -16						; size = 4
$T195 = -16						; size = 4
$T196 = -16						; size = 4
$T197 = -16						; size = 4
$T198 = -16						; size = 4
$T199 = -16						; size = 4
$T200 = -16						; size = 4
$T201 = -16						; size = 4
$T202 = -16						; size = 4
$T203 = -16						; size = 4
$T204 = -16						; size = 4
$T205 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pixelsize$ = 8						; size = 4
_arch$ = 12						; size = 4
?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z PROC ; get_overlaps_function, COMDAT
; _BlockX$ = ecx
; _BlockY$ = edx

; 535  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _BlockY$[ebp], edx
	mov	DWORD PTR _BlockX$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR _func_overlaps$[ebp], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR _func_overlaps$[ebp+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR _func_overlaps$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T72[ebp]
; File c:\github\mvtools\sources\overlap.cpp

; 539  :     std::map<std::tuple<int, int, int, arch_t>, OverlapsFunction*> func_overlaps;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	lea	eax, DWORD PTR $T120[ebp]
	push	eax
	movups	XMMWORD PTR $T72[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 541  :     func_overlaps[make_tuple(32, 32, 1, NO_SIMD)] = Overlaps_C<uint8_t, 32, 32>;

	mov	eax, DWORD PTR $T120[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 541  :     func_overlaps[make_tuple(32, 32, 1, NO_SIMD)] = Overlaps_C<uint8_t, 32, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,32,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T71[ebp]
	push	eax
	lea	eax, DWORD PTR $T119[ebp]
	push	eax
	movups	XMMWORD PTR $T71[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 542  :     func_overlaps[make_tuple(32, 16, 1, NO_SIMD)] = Overlaps_C<uint8_t, 32, 16>;

	mov	eax, DWORD PTR $T119[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 542  :     func_overlaps[make_tuple(32, 16, 1, NO_SIMD)] = Overlaps_C<uint8_t, 32, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,32,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T70[ebp]
	push	eax
	lea	eax, DWORD PTR $T118[ebp]
	push	eax
	movups	XMMWORD PTR $T70[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 543  :     func_overlaps[make_tuple(32, 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 32, 8>;

	mov	eax, DWORD PTR $T118[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 543  :     func_overlaps[make_tuple(32, 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 32, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0CA@$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,32,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T69[ebp]
	push	eax
	lea	eax, DWORD PTR $T117[ebp]
	push	eax
	movups	XMMWORD PTR $T69[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 544  :     func_overlaps[make_tuple(16, 32, 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 32>;

	mov	eax, DWORD PTR $T117[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 544  :     func_overlaps[make_tuple(16, 32, 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,16,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T68[ebp]
	push	eax
	lea	eax, DWORD PTR $T116[ebp]
	push	eax
	movups	XMMWORD PTR $T68[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 545  :     func_overlaps[make_tuple(16, 16, 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 16>;

	mov	eax, DWORD PTR $T116[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 545  :     func_overlaps[make_tuple(16, 16, 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,16,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T67[ebp]
	push	eax
	lea	eax, DWORD PTR $T115[ebp]
	push	eax
	movups	XMMWORD PTR $T67[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 546  :     func_overlaps[make_tuple(16, 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 8>;

	mov	eax, DWORD PTR $T115[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 546  :     func_overlaps[make_tuple(16, 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0BA@$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,16,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T66[ebp]
	push	eax
	lea	eax, DWORD PTR $T114[ebp]
	push	eax
	movups	XMMWORD PTR $T66[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 547  :     func_overlaps[make_tuple(16, 4 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 4>;

	mov	eax, DWORD PTR $T114[ebp]
	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0BA@$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,16,4>
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T65[ebp]
	push	eax
	lea	eax, DWORD PTR $T113[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movups	XMMWORD PTR $T65[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 548  :     func_overlaps[make_tuple(16, 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 2>;

	mov	eax, DWORD PTR $T113[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 548  :     func_overlaps[make_tuple(16, 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 16, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$0BA@$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,16,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T64[ebp]
	push	eax
	lea	eax, DWORD PTR $T112[ebp]
	push	eax
	movups	XMMWORD PTR $T64[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 549  :     func_overlaps[make_tuple(8 , 16, 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 16>;

	mov	eax, DWORD PTR $T112[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 549  :     func_overlaps[make_tuple(8 , 16, 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$07$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,8,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T63[ebp]
	push	eax
	lea	eax, DWORD PTR $T111[ebp]
	push	eax
	movups	XMMWORD PTR $T63[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 550  :     func_overlaps[make_tuple(8 , 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 8>;

	mov	eax, DWORD PTR $T111[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 550  :     func_overlaps[make_tuple(8 , 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$07$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,8,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T62[ebp]
	push	eax
	lea	eax, DWORD PTR $T110[ebp]
	push	eax
	movups	XMMWORD PTR $T62[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 551  :     func_overlaps[make_tuple(8 , 4 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 4>;

	mov	eax, DWORD PTR $T110[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 551  :     func_overlaps[make_tuple(8 , 4 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$07$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,8,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T61[ebp]
	push	eax
	lea	eax, DWORD PTR $T109[ebp]
	push	eax
	movups	XMMWORD PTR $T61[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 552  :     func_overlaps[make_tuple(8 , 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 2>;

	mov	eax, DWORD PTR $T109[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 552  :     func_overlaps[make_tuple(8 , 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$07$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,8,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T60[ebp]
	push	eax
	lea	eax, DWORD PTR $T108[ebp]
	push	eax
	movups	XMMWORD PTR $T60[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 553  :     func_overlaps[make_tuple(8 , 1 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 1>;

	mov	eax, DWORD PTR $T108[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 553  :     func_overlaps[make_tuple(8 , 1 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 8 , 1>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$07$00@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,8,1>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T59[ebp]
	push	eax
	lea	eax, DWORD PTR $T107[ebp]
	push	eax
	movups	XMMWORD PTR $T59[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 554  :     func_overlaps[make_tuple(4 , 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 4 , 8>;

	mov	eax, DWORD PTR $T107[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 554  :     func_overlaps[make_tuple(4 , 8 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 4 , 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$03$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,4,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T58[ebp]
	push	eax
	lea	eax, DWORD PTR $T106[ebp]
	push	eax
	movups	XMMWORD PTR $T58[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 555  :     func_overlaps[make_tuple(4 , 4 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 4 , 4>;

	mov	eax, DWORD PTR $T106[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000020000000100000000
	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$03$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,4,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T57[ebp]
	push	eax
	lea	eax, DWORD PTR $T105[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movups	XMMWORD PTR $T57[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 556  :     func_overlaps[make_tuple(4 , 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 4 , 2>;

	mov	eax, DWORD PTR $T105[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 556  :     func_overlaps[make_tuple(4 , 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 4 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$03$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,4,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T56[ebp]
	push	eax
	lea	eax, DWORD PTR $T104[ebp]
	push	eax
	movups	XMMWORD PTR $T56[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 557  :     func_overlaps[make_tuple(2 , 4 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 2 , 4>;

	mov	eax, DWORD PTR $T104[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000020000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 557  :     func_overlaps[make_tuple(2 , 4 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 2 , 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$01$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,2,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T55[ebp]
	push	eax
	lea	eax, DWORD PTR $T103[ebp]
	push	eax
	movups	XMMWORD PTR $T55[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 558  :     func_overlaps[make_tuple(2 , 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 2 , 2>;

	mov	eax, DWORD PTR $T103[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 558  :     func_overlaps[make_tuple(2 , 2 , 1, NO_SIMD)] = Overlaps_C<uint8_t, 2 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@E$01$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned char,2,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T54[ebp]
	push	eax
	lea	eax, DWORD PTR $T102[ebp]
	push	eax
	movups	XMMWORD PTR $T54[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 560  :     func_overlaps[make_tuple(32, 32, 2, NO_SIMD)] = Overlaps_C<uint16_t, 32, 32>;

	mov	eax, DWORD PTR $T102[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 560  :     func_overlaps[make_tuple(32, 32, 2, NO_SIMD)] = Overlaps_C<uint16_t, 32, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,32,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T53[ebp]
	push	eax
	lea	eax, DWORD PTR $T101[ebp]
	push	eax
	movups	XMMWORD PTR $T53[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 561  :     func_overlaps[make_tuple(32, 16, 2, NO_SIMD)] = Overlaps_C<uint16_t, 32, 16>;

	mov	eax, DWORD PTR $T101[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 561  :     func_overlaps[make_tuple(32, 16, 2, NO_SIMD)] = Overlaps_C<uint16_t, 32, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,32,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T52[ebp]
	push	eax
	lea	eax, DWORD PTR $T100[ebp]
	push	eax
	movups	XMMWORD PTR $T52[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 562  :     func_overlaps[make_tuple(32, 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 32, 8>;

	mov	eax, DWORD PTR $T100[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 562  :     func_overlaps[make_tuple(32, 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 32, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0CA@$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,32,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T51[ebp]
	push	eax
	lea	eax, DWORD PTR $T99[ebp]
	push	eax
	movups	XMMWORD PTR $T51[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 563  :     func_overlaps[make_tuple(16, 32, 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 32>;

	mov	eax, DWORD PTR $T99[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 563  :     func_overlaps[make_tuple(16, 32, 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,16,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T50[ebp]
	push	eax
	lea	eax, DWORD PTR $T98[ebp]
	push	eax
	movups	XMMWORD PTR $T50[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 564  :     func_overlaps[make_tuple(16, 16, 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 16>;

	mov	eax, DWORD PTR $T98[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,16,16>
	movups	XMMWORD PTR $T49[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T49[ebp]
	push	eax
	lea	eax, DWORD PTR $T97[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 565  :     func_overlaps[make_tuple(16, 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 8>;

	mov	eax, DWORD PTR $T97[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 565  :     func_overlaps[make_tuple(16, 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0BA@$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,16,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T48[ebp]
	push	eax
	lea	eax, DWORD PTR $T96[ebp]
	push	eax
	movups	XMMWORD PTR $T48[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 566  :     func_overlaps[make_tuple(16, 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 4>;

	mov	eax, DWORD PTR $T96[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 566  :     func_overlaps[make_tuple(16, 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0BA@$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,16,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T47[ebp]
	push	eax
	lea	eax, DWORD PTR $T95[ebp]
	push	eax
	movups	XMMWORD PTR $T47[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 567  :     func_overlaps[make_tuple(16, 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 2>;

	mov	eax, DWORD PTR $T95[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 567  :     func_overlaps[make_tuple(16, 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 16, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$0BA@$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,16,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T46[ebp]
	push	eax
	lea	eax, DWORD PTR $T94[ebp]
	push	eax
	movups	XMMWORD PTR $T46[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 568  :     func_overlaps[make_tuple(8 , 16, 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 16>;

	mov	eax, DWORD PTR $T94[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 568  :     func_overlaps[make_tuple(8 , 16, 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$07$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,8,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T45[ebp]
	push	eax
	lea	eax, DWORD PTR $T93[ebp]
	push	eax
	movups	XMMWORD PTR $T45[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 569  :     func_overlaps[make_tuple(8 , 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 8>;

	mov	eax, DWORD PTR $T93[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 569  :     func_overlaps[make_tuple(8 , 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$07$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,8,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T44[ebp]
	push	eax
	lea	eax, DWORD PTR $T92[ebp]
	push	eax
	movups	XMMWORD PTR $T44[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 570  :     func_overlaps[make_tuple(8 , 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 4>;

	mov	eax, DWORD PTR $T92[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 570  :     func_overlaps[make_tuple(8 , 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$07$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,8,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T43[ebp]
	push	eax
	lea	eax, DWORD PTR $T91[ebp]
	push	eax
	movups	XMMWORD PTR $T43[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 571  :     func_overlaps[make_tuple(8 , 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 2>;

	mov	eax, DWORD PTR $T91[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 571  :     func_overlaps[make_tuple(8 , 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$07$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,8,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T42[ebp]
	push	eax
	lea	eax, DWORD PTR $T90[ebp]
	push	eax
	movups	XMMWORD PTR $T42[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 572  :     func_overlaps[make_tuple(8 , 1 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 8 , 1>;

	mov	eax, DWORD PTR $T90[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$07$00@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,8,1>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T41[ebp]
	movups	XMMWORD PTR $T41[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR $T89[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 573  :     func_overlaps[make_tuple(4 , 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 4 , 8>;

	mov	eax, DWORD PTR $T89[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000040000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 573  :     func_overlaps[make_tuple(4 , 8 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 4 , 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$03$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,4,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T40[ebp]
	push	eax
	lea	eax, DWORD PTR $T88[ebp]
	push	eax
	movups	XMMWORD PTR $T40[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 574  :     func_overlaps[make_tuple(4 , 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 4 , 4>;

	mov	eax, DWORD PTR $T88[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000020000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 574  :     func_overlaps[make_tuple(4 , 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 4 , 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$03$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,4,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T39[ebp]
	push	eax
	lea	eax, DWORD PTR $T87[ebp]
	push	eax
	movups	XMMWORD PTR $T39[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 575  :     func_overlaps[make_tuple(4 , 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 4 , 2>;

	mov	eax, DWORD PTR $T87[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000040000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 575  :     func_overlaps[make_tuple(4 , 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 4 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$03$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,4,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T38[ebp]
	push	eax
	lea	eax, DWORD PTR $T86[ebp]
	push	eax
	movups	XMMWORD PTR $T38[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 576  :     func_overlaps[make_tuple(2 , 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 2 , 4>;

	mov	eax, DWORD PTR $T86[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000020000000200000000
; File c:\github\mvtools\sources\overlap.cpp

; 576  :     func_overlaps[make_tuple(2 , 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 2 , 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$01$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,2,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T37[ebp]
	push	eax
	lea	eax, DWORD PTR $T85[ebp]
	push	eax
	movups	XMMWORD PTR $T37[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 577  :     func_overlaps[make_tuple(2 , 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 2 , 2>;

	mov	eax, DWORD PTR $T85[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 577  :     func_overlaps[make_tuple(2 , 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 2 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$Overlaps_C@G$01$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_C<unsigned short,2,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T36[ebp]
	push	eax
	lea	eax, DWORD PTR $T84[ebp]
	push	eax
	movups	XMMWORD PTR $T36[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 579  :     func_overlaps[make_tuple(32, 32, 1, USE_SSE2)] = Overlaps32x32_sse2;

	mov	eax, DWORD PTR $T84[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 579  :     func_overlaps[make_tuple(32, 32, 1, USE_SSE2)] = Overlaps32x32_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps32x32_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T35[ebp]
	push	eax
	lea	eax, DWORD PTR $T83[ebp]
	push	eax
	movups	XMMWORD PTR $T35[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 580  :     func_overlaps[make_tuple(32, 16, 1, USE_SSE2)] = Overlaps32x16_sse2;

	mov	eax, DWORD PTR $T83[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 580  :     func_overlaps[make_tuple(32, 16, 1, USE_SSE2)] = Overlaps32x16_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps32x16_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T34[ebp]
	push	eax
	lea	eax, DWORD PTR $T82[ebp]
	push	eax
	movups	XMMWORD PTR $T34[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 581  :     func_overlaps[make_tuple(32, 8 , 1, USE_SSE2)] = Overlaps32x8_sse2;

	mov	eax, DWORD PTR $T82[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000100000002
	mov	DWORD PTR [eax+32], OFFSET _Overlaps32x8_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T33[ebp]
	movups	XMMWORD PTR $T33[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR $T81[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 582  :     func_overlaps[make_tuple(16, 32, 1, USE_SSE2)] = Overlaps16x32_sse2;

	mov	eax, DWORD PTR $T81[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 582  :     func_overlaps[make_tuple(16, 32, 1, USE_SSE2)] = Overlaps16x32_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps16x32_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	lea	eax, DWORD PTR $T80[ebp]
	push	eax
	movups	XMMWORD PTR $T32[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 583  :     func_overlaps[make_tuple(16, 16, 1, USE_SSE2)] = Overlaps16x16_sse2;

	mov	eax, DWORD PTR $T80[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 583  :     func_overlaps[make_tuple(16, 16, 1, USE_SSE2)] = Overlaps16x16_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps16x16_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T31[ebp]
	push	eax
	lea	eax, DWORD PTR $T79[ebp]
	push	eax
	movups	XMMWORD PTR $T31[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 584  :     func_overlaps[make_tuple(16, 8 , 1, USE_SSE2)] = Overlaps16x8_sse2;

	mov	eax, DWORD PTR $T79[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 584  :     func_overlaps[make_tuple(16, 8 , 1, USE_SSE2)] = Overlaps16x8_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps16x8_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T30[ebp]
	push	eax
	lea	eax, DWORD PTR $T78[ebp]
	push	eax
	movups	XMMWORD PTR $T30[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 585  :     func_overlaps[make_tuple(16, 4 , 1, USE_SSE2)] = Overlaps16x4_sse2;

	mov	eax, DWORD PTR $T78[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 585  :     func_overlaps[make_tuple(16, 4 , 1, USE_SSE2)] = Overlaps16x4_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps16x4_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	lea	eax, DWORD PTR $T77[ebp]
	push	eax
	movups	XMMWORD PTR $T29[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 586  :     func_overlaps[make_tuple(16, 2 , 1, USE_SSE2)] = Overlaps16x2_sse2;

	mov	eax, DWORD PTR $T77[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 586  :     func_overlaps[make_tuple(16, 2 , 1, USE_SSE2)] = Overlaps16x2_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps16x2_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T28[ebp]
	push	eax
	lea	eax, DWORD PTR $T76[ebp]
	push	eax
	movups	XMMWORD PTR $T28[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 587  :     func_overlaps[make_tuple(8 , 16, 1, USE_SSE2)] = Overlaps8x16_sse2;

	mov	eax, DWORD PTR $T76[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 587  :     func_overlaps[make_tuple(8 , 16, 1, USE_SSE2)] = Overlaps8x16_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps8x16_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	lea	eax, DWORD PTR $T75[ebp]
	push	eax
	movups	XMMWORD PTR $T27[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 588  :     func_overlaps[make_tuple(8 , 8 , 1, USE_SSE2)] = Overlaps8x8_sse2;

	mov	eax, DWORD PTR $T75[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000002
; File c:\github\mvtools\sources\overlap.cpp

; 588  :     func_overlaps[make_tuple(8 , 8 , 1, USE_SSE2)] = Overlaps8x8_sse2;

	mov	DWORD PTR [eax+32], OFFSET _Overlaps8x8_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	lea	eax, DWORD PTR $T74[ebp]
	push	eax
	movups	XMMWORD PTR $T26[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 589  :     func_overlaps[make_tuple(8 , 4 , 1, USE_SSE2)] = Overlaps8x4_sse2;

	mov	eax, DWORD PTR $T74[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000100000002
	mov	DWORD PTR [eax+32], OFFSET _Overlaps8x4_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T25[ebp]
	push	eax
	movups	XMMWORD PTR $T25[ebp], xmm0
	lea	eax, DWORD PTR $T73[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 590  :     func_overlaps[make_tuple(8 , 2 , 1, USE_SSE2)] = Overlaps8x2_sse2;

	mov	eax, DWORD PTR $T73[ebp]

; 591  :     func_overlaps[make_tuple(8 , 1 , 1, USE_SSE2)] = Overlaps8x1_sse2;

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000100000002
	mov	DWORD PTR [eax+32], OFFSET _Overlaps8x2_sse2
	lea	eax, DWORD PTR $T24[ebp]
	push	eax
	movups	XMMWORD PTR $T24[ebp], xmm0
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 592  :     func_overlaps[make_tuple(4 , 8 , 1, USE_SSE2)] = Overlaps4x8_sse2;

	lea	edx, DWORD PTR $T141[ebp]
	mov	DWORD PTR $T205[ebp], 2
	lea	ecx, DWORD PTR $T23[ebp]
	mov	DWORD PTR $T183[ebp], 1
	mov	DWORD PTR $T162[ebp], 8
	mov	DWORD PTR [eax], OFFSET _Overlaps8x1_sse2
	lea	eax, DWORD PTR $T205[ebp]
	push	eax
	lea	eax, DWORD PTR $T183[ebp]
	mov	DWORD PTR $T141[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T162[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 593  :     func_overlaps[make_tuple(4 , 4 , 1, USE_SSE2)] = Overlaps4x4_sse2;

	lea	edx, DWORD PTR $T204[ebp]
	mov	DWORD PTR $T140[ebp], 2
	lea	ecx, DWORD PTR $T22[ebp]
	mov	DWORD PTR $T161[ebp], 1
	mov	DWORD PTR $T182[ebp], 4
	mov	DWORD PTR [eax], OFFSET _Overlaps4x8_sse2
	lea	eax, DWORD PTR $T140[ebp]
	push	eax
	lea	eax, DWORD PTR $T161[ebp]
	mov	DWORD PTR $T204[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T182[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 594  :     func_overlaps[make_tuple(4 , 2 , 1, USE_SSE2)] = Overlaps4x2_sse2;

	lea	edx, DWORD PTR $T203[ebp]
	mov	DWORD PTR $T139[ebp], 2
	lea	ecx, DWORD PTR $T21[ebp]
	mov	DWORD PTR $T160[ebp], 1
	mov	DWORD PTR $T181[ebp], 2
	mov	DWORD PTR [eax], OFFSET _Overlaps4x4_sse2
	lea	eax, DWORD PTR $T139[ebp]
	push	eax
	lea	eax, DWORD PTR $T160[ebp]
	mov	DWORD PTR $T203[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T181[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 595  :     func_overlaps[make_tuple(2 , 4 , 1, USE_SSE2)] = Overlaps2x4_sse2;

	lea	edx, DWORD PTR $T202[ebp]
	mov	DWORD PTR $T138[ebp], 2
	lea	ecx, DWORD PTR $T20[ebp]
	mov	DWORD PTR $T159[ebp], 1
	mov	DWORD PTR $T180[ebp], 4
	mov	DWORD PTR [eax], OFFSET _Overlaps4x2_sse2
	lea	eax, DWORD PTR $T138[ebp]
	push	eax
	lea	eax, DWORD PTR $T159[ebp]
	mov	DWORD PTR $T202[ebp], 2
	push	eax
	lea	eax, DWORD PTR $T180[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 596  :     func_overlaps[make_tuple(2 , 2 , 1, USE_SSE2)] = Overlaps2x2_sse2;

	lea	edx, DWORD PTR $T201[ebp]
	mov	DWORD PTR $T137[ebp], 2
	lea	ecx, DWORD PTR $T19[ebp]
	mov	DWORD PTR $T158[ebp], 1
	mov	DWORD PTR $T179[ebp], 2
	mov	DWORD PTR [eax], OFFSET _Overlaps2x4_sse2
	lea	eax, DWORD PTR $T137[ebp]
	push	eax
	lea	eax, DWORD PTR $T158[ebp]
	mov	DWORD PTR $T201[ebp], 2
	push	eax
	lea	eax, DWORD PTR $T179[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 597  :     
; 598  :     func_overlaps[make_tuple(32, 32, 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 32, 32>;

	lea	edx, DWORD PTR $T200[ebp]
	mov	DWORD PTR $T136[ebp], 3
	lea	ecx, DWORD PTR $T18[ebp]
	mov	DWORD PTR $T157[ebp], 2
	mov	DWORD PTR $T178[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET _Overlaps2x2_sse2
	lea	eax, DWORD PTR $T136[ebp]
	push	eax
	lea	eax, DWORD PTR $T157[ebp]
	mov	DWORD PTR $T200[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T178[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 599  :     func_overlaps[make_tuple(32, 16, 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 32, 16>;

	lea	edx, DWORD PTR $T199[ebp]
	mov	DWORD PTR $T135[ebp], 3
	lea	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR $T156[ebp], 2
	mov	DWORD PTR $T177[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,32,32>
	lea	eax, DWORD PTR $T135[ebp]
	push	eax
	lea	eax, DWORD PTR $T156[ebp]
	mov	DWORD PTR $T199[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T177[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 600  :     func_overlaps[make_tuple(32, 8 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 32, 8>;

	lea	edx, DWORD PTR $T198[ebp]
	mov	DWORD PTR $T134[ebp], 3
	lea	ecx, DWORD PTR $T16[ebp]
	mov	DWORD PTR $T155[ebp], 2
	mov	DWORD PTR $T176[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,32,16>
	lea	eax, DWORD PTR $T134[ebp]
	push	eax
	lea	eax, DWORD PTR $T155[ebp]
	mov	DWORD PTR $T198[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T176[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 601  :     func_overlaps[make_tuple(16, 32, 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 16, 32>;

	mov	DWORD PTR $T133[ebp], 3
	mov	DWORD PTR $T154[ebp], 2
	mov	DWORD PTR $T175[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0CA@$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,32,8>
	lea	eax, DWORD PTR $T133[ebp]
	mov	DWORD PTR $T197[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T154[ebp]
	push	eax
	lea	eax, DWORD PTR $T175[ebp]
	push	eax
	lea	edx, DWORD PTR $T197[ebp]
	lea	ecx, DWORD PTR $T15[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 602  :     func_overlaps[make_tuple(16, 16, 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 16, 16>;

	lea	edx, DWORD PTR $T196[ebp]
	mov	DWORD PTR $T132[ebp], 3
	lea	ecx, DWORD PTR $T14[ebp]
	mov	DWORD PTR $T153[ebp], 2
	mov	DWORD PTR $T174[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,16,32>
	lea	eax, DWORD PTR $T132[ebp]
	push	eax
	lea	eax, DWORD PTR $T153[ebp]
	mov	DWORD PTR $T196[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T174[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 603  :     func_overlaps[make_tuple(16, 8 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 16, 8>;

	lea	edx, DWORD PTR $T195[ebp]
	mov	DWORD PTR $T131[ebp], 3
	lea	ecx, DWORD PTR $T13[ebp]
	mov	DWORD PTR $T152[ebp], 2
	mov	DWORD PTR $T173[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,16,16>
	lea	eax, DWORD PTR $T131[ebp]
	push	eax
	lea	eax, DWORD PTR $T152[ebp]
	mov	DWORD PTR $T195[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T173[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 604  :     func_overlaps[make_tuple(16, 4 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 16, 4>;

	lea	edx, DWORD PTR $T194[ebp]
	mov	DWORD PTR $T130[ebp], 3
	lea	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR $T151[ebp], 2
	mov	DWORD PTR $T172[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0BA@$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,16,8>
	lea	eax, DWORD PTR $T130[ebp]
	push	eax
	lea	eax, DWORD PTR $T151[ebp]
	mov	DWORD PTR $T194[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T172[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 605  :     func_overlaps[make_tuple(16, 2 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 16, 2>;

	lea	edx, DWORD PTR $T193[ebp]
	mov	DWORD PTR $T129[ebp], 3
	lea	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T150[ebp], 2
	mov	DWORD PTR $T171[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0BA@$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,16,4>
	lea	eax, DWORD PTR $T129[ebp]
	push	eax
	lea	eax, DWORD PTR $T150[ebp]
	mov	DWORD PTR $T193[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T171[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 606  :     func_overlaps[make_tuple(8 , 16, 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 8 , 16>;

	lea	edx, DWORD PTR $T192[ebp]
	mov	DWORD PTR $T128[ebp], 3
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T149[ebp], 2
	mov	DWORD PTR $T170[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$0BA@$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,16,2>
	lea	eax, DWORD PTR $T128[ebp]
	push	eax
	lea	eax, DWORD PTR $T149[ebp]
	mov	DWORD PTR $T192[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T170[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 607  :     func_overlaps[make_tuple(8 , 8 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 8 , 8>;

	lea	edx, DWORD PTR $T191[ebp]
	mov	DWORD PTR $T127[ebp], 3
	lea	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T148[ebp], 2
	mov	DWORD PTR $T169[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$07$0BA@@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,8,16>
	lea	eax, DWORD PTR $T127[ebp]
	push	eax
	lea	eax, DWORD PTR $T148[ebp]
	mov	DWORD PTR $T191[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T169[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 608  :     func_overlaps[make_tuple(8 , 4 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 8 , 4>;

	lea	edx, DWORD PTR $T190[ebp]
	mov	DWORD PTR $T126[ebp], 3
	lea	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T147[ebp], 2
	mov	DWORD PTR $T168[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$07$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,8,8>
	lea	eax, DWORD PTR $T126[ebp]
	push	eax
	lea	eax, DWORD PTR $T147[ebp]
	mov	DWORD PTR $T190[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T168[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 609  :     func_overlaps[make_tuple(8 , 2 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 8 , 2>;

	lea	edx, DWORD PTR $T189[ebp]
	mov	DWORD PTR $T125[ebp], 3
	lea	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T146[ebp], 2
	mov	DWORD PTR $T167[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$07$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,8,4>
	lea	eax, DWORD PTR $T125[ebp]
	push	eax
	lea	eax, DWORD PTR $T146[ebp]
	mov	DWORD PTR $T189[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T167[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 610  :     func_overlaps[make_tuple(8 , 1 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 8 , 1>;

	mov	DWORD PTR $T124[ebp], 3
	mov	DWORD PTR $T145[ebp], 2
	mov	DWORD PTR $T166[ebp], 1
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$07$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,8,2>
	lea	eax, DWORD PTR $T124[ebp]
	mov	DWORD PTR $T188[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T145[ebp]
	push	eax
	lea	eax, DWORD PTR $T166[ebp]
	push	eax
	lea	edx, DWORD PTR $T188[ebp]
	lea	ecx, DWORD PTR $T6[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 611  :     func_overlaps[make_tuple(4 , 8 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 4 , 8>;

	lea	edx, DWORD PTR $T187[ebp]
	mov	DWORD PTR $T123[ebp], 3
	lea	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T144[ebp], 2
	mov	DWORD PTR $T165[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$07$00@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,8,1>
	lea	eax, DWORD PTR $T123[ebp]
	push	eax
	lea	eax, DWORD PTR $T144[ebp]
	mov	DWORD PTR $T187[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T165[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 612  :     func_overlaps[make_tuple(4 , 4 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 4 , 4>;

	lea	edx, DWORD PTR $T186[ebp]
	mov	DWORD PTR $T122[ebp], 3
	lea	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T143[ebp], 2
	mov	DWORD PTR $T164[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$03$07@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,4,8>
	lea	eax, DWORD PTR $T122[ebp]
	push	eax
	lea	eax, DWORD PTR $T143[ebp]
	mov	DWORD PTR $T186[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T164[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]

; 613  :     func_overlaps[make_tuple(4 , 2 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 4 , 2>;

	lea	edx, DWORD PTR $T185[ebp]
	mov	DWORD PTR $T121[ebp], 3
	lea	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T142[ebp], 2
	mov	DWORD PTR $T163[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$03$03@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,4,4>
	lea	eax, DWORD PTR $T121[ebp]
	push	eax
	lea	eax, DWORD PTR $T142[ebp]
	mov	DWORD PTR $T185[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T163[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000030000000500000006
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	lea	esi, DWORD PTR _archlist$[ebp]
	mov	ebx, DWORD PTR _arch$[ebp]
	movups	XMMWORD PTR _archlist$[ebp], xmm0
; File c:\github\mvtools\sources\overlap.cpp

; 613  :     func_overlaps[make_tuple(4 , 2 , 2, USE_SSE41)] = Overlaps_sse4<uint16_t, 4 , 2>;

	mov	DWORD PTR [eax], OFFSET ??$Overlaps_sse4@G$03$01@@YAXPAGHPBEHPAFH@Z ; Overlaps_sse4<unsigned short,4,2>

; 614  :     //func_overlaps[make_tuple(2 , 4 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 2 , 4>;
; 615  :     //func_overlaps[make_tuple(2 , 2 , 2, NO_SIMD)] = Overlaps_C<uint16_t, 2 , 2>;
; 616  :     
; 617  : 
; 618  : 
; 619  : #if 0
; 620  :     // Why did the original code used sse2 named functions for overlaps 
; 621  :     // when no CPUF_SSE2 was detected bit isse param is true?
; 622  :     func_overlaps[make_tuple(32, 32, 1, USE_MMX)] = Overlaps32x32_sse2;
; 623  :     func_overlaps[make_tuple(32, 16, 1, USE_MMX)] = Overlaps32x16_sse2;
; 624  :     func_overlaps[make_tuple(32, 8 , 1, USE_MMX)] = Overlaps32x8_sse2;
; 625  :     func_overlaps[make_tuple(16, 32, 1, USE_MMX)] = Overlaps16x32_sse2;
; 626  :     func_overlaps[make_tuple(16, 16, 1, USE_MMX)] = Overlaps16x16_sse2;
; 627  :     func_overlaps[make_tuple(16, 8 , 1, USE_MMX)] = Overlaps16x8_sse2;
; 628  :     func_overlaps[make_tuple(16, 4 , 1, USE_MMX)] = Overlaps16x4_sse2;
; 629  :     func_overlaps[make_tuple(16, 2 , 1, USE_MMX)] = Overlaps16x2_sse2;
; 630  :     func_overlaps[make_tuple(8 , 16, 1, USE_MMX)] = Overlaps8x16_sse2;
; 631  :     func_overlaps[make_tuple(8 , 8 , 1, USE_MMX)] = Overlaps8x8_sse2;
; 632  :     func_overlaps[make_tuple(8 , 4 , 1, USE_MMX)] = Overlaps8x4_sse2;
; 633  :     func_overlaps[make_tuple(8 , 2 , 1, USE_MMX)] = Overlaps8x2_sse2;
; 634  :     func_overlaps[make_tuple(8 , 1 , 1, USE_MMX)] = Overlaps8x1_sse2;
; 635  :     func_overlaps[make_tuple(4 , 8 , 1, USE_MMX)] = Overlaps4x8_sse2;
; 636  :     func_overlaps[make_tuple(4 , 4 , 1, USE_MMX)] = Overlaps4x4_sse2;
; 637  :     func_overlaps[make_tuple(4 , 2 , 1, USE_MMX)] = Overlaps4x2_sse2;
; 638  :     func_overlaps[make_tuple(2 , 4 , 1, USE_MMX)] = Overlaps2x4_sse2;
; 639  :     func_overlaps[make_tuple(2 , 2 , 1, USE_MMX)] = Overlaps2x2_sse2;
; 640  : #endif
; 641  :     OverlapsFunction *result = nullptr;
; 642  : 
; 643  :     arch_t archlist[] = { USE_AVX2, USE_AVX, USE_SSE41, USE_SSE2, NO_SIMD };

	mov	DWORD PTR _archlist$[ebp+16], 0
	npad	1
$LL2@get_overla:

; 644  :     int index = 0;
; 645  :     while (result == nullptr) {
; 646  :       arch_t current_arch_try = archlist[index++];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+4]
	mov	DWORD PTR _current_arch_try$184[ebp], eax

; 647  :       if (current_arch_try > arch) continue;

	cmp	eax, ebx
	jg	SHORT $LL2@get_overla

; 648  :       result = func_overlaps[make_tuple(BlockX, BlockY, pixelsize, current_arch_try)];

	lea	eax, DWORD PTR _current_arch_try$184[ebp]
	push	eax
	lea	eax, DWORD PTR _pixelsize$[ebp]
	push	eax
	lea	eax, DWORD PTR _BlockY$[ebp]
	push	eax
	lea	edx, DWORD PTR _BlockX$[ebp]
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$make_tuple@AAHAAHAAHAAW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00AAW4arch_t@@@Z ; std::make_tuple<int &,int &,int &,enum arch_t &>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]
	mov	edi, DWORD PTR [eax]

; 649  :       if (result == nullptr && current_arch_try == NO_SIMD)

	test	edi, edi
	jne	SHORT $LN4823@get_overla
	cmp	DWORD PTR _current_arch_try$184[ebp], edi
	jne	SHORT $LL2@get_overla
$LN4823@get_overla:

; 650  :         break;
; 651  :     }
; 652  : #if 0
; 653  :     OverlapsFunction *result = func_overlaps[std::make_tuple(BlockX, BlockY, pixelsize, arch)];
; 654  :     arch_t arch_orig = arch;
; 655  :     // no AVX2 -> try AVX
; 656  :     if (result == nullptr && (arch==USE_AVX2 || arch_orig==USE_AVX)) {
; 657  :       arch = USE_AVX;
; 658  :       result = func_overlaps[make_tuple(BlockX, BlockY, pixelsize, USE_AVX)];
; 659  :     }
; 660  :     // no AVX -> try SSE41
; 661  :     if (result == nullptr && (arch==USE_AVX || arch_orig==USE_SSE41)) {
; 662  :       arch = USE_SSE41;
; 663  :       result = func_overlaps[make_tuple(BlockX, BlockY, pixelsize, USE_SSE41)];
; 664  :     }
; 665  :     // no SSE41 -> try SSE2
; 666  :     if (result == nullptr && (arch==USE_SSE41 || arch_orig==USE_SSE2)) {
; 667  :       arch = USE_SSE2;
; 668  :       result = func_overlaps[make_tuple(BlockX, BlockY, pixelsize, USE_SSE2)];
; 669  :     }
; 670  :     // no SSE2 -> try C
; 671  :     if (result == nullptr && (arch==USE_SSE2 || arch_orig==NO_SIMD)) {
; 672  :       arch = NO_SIMD;
; 673  :       /* C version variations are only working in SAD
; 674  :       // priority: C version compiled to avx2, avx
; 675  :       if(arch_orig==USE_AVX2)
; 676  :       result = get_luma_avx2_C_function(BlockX, BlockY, pixelsize, NO_SIMD);
; 677  :       else if(arch_orig==USE_AVX)
; 678  :       result = get_luma_avx_C_function(BlockX, BlockY, pixelsize, NO_SIMD);
; 679  :       */
; 680  :       if(result == nullptr)
; 681  :         result = func_overlaps[make_tuple(BlockX, BlockY, pixelsize, NO_SIMD)]; // fallback to C
; 682  :     }
; 683  : #endif
; 684  :     return result;

	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	call	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ

; 685  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z$0:
	lea	ecx, DWORD PTR _func_overlaps$[ebp]
	jmp	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ
__ehhandler$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ENDP ; get_overlaps_function
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
; File c:\github\mvtools\sources\include\avs\minmax.h
; File c:\github\mvtools\sources\overlap.cpp
; File c:\github\mvtools\sources\include\avs\minmax.h
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$LimitChanges_c@E@@YAXPAEHPBEHHHH@Z
_TEXT	SEGMENT
_min$1$ = -12						; size = 4
_nDstPitch$1$ = -8					; size = 4
_pDst$1$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
_nLimit$ = 24						; size = 4
??$LimitChanges_c@E@@YAXPAEHPBEHHHH@Z PROC		; LimitChanges_c<unsigned char>, COMDAT
; _pDst$ = ecx
; _nDstPitch$ = edx

; 393  : {

	sub	esp, 12					; 0000000cH
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _pDst$1$[esp+16], ecx

; 394  : 	for (int h=0; h<nHeight; h++)

	mov	ecx, DWORD PTR _nHeight$[esp+12]
	mov	DWORD PTR _nDstPitch$1$[esp+16], edx
	test	ecx, ecx
	jle	$LN3@LimitChang
	mov	edx, DWORD PTR _nWidth$[esp+12]
	mov	eax, DWORD PTR _pSrc$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR _nDstPitch$1$[esp+20]
	push	ebp
	push	esi
	npad	7
$LL4@LimitChang:

; 395  : 	{
; 396  : 		for (int i=0; i<nWidth; i++)

	test	edx, edx
	jle	SHORT $LN6@LimitChang
	mov	esi, DWORD PTR _pSrc$[esp+24]
	mov	eax, edi
	sub	esi, edi
	mov	ebp, edx
	mov	edi, DWORD PTR _nLimit$[esp+24]
$LL7@LimitChang:

; 397  : 			reinterpret_cast<pixel_t *>(pDst)[i] = 

	movzx	edx, BYTE PTR [esi+eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	ebx, BYTE PTR [eax-1]
	lea	ecx, DWORD PTR [edx+edi]
	sub	edx, edi
; File c:\github\mvtools\sources\include\avs\minmax.h

; 50   :     n = n > max ? max : n;

	cmp	ebx, ecx
; File c:\github\mvtools\sources\overlap.cpp

; 397  : 			reinterpret_cast<pixel_t *>(pDst)[i] = 

	mov	DWORD PTR _min$1$[esp+28], edx
; File c:\github\mvtools\sources\include\avs\minmax.h

; 50   :     n = n > max ? max : n;

	cmovg	ebx, ecx

; 51   :     return n < min ? min : n;

	mov	ecx, DWORD PTR _min$1$[esp+28]
	cmp	ebx, DWORD PTR _min$1$[esp+28]
	movzx	edx, bl
	movzx	ecx, cl
	cmovl	edx, ecx
; File c:\github\mvtools\sources\overlap.cpp

; 397  : 			reinterpret_cast<pixel_t *>(pDst)[i] = 

	mov	BYTE PTR [eax-1], dl
	sub	ebp, 1
	jne	SHORT $LL7@LimitChang
	mov	edi, DWORD PTR _pDst$1$[esp+28]
	mov	eax, DWORD PTR _pSrc$[esp+24]
	mov	ecx, DWORD PTR _nHeight$[esp+24]
	mov	edx, DWORD PTR _nWidth$[esp+24]
	mov	ebx, DWORD PTR _nDstPitch$1$[esp+28]
$LN6@LimitChang:

; 398  :         (pixel_t)clamp((int)reinterpret_cast<pixel_t *>(pDst)[i], (reinterpret_cast<const pixel_t *>(pSrc)[i]-nLimit), (reinterpret_cast<const pixel_t *>(pSrc)[i]+nLimit));
; 399  : 		pDst += nDstPitch;
; 400  : 		pSrc += nSrcPitch;

	add	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	edi, ebx
	sub	ecx, 1
	mov	DWORD PTR _pDst$1$[esp+28], edi
	mov	DWORD PTR _pSrc$[esp+24], eax
	mov	DWORD PTR _nHeight$[esp+24], ecx
	jne	SHORT $LL4@LimitChang
	pop	esi
	pop	ebp
	pop	ebx
$LN3@LimitChang:
	pop	edi

; 401  : 	}
; 402  : }

	add	esp, 12					; 0000000cH
	ret	0
??$LimitChanges_c@E@@YAXPAEHPBEHHHH@Z ENDP		; LimitChanges_c<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
; File c:\github\mvtools\sources\include\avs\minmax.h
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$LimitChanges_c@G@@YAXPAEHPBEHHHH@Z
_TEXT	SEGMENT
_nDstPitch$1$ = -8					; size = 4
_pDst$1$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
_nLimit$ = 24						; size = 4
??$LimitChanges_c@G@@YAXPAEHPBEHHHH@Z PROC		; LimitChanges_c<unsigned short>, COMDAT
; _pDst$ = ecx
; _nDstPitch$ = edx

; 393  : {

	sub	esp, 8
	push	ebp
	mov	ebp, ecx
	mov	DWORD PTR _pDst$1$[esp+12], ecx

; 394  : 	for (int h=0; h<nHeight; h++)

	mov	ecx, DWORD PTR _nHeight$[esp+8]
	mov	DWORD PTR _nDstPitch$1$[esp+12], edx
	test	ecx, ecx
	jle	SHORT $LN3@LimitChang
	mov	edx, DWORD PTR _nWidth$[esp+8]
	mov	eax, DWORD PTR _pSrc$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _nDstPitch$1$[esp+16]
	push	esi
	push	edi
$LL4@LimitChang:

; 395  : 	{
; 396  : 		for (int i=0; i<nWidth; i++)

	test	edx, edx
	jle	SHORT $LN6@LimitChang
	mov	ebx, DWORD PTR _pSrc$[esp+20]
	mov	eax, ebp
	sub	ebx, ebp
	mov	ebp, edx
$LL15@LimitChang:

; 397  : 			reinterpret_cast<pixel_t *>(pDst)[i] = 

	movzx	edi, WORD PTR [ebx+eax]
	lea	eax, DWORD PTR [eax+2]
	mov	edx, DWORD PTR _nLimit$[esp+20]
	movzx	esi, WORD PTR [eax-2]
	lea	ecx, DWORD PTR [edi+edx]
	sub	edi, edx
; File c:\github\mvtools\sources\include\avs\minmax.h

; 50   :     n = n > max ? max : n;

	cmp	esi, ecx
	cmovg	esi, ecx

; 51   :     return n < min ? min : n;

	movzx	ecx, di
	cmp	esi, edi
	movzx	edx, si
	cmovl	edx, ecx
; File c:\github\mvtools\sources\overlap.cpp

; 397  : 			reinterpret_cast<pixel_t *>(pDst)[i] = 

	mov	WORD PTR [eax-2], dx
	sub	ebp, 1
	jne	SHORT $LL15@LimitChang
	mov	ebp, DWORD PTR _pDst$1$[esp+24]
	mov	eax, DWORD PTR _pSrc$[esp+20]
	mov	ecx, DWORD PTR _nHeight$[esp+20]
	mov	edx, DWORD PTR _nWidth$[esp+20]
	mov	ebx, DWORD PTR _nDstPitch$1$[esp+24]
$LN6@LimitChang:

; 398  :         (pixel_t)clamp((int)reinterpret_cast<pixel_t *>(pDst)[i], (reinterpret_cast<const pixel_t *>(pSrc)[i]-nLimit), (reinterpret_cast<const pixel_t *>(pSrc)[i]+nLimit));
; 399  : 		pDst += nDstPitch;
; 400  : 		pSrc += nSrcPitch;

	add	eax, DWORD PTR _nSrcPitch$[esp+20]
	add	ebp, ebx
	sub	ecx, 1
	mov	DWORD PTR _pDst$1$[esp+24], ebp
	mov	DWORD PTR _pSrc$[esp+20], eax
	mov	DWORD PTR _nHeight$[esp+20], ecx
	jne	SHORT $LL4@LimitChang
	pop	edi
	pop	esi
	pop	ebx
$LN3@LimitChang:
	pop	ebp

; 401  : 	}
; 402  : }

	add	esp, 8
	ret	0
??$LimitChanges_c@G@@YAXPAEHPBEHHHH@Z ENDP		; LimitChanges_c<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$LimitChanges_sse2_new@E@@YAXPAEHPBEHHHH@Z
_TEXT	SEGMENT
_nDstPitch$1$ = -4					; size = 4
_pSrc8$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
_nLimit$ = 24						; size = 4
??$LimitChanges_sse2_new@E@@YAXPAEHPBEHHHH@Z PROC	; LimitChanges_sse2_new<unsigned char>, COMDAT
; _pDst8$ = ecx
; _nDstPitch$ = edx

; 272  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8

; 273  :   __m128i limits;
; 274  :   if (sizeof(pixel_t) == 1)
; 275  :     limits = _mm_set1_epi8(nLimit);

	movsx	eax, BYTE PTR _nLimit$[ebp]
	xorps	xmm6, xmm6
	push	esi
	push	edi
	mov	DWORD PTR _nDstPitch$1$[esp+16], edx
	mov	esi, ecx
	movd	xmm0, eax

; 276  :   else
; 277  :     limits = _mm_set1_epi16(nLimit);
; 278  : 
; 279  :   const int stride = nWidth * sizeof(pixel_t); // back to byte size
; 280  : 
; 281  :   __m128i zero = _mm_setzero_si128();
; 282  :   for (int y = 0; y < nHeight; y++)

	mov	eax, DWORD PTR _nHeight$[ebp]
	punpcklbw xmm0, xmm0
	punpcklwd xmm0, xmm0
	pshufd	xmm5, xmm0, 0
	test	eax, eax
	jle	$LN3@LimitChang

; 273  :   __m128i limits;
; 274  :   if (sizeof(pixel_t) == 1)
; 275  :     limits = _mm_set1_epi8(nLimit);

	mov	edi, DWORD PTR _pSrc8$[ebp]
	mov	ecx, DWORD PTR _nWidth$[ebp]
	npad	6
$LL4@LimitChang:

; 283  :   {
; 284  :     for (int x = 0; x < stride; x += 16) {

	test	ecx, ecx
	jle	SHORT $LN6@LimitChang
	mov	eax, DWORD PTR _nWidth$[ebp]
	mov	edx, edi
	dec	eax
	sub	edx, esi
	shr	eax, 4
	mov	ecx, esi
	inc	eax
$LL7@LimitChang:

; 285  :       __m128i src = _mm_load_si128((__m128i *)(pSrc8 + x));

	movaps	xmm4, XMMWORD PTR [edx+ecx]
	lea	ecx, DWORD PTR [ecx+16]

; 286  :       __m128i dst = _mm_load_si128((__m128i *)(pDst8 + x));
; 287  :       __m128i res;
; 288  :       if (sizeof(pixel_t) == 1) {
; 289  :         __m128i src_plus_limit = _mm_adds_epu8(src, limits);   //  max possible
; 290  :         // dst <= (src + limit)  ==>   dst - src - limit <= 0  ==> zero where dst was ok (under limit) (dst <= (src + limit) == true)
; 291  :         __m128i compare_tmp = _mm_subs_epu8(dst, src); // dst - orig,   saturated to 0

	movaps	xmm1, XMMWORD PTR [ecx-16]
	movaps	xmm0, xmm4
	psubusb	xmm1, xmm4
	paddusb	xmm0, xmm5

; 292  :         compare_tmp = _mm_subs_epu8(compare_tmp, src_plus_limit);  // did it change too much, Y where nonzero

	psubusb	xmm1, xmm0

; 293  :         compare_tmp = _mm_cmpeq_epi8(compare_tmp, zero); // now ff where new value should be used, else 

	pcmpeqb	xmm1, xmm6

; 294  : 
; 295  :         __m128i m1 = _mm_and_si128(dst, compare_tmp); //  use new value from dst for these pixels
; 296  :         __m128i m2 = _mm_andnot_si128(compare_tmp, src_plus_limit); // use max value for these pixels

	movaps	xmm3, xmm1
	pand	xmm1, XMMWORD PTR [ecx-16]
	pandn	xmm3, xmm0

; 297  :         __m128i dst_maxlimited = _mm_or_si128(m1, m2); // combine them, get result with limited  positive correction

	por	xmm3, xmm1

; 298  : 
; 299  :         // here we use dst_maxlimited instead of dst
; 300  :         __m128i src_minus_limit = _mm_subs_epu8(src, limits);   //  min possible

	movaps	xmm1, xmm4

; 301  :         // dst_maxlimited >= (src - limit)  ==>  0 >= src - dst_maxlimited - limit   ==> zero where dst was ok 
; 302  :         compare_tmp = _mm_subs_epu8(src, dst_maxlimited); // orig - dst_maxlimited,   saturated to 0

	psubusb	xmm4, xmm3
	psubusb	xmm1, xmm5

; 303  :         compare_tmp = _mm_subs_epu8(compare_tmp, src_minus_limit);  // did it change too much, Y where nonzero

	psubusb	xmm4, xmm1

; 304  :         compare_tmp = _mm_cmpeq_epi8(compare_tmp, zero); // now ff where new value should be used, else 00

	pcmpeqb	xmm4, xmm6

; 305  : 
; 306  :         m1 = _mm_and_si128(dst_maxlimited, compare_tmp); //  use new value for these pixels
; 307  :         m2 = _mm_andnot_si128(compare_tmp, src_minus_limit); // use min value for these pixels

	movaps	xmm0, xmm4
	pand	xmm3, xmm4
	pandn	xmm0, xmm1

; 308  :         res = _mm_or_si128(m1, m2); // combine them, get result with limited  negative correction

	por	xmm0, xmm3

; 309  : 
; 310  :       }
; 311  :       else {
; 312  : 
; 313  :         __m128i src_plus_limit = _mm_adds_epu16(src, limits);   //  max possible
; 314  :                                                                // dst <= (src + limit)  ==>   dst - src - limit <= 0  ==> zero where dst was ok (under limit) (dst <= (src + limit) == true)
; 315  :         __m128i compare_tmp = _mm_subs_epu16(dst, src); // dst - orig,   saturated to 0
; 316  :         compare_tmp = _mm_subs_epu16(compare_tmp, src_plus_limit);  // did it change too much, Y where nonzero
; 317  :         compare_tmp = _mm_cmpeq_epi16(compare_tmp, zero); // now ff where new value should be used, else 
; 318  : 
; 319  :         __m128i m1 = _mm_and_si128(dst, compare_tmp); //  use new value from dst for these pixels
; 320  :         __m128i m2 = _mm_andnot_si128(compare_tmp, src_plus_limit); // use max value for these pixels
; 321  :         __m128i dst_maxlimited = _mm_or_si128(m1, m2); // combine them, get result with limited  positive correction
; 322  : 
; 323  :                                                        // here we use dst_maxlimited instead of dst
; 324  :         __m128i src_minus_limit = _mm_subs_epu16(src, limits);   //  min possible
; 325  :                                                                 // dst_maxlimited >= (src - limit)  ==>  0 >= src - dst_maxlimited - limit   ==> zero where dst was ok 
; 326  :         compare_tmp = _mm_subs_epu16(src, dst_maxlimited); // orig - dst_maxlimited,   saturated to 0
; 327  :         compare_tmp = _mm_subs_epu16(compare_tmp, src_minus_limit);  // did it change too much, Y where nonzero
; 328  :         compare_tmp = _mm_cmpeq_epi16(compare_tmp, zero); // now ff where new value should be used, else 00
; 329  : 
; 330  :         m1 = _mm_and_si128(dst_maxlimited, compare_tmp); //  use new value for these pixels
; 331  :         m2 = _mm_andnot_si128(compare_tmp, src_minus_limit); // use min value for these pixels
; 332  :         res = _mm_or_si128(m1, m2); // combine them, get result with limited  negative correction
; 333  :       }
; 334  :       _mm_stream_si128((__m128i *)(pDst8 + x), res);

	movntdq	XMMWORD PTR [ecx-16], xmm0
	sub	eax, 1
	jne	SHORT $LL7@LimitChang
	mov	eax, DWORD PTR _nHeight$[ebp]
	mov	ecx, DWORD PTR _nWidth$[ebp]
	mov	edx, DWORD PTR _nDstPitch$1$[esp+16]
$LN6@LimitChang:

; 335  :     }
; 336  :     //  reinterpret_cast<pixel_t *>(pDst)[i] = 
; 337  :     //  (pixel_t)clamp((int)reinterpret_cast<pixel_t *>(pDst)[i], (reinterpret_cast<const pixel_t *>(pSrc)[i]-nLimit), (reinterpret_cast<const pixel_t *>(pSrc)[i]+nLimit));
; 338  :     pDst8 += nDstPitch;
; 339  :     pSrc8 += nSrcPitch;

	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	esi, edx
	sub	eax, 1
	mov	DWORD PTR _nHeight$[ebp], eax
	jne	$LL4@LimitChang
$LN3@LimitChang:

; 340  :   }
; 341  : 
; 342  : #if 0
; 343  :   original external asm from MVDegrains - a.asm
; 344  :     .h_loopy:
; 345  :   ; limit is no longer needed
; 346  :     xor r6, r6
; 347  : 
; 348  :     .h_loopx:
; 349  :   ; srcp and dstp should be aligned
; 350  :     movdqa m0, [srcpq + r6]; src bytes
; 351  :     movdqa m1, [dstpq + r6]; dest bytes
; 352  :     movdqa m2, m5;/* copy limit */
; 353  :   paddusb m2, m0;/* max possible (m0 is original) */
; 354  :   movdqa m3, m1;/* (m1 is changed) */
; 355  :   psubusb m3, m0;/* changed - orig,   saturated to 0 */
; 356  :   psubusb m3, m5;/* did it change too much, Y where nonzero */
; 357  :   pcmpeqb m3, m4;/* now ff where new value should be used, else 00 (m4=0)*/
; 358  :   pand m1, m3;    /* use new value for these pixels */
; 359  :   pandn m3, m2; /* use max value for these pixels */
; 360  :   por m1, m3;/* combine them, get result with limited  positive correction */
; 361  : 
; 362  :   movdqa m3, m5;/* copy limit */
; 363  :   movdqa m2, m0;/* copy orig */
; 364  :   psubusb m2, m5;/* min possible */
; 365  :   movdqa m3, m0;/* copy orig */
; 366  :   psubusb m3, m1;/* orig - changed, saturated to 0 */
; 367  :   psubusb m3, m5;/* did it change too much, Y where nonzero */
; 368  :   pcmpeqb m3, m4;/* now ff where new value should be used, else 00 */
; 369  : 
; 370  :   pand m1, m3;/* use new value for these pixels */
; 371  :   pandn m3, m2;/* use min value for these pixels */
; 372  :   por m1, m3;/* combine them, get result with limited  negative correction */
; 373  : 
; 374  :   movdqa[dstpq + r6], m1
; 375  :     add r6, 16
; 376  :     cmp r6, widthq
; 377  :     jl.h_loopx
; 378  : 
; 379  :     ; do not process rightmost rest bytes
; 380  : 
; 381  :     add srcpq, src_strideq
; 382  :     add dstpq, dst_strideq
; 383  :     dec heightq
; 384  :     jnz.h_loopy
; 385  : 
; 386  :     RET
; 387  : #endif
; 388  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LimitChanges_sse2_new@E@@YAXPAEHPBEHHHH@Z ENDP	; LimitChanges_sse2_new<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$LimitChanges_sse2_new@G@@YAXPAEHPBEHHHH@Z
_TEXT	SEGMENT
_stride$1$ = -8						; size = 4
_nDstPitch$1$ = -4					; size = 4
_pSrc8$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
_nLimit$ = 24						; size = 4
??$LimitChanges_sse2_new@G@@YAXPAEHPBEHHHH@Z PROC	; LimitChanges_sse2_new<unsigned short>, COMDAT
; _pDst8$ = ecx
; _nDstPitch$ = edx

; 272  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8

; 273  :   __m128i limits;
; 274  :   if (sizeof(pixel_t) == 1)
; 275  :     limits = _mm_set1_epi8(nLimit);
; 276  :   else
; 277  :     limits = _mm_set1_epi16(nLimit);

	movsx	eax, WORD PTR _nLimit$[ebp]
	xorps	xmm6, xmm6
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _nDstPitch$1$[esp+12], edx
	push	edi
	movd	xmm0, eax

; 278  : 
; 279  :   const int stride = nWidth * sizeof(pixel_t); // back to byte size

	mov	eax, DWORD PTR _nWidth$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm5, xmm0, 0
	lea	ecx, DWORD PTR [eax+eax]

; 280  : 
; 281  :   __m128i zero = _mm_setzero_si128();
; 282  :   for (int y = 0; y < nHeight; y++)

	mov	eax, DWORD PTR _nHeight$[ebp]
	mov	DWORD PTR _stride$1$[esp+16], ecx
	test	eax, eax
	jle	$LN3@LimitChang

; 273  :   __m128i limits;
; 274  :   if (sizeof(pixel_t) == 1)
; 275  :     limits = _mm_set1_epi8(nLimit);
; 276  :   else
; 277  :     limits = _mm_set1_epi16(nLimit);

	mov	edi, DWORD PTR _pSrc8$[ebp]
	npad	3
$LL4@LimitChang:

; 283  :   {
; 284  :     for (int x = 0; x < stride; x += 16) {

	test	ecx, ecx
	jle	SHORT $LN6@LimitChang
	mov	eax, DWORD PTR _stride$1$[esp+16]
	mov	edx, edi
	dec	eax
	sub	edx, esi
	shr	eax, 4
	mov	ecx, esi
	inc	eax
$LL7@LimitChang:

; 285  :       __m128i src = _mm_load_si128((__m128i *)(pSrc8 + x));

	movaps	xmm4, XMMWORD PTR [edx+ecx]
	lea	ecx, DWORD PTR [ecx+16]

; 286  :       __m128i dst = _mm_load_si128((__m128i *)(pDst8 + x));
; 287  :       __m128i res;
; 288  :       if (sizeof(pixel_t) == 1) {
; 289  :         __m128i src_plus_limit = _mm_adds_epu8(src, limits);   //  max possible
; 290  :         // dst <= (src + limit)  ==>   dst - src - limit <= 0  ==> zero where dst was ok (under limit) (dst <= (src + limit) == true)
; 291  :         __m128i compare_tmp = _mm_subs_epu8(dst, src); // dst - orig,   saturated to 0
; 292  :         compare_tmp = _mm_subs_epu8(compare_tmp, src_plus_limit);  // did it change too much, Y where nonzero
; 293  :         compare_tmp = _mm_cmpeq_epi8(compare_tmp, zero); // now ff where new value should be used, else 
; 294  : 
; 295  :         __m128i m1 = _mm_and_si128(dst, compare_tmp); //  use new value from dst for these pixels
; 296  :         __m128i m2 = _mm_andnot_si128(compare_tmp, src_plus_limit); // use max value for these pixels
; 297  :         __m128i dst_maxlimited = _mm_or_si128(m1, m2); // combine them, get result with limited  positive correction
; 298  : 
; 299  :         // here we use dst_maxlimited instead of dst
; 300  :         __m128i src_minus_limit = _mm_subs_epu8(src, limits);   //  min possible
; 301  :         // dst_maxlimited >= (src - limit)  ==>  0 >= src - dst_maxlimited - limit   ==> zero where dst was ok 
; 302  :         compare_tmp = _mm_subs_epu8(src, dst_maxlimited); // orig - dst_maxlimited,   saturated to 0
; 303  :         compare_tmp = _mm_subs_epu8(compare_tmp, src_minus_limit);  // did it change too much, Y where nonzero
; 304  :         compare_tmp = _mm_cmpeq_epi8(compare_tmp, zero); // now ff where new value should be used, else 00
; 305  : 
; 306  :         m1 = _mm_and_si128(dst_maxlimited, compare_tmp); //  use new value for these pixels
; 307  :         m2 = _mm_andnot_si128(compare_tmp, src_minus_limit); // use min value for these pixels
; 308  :         res = _mm_or_si128(m1, m2); // combine them, get result with limited  negative correction
; 309  : 
; 310  :       }
; 311  :       else {
; 312  : 
; 313  :         __m128i src_plus_limit = _mm_adds_epu16(src, limits);   //  max possible
; 314  :                                                                // dst <= (src + limit)  ==>   dst - src - limit <= 0  ==> zero where dst was ok (under limit) (dst <= (src + limit) == true)
; 315  :         __m128i compare_tmp = _mm_subs_epu16(dst, src); // dst - orig,   saturated to 0

	movaps	xmm1, XMMWORD PTR [ecx-16]
	movaps	xmm0, xmm4
	psubusw	xmm1, xmm4
	paddusw	xmm0, xmm5

; 316  :         compare_tmp = _mm_subs_epu16(compare_tmp, src_plus_limit);  // did it change too much, Y where nonzero

	psubusw	xmm1, xmm0

; 317  :         compare_tmp = _mm_cmpeq_epi16(compare_tmp, zero); // now ff where new value should be used, else 

	pcmpeqw	xmm1, xmm6

; 318  : 
; 319  :         __m128i m1 = _mm_and_si128(dst, compare_tmp); //  use new value from dst for these pixels
; 320  :         __m128i m2 = _mm_andnot_si128(compare_tmp, src_plus_limit); // use max value for these pixels

	movaps	xmm3, xmm1
	pand	xmm1, XMMWORD PTR [ecx-16]
	pandn	xmm3, xmm0

; 321  :         __m128i dst_maxlimited = _mm_or_si128(m1, m2); // combine them, get result with limited  positive correction

	por	xmm3, xmm1

; 322  : 
; 323  :                                                        // here we use dst_maxlimited instead of dst
; 324  :         __m128i src_minus_limit = _mm_subs_epu16(src, limits);   //  min possible

	movaps	xmm1, xmm4

; 325  :                                                                 // dst_maxlimited >= (src - limit)  ==>  0 >= src - dst_maxlimited - limit   ==> zero where dst was ok 
; 326  :         compare_tmp = _mm_subs_epu16(src, dst_maxlimited); // orig - dst_maxlimited,   saturated to 0

	psubusw	xmm4, xmm3
	psubusw	xmm1, xmm5

; 327  :         compare_tmp = _mm_subs_epu16(compare_tmp, src_minus_limit);  // did it change too much, Y where nonzero

	psubusw	xmm4, xmm1

; 328  :         compare_tmp = _mm_cmpeq_epi16(compare_tmp, zero); // now ff where new value should be used, else 00

	pcmpeqw	xmm4, xmm6

; 329  : 
; 330  :         m1 = _mm_and_si128(dst_maxlimited, compare_tmp); //  use new value for these pixels
; 331  :         m2 = _mm_andnot_si128(compare_tmp, src_minus_limit); // use min value for these pixels

	movaps	xmm0, xmm4
	pand	xmm3, xmm4
	pandn	xmm0, xmm1

; 332  :         res = _mm_or_si128(m1, m2); // combine them, get result with limited  negative correction

	por	xmm0, xmm3

; 333  :       }
; 334  :       _mm_stream_si128((__m128i *)(pDst8 + x), res);

	movntdq	XMMWORD PTR [ecx-16], xmm0
	sub	eax, 1
	jne	SHORT $LL7@LimitChang
	mov	eax, DWORD PTR _nHeight$[ebp]
	mov	ecx, DWORD PTR _stride$1$[esp+16]
	mov	edx, DWORD PTR _nDstPitch$1$[esp+16]
$LN6@LimitChang:

; 335  :     }
; 336  :     //  reinterpret_cast<pixel_t *>(pDst)[i] = 
; 337  :     //  (pixel_t)clamp((int)reinterpret_cast<pixel_t *>(pDst)[i], (reinterpret_cast<const pixel_t *>(pSrc)[i]-nLimit), (reinterpret_cast<const pixel_t *>(pSrc)[i]+nLimit));
; 338  :     pDst8 += nDstPitch;
; 339  :     pSrc8 += nSrcPitch;

	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	esi, edx
	sub	eax, 1
	mov	DWORD PTR _nHeight$[ebp], eax
	jne	$LL4@LimitChang
$LN3@LimitChang:

; 340  :   }
; 341  : 
; 342  : #if 0
; 343  :   original external asm from MVDegrains - a.asm
; 344  :     .h_loopy:
; 345  :   ; limit is no longer needed
; 346  :     xor r6, r6
; 347  : 
; 348  :     .h_loopx:
; 349  :   ; srcp and dstp should be aligned
; 350  :     movdqa m0, [srcpq + r6]; src bytes
; 351  :     movdqa m1, [dstpq + r6]; dest bytes
; 352  :     movdqa m2, m5;/* copy limit */
; 353  :   paddusb m2, m0;/* max possible (m0 is original) */
; 354  :   movdqa m3, m1;/* (m1 is changed) */
; 355  :   psubusb m3, m0;/* changed - orig,   saturated to 0 */
; 356  :   psubusb m3, m5;/* did it change too much, Y where nonzero */
; 357  :   pcmpeqb m3, m4;/* now ff where new value should be used, else 00 (m4=0)*/
; 358  :   pand m1, m3;    /* use new value for these pixels */
; 359  :   pandn m3, m2; /* use max value for these pixels */
; 360  :   por m1, m3;/* combine them, get result with limited  positive correction */
; 361  : 
; 362  :   movdqa m3, m5;/* copy limit */
; 363  :   movdqa m2, m0;/* copy orig */
; 364  :   psubusb m2, m5;/* min possible */
; 365  :   movdqa m3, m0;/* copy orig */
; 366  :   psubusb m3, m1;/* orig - changed, saturated to 0 */
; 367  :   psubusb m3, m5;/* did it change too much, Y where nonzero */
; 368  :   pcmpeqb m3, m4;/* now ff where new value should be used, else 00 */
; 369  : 
; 370  :   pand m1, m3;/* use new value for these pixels */
; 371  :   pandn m3, m2;/* use min value for these pixels */
; 372  :   por m1, m3;/* combine them, get result with limited  negative correction */
; 373  : 
; 374  :   movdqa[dstpq + r6], m1
; 375  :     add r6, 16
; 376  :     cmp r6, widthq
; 377  :     jl.h_loopx
; 378  : 
; 379  :     ; do not process rightmost rest bytes
; 380  : 
; 381  :     add srcpq, src_strideq
; 382  :     add dstpq, dst_strideq
; 383  :     dec heightq
; 384  :     jnz.h_loopy
; 385  : 
; 386  :     RET
; 387  : #endif
; 388  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$LimitChanges_sse2_new@G@@YAXPAEHPBEHHHH@Z ENDP	; LimitChanges_sse2_new<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ?Short2BytesLsb@@YAXPAE0HPAHHHH@Z
_TEXT	SEGMENT
_pDst$1$ = -8						; size = 4
tv266 = -4						; size = 4
_nDstPitch$ = 8						; size = 4
_pDstInt$ = 12						; size = 4
_dstIntPitch$ = 16					; size = 4
_nWidth$ = 20						; size = 4
_nHeight$ = 24						; size = 4
?Short2BytesLsb@@YAXPAE0HPAHHHH@Z PROC			; Short2BytesLsb, COMDAT
; _pDst$ = ecx
; _pDstLsb$ = edx

; 175  : {

	sub	esp, 8

; 176  : 	for (int h=0; h<nHeight; h++)

	cmp	DWORD PTR _nHeight$[esp+4], 0
	push	ebp
	mov	ebp, edx
	mov	DWORD PTR _pDst$1$[esp+12], ecx
	mov	edx, ecx
	jle	SHORT $LN3@Short2Byte
	mov	eax, DWORD PTR _dstIntPitch$[esp+8]
	mov	ecx, DWORD PTR _nWidth$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _pDstInt$[esp+12]
	push	esi
	mov	esi, DWORD PTR _nDstPitch$[esp+16]
	shl	eax, 2
	push	edi
	mov	DWORD PTR tv266[esp+24], eax
	npad	3
$LL4@Short2Byte:

; 177  : 	{
; 178  : 		for (int i=0; i<nWidth; i++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN6@Short2Byte
	mov	edi, edx
	mov	esi, ebp
	sub	edi, ebp
	npad	4
$LL13@Short2Byte:

; 179  : 		{
; 180  : 			const int		a = pDstInt [i] >> (5+6);

	mov	edx, DWORD PTR [ebx+eax*4]
	lea	esi, DWORD PTR [esi+1]
	sar	edx, 11					; 0000000bH
	inc	eax

; 181  : 			pDst [i] = a >> 8;

	mov	ecx, edx
	sar	ecx, 8
	mov	BYTE PTR [edi+esi-1], cl
	mov	ecx, DWORD PTR _nWidth$[esp+20]

; 182  : 			pDstLsb [i] = (unsigned char) (a);

	mov	BYTE PTR [esi-1], dl
	cmp	eax, ecx
	jl	SHORT $LL13@Short2Byte
	mov	edx, DWORD PTR _pDst$1$[esp+24]
	mov	esi, DWORD PTR _nDstPitch$[esp+20]
$LN6@Short2Byte:

; 183  : 		}
; 184  : 		pDst += nDstPitch;
; 185  : 		pDstLsb += nDstPitch;
; 186  : 		pDstInt += dstIntPitch;

	add	ebx, DWORD PTR tv266[esp+24]
	add	edx, esi
	add	ebp, esi
	mov	DWORD PTR _pDst$1$[esp+24], edx
	sub	DWORD PTR _nHeight$[esp+20], 1
	jne	SHORT $LL4@Short2Byte
	pop	edi
	pop	esi
	pop	ebx
$LN3@Short2Byte:
	pop	ebp

; 187  : 	}
; 188  : }

	add	esp, 8
	ret	0
?Short2BytesLsb@@YAXPAE0HPAHHHH@Z ENDP			; Short2BytesLsb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ?Short2Bytes_FloatInInt32ArrayToFloat@@YAXPAMHPAHHHH@Z
_TEXT	SEGMENT
_nDstPitch$1$ = -8					; size = 4
tv1167 = -4						; size = 4
_pDstInt$ = 8						; size = 4
_dstIntPitch$dead$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
?Short2Bytes_FloatInInt32ArrayToFloat@@YAXPAMHPAHHHH@Z PROC ; Short2Bytes_FloatInInt32ArrayToFloat, COMDAT
; _pDst$ = ecx
; _nDstPitch$ = edx

; 254  :   float *pDstIntF = reinterpret_cast<float *>(pDstInt);
; 255  :   for (int h=0; h<nHeight; h++)

	mov	eax, DWORD PTR _nHeight$[esp-4]
	sub	esp, 8
	push	ebp
	mov	ebp, ecx
	test	eax, eax
	jle	$LN3@Short2Byte
	movss	xmm1, DWORD PTR __real@3f800000
	shr	edx, 2
	push	ebx
	mov	ebx, DWORD PTR _nWidth$[esp+12]
	push	esi
	lea	ecx, DWORD PTR [edx*4]
	neg	edx
	push	edi
	mov	edi, DWORD PTR _pDstInt$[esp+20]
	mov	esi, edi
	shl	edx, 2
	sub	esi, ebp
	mov	DWORD PTR tv1167[esp+24], ecx
	mov	DWORD PTR _nDstPitch$1$[esp+24], edx
$LL4@Short2Byte:

; 256  :   {
; 257  :     for (int i=0; i<nWidth; i++)

	xor	ecx, ecx
	test	ebx, ebx
	jle	$LN22@Short2Byte
	cmp	ebx, 8
	jb	SHORT $LN16@Short2Byte

; 258  :     {
; 259  :       // const int		a = pDstInt [i] >> (5+6); float: no scale
; 260  :       pDst [i] = min(pDstIntF[i], 1.0f);

	lea	eax, DWORD PTR [ebx-1]
	lea	edx, DWORD PTR [ebx*4-4]
	lea	eax, DWORD PTR [edi+eax*4]
	add	edx, ebp
	cmp	ebp, eax
	ja	SHORT $LN17@Short2Byte
	cmp	edx, edi
	jae	SHORT $LN30@Short2Byte
$LN17@Short2Byte:
	mov	eax, ebx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN31@Short2Byte
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN31@Short2Byte:
	movaps	xmm2, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	mov	edx, ebx
	sub	edx, eax
	lea	eax, DWORD PTR [ebp+16]
$LL7@Short2Byte:
	movups	xmm0, XMMWORD PTR [edi+ecx*4]

; 256  :   {
; 257  :     for (int i=0; i<nWidth; i++)

	add	ecx, 8
	lea	eax, DWORD PTR [eax+32]
	minps	xmm0, xmm2
	movups	XMMWORD PTR [eax-48], xmm0
	movups	xmm0, XMMWORD PTR [eax+esi-32]
	minps	xmm0, xmm2
	movups	XMMWORD PTR [eax-32], xmm0
	cmp	ecx, edx
	jl	SHORT $LL7@Short2Byte
$LN30@Short2Byte:
	mov	edx, DWORD PTR _nDstPitch$1$[esp+24]
	mov	eax, DWORD PTR _nHeight$[esp+20]
$LN16@Short2Byte:
	cmp	ecx, ebx
	jge	$LN22@Short2Byte
	mov	eax, ebx
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LC23@Short2Byte
	lea	edx, DWORD PTR [edi+12]
	mov	edi, ebx
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx*4+4]
	sub	edi, 4
	lea	edx, DWORD PTR [edx+ecx*4]
	shr	edi, 2
	add	eax, ebp
	inc	edi
	lea	ecx, DWORD PTR [ecx+edi*4]
	npad	7
$LL24@Short2Byte:

; 258  :     {
; 259  :       // const int		a = pDstInt [i] >> (5+6); float: no scale
; 260  :       pDst [i] = min(pDstIntF[i], 1.0f);

	movss	xmm0, DWORD PTR [edx-12]
	lea	eax, DWORD PTR [eax+16]
	minss	xmm0, xmm1
	lea	edx, DWORD PTR [edx+16]
	movss	DWORD PTR [eax-20], xmm0
	movss	xmm0, DWORD PTR [eax+esi-16]
	minss	xmm0, xmm1
	movss	DWORD PTR [eax-16], xmm0
	movss	xmm0, DWORD PTR [edx-20]
	minss	xmm0, xmm1
	movss	DWORD PTR [eax-12], xmm0
	movss	xmm0, DWORD PTR [edx-16]
	minss	xmm0, xmm1
	movss	DWORD PTR [eax-8], xmm0
	sub	edi, 1
	jne	SHORT $LL24@Short2Byte
	mov	edi, DWORD PTR _pDstInt$[esp+20]
$LC23@Short2Byte:

; 256  :   {
; 257  :     for (int i=0; i<nWidth; i++)

	cmp	ecx, ebx
	jge	SHORT $LN29@Short2Byte
	lea	eax, DWORD PTR [ecx*4]
	mov	edx, ebx
	add	eax, ebp
	sub	edx, ecx
	npad	7
$LC15@Short2Byte:

; 258  :     {
; 259  :       // const int		a = pDstInt [i] >> (5+6); float: no scale
; 260  :       pDst [i] = min(pDstIntF[i], 1.0f);

	movss	xmm0, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+4]
	minss	xmm0, xmm1
	movss	DWORD PTR [eax-4], xmm0
	sub	edx, 1
	jne	SHORT $LC15@Short2Byte
$LN29@Short2Byte:
	mov	edx, DWORD PTR _nDstPitch$1$[esp+24]
	mov	eax, DWORD PTR _nHeight$[esp+20]
$LN22@Short2Byte:

; 261  :     }
; 262  :     pDst += nDstPitch/sizeof(float);

	add	ebp, DWORD PTR tv1167[esp+24]
	add	esi, edx
	sub	eax, 1
	mov	DWORD PTR _nHeight$[esp+20], eax
	jne	$LL4@Short2Byte
	pop	edi
	pop	esi
	pop	ebx
$LN3@Short2Byte:
	pop	ebp

; 263  :     pDstInt += dstIntPitch; // this pitch is int/float (4 byte) granularity
; 264  :   }
; 265  : }

	add	esp, 8
	ret	0
?Short2Bytes_FloatInInt32ArrayToFloat@@YAXPAMHPAHHHH@Z ENDP ; Short2Bytes_FloatInInt32ArrayToFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ?Short2Bytes@@YAXPAEHPAGHHH@Z
_TEXT	SEGMENT
_nDstPitch$1$ = -8					; size = 4
tv222 = -4						; size = 4
_pDstShort$ = 8						; size = 4
_dstShortPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
?Short2Bytes@@YAXPAEHPAGHHH@Z PROC			; Short2Bytes, COMDAT
; _pDst$ = ecx
; _nDstPitch$ = edx

; 146  : {

	sub	esp, 8
	push	ebp

; 147  : 	for (int h=0; h<nHeight; h++)

	mov	ebp, DWORD PTR _nHeight$[esp+8]
	mov	DWORD PTR _nDstPitch$1$[esp+12], edx
	push	esi
	mov	esi, ecx
	test	ebp, ebp
	jle	SHORT $LN3@Short2Byte
	mov	eax, DWORD PTR _dstShortPitch$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR _nWidth$[esp+16]
	add	eax, eax
	push	edi
	mov	edi, DWORD PTR _pDstShort$[esp+20]
	mov	DWORD PTR tv222[esp+24], eax
$LL4@Short2Byte:

; 148  : 	{
; 149  : 		for (int i=0; i<nWidth; i++)

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN6@Short2Byte
	mov	ebp, 255				; 000000ffH
$LL13@Short2Byte:

; 150  : 		{
; 151  : 			int a = (pDstShort[i])>>5;

	movzx	edx, WORD PTR [edi+eax*2]
	shr	edx, 5

; 152  : //			pDst[i] = a | ((255-a) >> (sizeof(int)*8-1)); // tricky but conditional move can be faster nowadays
; 153  :       /*
; 154  :       mov	ecx, 255				; 000000ffH
; 155  :       shr	edx, 5
; 156  :       sub	ecx, edx
; 157  :       sar	ecx, 31					; 0000001fH
; 158  :       or	cl, dl
; 159  :       mov	BYTE PTR [eax+esi], cl
; 160  :       */
; 161  : 			pDst[i] = min(255, a); // PF everyone can understand it

	cmp	edx, ebp
	movzx	ecx, dl
	cmovg	ecx, ebp
	mov	BYTE PTR [eax+esi], cl
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL13@Short2Byte
	mov	ebp, DWORD PTR _nHeight$[esp+20]
$LN6@Short2Byte:

; 162  : /*
; 163  : cmp	edx, ebp
; 164  : movzx	ecx, dl
; 165  : cmovg	ecx, ebp
; 166  : mov	BYTE PTR [eax+esi], cl
; 167  : */
; 168  : 		}
; 169  : 		pDst += nDstPitch;

	add	esi, DWORD PTR _nDstPitch$1$[esp+24]

; 170  : 		pDstShort += dstShortPitch;

	add	edi, DWORD PTR tv222[esp+24]
	sub	ebp, 1
	mov	DWORD PTR _nHeight$[esp+20], ebp
	jne	SHORT $LL4@Short2Byte
	pop	edi
	pop	ebx
$LN3@Short2Byte:
	pop	esi
	pop	ebp

; 171  : 	}
; 172  : }

	add	esp, 8
	ret	0
?Short2Bytes@@YAXPAEHPAGHHH@Z ENDP			; Short2Bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z
_TEXT	SEGMENT
_archlist$ = -72					; size = 20
$T2 = -52						; size = 16
$T3 = -52						; size = 16
$T4 = -52						; size = 16
$T5 = -52						; size = 16
$T6 = -52						; size = 16
$T7 = -52						; size = 16
$T8 = -52						; size = 16
$T9 = -52						; size = 16
$T10 = -52						; size = 16
$T11 = -52						; size = 16
$T12 = -52						; size = 16
$T13 = -52						; size = 16
$T14 = -52						; size = 16
$T15 = -52						; size = 16
$T16 = -52						; size = 16
$T17 = -52						; size = 16
$T18 = -52						; size = 16
$T19 = -52						; size = 16
$T20 = -52						; size = 16
$T21 = -36						; size = 8
$T22 = -36						; size = 8
$T23 = -36						; size = 8
$T24 = -36						; size = 8
$T25 = -36						; size = 8
$T26 = -36						; size = 8
$T27 = -36						; size = 8
$T28 = -36						; size = 8
$T29 = -36						; size = 8
$T30 = -36						; size = 8
$T31 = -36						; size = 8
$T32 = -36						; size = 8
$T33 = -36						; size = 8
$T34 = -36						; size = 8
$T35 = -36						; size = 8
$T36 = -36						; size = 8
$T37 = -36						; size = 8
$T38 = -36						; size = 8
$T39 = -36						; size = 8
_func_overlaps_lsb$ = -28				; size = 8
_BlockX$1$ = -20					; size = 4
$T40 = -20						; size = 4
_BlockY$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pixelsize$dead$ = 8					; size = 4
_arch$dead$ = 12					; size = 4
?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z PROC ; get_overlaps_lsb_function, COMDAT
; _BlockX$ = ecx
; _BlockY$ = edx

; 688  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	mov	ebx, edx
	mov	DWORD PTR _BlockX$1$[ebp], ecx
	push	edi
	mov	DWORD PTR _BlockY$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR _func_overlaps_lsb$[ebp], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR _func_overlaps_lsb$[ebp+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR _func_overlaps_lsb$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T20[ebp]
; File c:\github\mvtools\sources\overlap.cpp

; 691  :     std::map<std::tuple<int, int, int, arch_t>, OverlapsLsbFunction*> func_overlaps_lsb;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	push	eax
	lea	eax, DWORD PTR $T39[ebp]
	push	eax
	movups	XMMWORD PTR $T20[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 693  :     func_overlaps_lsb[make_tuple(32, 32, 1, NO_SIMD)] = OverlapsLsb_C<32, 32>;

	mov	eax, DWORD PTR $T39[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 693  :     func_overlaps_lsb[make_tuple(32, 32, 1, NO_SIMD)] = OverlapsLsb_C<32, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0CA@$0CA@@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<32,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	lea	eax, DWORD PTR $T38[ebp]
	push	eax
	movups	XMMWORD PTR $T19[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 694  :     func_overlaps_lsb[make_tuple(32, 16, 1, NO_SIMD)] = OverlapsLsb_C<32, 16>;

	mov	eax, DWORD PTR $T38[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 694  :     func_overlaps_lsb[make_tuple(32, 16, 1, NO_SIMD)] = OverlapsLsb_C<32, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0CA@$0BA@@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<32,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	lea	eax, DWORD PTR $T37[ebp]
	push	eax
	movups	XMMWORD PTR $T18[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 695  :     func_overlaps_lsb[make_tuple(32, 8 , 1, NO_SIMD)] = OverlapsLsb_C<32, 8>;

	mov	eax, DWORD PTR $T37[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 695  :     func_overlaps_lsb[make_tuple(32, 8 , 1, NO_SIMD)] = OverlapsLsb_C<32, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0CA@$07@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<32,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	lea	eax, DWORD PTR $T36[ebp]
	push	eax
	movups	XMMWORD PTR $T17[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 696  :     func_overlaps_lsb[make_tuple(16, 32, 1, NO_SIMD)] = OverlapsLsb_C<16, 32>;

	mov	eax, DWORD PTR $T36[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 696  :     func_overlaps_lsb[make_tuple(16, 32, 1, NO_SIMD)] = OverlapsLsb_C<16, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0BA@$0CA@@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<16,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	lea	eax, DWORD PTR $T35[ebp]
	push	eax
	movups	XMMWORD PTR $T16[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 697  :     func_overlaps_lsb[make_tuple(16, 16, 1, NO_SIMD)] = OverlapsLsb_C<16, 16>;

	mov	eax, DWORD PTR $T35[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 697  :     func_overlaps_lsb[make_tuple(16, 16, 1, NO_SIMD)] = OverlapsLsb_C<16, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0BA@$0BA@@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<16,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	lea	eax, DWORD PTR $T34[ebp]
	push	eax
	movups	XMMWORD PTR $T15[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 698  :     func_overlaps_lsb[make_tuple(16, 8 , 1, NO_SIMD)] = OverlapsLsb_C<16, 8>;

	mov	eax, DWORD PTR $T34[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 698  :     func_overlaps_lsb[make_tuple(16, 8 , 1, NO_SIMD)] = OverlapsLsb_C<16, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0BA@$07@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<16,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	lea	eax, DWORD PTR $T33[ebp]
	push	eax
	movups	XMMWORD PTR $T14[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 699  :     func_overlaps_lsb[make_tuple(16, 4 , 1, NO_SIMD)] = OverlapsLsb_C<16, 4>;

	mov	eax, DWORD PTR $T33[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
; File c:\github\mvtools\sources\overlap.cpp

; 699  :     func_overlaps_lsb[make_tuple(16, 4 , 1, NO_SIMD)] = OverlapsLsb_C<16, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0BA@$03@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<16,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	movups	XMMWORD PTR $T13[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 700  :     func_overlaps_lsb[make_tuple(16, 2 , 1, NO_SIMD)] = OverlapsLsb_C<16, 2>;

	mov	eax, DWORD PTR $T32[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 700  :     func_overlaps_lsb[make_tuple(16, 2 , 1, NO_SIMD)] = OverlapsLsb_C<16, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$0BA@$01@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<16,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	lea	eax, DWORD PTR $T31[ebp]
	push	eax
	movups	XMMWORD PTR $T12[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 701  :     func_overlaps_lsb[make_tuple(8 , 16, 1, NO_SIMD)] = OverlapsLsb_C<8 , 16>;

	mov	eax, DWORD PTR $T31[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 701  :     func_overlaps_lsb[make_tuple(8 , 16, 1, NO_SIMD)] = OverlapsLsb_C<8 , 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$07$0BA@@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<8,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	lea	eax, DWORD PTR $T30[ebp]
	push	eax
	movups	XMMWORD PTR $T11[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 702  :     func_overlaps_lsb[make_tuple(8 , 8 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 8>;

	mov	eax, DWORD PTR $T30[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 702  :     func_overlaps_lsb[make_tuple(8 , 8 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$07$07@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<8,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	movups	XMMWORD PTR $T10[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 703  :     func_overlaps_lsb[make_tuple(8 , 4 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 4>;

	mov	eax, DWORD PTR $T29[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 703  :     func_overlaps_lsb[make_tuple(8 , 4 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$07$03@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<8,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	eax, DWORD PTR $T28[ebp]
	push	eax
	movups	XMMWORD PTR $T9[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 704  :     func_overlaps_lsb[make_tuple(8 , 2 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 2>;

	mov	eax, DWORD PTR $T28[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 704  :     func_overlaps_lsb[make_tuple(8 , 2 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$07$01@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<8,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	movups	XMMWORD PTR $T8[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 705  :     func_overlaps_lsb[make_tuple(8 , 1 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 1>;

	mov	eax, DWORD PTR $T27[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 705  :     func_overlaps_lsb[make_tuple(8 , 1 , 1, NO_SIMD)] = OverlapsLsb_C<8 , 1>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$07$00@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<8,1>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	movups	XMMWORD PTR $T7[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 706  :     func_overlaps_lsb[make_tuple(4 , 8 , 1, NO_SIMD)] = OverlapsLsb_C<4 , 8>;

	mov	eax, DWORD PTR $T26[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 706  :     func_overlaps_lsb[make_tuple(4 , 8 , 1, NO_SIMD)] = OverlapsLsb_C<4 , 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$03$07@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<4,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	eax, DWORD PTR $T25[ebp]
	push	eax
	movups	XMMWORD PTR $T6[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 707  :     func_overlaps_lsb[make_tuple(4 , 4 , 1, NO_SIMD)] = OverlapsLsb_C<4 , 4>;

	mov	eax, DWORD PTR $T25[ebp]
	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$03$03@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<4,4>
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000020000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T24[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movups	XMMWORD PTR $T5[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 708  :     func_overlaps_lsb[make_tuple(4 , 2 , 1, NO_SIMD)] = OverlapsLsb_C<4 , 2>;

	mov	eax, DWORD PTR $T24[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000040000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 708  :     func_overlaps_lsb[make_tuple(4 , 2 , 1, NO_SIMD)] = OverlapsLsb_C<4 , 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$03$01@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<4,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	eax, DWORD PTR $T23[ebp]
	push	eax
	movups	XMMWORD PTR $T4[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 709  :     func_overlaps_lsb[make_tuple(2 , 4 , 1, NO_SIMD)] = OverlapsLsb_C<2 , 4>;

	mov	eax, DWORD PTR $T23[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000020000000100000000
; File c:\github\mvtools\sources\overlap.cpp

; 709  :     func_overlaps_lsb[make_tuple(2 , 4 , 1, NO_SIMD)] = OverlapsLsb_C<2 , 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$01$03@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<2,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T22[ebp]
	push	eax
	movups	XMMWORD PTR $T3[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 710  :     func_overlaps_lsb[make_tuple(2 , 2 , 1, NO_SIMD)] = OverlapsLsb_C<2 , 2>;

	mov	eax, DWORD PTR $T22[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	lea	esi, DWORD PTR _archlist$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000030000000500000006
	movups	XMMWORD PTR _archlist$[ebp], xmm0
; File c:\github\mvtools\sources\overlap.cpp

; 713  :     arch_t archlist[] = { USE_AVX2, USE_AVX, USE_SSE41, USE_SSE2, NO_SIMD };

	mov	DWORD PTR _archlist$[ebp+16], 0
	mov	DWORD PTR [eax+32], OFFSET ??$OverlapsLsb_C@$01$01@@YAXPAHHPBE1HPAFH@Z ; OverlapsLsb_C<2,2>
	jmp	SHORT $LL2@get_overla
$LL2065@get_overla:
	mov	ebx, DWORD PTR _BlockY$1$[ebp]
$LL2@get_overla:

; 714  :     int index = 0;
; 715  :     while (result == nullptr) {
; 716  :       arch_t current_arch_try = archlist[index++];

	mov	edi, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+4]

; 717  :       if (current_arch_try > arch) continue;

	test	edi, edi
	jg	SHORT $LL2@get_overla
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR _BlockX$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T21[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp+4], 1
	mov	DWORD PTR $T2[ebp+8], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\overlap.cpp

; 718  :       result = func_overlaps_lsb[make_tuple(BlockX, BlockY, pixelsize, current_arch_try)];

	mov	eax, DWORD PTR $T21[ebp]
	mov	ebx, DWORD PTR [eax+32]

; 719  :       if (result == nullptr && current_arch_try == NO_SIMD)

	test	ebx, ebx
	jne	SHORT $LN2062@get_overla
	test	edi, edi
	jne	SHORT $LL2065@get_overla
$LN2062@get_overla:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2168 : 		erase(begin(), end());

	mov	eax, DWORD PTR _func_overlaps_lsb$[ebp]
	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T40[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\github\mvtools\sources\overlap.cpp

; 729  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\github\mvtools\sources\overlap.cpp

; 728  :     return result;

	mov	eax, ebx

; 729  : }

	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z$0:
	lea	ecx, DWORD PTR _func_overlaps_lsb$[ebp]
	jmp	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ
__ehhandler$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z ENDP ; get_overlaps_lsb_function
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z
_TEXT	SEGMENT
tv217 = -4						; size = 4
_pDstInt$ = 8						; size = 4
_dstIntPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$ = 20						; size = 4
_nDstPitch$1$ = 24					; size = 4
_bits_per_pixel$ = 24					; size = 4
?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z PROC	; Short2Bytes_Int32toWord16, COMDAT
; _pDst$ = ecx
; _nDstPitch$ = edx

; 192  : {

	push	ecx
	push	ebx
	push	edi
	mov	ebx, ecx

; 193  :   const int max_pixel_value = (1 << bits_per_pixel) - 1;

	mov	edi, 1
	mov	ecx, DWORD PTR _bits_per_pixel$[esp+8]
	mov	eax, edx
	shl	edi, cl
	dec	edi

; 194  :   for (int h=0; h<nHeight; h++)

	cmp	DWORD PTR _nHeight$[esp+8], 0
	jle	SHORT $LN3@Short2Byte

; 193  :   const int max_pixel_value = (1 << bits_per_pixel) - 1;

	mov	ecx, DWORD PTR _nWidth$[esp+8]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR _nDstPitch$1$[esp+8], eax
	mov	eax, DWORD PTR _dstIntPitch$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _pDstInt$[esp+12]
	shl	eax, 2
	push	esi
	mov	DWORD PTR tv217[esp+20], eax
$LL4@Short2Byte:

; 195  :   {
; 196  :     for (int i=0; i<nWidth; i++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN6@Short2Byte
	npad	4
$LL13@Short2Byte:

; 197  :     {
; 198  :       const int		a = pDstInt [i] >> (5+6); //scale back

	mov	esi, DWORD PTR [ebp+eax*4]
	sar	esi, 11					; 0000000bH

; 199  :       pDst [i] = min(a, max_pixel_value); // no need 8*shift

	cmp	esi, edi
	movzx	ecx, si
	movzx	edx, di
	cmovl	edx, ecx
	mov	ecx, DWORD PTR _nWidth$[esp+16]
	mov	WORD PTR [ebx+eax*2], dx
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL13@Short2Byte
$LN6@Short2Byte:

; 200  :     }
; 201  :     pDst += nDstPitch/sizeof(uint16_t);

	add	ebx, DWORD PTR _nDstPitch$1$[esp+16]

; 202  :     pDstInt += dstIntPitch; // this pitch is int granularity

	add	ebp, DWORD PTR tv217[esp+20]
	sub	DWORD PTR _nHeight$[esp+16], 1
	jne	SHORT $LL4@Short2Byte
	pop	esi
	pop	ebp
$LN3@Short2Byte:
	pop	edi
	pop	ebx

; 203  :   }
; 204  : }

	pop	ecx
	ret	0
?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ENDP	; Short2Bytes_Int32toWord16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _cosl
_TEXT	SEGMENT
_cosl	PROC						; COMDAT
; __X$ = xmm0l

; 813  :     return cos((double)_X);

	jmp	__libm_sse2_cos_precise
_cosl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?cos@@YAOO@Z
_TEXT	SEGMENT
?cos@@YAOO@Z PROC					; cos, COMDAT
; __Xx$ = xmm0l

; 386  : 	{

	push	ecx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 813  :     return cos((double)_X);

	call	__libm_sse2_cos_precise
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 388  : 	}

	ret	0
?cos@@YAOO@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
	pop	ecx
	ret	0
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
	pop	ecx
	ret	0
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1092 : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAEAAP6AXPAHHPBE1HPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Keyval$ = 8						; size = 4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAEAAP6AXPAHHPBE1HPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::operator[], COMDAT
; _this$ = ecx

; 177  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 8

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp+4]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >

; 178  : 		return (try_emplace(_STD move(_Keyval)).first->second);

	mov	eax, DWORD PTR $T1[esp+8]
	add	eax, 32					; 00000020H

; 179  : 		}

	add	esp, 8
	ret	4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAEAAP6AXPAHHPBE1HPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >, COMDAT
; _this$ = ecx

; 100  : 		{	// construct empty map from defaults

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 101  : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	0
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1092 : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Keyval$ = 8						; size = 4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[], COMDAT
; _this$ = ecx

; 177  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 8

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp+4]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >

; 178  : 		return (try_emplace(_STD move(_Keyval)).first->second);

	mov	eax, DWORD PTR $T1[esp+8]
	add	eax, 32					; 00000020H

; 179  : 		}

	add	esp, 8
	ret	4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAEAAP6AXPAGHPBEHPAFH@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >, COMDAT
; _this$ = ecx

; 100  : 		{	// construct empty map from defaults

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 101  : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	0
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator->, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 407  : 		return (pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 727  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase

; 2169 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1005 : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator->, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 407  : 		return (pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 727  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase

; 2169 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1005 : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> *>::pointer_to, COMDAT
; __Val$ = ecx

; 280  : 		return (_STD addressof(_Val));

	mov	eax, ecx

; 281  : 		}

	ret	0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> *>::pointer_to, COMDAT
; __Val$ = ecx

; 280  : 		return (_STD addressof(_Val));

	mov	eax, ecx

; 281  : 		}

	ret	0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Freeheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 846  : 		}

	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

	push	esi
	mov	esi, ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 705  : 		_Construct();
; 706  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

	push	ecx

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp]

; 1445 : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	esi, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	edx, esi

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 1446 : 			{	// erase all
; 1447 : 			clear();

	call	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::clear

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN176@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 279  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN133@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN178@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN188@erase
	npad	7
$LL144@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL144@erase

; 65   : 		else

	jmp	SHORT $LN188@erase
$LN178@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN188@erase
$LL128@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN188@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[esp+8], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL128@erase
$LN188@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[esp+8], edx
$LN133@erase:

; 1453 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T1[esp+16]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp+8]
	cmp	eax, DWORD PTR __Last$[esp+8]

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

	mov	eax, ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::end, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1122 : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::begin, COMDAT
; _this$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1112 : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Freeheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 846  : 		}

	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

	push	esi
	mov	esi, ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 705  : 		_Construct();
; 706  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

	push	ecx

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp]

; 1445 : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	esi, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	edx, esi

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 1446 : 			{	// erase all
; 1447 : 			clear();

	call	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::clear

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN176@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 279  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN133@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN178@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN188@erase
	npad	7
$LL144@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL144@erase

; 65   : 		else

	jmp	SHORT $LN188@erase
$LN178@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN188@erase
$LL128@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN188@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[esp+8], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL128@erase
$LN188@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[esp+8], edx
$LN133@erase:

; 1453 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T1[esp+16]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp+8]
	cmp	eax, DWORD PTR __Last$[esp+8]

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

	mov	eax, ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::end, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1122 : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::begin, COMDAT
; _this$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1112 : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 385  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 279  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], edx

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 280  : 		++*this;
; 281  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 282  : 		}

	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));
; 250  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 911  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

	push	esi
	mov	esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 722  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 684  : 		}

	ret	0
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 679  : 		}

	ret	0
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Left, COMDAT
; __Pnode$ = ecx

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, ecx

; 674  : 		}

	ret	0
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2078 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+4]

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	esi, ebx

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN23@clear
	npad	6
$LL24@clear:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL24@clear
$LN23@clear:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1477 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1473 : 		_Root() = this->_Myhead();
; 1474 : 		_Lmost() = this->_Myhead();
; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1477 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1195 = -12						; size = 4
tv1197 = -8						; size = 4
tv1196 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 123  : 		return (_Ptr);

	mov	ebp, DWORD PTR __Where$[esp+16]

; 1259 : 		{	// erase element at _Where

	mov	ebx, ecx
	push	esi
	push	edi

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[esp+24]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [ebp]

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1270 : 		++_Where;	// save successor iterator for return
; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN691@erase
$LN5@erase:
	mov	eax, DWORD PTR [ebp+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, ecx

; 1281 : 		else

	jmp	SHORT $LN691@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[esp+24]

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

	cmp	edx, ebp
	jne	$LN9@erase
$LN691@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1297 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [ebx]

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [edx], ebp
	jne	SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	ecx, esi
	jmp	SHORT $LN166@erase
$LN42@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, edi

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
	npad	3
$LL165@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx], ecx
$LN16@erase:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR [ebx]

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [edx+8], ebp
	jne	$LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	ecx, esi
	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN44@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, edi

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
	npad	1
$LL217@erase:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [ecx+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ebp+8]
	jne	SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1320 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebp+4]

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 50   : 	_Left = _STD move(_Right);

	mov	al, BYTE PTR [ebp+12]
	mov	cl, BYTE PTR [edx+12]
	mov	BYTE PTR [edx+12], al

; 51   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ebp+12], cl
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ebp+12], 1
	jne	$LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	4
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	edx, esi
	mov	DWORD PTR tv1195[esp+28], edx
	mov	DWORD PTR tv1197[esp+28], esi
	mov	DWORD PTR tv1196[esp+28], esi
	jne	$LN3@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, esi
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN694@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN3@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR tv1195[esp+28]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN694@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1197[esp+28]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1196[esp+28]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebp
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[esp+24]

; 1436 : 		if (0 < this->_Mysize())

	test	eax, eax
	je	SHORT $LN693@erase

; 1437 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN693@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,
; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

	add	esp, 12					; 0000000cH
	ret	8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
	jmp	SHORT $LN3@erase
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 385  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 279  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], edx

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 280  : 		++*this;
; 281  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 282  : 		}

	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));
; 250  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 911  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

	push	esi
	mov	esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 722  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 684  : 		}

	ret	0
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 679  : 		}

	ret	0
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Left, COMDAT
; __Pnode$ = ecx

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, ecx

; 674  : 		}

	ret	0
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2078 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+4]

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	esi, ebx

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN23@clear
	npad	6
$LL24@clear:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL24@clear
$LN23@clear:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1477 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1473 : 		_Root() = this->_Myhead();
; 1474 : 		_Lmost() = this->_Myhead();
; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1477 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1195 = -12						; size = 4
tv1197 = -8						; size = 4
tv1196 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 123  : 		return (_Ptr);

	mov	ebp, DWORD PTR __Where$[esp+16]

; 1259 : 		{	// erase element at _Where

	mov	ebx, ecx
	push	esi
	push	edi

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[esp+24]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [ebp]

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1270 : 		++_Where;	// save successor iterator for return
; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN691@erase
$LN5@erase:
	mov	eax, DWORD PTR [ebp+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, ecx

; 1281 : 		else

	jmp	SHORT $LN691@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[esp+24]

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

	cmp	edx, ebp
	jne	$LN9@erase
$LN691@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1297 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [ebx]

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [edx], ebp
	jne	SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	ecx, esi
	jmp	SHORT $LN166@erase
$LN42@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, edi

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
	npad	3
$LL165@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx], ecx
$LN16@erase:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR [ebx]

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [edx+8], ebp
	jne	$LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	ecx, esi
	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN44@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, edi

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
	npad	1
$LL217@erase:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [ecx+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ebp+8]
	jne	SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1320 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebp+4]

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 50   : 	_Left = _STD move(_Right);

	mov	al, BYTE PTR [ebp+12]
	mov	cl, BYTE PTR [edx+12]
	mov	BYTE PTR [edx+12], al

; 51   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ebp+12], cl
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ebp+12], 1
	jne	$LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	4
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	edx, esi
	mov	DWORD PTR tv1195[esp+28], edx
	mov	DWORD PTR tv1197[esp+28], esi
	mov	DWORD PTR tv1196[esp+28], esi
	jne	$LN3@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, esi
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN694@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN3@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR tv1195[esp+28]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN694@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1197[esp+28]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1196[esp+28]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebp
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[esp+24]

; 1436 : 		if (0 < this->_Mysize())

	test	eax, eax
	je	SHORT $LN693@erase

; 1437 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN693@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,
; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

	add	esp, 12					; 0000000cH
	ret	8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
	jmp	SHORT $LN3@erase
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

	mov	eax, esi
	pop	esi

; 275  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 604  : 		}

	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 599  : 		}

	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 594  : 		}

	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Left, COMDAT
; __Pnode$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, ecx

; 589  : 		}

	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 941  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN61@Buyheadnod
	mov	DWORD PTR [eax], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 832  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
$LL4@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 699  : 		}

	ret	0
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
	npad	7
$LL4@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 694  : 		}

	ret	0
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 689  : 		}

	ret	0
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 669  : 		}

	ret	0
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 664  : 		}

	ret	0
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN3@Rrotate:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Root, COMDAT
; _this$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2107 : 		return (this->_Parent(this->_Myhead()));
; 2108 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2102 : 		return (this->_Right(this->_Myhead()));
; 2103 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN3@Lrotate:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	mov	ebx, ecx
	mov	esi, edi

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN3@Erase
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL4@Erase
$LN3@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 2038 : 			this->_Getal().destroy(
; 2039 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2040 : 
; 2041 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2042 : 			}
; 2043 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

	mov	eax, esi
	pop	esi

; 275  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 604  : 		}

	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 599  : 		}

	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 594  : 		}

	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Left, COMDAT
; __Pnode$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, ecx

; 589  : 		}

	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 941  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN61@Buyheadnod
	mov	DWORD PTR [eax], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 832  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
$LL4@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 699  : 		}

	ret	0
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
	npad	7
$LL4@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 694  : 		}

	ret	0
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 689  : 		}

	ret	0
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 669  : 		}

	ret	0
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 664  : 		}

	ret	0
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN3@Rrotate:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Root, COMDAT
; _this$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2107 : 		return (this->_Parent(this->_Myhead()));
; 2108 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2102 : 		return (this->_Right(this->_Myhead()));
; 2103 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN3@Lrotate:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	mov	ebx, ecx
	mov	esi, edi

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN3@Erase
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL4@Erase
$LN3@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 2038 : 			this->_Getal().destroy(
; 2039 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2040 : 
; 2041 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2042 : 			}
; 2043 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

	mov	eax, ecx

; 618  : 		}

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
	npad	7
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 584  : 		}

	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 579  : 		}

	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

	mov	eax, ecx

; 618  : 		}

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
	npad	7
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 584  : 		}

	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 579  : 		}

	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	ret	4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	ret	4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv962 = -20						; size = 4
tv961 = -16						; size = 4
tv967 = -12						; size = 4
tv972 = -8						; size = 4
tv971 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned char,32,32>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv961[esp+20], 32		; 00000020H
	mov	DWORD PTR tv972[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv971[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv962[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv967[esp+36], ebp
	mov	ebx, 8
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv962[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv972[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv971[esp+36]
	sub	DWORD PTR tv961[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv962[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned char,32,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv963 = -20						; size = 4
tv962 = -16						; size = 4
tv968 = -12						; size = 4
tv973 = -8						; size = 4
tv972 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned char,32,16>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv962[esp+20], 16		; 00000010H
	mov	DWORD PTR tv973[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv972[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv963[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv968[esp+36], ebp
	mov	ebx, 8
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv963[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv973[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv972[esp+36]
	sub	DWORD PTR tv962[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv963[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned char,32,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0CA@$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv963 = -20						; size = 4
tv962 = -16						; size = 4
tv968 = -12						; size = 4
tv973 = -8						; size = 4
tv972 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0CA@$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,32,8>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv962[esp+20], 8
	mov	DWORD PTR tv973[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv972[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv963[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv968[esp+36], ebp
	mov	ebx, 8
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv963[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv973[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv972[esp+36]
	sub	DWORD PTR tv962[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv963[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0CA@$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,32,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv963 = -20						; size = 4
tv962 = -16						; size = 4
tv968 = -12						; size = 4
tv973 = -8						; size = 4
tv972 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned char,16,32>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv962[esp+20], 32		; 00000020H
	mov	DWORD PTR tv973[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv972[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv963[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv968[esp+36], ebp
	mov	ebx, 4
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv963[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv973[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv972[esp+36]
	sub	DWORD PTR tv962[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv963[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned char,16,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv962 = -20						; size = 4
tv961 = -16						; size = 4
tv967 = -12						; size = 4
tv972 = -8						; size = 4
tv971 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned char,16,16>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv961[esp+20], 16		; 00000010H
	mov	DWORD PTR tv972[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv971[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv962[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv967[esp+36], ebp
	mov	ebx, 4
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv962[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv972[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv971[esp+36]
	sub	DWORD PTR tv961[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv962[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned char,16,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0BA@$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv963 = -20						; size = 4
tv962 = -16						; size = 4
tv968 = -12						; size = 4
tv973 = -8						; size = 4
tv972 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0BA@$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,16,8>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv962[esp+20], 8
	mov	DWORD PTR tv973[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv972[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv963[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv968[esp+36], ebp
	mov	ebx, 4
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv963[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv973[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv972[esp+36]
	sub	DWORD PTR tv962[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv963[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0BA@$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,16,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0BA@$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv963 = -20						; size = 4
tv962 = -16						; size = 4
tv968 = -12						; size = 4
tv973 = -8						; size = 4
tv972 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0BA@$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,16,4>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv962[esp+20], 4
	mov	DWORD PTR tv973[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv972[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv963[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv968[esp+36], ebp
	mov	ebx, 4
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv963[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv973[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv972[esp+36]
	sub	DWORD PTR tv962[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv963[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0BA@$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,16,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$0BA@$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv963 = -20						; size = 4
tv962 = -16						; size = 4
tv968 = -12						; size = 4
tv973 = -8						; size = 4
tv972 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$0BA@$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,16,2>, COMDAT

; 78   : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _nDstPitch$[esp+16]
	add	eax, eax

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	DWORD PTR tv962[esp+20], 2
	mov	DWORD PTR tv973[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	ebx
	mov	ebx, DWORD PTR _pDst0$[esp+20]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pWin$[esp+24]
	mov	DWORD PTR tv972[esp+28], eax
	mov	eax, DWORD PTR _pSrc$[esp+24]
	push	esi
	inc	eax
	push	edi
	mov	DWORD PTR tv963[esp+36], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	mov	esi, eax
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR tv968[esp+36], ebp
	mov	ebx, 4
	npad	9
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-1]
	lea	esi, DWORD PTR [esi+4]
	movsx	edx, WORD PTR [edi-6]
	lea	eax, DWORD PTR [eax+8]
	imul	edx, ecx
	lea	edi, DWORD PTR [edi+8]
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-10], dx
	movzx	ecx, BYTE PTR [esi-4]
	movsx	edx, WORD PTR [eax+ebp-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-8], dx
	movzx	ecx, BYTE PTR [esi-3]
	movsx	edx, WORD PTR [edi-10]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-6], dx
	movzx	edx, BYTE PTR [esi-2]
	movsx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	sub	ebx, 1
	jne	SHORT $LL7@Overlaps_C

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	ebx, DWORD PTR _pDst0$[esp+32]

; 94   : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR tv963[esp+36]

; 95   : 		pWin += nWinPitch;

	mov	ebp, DWORD PTR _pWin$[esp+32]
	add	ebx, DWORD PTR tv973[esp+36]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	add	ebp, DWORD PTR tv972[esp+36]
	sub	DWORD PTR tv962[esp+36], 1
	mov	DWORD PTR _pDst0$[esp+32], ebx
	mov	DWORD PTR tv963[esp+36], eax
	mov	DWORD PTR _pWin$[esp+32], ebp
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 20					; 00000014H
	ret	0
??$Overlaps_C@E$0BA@$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,16,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$07$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1460 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$07$0BA@@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,8,16>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 2
	add	eax, eax
	mov	ebx, 16					; 00000010H
	mov	DWORD PTR tv1460[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 4
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-2]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	movzx	ecx, BYTE PTR [esi-1]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-2], dx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, BYTE PTR [esi]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax], dx
	movzx	ecx, BYTE PTR [esi+1]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+2], dx
	movzx	ecx, BYTE PTR [esi+2]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+4], dx
	movzx	ecx, BYTE PTR [esi+3]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+6], dx
	movzx	ecx, BYTE PTR [esi+4]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+8], dx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, BYTE PTR [esi+5]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1460[esp+20]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+10], dx
	add	eax, ebp
	sub	ebx, 1
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@E$07$0BA@@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,8,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$07$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1459 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$07$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,8,8>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 2
	add	eax, eax
	mov	ebx, 8
	mov	DWORD PTR tv1459[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 4
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-2]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	movzx	ecx, BYTE PTR [esi-1]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-2], dx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, BYTE PTR [esi]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax], dx
	movzx	ecx, BYTE PTR [esi+1]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+2], dx
	movzx	ecx, BYTE PTR [esi+2]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+4], dx
	movzx	ecx, BYTE PTR [esi+3]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+6], dx
	movzx	ecx, BYTE PTR [esi+4]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+8], dx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, BYTE PTR [esi+5]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1459[esp+20]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+10], dx
	add	eax, ebp
	sub	ebx, 1
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@E$07$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,8,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$07$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1460 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$07$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,8,4>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 2
	add	eax, eax
	mov	ebx, 4
	mov	DWORD PTR tv1460[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 4
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-2]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	movzx	ecx, BYTE PTR [esi-1]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-2], dx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, BYTE PTR [esi]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax], dx
	movzx	ecx, BYTE PTR [esi+1]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+2], dx
	movzx	ecx, BYTE PTR [esi+2]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+4], dx
	movzx	ecx, BYTE PTR [esi+3]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+6], dx
	movzx	ecx, BYTE PTR [esi+4]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+8], dx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, BYTE PTR [esi+5]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1460[esp+20]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+10], dx
	add	eax, ebp
	sub	ebx, 1
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@E$07$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,8,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$07$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1460 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$07$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,8,2>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 2
	add	eax, eax
	mov	ebx, 2
	mov	DWORD PTR tv1460[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 4
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-2]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	movzx	ecx, BYTE PTR [esi-1]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-2], dx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, BYTE PTR [esi]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax], dx
	movzx	ecx, BYTE PTR [esi+1]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+2], dx
	movzx	ecx, BYTE PTR [esi+2]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+4], dx
	movzx	ecx, BYTE PTR [esi+3]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+6], dx
	movzx	ecx, BYTE PTR [esi+4]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+8], dx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, BYTE PTR [esi+5]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1460[esp+20]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+10], dx
	add	eax, ebp
	sub	ebx, 1
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@E$07$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,8,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$07$00@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$07$00@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,8,1>, COMDAT

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);
; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	mov	edx, DWORD PTR _pDst0$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pWin$[esp]
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+4]
	movsx	eax, WORD PTR [esi]
	movzx	ecx, BYTE PTR [edi]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx], cx
	movsx	eax, WORD PTR [esi+2]
	movzx	ecx, BYTE PTR [edi+1]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+2], cx
	movsx	eax, WORD PTR [esi+4]
	movzx	ecx, BYTE PTR [edi+2]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+4], cx
	movsx	eax, WORD PTR [esi+6]
	movzx	ecx, BYTE PTR [edi+3]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+6], cx
	movsx	eax, WORD PTR [esi+8]
	movzx	ecx, BYTE PTR [edi+4]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+8], cx
	movsx	eax, WORD PTR [esi+10]
	movzx	ecx, BYTE PTR [edi+5]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+10], cx
	movsx	eax, WORD PTR [esi+12]
	movzx	ecx, BYTE PTR [edi+6]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+12], cx
	movzx	ecx, BYTE PTR [edi+7]
	movsx	eax, WORD PTR [esi+14]
	imul	ecx, eax
	pop	edi
	pop	esi
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+14], cx

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;
; 95   : 		pWin += nWinPitch;
; 96   : 	}
; 97   : }

	ret	0
??$Overlaps_C@E$07$00@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,8,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$03$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv727 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$03$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,4,8>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 2
	add	eax, eax
	mov	ebx, 8
	mov	DWORD PTR tv727[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 4
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-2]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	movzx	ecx, BYTE PTR [esi-1]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-2], dx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, BYTE PTR [esi]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax], dx
	movsx	edx, WORD PTR [edi+2]
	movzx	ecx, BYTE PTR [esi+1]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv727[esp+20]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+2], dx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@E$03$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,4,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$03$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv726 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$03$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,4,4>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 2
	add	eax, eax
	mov	ebx, 4
	mov	DWORD PTR tv726[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 4
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-2]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	movzx	ecx, BYTE PTR [esi-1]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-2], dx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, BYTE PTR [esi]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax], dx
	movsx	edx, WORD PTR [edi+2]
	movzx	ecx, BYTE PTR [esi+1]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv726[esp+20]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+2], dx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@E$03$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,4,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$03$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv727 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$03$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,4,2>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 2
	add	eax, eax
	mov	ebx, 2
	mov	DWORD PTR tv727[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 4
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	movzx	ecx, BYTE PTR [esi-2]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-4], dx
	movzx	ecx, BYTE PTR [esi-1]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax-2], dx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, BYTE PTR [esi]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax], dx
	movsx	edx, WORD PTR [edi+2]
	movzx	ecx, BYTE PTR [esi+1]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv727[esp+20]
	imul	edx, ecx
	add	edx, 256				; 00000100H
	sar	edx, 6
	add	WORD PTR [eax+2], dx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@E$03$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,4,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$01$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv736 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$01$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,2,4>, COMDAT

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);
; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	mov	edx, DWORD PTR _pDst0$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _pWin$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+8]
	movsx	eax, WORD PTR [ebx]
	push	edi
	movzx	ecx, BYTE PTR [esi]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx], cx
	movzx	ecx, BYTE PTR [esi+1]
	movsx	eax, WORD PTR [ebx+2]
	imul	ecx, eax

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+12]

; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+12]
	add	eax, eax
	lea	edi, DWORD PTR [eax+edx]
	mov	DWORD PTR tv736[esp+12], eax

; 95   : 		pWin += nWinPitch;

	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+2], cx
	lea	ebp, DWORD PTR [eax+eax]
	movzx	eax, BYTE PTR [esi]
	movsx	ecx, WORD PTR [ebx+ebp]
	lea	edx, DWORD PTR [ebx+ebp]
	imul	ecx, eax
	mov	ebx, DWORD PTR _nSrcPitch$[esp+12]
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edi], cx
	movzx	eax, BYTE PTR [esi+1]
	add	esi, ebx
	movsx	ecx, WORD PTR [edx+2]
	add	edx, ebp
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edi+2], cx
	movzx	eax, BYTE PTR [esi]
	movsx	ecx, WORD PTR [edx]
	add	edi, DWORD PTR tv736[esp+12]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edi], cx
	movzx	eax, BYTE PTR [esi+1]
	movsx	ecx, WORD PTR [edx+2]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edi+2], cx
	movzx	ecx, BYTE PTR [esi+ebx]
	movsx	eax, WORD PTR [edx+ebp]
	imul	ecx, eax
	mov	eax, DWORD PTR tv736[esp+12]
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [eax+edi], cx
	movzx	eax, BYTE PTR [esi+ebx+1]
	movsx	ecx, WORD PTR [edx+ebp+2]
	imul	ecx, eax
	mov	eax, DWORD PTR tv736[esp+12]
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [eax+edi+2], cx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	ret	0
??$Overlaps_C@E$01$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,2,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@E$01$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@E$01$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned char,2,2>, COMDAT

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);
; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp

	mov	edx, DWORD PTR _pDst0$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _pWin$[esp]
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+4]
	push	edi
	movsx	eax, WORD PTR [ebx]
	movzx	ecx, BYTE PTR [esi]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx], cx
	movzx	ecx, BYTE PTR [esi+1]
	movsx	eax, WORD PTR [ebx+2]

; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+8]
	imul	ecx, eax
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	lea	edi, DWORD PTR [edx+eax*2]

; 95   : 		pWin += nWinPitch;

	mov	eax, DWORD PTR _nWinPitch$[esp+8]
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edx+2], cx
	lea	edx, DWORD PTR [ebx+eax*2]
	movzx	ecx, BYTE PTR [esi]
	movsx	eax, WORD PTR [edx]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edi], cx
	movzx	eax, BYTE PTR [esi+1]
	movsx	ecx, WORD PTR [edx+2]
	imul	ecx, eax
	add	ecx, 256				; 00000100H
	sar	ecx, 6
	add	WORD PTR [edi+2], cx
	pop	edi
	pop	esi
	pop	ebx

; 96   : 	}
; 97   : }

	ret	0
??$Overlaps_C@E$01$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned char,2,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv955 = -16						; size = 4
tv961 = -12						; size = 4
tv966 = -8						; size = 4
tv965 = -4						; size = 4
tv956 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned short,32,32>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv966[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv965[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv955[esp+28], 32		; 00000020H
	push	edi
	mov	DWORD PTR tv956[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv961[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv961[esp+32]
	mov	ebp, 8
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv956[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv966[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv965[esp+32]
	sub	DWORD PTR tv955[esp+32], 1
	mov	DWORD PTR tv956[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned short,32,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv956 = -16						; size = 4
tv962 = -12						; size = 4
tv967 = -8						; size = 4
tv966 = -4						; size = 4
tv957 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned short,32,16>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv967[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv966[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv956[esp+28], 16		; 00000010H
	push	edi
	mov	DWORD PTR tv957[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv962[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv962[esp+32]
	mov	ebp, 8
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv957[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv967[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv966[esp+32]
	sub	DWORD PTR tv956[esp+32], 1
	mov	DWORD PTR tv957[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned short,32,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0CA@$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv956 = -16						; size = 4
tv962 = -12						; size = 4
tv967 = -8						; size = 4
tv966 = -4						; size = 4
tv957 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0CA@$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,32,8>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv967[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv966[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv956[esp+28], 8
	push	edi
	mov	DWORD PTR tv957[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv962[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv962[esp+32]
	mov	ebp, 8
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv957[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv967[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv966[esp+32]
	sub	DWORD PTR tv956[esp+32], 1
	mov	DWORD PTR tv957[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0CA@$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,32,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv956 = -16						; size = 4
tv962 = -12						; size = 4
tv967 = -8						; size = 4
tv966 = -4						; size = 4
tv957 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned short,16,32>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv967[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv966[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv956[esp+28], 32		; 00000020H
	push	edi
	mov	DWORD PTR tv957[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv962[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv962[esp+32]
	mov	ebp, 4
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv957[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv967[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv966[esp+32]
	sub	DWORD PTR tv956[esp+32], 1
	mov	DWORD PTR tv957[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned short,16,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv955 = -16						; size = 4
tv961 = -12						; size = 4
tv966 = -8						; size = 4
tv965 = -4						; size = 4
tv956 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_C<unsigned short,16,16>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv966[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv965[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv955[esp+28], 16		; 00000010H
	push	edi
	mov	DWORD PTR tv956[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv961[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv961[esp+32]
	mov	ebp, 4
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv956[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv966[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv965[esp+32]
	sub	DWORD PTR tv955[esp+32], 1
	mov	DWORD PTR tv956[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_C<unsigned short,16,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0BA@$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv956 = -16						; size = 4
tv962 = -12						; size = 4
tv967 = -8						; size = 4
tv966 = -4						; size = 4
tv957 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0BA@$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,16,8>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv967[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv966[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv956[esp+28], 8
	push	edi
	mov	DWORD PTR tv957[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv962[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv962[esp+32]
	mov	ebp, 4
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv957[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv967[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv966[esp+32]
	sub	DWORD PTR tv956[esp+32], 1
	mov	DWORD PTR tv957[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0BA@$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,16,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0BA@$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv956 = -16						; size = 4
tv962 = -12						; size = 4
tv967 = -8						; size = 4
tv966 = -4						; size = 4
tv957 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0BA@$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,16,4>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv967[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv966[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv956[esp+28], 4
	push	edi
	mov	DWORD PTR tv957[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv962[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv962[esp+32]
	mov	ebp, 4
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv957[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv967[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv966[esp+32]
	sub	DWORD PTR tv956[esp+32], 1
	mov	DWORD PTR tv957[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0BA@$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,16,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$0BA@$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv956 = -16						; size = 4
tv962 = -12						; size = 4
tv967 = -8						; size = 4
tv966 = -4						; size = 4
tv957 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$0BA@$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,16,2>, COMDAT

; 78   : {

	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	shl	eax, 2
	mov	DWORD PTR tv967[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	push	ebx

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ebx, DWORD PTR _pWin$[esp+16]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
	mov	DWORD PTR tv966[esp+24], eax
	mov	eax, DWORD PTR _pDst0$[esp+20]
	push	esi
	add	eax, 8
	mov	DWORD PTR tv956[esp+28], 2
	push	edi
	mov	DWORD PTR tv957[esp+28], eax
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)

	lea	edi, DWORD PTR [ebp+6]
	sub	ebp, ebx
	mov	DWORD PTR tv962[esp+32], ebp
	lea	esi, DWORD PTR [ebx+2]
	mov	ebx, DWORD PTR tv962[esp+32]
	mov	ebp, 4
	npad	4
$LL7@Overlaps_C:

; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [edi-6]
	lea	esi, DWORD PTR [esi+8]
	movsx	edx, WORD PTR [esi-10]
	lea	edi, DWORD PTR [edi+8]
	imul	edx, ecx
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [eax-24], edx
	movsx	ecx, WORD PTR [esi-8]
	movzx	edx, WORD PTR [ebx+esi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-20], edx
	movzx	ecx, WORD PTR [edi-10]
	movsx	edx, WORD PTR [esi-6]
	imul	edx, ecx
	add	DWORD PTR [eax-16], edx
	movsx	edx, WORD PTR [esi-4]
	movzx	ecx, WORD PTR [edi-8]
	imul	edx, ecx
	add	DWORD PTR [eax-12], edx
	sub	ebp, 1
	jne	SHORT $LL7@Overlaps_C

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR tv957[esp+28]

; 94   : 		pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _pSrc$[esp+28]

; 95   : 		pWin += nWinPitch;

	mov	ebx, DWORD PTR _pWin$[esp+28]
	add	eax, DWORD PTR tv967[esp+32]
	add	ebp, DWORD PTR _nSrcPitch$[esp+28]
	add	ebx, DWORD PTR tv966[esp+32]
	sub	DWORD PTR tv956[esp+32], 1
	mov	DWORD PTR tv957[esp+28], eax
	mov	DWORD PTR _pSrc$[esp+28], ebp
	mov	DWORD PTR _pWin$[esp+28], ebx
	jne	$LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	add	esp, 16					; 00000010H
	ret	0
??$Overlaps_C@G$0BA@$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,16,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$07$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1356 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$07$0BA@@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,8,16>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 4
	add	eax, eax
	mov	ebx, 16					; 00000010H
	mov	DWORD PTR tv1356[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 8
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [esi-4]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	ecx, WORD PTR [esi-2]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, WORD PTR [esi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	ecx, WORD PTR [esi+4]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	ecx, WORD PTR [esi+6]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	ecx, WORD PTR [esi+8]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, WORD PTR [esi+10]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1356[esp+20]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@G$07$0BA@@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,8,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$07$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1355 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$07$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,8,8>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 4
	add	eax, eax
	mov	ebx, 8
	mov	DWORD PTR tv1355[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 8
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [esi-4]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	ecx, WORD PTR [esi-2]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, WORD PTR [esi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	ecx, WORD PTR [esi+4]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	ecx, WORD PTR [esi+6]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	ecx, WORD PTR [esi+8]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, WORD PTR [esi+10]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1355[esp+20]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@G$07$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,8,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$07$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1356 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$07$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,8,4>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 4
	add	eax, eax
	mov	ebx, 4
	mov	DWORD PTR tv1356[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 8
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [esi-4]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	ecx, WORD PTR [esi-2]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, WORD PTR [esi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	ecx, WORD PTR [esi+4]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	ecx, WORD PTR [esi+6]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	ecx, WORD PTR [esi+8]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, WORD PTR [esi+10]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1356[esp+20]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@G$07$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,8,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$07$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv1356 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$07$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,8,2>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 4
	add	eax, eax
	mov	ebx, 2
	mov	DWORD PTR tv1356[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 8
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [esi-4]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	ecx, WORD PTR [esi-2]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, WORD PTR [esi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	ecx, WORD PTR [esi+4]
	movsx	edx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	ecx, WORD PTR [esi+6]
	movsx	edx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	ecx, WORD PTR [esi+8]
	movsx	edx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movsx	edx, WORD PTR [edi+10]
	movzx	ecx, WORD PTR [esi+10]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1356[esp+20]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@G$07$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,8,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$07$00@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$07$00@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,8,1>, COMDAT

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);
; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	mov	edx, DWORD PTR _pDst0$[esp-4]
	push	esi
	mov	esi, DWORD PTR _pWin$[esp]
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+4]
	movsx	eax, WORD PTR [esi]
	movzx	ecx, WORD PTR [edi]
	imul	ecx, eax
	add	DWORD PTR [edx], ecx
	movsx	eax, WORD PTR [esi+2]
	movzx	ecx, WORD PTR [edi+2]
	imul	ecx, eax
	add	DWORD PTR [edx+4], ecx
	movsx	eax, WORD PTR [esi+4]
	movzx	ecx, WORD PTR [edi+4]
	imul	ecx, eax
	add	DWORD PTR [edx+8], ecx
	movsx	eax, WORD PTR [esi+6]
	movzx	ecx, WORD PTR [edi+6]
	imul	ecx, eax
	add	DWORD PTR [edx+12], ecx
	movsx	eax, WORD PTR [esi+8]
	movzx	ecx, WORD PTR [edi+8]
	imul	ecx, eax
	add	DWORD PTR [edx+16], ecx
	movsx	eax, WORD PTR [esi+10]
	movzx	ecx, WORD PTR [edi+10]
	imul	ecx, eax
	add	DWORD PTR [edx+20], ecx
	movsx	eax, WORD PTR [esi+12]
	movzx	ecx, WORD PTR [edi+12]
	imul	ecx, eax
	add	DWORD PTR [edx+24], ecx
	movzx	ecx, WORD PTR [edi+14]
	movsx	eax, WORD PTR [esi+14]
	imul	ecx, eax
	pop	edi
	pop	esi
	add	DWORD PTR [edx+28], ecx

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;
; 95   : 		pWin += nWinPitch;
; 96   : 	}
; 97   : }

	ret	0
??$Overlaps_C@G$07$00@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,8,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$03$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv692 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$03$07@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,4,8>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 4
	add	eax, eax
	mov	ebx, 8
	mov	DWORD PTR tv692[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 8
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [esi-4]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	ecx, WORD PTR [esi-2]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, WORD PTR [esi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movsx	edx, WORD PTR [edi+2]
	movzx	ecx, WORD PTR [esi+2]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv692[esp+20]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@G$03$07@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,4,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$03$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv691 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$03$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,4,4>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 4
	add	eax, eax
	mov	ebx, 4
	mov	DWORD PTR tv691[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 8
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [esi-4]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	ecx, WORD PTR [esi-2]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, WORD PTR [esi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movsx	edx, WORD PTR [edi+2]
	movzx	ecx, WORD PTR [esi+2]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv691[esp+20]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@G$03$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,4,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$03$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv692 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$03$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,4,2>, COMDAT

; 78   : {

	push	ecx
	mov	eax, DWORD PTR _nDstPitch$[esp]
	push	ebx
	push	ebp
	push	esi

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	add	esi, 4
	add	eax, eax
	mov	ebx, 2
	mov	DWORD PTR tv692[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+16]
	add	eax, 8
	add	edi, 4
$LL4@Overlaps_C:

; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	movzx	ecx, WORD PTR [esi-4]
	movsx	edx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	ecx, WORD PTR [esi-2]
	movsx	edx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movsx	ecx, WORD PTR [edi]
	movzx	edx, WORD PTR [esi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movsx	edx, WORD PTR [edi+2]
	movzx	ecx, WORD PTR [esi+2]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+16]

; 95   : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv692[esp+20]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	add	eax, ebp
	sub	ebx, 1
	jne	SHORT $LL4@Overlaps_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	pop	ecx
	ret	0
??$Overlaps_C@G$03$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,4,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$01$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv678 = 8						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$01$03@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,2,4>, COMDAT

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);
; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	mov	edx, DWORD PTR _pDst0$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _pWin$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+8]
	movsx	eax, WORD PTR [ebx]
	push	edi
	movzx	ecx, WORD PTR [esi]
	imul	ecx, eax
	add	DWORD PTR [edx], ecx
	movzx	ecx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [ebx+2]
	imul	ecx, eax

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+12]

; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+12]
	shl	eax, 2
	lea	edi, DWORD PTR [eax+edx]
	mov	DWORD PTR tv678[esp+12], eax
	add	DWORD PTR [edx+4], ecx

; 95   : 		pWin += nWinPitch;

	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	lea	ebp, DWORD PTR [eax+eax]
	movzx	eax, WORD PTR [esi]
	movsx	ecx, WORD PTR [ebx+ebp]
	lea	edx, DWORD PTR [ebx+ebp]
	mov	ebx, DWORD PTR _nSrcPitch$[esp+12]
	imul	ecx, eax
	add	DWORD PTR [edi], ecx
	movzx	eax, WORD PTR [esi+2]
	add	esi, ebx
	movsx	ecx, WORD PTR [edx+2]
	add	edx, ebp
	imul	ecx, eax
	add	DWORD PTR [edi+4], ecx
	movzx	ecx, WORD PTR [esi]
	movsx	eax, WORD PTR [edx]
	add	edi, DWORD PTR tv678[esp+12]
	imul	ecx, eax
	add	DWORD PTR [edi], ecx
	movzx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [edx+2]
	imul	ecx, eax
	add	DWORD PTR [edi+4], ecx
	movzx	ecx, WORD PTR [esi+ebx]
	movsx	eax, WORD PTR [edx+ebp]
	imul	ecx, eax
	mov	eax, DWORD PTR tv678[esp+12]
	add	DWORD PTR [eax+edi], ecx
	movzx	eax, WORD PTR [esi+ebx+2]
	movsx	ecx, WORD PTR [edx+ebp+2]
	imul	ecx, eax
	mov	eax, DWORD PTR tv678[esp+12]
	add	DWORD PTR [eax+edi+4], ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 96   : 	}
; 97   : }

	ret	0
??$Overlaps_C@G$01$03@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,2,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$Overlaps_C@G$01$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_C@G$01$01@@YAXPAGHPBEHPAFH@Z PROC		; Overlaps_C<unsigned short,2,2>, COMDAT

; 79   : 	// pWin from 0 to 2048
; 80   :   // when pixel_t == uint16_t, dst should be int*
; 81   :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 82   :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);
; 83   :   for (int j=0; j<blockHeight; j++)
; 84   : 	{
; 85   : 	    for (int i=0; i<blockWidth; i++)
; 86   : 	    {
; 87   :         if(sizeof(pixel_t) == 1)
; 88   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 89   :         else
; 90   :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16

	mov	edx, DWORD PTR _pDst0$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _pWin$[esp]
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+4]
	push	edi
	movsx	eax, WORD PTR [ebx]
	movzx	ecx, WORD PTR [esi]
	imul	ecx, eax
	add	DWORD PTR [edx], ecx
	movzx	ecx, WORD PTR [esi+2]
	movsx	eax, WORD PTR [ebx+2]

; 91   :         // no shift 6
; 92   : 	    }
; 93   :       pDst += nDstPitch;
; 94   : 		pSrc += nSrcPitch;

	add	esi, DWORD PTR _nSrcPitch$[esp+8]
	imul	ecx, eax
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	lea	edi, DWORD PTR [edx+eax*4]

; 95   : 		pWin += nWinPitch;

	mov	eax, DWORD PTR _nWinPitch$[esp+8]
	add	DWORD PTR [edx+4], ecx
	lea	edx, DWORD PTR [ebx+eax*2]
	movzx	ecx, WORD PTR [esi]
	movsx	eax, WORD PTR [edx]
	imul	ecx, eax
	add	DWORD PTR [edi], ecx
	movzx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [edx+2]
	imul	ecx, eax
	add	DWORD PTR [edi+4], ecx
	pop	edi
	pop	esi
	pop	ebx

; 96   : 	}
; 97   : }

	ret	0
??$Overlaps_C@G$01$01@@YAXPAGHPBEHPAFH@Z ENDP		; Overlaps_C<unsigned short,2,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv527 = -16						; size = 4
tv528 = -12						; size = 4
tv526 = -8						; size = 4
tv525 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,32,32>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	edx, DWORD PTR _pSrc$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv526[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv528[esp+20], 32		; 00000020H
	push	edi
	mov	edi, DWORD PTR _pDst0$[ebp]
	mov	DWORD PTR tv525[esp+24], eax
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {

	mov	esi, DWORD PTR _pWin$[ebp]
	mov	eax, edi
	mov	ecx, edx
	mov	DWORD PTR tv527[esp+24], 4
	sub	esi, edx
$LL7@Overlaps_s:
	sub	DWORD PTR tv527[esp+24], 1
	lea	ecx, DWORD PTR [ecx+16]

; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [esi+ecx-16]
	lea	eax, DWORD PTR [eax+32]

; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [ecx-16]

; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 511  :           dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3
	jne	SHORT $LL7@Overlaps_s

; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	mov	eax, DWORD PTR tv525[esp+24]
	add	edi, DWORD PTR tv526[esp+24]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pWin$[ebp], eax
	sub	DWORD PTR tv528[esp+24], 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0CA@$0CA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,32,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv528 = -16						; size = 4
tv529 = -12						; size = 4
tv527 = -8						; size = 4
tv526 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,32,16>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	edx, DWORD PTR _pSrc$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv527[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv529[esp+20], 16		; 00000010H
	push	edi
	mov	edi, DWORD PTR _pDst0$[ebp]
	mov	DWORD PTR tv526[esp+24], eax
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {

	mov	esi, DWORD PTR _pWin$[ebp]
	mov	eax, edi
	mov	ecx, edx
	mov	DWORD PTR tv528[esp+24], 4
	sub	esi, edx
$LL7@Overlaps_s:
	sub	DWORD PTR tv528[esp+24], 1
	lea	ecx, DWORD PTR [ecx+16]

; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [esi+ecx-16]
	lea	eax, DWORD PTR [eax+32]

; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [ecx-16]

; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 511  :           dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3
	jne	SHORT $LL7@Overlaps_s

; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	mov	eax, DWORD PTR tv526[esp+24]
	add	edi, DWORD PTR tv527[esp+24]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pWin$[ebp], eax
	sub	DWORD PTR tv529[esp+24], 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0CA@$0BA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,32,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0CA@$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv528 = -16						; size = 4
tv529 = -12						; size = 4
tv527 = -8						; size = 4
tv526 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0CA@$07@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,32,8>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	edx, DWORD PTR _pSrc$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv527[esp+16], eax
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv529[esp+20], 8
	push	edi
	mov	edi, DWORD PTR _pDst0$[ebp]
	mov	DWORD PTR tv526[esp+24], eax
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {

	mov	esi, DWORD PTR _pWin$[ebp]
	mov	eax, edi
	mov	ecx, edx
	mov	DWORD PTR tv528[esp+24], 4
	sub	esi, edx
$LL7@Overlaps_s:
	sub	DWORD PTR tv528[esp+24], 1
	lea	ecx, DWORD PTR [ecx+16]

; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [esi+ecx-16]
	lea	eax, DWORD PTR [eax+32]

; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [ecx-16]

; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 511  :           dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3
	jne	SHORT $LL7@Overlaps_s

; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	mov	eax, DWORD PTR tv526[esp+24]
	add	edi, DWORD PTR tv527[esp+24]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pWin$[ebp], eax
	sub	DWORD PTR tv529[esp+24], 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0CA@$07@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,32,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv486 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,16,32>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pWin$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 32					; 00000020H
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv486[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[ebp]
	add	eax, 32					; 00000020H
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx]

; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [edx]

; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 482  :         dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3

; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx+16]

; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	ecx, DWORD PTR tv486[esp+16]
	movups	xmm3, XMMWORD PTR [edx+16]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax], xmm1
	movups	xmm0, XMMWORD PTR [eax+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [eax+16], xmm3
	add	eax, edi
	sub	esi, 1
	jne	$LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0BA@$0CA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,16,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv486 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,16,16>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pWin$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 16					; 00000010H
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv486[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[ebp]
	add	eax, 32					; 00000020H
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx]

; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [edx]

; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 482  :         dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3

; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx+16]

; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	ecx, DWORD PTR tv486[esp+16]
	movups	xmm3, XMMWORD PTR [edx+16]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax], xmm1
	movups	xmm0, XMMWORD PTR [eax+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [eax+16], xmm3
	add	eax, edi
	sub	esi, 1
	jne	$LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0BA@$0BA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,16,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0BA@$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv486 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0BA@$07@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,16,8>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pWin$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 8
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv486[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[ebp]
	add	eax, 32					; 00000020H
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx]

; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [edx]

; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 482  :         dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3

; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx+16]

; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	ecx, DWORD PTR tv486[esp+16]
	movups	xmm3, XMMWORD PTR [edx+16]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax], xmm1
	movups	xmm0, XMMWORD PTR [eax+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [eax+16], xmm3
	add	eax, edi
	sub	esi, 1
	jne	$LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0BA@$07@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,16,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0BA@$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv486 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0BA@$03@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,16,4>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pWin$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 4
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv486[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[ebp]
	add	eax, 32					; 00000020H
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx]

; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [edx]

; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 482  :         dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3

; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx+16]

; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	ecx, DWORD PTR tv486[esp+16]
	movups	xmm3, XMMWORD PTR [edx+16]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax], xmm1
	movups	xmm0, XMMWORD PTR [eax+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [eax+16], xmm3
	add	eax, edi
	sub	esi, 1
	jne	$LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0BA@$03@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,16,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$0BA@$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv486 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$0BA@$01@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,16,2>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pWin$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 2
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv486[esp+16], eax
	mov	eax, DWORD PTR _pDst0$[ebp]
	add	eax, 32					; 00000020H
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx]

; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels

	movups	xmm3, XMMWORD PTR [edx]

; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-32]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax-32], xmm1

; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax-16]
	pmulld	xmm3, xmm2

; 482  :         dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);

	movups	XMMWORD PTR [eax-16], xmm3

; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window

	movups	xmm2, XMMWORD PTR [ecx+16]

; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	ecx, DWORD PTR tv486[esp+16]
	movups	xmm3, XMMWORD PTR [edx+16]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax], xmm1
	movups	xmm0, XMMWORD PTR [eax+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [eax+16], xmm3
	add	eax, edi
	sub	esi, 1
	jne	$LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$0BA@$01@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,16,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$07$0BA@@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv414 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$07$0BA@@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,8,16>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pDst0$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 16					; 00000010H
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv414[esp+16], eax
	mov	eax, DWORD PTR _pWin$[ebp]
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [eax]

; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	eax, DWORD PTR tv414[esp+16]
	movups	xmm3, XMMWORD PTR [edx]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [ecx]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [ecx], xmm1
	movups	xmm0, XMMWORD PTR [ecx+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [ecx+16], xmm3
	add	ecx, edi
	sub	esi, 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$07$0BA@@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,8,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$07$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv414 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$07$07@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,8,8>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pDst0$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 8
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv414[esp+16], eax
	mov	eax, DWORD PTR _pWin$[ebp]
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [eax]

; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	eax, DWORD PTR tv414[esp+16]
	movups	xmm3, XMMWORD PTR [edx]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [ecx]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [ecx], xmm1
	movups	xmm0, XMMWORD PTR [ecx+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [ecx+16], xmm3
	add	ecx, edi
	sub	esi, 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$07$07@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,8,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$07$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv414 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$07$03@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,8,4>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pDst0$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 4
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv414[esp+16], eax
	mov	eax, DWORD PTR _pWin$[ebp]
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [eax]

; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	eax, DWORD PTR tv414[esp+16]
	movups	xmm3, XMMWORD PTR [edx]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [ecx]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [ecx], xmm1
	movups	xmm0, XMMWORD PTR [ecx+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [ecx+16], xmm3
	add	ecx, edi
	sub	esi, 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$07$03@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,8,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$07$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv414 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$07$01@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,8,2>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm4, xmm4

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pDst0$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 2
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv414[esp+16], eax
	mov	eax, DWORD PTR _pWin$[ebp]
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	movups	xmm2, XMMWORD PTR [eax]

; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;

	add	eax, DWORD PTR tv414[esp+16]
	movups	xmm3, XMMWORD PTR [edx]
	add	edx, DWORD PTR _nSrcPitch$[ebp]
	movaps	xmm0, xmm2
	punpckhwd xmm2, xmm4
	movaps	xmm1, xmm3
	punpcklwd xmm0, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [ecx]
	punpckhwd xmm3, xmm4
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [ecx], xmm1
	movups	xmm0, XMMWORD PTR [ecx+16]
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movups	XMMWORD PTR [ecx+16], xmm3
	add	ecx, edi
	sub	esi, 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$07$01@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,8,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$07$00@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$07$00@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,8,1>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);
; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window
; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels
; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window

	mov	eax, DWORD PTR _pWin$[ebp]
	xorps	xmm4, xmm4
	movups	xmm2, XMMWORD PTR [eax]

; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels

	mov	eax, DWORD PTR _pSrc$[ebp]

; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));

	movaps	xmm0, xmm2

; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));

	punpckhwd xmm2, xmm4
	punpcklwd xmm0, xmm4
	movups	xmm3, XMMWORD PTR [eax]
	mov	eax, DWORD PTR _pDst0$[ebp]
	movaps	xmm1, xmm3
	punpckhwd xmm3, xmm4
	punpcklwd xmm1, xmm4
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax]
	pmulld	xmm3, xmm2
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [eax], xmm1

; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels

	movups	xmm0, XMMWORD PTR [eax+16]

; 467  :         dst = _mm_add_epi32(dst, reshi);

	paddd	xmm3, xmm0

; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);

	movups	XMMWORD PTR [eax+16], xmm3

; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;
; 529  :     pWin += nWinPitch;
; 530  :   }
; 531  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$07$00@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,8,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$03$07@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv408 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$03$07@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,4,8>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm2, xmm2

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pDst0$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 8
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv408[esp+16], eax
	mov	eax, DWORD PTR _pWin$[ebp]
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window

	movq	xmm0, QWORD PTR [eax]

; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels

	movq	xmm1, QWORD PTR [edx]

; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;

	add	edx, DWORD PTR _nSrcPitch$[ebp]

; 529  :     pWin += nWinPitch;

	add	eax, DWORD PTR tv408[esp+16]
	punpcklwd xmm0, xmm2
	punpcklwd xmm1, xmm2
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [ecx]
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [ecx], xmm1
	add	ecx, edi
	sub	esi, 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$03$07@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,4,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$03$03@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv408 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$03$03@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,4,4>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm2, xmm2

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pDst0$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 4
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv408[esp+16], eax
	mov	eax, DWORD PTR _pWin$[ebp]
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window

	movq	xmm0, QWORD PTR [eax]

; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels

	movq	xmm1, QWORD PTR [edx]

; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;

	add	edx, DWORD PTR _nSrcPitch$[ebp]

; 529  :     pWin += nWinPitch;

	add	eax, DWORD PTR tv408[esp+16]
	punpcklwd xmm0, xmm2
	punpcklwd xmm1, xmm2
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [ecx]
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [ecx], xmm1
	add	ecx, edi
	sub	esi, 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$03$03@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,4,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??$Overlaps_sse4@G$03$01@@YAXPAGHPBEHPAFH@Z
_TEXT	SEGMENT
tv408 = -4						; size = 4
_pDst0$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_nSrcPitch$ = 20					; size = 4
_pWin$ = 24						; size = 4
_nWinPitch$ = 28					; size = 4
??$Overlaps_sse4@G$03$01@@YAXPAGHPBEHPAFH@Z PROC	; Overlaps_sse4<unsigned short,4,2>, COMDAT

; 430  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	eax, DWORD PTR _nDstPitch$[ebp]
	xorps	xmm2, xmm2

; 431  :   // pWin from 0 to 2048
; 432  :   // when pixel_t == uint16_t, dst should be int*
; 433  :   typedef typename std::conditional < sizeof(pixel_t) == 1, short, int>::type target_t;
; 434  :   target_t *pDst = reinterpret_cast<target_t *>(pDst0);

	mov	ecx, DWORD PTR _pDst0$[ebp]
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	esi, 2
	mov	eax, DWORD PTR _nWinPitch$[ebp]
	add	eax, eax
	mov	DWORD PTR tv408[esp+16], eax
	mov	eax, DWORD PTR _pWin$[ebp]
	npad	1
$LL4@Overlaps_s:

; 435  :   __m128i zero = _mm_setzero_si128();
; 436  :   //const int stride = BlockWidth * sizeof(pixel_t); // back to byte size
; 437  : 
; 438  :   for (int j=0; j<blockHeight; j++)
; 439  :   {
; 440  :     __m128i dst;
; 441  :     __m128i win, src;
; 442  : 
; 443  :     if (sizeof(pixel_t) == 2) {
; 444  :       if (blockWidth == 4) // half of 1x16 byte
; 445  :       {
; 446  :         win = _mm_loadl_epi64(reinterpret_cast<__m128i *>(pWin)); // 4x16 short: Window

	movq	xmm0, QWORD PTR [eax]

; 447  :         src = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(pSrc)); // 4x16 uint16_t: source pixels

	movq	xmm1, QWORD PTR [edx]

; 448  : 
; 449  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 450  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 451  :         dst = _mm_add_epi32(dst, reslo);
; 452  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 453  : 
; 454  :       }
; 455  :       else if (blockWidth == 8) // exact 1x16 byte
; 456  :       {
; 457  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 458  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 459  : 
; 460  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 461  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 462  :         dst = _mm_add_epi32(dst, reslo);
; 463  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 464  : 
; 465  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 466  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 467  :         dst = _mm_add_epi32(dst, reshi);
; 468  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 469  :       }
; 470  :       else if (blockWidth == 16) // 2x16 byte: 2x8 pixels
; 471  :       {
; 472  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin)); // 8x16 short: Window
; 473  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc)); // 8x16 uint16_t: source pixels
; 474  : 
; 475  :         __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 476  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst)); // 4x32 int: destination pixels
; 477  :         dst = _mm_add_epi32(dst, reslo);
; 478  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst), dst);
; 479  : 
; 480  :         __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 481  :         dst = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pDst + 4)); // next 4x32 int: destination pixels
; 482  :         dst = _mm_add_epi32(dst, reshi);
; 483  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 4), dst);
; 484  : 
; 485  :         win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + 8)); // next 8x16 short: Window
; 486  :         src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + 16)); // next 8x16 uint16_t: source pixels
; 487  : 
; 488  :         // once again
; 489  :         reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 490  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8)); // 4x32 int: destination pixels
; 491  :         dst = _mm_add_epi32(dst, reslo);
; 492  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8), dst);
; 493  : 
; 494  :         reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 495  :         dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4)); // next 4x32 int: destination pixels
; 496  :         dst = _mm_add_epi32(dst, reshi);
; 497  :         _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + 8 + 4), dst);
; 498  :       }
; 499  :       else {
; 500  :         for (int x = 0; x < blockWidth; x += 16 / sizeof(pixel_t)) {
; 501  :           win = _mm_loadu_si128(reinterpret_cast<__m128i *>(pWin + x)); // 8x16 short: Window
; 502  :           src = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pSrc + x * 2)); // 8x16 uint16_t: source pixels
; 503  : 
; 504  :           __m128i reslo = _mm_mullo_epi32(_mm_unpacklo_epi16(src, zero), _mm_unpacklo_epi16(win, zero));
; 505  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x)); // 4x32 int: destination pixels
; 506  :           dst = _mm_add_epi32(dst, reslo);
; 507  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x), dst);
; 508  : 
; 509  :           __m128i reshi = _mm_mullo_epi32(_mm_unpackhi_epi16(src, zero), _mm_unpackhi_epi16(win, zero));
; 510  :           dst = _mm_loadu_si128(reinterpret_cast<__m128i *>(pDst + x + 4)); // next 4x32 int: destination pixels
; 511  :           dst = _mm_add_epi32(dst, reshi);
; 512  :           _mm_storeu_si128(reinterpret_cast<__m128i *>(pDst + x + 4), dst);
; 513  :         }
; 514  :       }
; 515  :     } // pixel_t == 2
; 516  : 
; 517  :     /*
; 518  :       for (int i=0; i<blockWidth; i++)
; 519  :       {
; 520  :         if(sizeof(pixel_t) == 1)
; 521  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i] + 256)>> 6)); // shift 5 in Short2Bytes<uint8_t> in overlap.cpp
; 522  :         else
; 523  :           pDst[i] = ( pDst[i] + ((reinterpret_cast<const pixel_t *>(pSrc)[i]*pWin[i]))); // shift (5+6); in Short2Bytes16
; 524  :                                                                                          // no shift 6
; 525  :       }
; 526  :       */
; 527  :     pDst += nDstPitch;
; 528  :     pSrc += nSrcPitch;

	add	edx, DWORD PTR _nSrcPitch$[ebp]

; 529  :     pWin += nWinPitch;

	add	eax, DWORD PTR tv408[esp+16]
	punpcklwd xmm0, xmm2
	punpcklwd xmm1, xmm2
	pmulld	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [ecx]
	paddd	xmm1, xmm0
	movups	XMMWORD PTR [ecx], xmm1
	add	ecx, edi
	sub	esi, 1
	jne	SHORT $LL4@Overlaps_s

; 530  :   }
; 531  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Overlaps_sse4@G$03$01@@YAXPAGHPBEHPAFH@Z ENDP	; Overlaps_sse4<unsigned short,4,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0CA@$0CA@@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv286 = -12						; size = 4
tv290 = -8						; size = 4
tv289 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0CA@$0CA@@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<32,32>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv290[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv286[esp+24], 32		; 00000020H
	push	edi
	mov	DWORD PTR tv289[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 32					; 00000020H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv290[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv289[esp+28]
	sub	DWORD PTR tv286[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0CA@$0CA@@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<32,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0CA@$0BA@@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv287 = -12						; size = 4
tv291 = -8						; size = 4
tv290 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0CA@$0BA@@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<32,16>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv291[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv287[esp+24], 16		; 00000010H
	push	edi
	mov	DWORD PTR tv290[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 32					; 00000020H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv291[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv290[esp+28]
	sub	DWORD PTR tv287[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0CA@$0BA@@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<32,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0CA@$07@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv290 = -12						; size = 4
tv294 = -8						; size = 4
tv293 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0CA@$07@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<32,8>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv294[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv290[esp+24], 8
	push	edi
	mov	DWORD PTR tv293[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 32					; 00000020H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv294[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv293[esp+28]
	sub	DWORD PTR tv290[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0CA@$07@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<32,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0BA@$0CA@@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv287 = -12						; size = 4
tv291 = -8						; size = 4
tv290 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0BA@$0CA@@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<16,32>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv291[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv287[esp+24], 32		; 00000020H
	push	edi
	mov	DWORD PTR tv290[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv291[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv290[esp+28]
	sub	DWORD PTR tv287[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0BA@$0CA@@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<16,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0BA@$0BA@@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv286 = -12						; size = 4
tv290 = -8						; size = 4
tv289 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0BA@$0BA@@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<16,16>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv290[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv286[esp+24], 16		; 00000010H
	push	edi
	mov	DWORD PTR tv289[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv290[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv289[esp+28]
	sub	DWORD PTR tv286[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0BA@$0BA@@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<16,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0BA@$07@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv290 = -12						; size = 4
tv294 = -8						; size = 4
tv293 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0BA@$07@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<16,8>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv294[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv290[esp+24], 8
	push	edi
	mov	DWORD PTR tv293[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv294[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv293[esp+28]
	sub	DWORD PTR tv290[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0BA@$07@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<16,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0BA@$03@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv290 = -12						; size = 4
tv294 = -8						; size = 4
tv293 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0BA@$03@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<16,4>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv294[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv290[esp+24], 4
	push	edi
	mov	DWORD PTR tv293[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv294[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv293[esp+28]
	sub	DWORD PTR tv290[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0BA@$03@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<16,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$0BA@$01@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv290 = -12						; size = 4
tv294 = -8						; size = 4
tv293 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$0BA@$01@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<16,2>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]
	mov	ecx, DWORD PTR _pSrcLsb$[esp+8]
	push	ebx

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	ebx, DWORD PTR _pWin$[esp+12]
	shl	eax, 2
	push	ebp
	mov	ebp, DWORD PTR _pDst$[esp+16]
	mov	DWORD PTR tv294[esp+20], eax
	mov	eax, DWORD PTR _nWinPitch$[esp+16]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv290[esp+24], 2
	push	edi
	mov	DWORD PTR tv293[esp+28], eax
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)

	mov	edi, DWORD PTR _pSrc$[esp+24]
	xor	eax, eax
	mov	esi, ecx
	sub	edi, ecx
	npad	6
$LL7@OverlapsLs:

; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	shl	edx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [ebx+eax*2]
	imul	edx, ecx
	add	DWORD PTR [ebp+eax*4], edx
	inc	eax
	cmp	eax, 16					; 00000010H
	jl	SHORT $LL7@OverlapsLs

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	mov	ecx, DWORD PTR _pSrcLsb$[esp+24]
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	ecx, eax
	add	ebp, DWORD PTR tv294[esp+28]
	add	DWORD PTR _pSrc$[esp+24], eax

; 114  : 		pWin += nWinPitch;

	add	ebx, DWORD PTR tv293[esp+28]
	sub	DWORD PTR tv290[esp+28], 1
	mov	DWORD PTR _pSrcLsb$[esp+24], ecx
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$0BA@$01@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<16,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$07$0BA@@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv2053 = -12						; size = 4
tv2052 = -8						; size = 4
tv2039 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$07$0BA@@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<8,16>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	edx, DWORD PTR _pSrcLsb$[esp+8]
	mov	ecx, DWORD PTR _pSrc$[esp+8]
	shl	eax, 2
	push	ebx
	mov	DWORD PTR tv2053[esp+16], eax
	lea	ebx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	sub	edx, ecx
	push	ebp
	add	eax, eax
	mov	ebp, 16					; 00000010H
	push	esi
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+24]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR tv2052[esp+28], eax
	add	edi, 4
	mov	eax, DWORD PTR _pDst$[esp+24]
	add	eax, 8
	add	edx, -2					; fffffffeH
	mov	DWORD PTR tv2039[esp+28], edx
	npad	10
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi-2]
	shl	ecx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	edx, BYTE PTR [esi-1]
	movzx	ecx, BYTE PTR [ebx-1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movzx	edx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ebx]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	edx, BYTE PTR [esi+1]
	movzx	ecx, BYTE PTR [ebx+1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	edx, BYTE PTR [esi+2]
	movzx	ecx, BYTE PTR [ebx+2]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	edx, BYTE PTR [esi+3]
	movzx	ecx, BYTE PTR [ebx+3]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	edx, BYTE PTR [esi+4]
	movzx	ecx, BYTE PTR [ebx+4]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movzx	edx, BYTE PTR [esi+5]
	movzx	ecx, BYTE PTR [ebx+5]

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, DWORD PTR _nSrcPitch$[esp+24]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+10]

; 114  : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv2052[esp+28]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, DWORD PTR tv2053[esp+28]
	mov	edx, DWORD PTR tv2039[esp+28]
	sub	ebp, 1
	jne	$LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$07$0BA@@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<8,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$07$07@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv2052 = -12						; size = 4
tv2051 = -8						; size = 4
tv2038 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$07$07@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<8,8>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	edx, DWORD PTR _pSrcLsb$[esp+8]
	mov	ecx, DWORD PTR _pSrc$[esp+8]
	shl	eax, 2
	push	ebx
	mov	DWORD PTR tv2052[esp+16], eax
	lea	ebx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	sub	edx, ecx
	push	ebp
	add	eax, eax
	mov	ebp, 8
	push	esi
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+24]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR tv2051[esp+28], eax
	add	edi, 4
	mov	eax, DWORD PTR _pDst$[esp+24]
	add	eax, 8
	add	edx, -2					; fffffffeH
	mov	DWORD PTR tv2038[esp+28], edx
	npad	10
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi-2]
	shl	ecx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	edx, BYTE PTR [esi-1]
	movzx	ecx, BYTE PTR [ebx-1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movzx	edx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ebx]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	edx, BYTE PTR [esi+1]
	movzx	ecx, BYTE PTR [ebx+1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	edx, BYTE PTR [esi+2]
	movzx	ecx, BYTE PTR [ebx+2]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	edx, BYTE PTR [esi+3]
	movzx	ecx, BYTE PTR [ebx+3]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	edx, BYTE PTR [esi+4]
	movzx	ecx, BYTE PTR [ebx+4]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movzx	edx, BYTE PTR [esi+5]
	movzx	ecx, BYTE PTR [ebx+5]

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, DWORD PTR _nSrcPitch$[esp+24]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+10]

; 114  : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv2051[esp+28]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, DWORD PTR tv2052[esp+28]
	mov	edx, DWORD PTR tv2038[esp+28]
	sub	ebp, 1
	jne	$LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$07$07@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<8,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$07$03@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv2053 = -12						; size = 4
tv2052 = -8						; size = 4
tv2039 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$07$03@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<8,4>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	edx, DWORD PTR _pSrcLsb$[esp+8]
	mov	ecx, DWORD PTR _pSrc$[esp+8]
	shl	eax, 2
	push	ebx
	mov	DWORD PTR tv2053[esp+16], eax
	lea	ebx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	sub	edx, ecx
	push	ebp
	add	eax, eax
	mov	ebp, 4
	push	esi
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+24]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR tv2052[esp+28], eax
	add	edi, 4
	mov	eax, DWORD PTR _pDst$[esp+24]
	add	eax, 8
	add	edx, -2					; fffffffeH
	mov	DWORD PTR tv2039[esp+28], edx
	npad	10
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi-2]
	shl	ecx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	edx, BYTE PTR [esi-1]
	movzx	ecx, BYTE PTR [ebx-1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movzx	edx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ebx]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	edx, BYTE PTR [esi+1]
	movzx	ecx, BYTE PTR [ebx+1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	edx, BYTE PTR [esi+2]
	movzx	ecx, BYTE PTR [ebx+2]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	edx, BYTE PTR [esi+3]
	movzx	ecx, BYTE PTR [ebx+3]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	edx, BYTE PTR [esi+4]
	movzx	ecx, BYTE PTR [ebx+4]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movzx	edx, BYTE PTR [esi+5]
	movzx	ecx, BYTE PTR [ebx+5]

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, DWORD PTR _nSrcPitch$[esp+24]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+10]

; 114  : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv2052[esp+28]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, DWORD PTR tv2053[esp+28]
	mov	edx, DWORD PTR tv2039[esp+28]
	sub	ebp, 1
	jne	$LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$07$03@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<8,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$07$01@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv2053 = -12						; size = 4
tv2052 = -8						; size = 4
tv2039 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$07$01@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<8,2>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	edx, DWORD PTR _pSrcLsb$[esp+8]
	mov	ecx, DWORD PTR _pSrc$[esp+8]
	shl	eax, 2
	push	ebx
	mov	DWORD PTR tv2053[esp+16], eax
	lea	ebx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	sub	edx, ecx
	push	ebp
	add	eax, eax
	mov	ebp, 2
	push	esi
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+24]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR tv2052[esp+28], eax
	add	edi, 4
	mov	eax, DWORD PTR _pDst$[esp+24]
	add	eax, 8
	add	edx, -2					; fffffffeH
	mov	DWORD PTR tv2039[esp+28], edx
	npad	10
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi-2]
	shl	ecx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	edx, BYTE PTR [esi-1]
	movzx	ecx, BYTE PTR [ebx-1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movzx	edx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ebx]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	edx, BYTE PTR [esi+1]
	movzx	ecx, BYTE PTR [ebx+1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+2]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	movzx	edx, BYTE PTR [esi+2]
	movzx	ecx, BYTE PTR [ebx+2]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+4]
	imul	edx, ecx
	add	DWORD PTR [eax+8], edx
	movzx	edx, BYTE PTR [esi+3]
	movzx	ecx, BYTE PTR [ebx+3]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+6]
	imul	edx, ecx
	add	DWORD PTR [eax+12], edx
	movzx	edx, BYTE PTR [esi+4]
	movzx	ecx, BYTE PTR [ebx+4]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+8]
	imul	edx, ecx
	add	DWORD PTR [eax+16], edx
	movzx	edx, BYTE PTR [esi+5]
	movzx	ecx, BYTE PTR [ebx+5]

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, DWORD PTR _nSrcPitch$[esp+24]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+10]

; 114  : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv2052[esp+28]
	imul	edx, ecx
	add	DWORD PTR [eax+20], edx
	add	eax, DWORD PTR tv2053[esp+28]
	mov	edx, DWORD PTR tv2039[esp+28]
	sub	ebp, 1
	jne	$LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$07$01@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<8,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$07$00@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$07$00@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<8,1>, COMDAT

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)
; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];
; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	mov	edx, DWORD PTR _pDst$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _pSrc$[esp]
	push	esi
	mov	esi, DWORD PTR _pWin$[esp+4]
	push	edi
	mov	edi, DWORD PTR _pSrcLsb$[esp+8]
	movzx	ecx, BYTE PTR [ebx]
	shl	ecx, 8
	movzx	eax, BYTE PTR [edi]
	add	ecx, eax
	movsx	eax, WORD PTR [esi]
	imul	ecx, eax
	add	DWORD PTR [edx], ecx
	movzx	ecx, BYTE PTR [ebx+1]
	movzx	eax, BYTE PTR [edi+1]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [esi+2]
	imul	ecx, eax
	add	DWORD PTR [edx+4], ecx
	movzx	ecx, BYTE PTR [ebx+2]
	movzx	eax, BYTE PTR [edi+2]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [esi+4]
	imul	ecx, eax
	add	DWORD PTR [edx+8], ecx
	movzx	ecx, BYTE PTR [ebx+3]
	movzx	eax, BYTE PTR [edi+3]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [esi+6]
	imul	ecx, eax
	add	DWORD PTR [edx+12], ecx
	movzx	ecx, BYTE PTR [ebx+4]
	movzx	eax, BYTE PTR [edi+4]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [esi+8]
	imul	ecx, eax
	add	DWORD PTR [edx+16], ecx
	movzx	ecx, BYTE PTR [ebx+5]
	movzx	eax, BYTE PTR [edi+5]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [esi+10]
	imul	ecx, eax
	add	DWORD PTR [edx+20], ecx
	movzx	ecx, BYTE PTR [ebx+6]
	movzx	eax, BYTE PTR [edi+6]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [esi+12]
	imul	ecx, eax
	add	DWORD PTR [edx+24], ecx
	movzx	ecx, BYTE PTR [ebx+7]
	movzx	eax, BYTE PTR [edi+7]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [esi+14]
	imul	ecx, eax
	pop	edi
	pop	esi
	pop	ebx
	add	DWORD PTR [edx+28], ecx

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;
; 114  : 		pWin += nWinPitch;
; 115  : 	}
; 116  : }

	ret	0
??$OverlapsLsb_C@$07$00@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<8,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$03$07@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv1025 = -12						; size = 4
tv1024 = -8						; size = 4
tv1015 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$03$07@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<4,8>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	edx, DWORD PTR _pSrcLsb$[esp+8]
	mov	ecx, DWORD PTR _pSrc$[esp+8]
	shl	eax, 2
	push	ebx
	mov	DWORD PTR tv1025[esp+16], eax
	lea	ebx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	sub	edx, ecx
	push	ebp
	add	eax, eax
	mov	ebp, 8
	push	esi
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+24]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR tv1024[esp+28], eax
	add	edi, 4
	mov	eax, DWORD PTR _pDst$[esp+24]
	add	eax, 8
	add	edx, -2					; fffffffeH
	mov	DWORD PTR tv1015[esp+28], edx
	npad	10
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi-2]
	shl	ecx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	edx, BYTE PTR [esi-1]
	movzx	ecx, BYTE PTR [ebx-1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movzx	edx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ebx]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	edx, BYTE PTR [esi+1]
	movzx	ecx, BYTE PTR [ebx+1]

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, DWORD PTR _nSrcPitch$[esp+24]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+2]

; 114  : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1024[esp+28]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	add	eax, DWORD PTR tv1025[esp+28]
	mov	edx, DWORD PTR tv1015[esp+28]
	sub	ebp, 1
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$03$07@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<4,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$03$03@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv1024 = -12						; size = 4
tv1023 = -8						; size = 4
tv1014 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$03$03@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<4,4>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	edx, DWORD PTR _pSrcLsb$[esp+8]
	mov	ecx, DWORD PTR _pSrc$[esp+8]
	shl	eax, 2
	push	ebx
	mov	DWORD PTR tv1024[esp+16], eax
	lea	ebx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	sub	edx, ecx
	push	ebp
	add	eax, eax
	mov	ebp, 4
	push	esi
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+24]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR tv1023[esp+28], eax
	add	edi, 4
	mov	eax, DWORD PTR _pDst$[esp+24]
	add	eax, 8
	add	edx, -2					; fffffffeH
	mov	DWORD PTR tv1014[esp+28], edx
	npad	10
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi-2]
	shl	ecx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	edx, BYTE PTR [esi-1]
	movzx	ecx, BYTE PTR [ebx-1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movzx	edx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ebx]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	edx, BYTE PTR [esi+1]
	movzx	ecx, BYTE PTR [ebx+1]

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, DWORD PTR _nSrcPitch$[esp+24]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+2]

; 114  : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1023[esp+28]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	add	eax, DWORD PTR tv1024[esp+28]
	mov	edx, DWORD PTR tv1014[esp+28]
	sub	ebp, 1
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$03$03@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<4,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$03$01@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv1025 = -12						; size = 4
tv1024 = -8						; size = 4
tv1015 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$03$01@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<4,2>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _nDstPitch$[esp+8]

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)

	mov	edx, DWORD PTR _pSrcLsb$[esp+8]
	mov	ecx, DWORD PTR _pSrc$[esp+8]
	shl	eax, 2
	push	ebx
	mov	DWORD PTR tv1025[esp+16], eax
	lea	ebx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	sub	edx, ecx
	push	ebp
	add	eax, eax
	mov	ebp, 2
	push	esi
	push	edi
	mov	edi, DWORD PTR _pWin$[esp+24]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR tv1024[esp+28], eax
	add	edi, 4
	mov	eax, DWORD PTR _pDst$[esp+24]
	add	eax, 8
	add	edx, -2					; fffffffeH
	mov	DWORD PTR tv1015[esp+28], edx
	npad	10
$LL4@OverlapsLs:

; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [esi-2]
	shl	ecx, 8
	add	edx, ecx

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	ecx, WORD PTR [edi-4]
	imul	edx, ecx
	add	DWORD PTR [eax-8], edx
	movzx	edx, BYTE PTR [esi-1]
	movzx	ecx, BYTE PTR [ebx-1]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi-2]
	imul	edx, ecx
	add	DWORD PTR [eax-4], edx
	movzx	edx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ebx]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi]
	imul	edx, ecx
	add	DWORD PTR [eax], edx
	movzx	edx, BYTE PTR [esi+1]
	movzx	ecx, BYTE PTR [ebx+1]

; 110  : 		}
; 111  : 		pDst += nDstPitch;
; 112  : 		pSrc += nSrcPitch;
; 113  : 		pSrcLsb += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, DWORD PTR _nSrcPitch$[esp+24]
	shl	edx, 8
	add	edx, ecx
	movsx	ecx, WORD PTR [edi+2]

; 114  : 		pWin += nWinPitch;

	add	edi, DWORD PTR tv1024[esp+28]
	imul	edx, ecx
	add	DWORD PTR [eax+4], edx
	add	eax, DWORD PTR tv1025[esp+28]
	mov	edx, DWORD PTR tv1015[esp+28]
	sub	ebp, 1
	jne	SHORT $LL4@OverlapsLs
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$03$01@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<4,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$01$03@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
tv764 = -12						; size = 4
_pDst$2$ = -8						; size = 4
tv754 = -4						; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$01$03@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<2,4>, COMDAT

; 102  : {

	sub	esp, 12					; 0000000cH

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	mov	edx, DWORD PTR _pDst$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _pWin$[esp+12]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+20]
	push	edi
	mov	edi, DWORD PTR _pSrcLsb$[esp+24]
	movzx	ecx, BYTE PTR [esi]
	shl	ecx, 8
	movzx	eax, BYTE PTR [edi]
	add	ecx, eax
	movsx	eax, WORD PTR [ebx]
	imul	ecx, eax
	add	DWORD PTR [edx], ecx
	movzx	ecx, BYTE PTR [esi+1]
	movzx	eax, BYTE PTR [edi+1]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [ebx+2]
	imul	ecx, eax

; 110  : 		}
; 111  : 		pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+24]
	shl	eax, 2
	mov	DWORD PTR tv764[esp+28], eax
	add	eax, edx
	mov	DWORD PTR _pDst$2$[esp+28], eax
	add	DWORD PTR [edx+4], ecx

; 112  : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	esi, eax

; 113  : 		pSrcLsb += nSrcPitch;

	lea	ebp, DWORD PTR [edi+eax]

; 114  : 		pWin += nWinPitch;

	mov	eax, DWORD PTR _nWinPitch$[esp+24]
	movzx	ecx, BYTE PTR [esi]
	add	eax, eax
	shl	ecx, 8
	mov	DWORD PTR tv754[esp+28], eax
	lea	edx, DWORD PTR [eax+ebx]
	movzx	eax, BYTE PTR [ebp]
	add	ecx, eax
	mov	ebx, DWORD PTR _pDst$2$[esp+28]
	movsx	eax, WORD PTR [edx]
	imul	ecx, eax
	add	DWORD PTR [ebx], ecx
	movzx	ecx, BYTE PTR [esi+1]
	movzx	eax, BYTE PTR [ebp+1]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	lea	edi, DWORD PTR [esi+eax]
	add	DWORD PTR [ebx+4], ecx
	lea	esi, DWORD PTR [eax+ebp]
	movzx	ecx, BYTE PTR [edi]
	mov	ebp, DWORD PTR tv754[esp+28]
	movzx	eax, BYTE PTR [esi]
	add	edx, ebp
	add	ebx, DWORD PTR tv764[esp+28]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [edx]
	imul	ecx, eax
	add	DWORD PTR [ebx], ecx
	movzx	ecx, BYTE PTR [edi+1]
	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [edx+2]
	imul	ecx, eax
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	add	DWORD PTR [ebx+4], ecx
	movzx	ecx, BYTE PTR [edi+eax]
	movzx	eax, BYTE PTR [esi+eax]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [edx+ebp]
	imul	ecx, eax
	mov	eax, DWORD PTR tv764[esp+28]
	add	DWORD PTR [eax+ebx], ecx
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	movzx	ecx, BYTE PTR [edi+eax+1]
	shl	ecx, 8

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)
; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];

	movzx	eax, BYTE PTR [esi+eax+1]
	add	ecx, eax

; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	movsx	eax, WORD PTR [edx+ebp+2]
	imul	ecx, eax
	mov	eax, DWORD PTR tv764[esp+28]
	pop	edi
	pop	esi
	pop	ebp
	add	DWORD PTR [eax+ebx+4], ecx
	pop	ebx

; 115  : 	}
; 116  : }

	add	esp, 12					; 0000000cH
	ret	0
??$OverlapsLsb_C@$01$03@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<2,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ??$OverlapsLsb_C@$01$01@@YAXPAHHPBE1HPAFH@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$ = 16						; size = 4
_pSrcLsb$ = 20						; size = 4
_nSrcPitch$ = 24					; size = 4
_pWin$ = 28						; size = 4
_nWinPitch$ = 32					; size = 4
??$OverlapsLsb_C@$01$01@@YAXPAHHPBE1HPAFH@Z PROC	; OverlapsLsb_C<2,2>, COMDAT

; 103  : 	// pWin from 0 to 2048
; 104  : 	for (int j=0; j<blockHeight; j++)
; 105  : 	{
; 106  : 		for (int i=0; i<blockWidth; i++)
; 107  : 		{
; 108  : 			const int		val = (pSrc [i] << 8) + pSrcLsb [i];
; 109  : 			pDst [i] += val * pWin [i]; // shift (5+6); in Short2BytesLsb

	mov	edx, DWORD PTR _pDst$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+4]
	push	esi
	mov	esi, DWORD PTR _pSrcLsb$[esp+8]
	push	edi
	movzx	ecx, BYTE PTR [ebp]
	mov	edi, DWORD PTR _pWin$[esp+12]
	movzx	eax, BYTE PTR [esi]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [edi]
	imul	ecx, eax
	add	DWORD PTR [edx], ecx
	movzx	ecx, BYTE PTR [ebp+1]
	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [edi+2]
	imul	ecx, eax

; 110  : 		}
; 111  : 		pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+12]
	lea	ebx, DWORD PTR [edx+eax*4]

; 112  : 		pSrc += nSrcPitch;

	mov	eax, DWORD PTR _nSrcPitch$[esp+12]

; 113  : 		pSrcLsb += nSrcPitch;

	add	esi, eax
	add	DWORD PTR [edx+4], ecx
	lea	edx, DWORD PTR [eax+ebp]

; 114  : 		pWin += nWinPitch;

	mov	eax, DWORD PTR _nWinPitch$[esp+12]
	movzx	ecx, BYTE PTR [edx]
	shl	ecx, 8
	lea	edi, DWORD PTR [edi+eax*2]
	movzx	eax, BYTE PTR [esi]
	add	ecx, eax
	movsx	eax, WORD PTR [edi]
	imul	ecx, eax
	add	DWORD PTR [ebx], ecx
	movzx	ecx, BYTE PTR [edx+1]
	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	movsx	eax, WORD PTR [edi+2]
	pop	edi
	imul	ecx, eax
	pop	esi
	pop	ebp
	add	DWORD PTR [ebx+4], ecx
	pop	ebx

; 115  : 	}
; 116  : }

	ret	0
??$OverlapsLsb_C@$01$01@@YAXPAHHPBE1HPAFH@Z ENDP	; OverlapsLsb_C<2,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::try_emplace<>, COMDAT
; _this$ = ecx

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp-4]
	push	DWORD PTR ___$ReturnUdt$[esp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 245  : 			_STD forward<_Mappedty>(_Mapval)...));
; 246  : 		}

	ret	8
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::try_emplace<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::try_emplace<>, COMDAT
; _this$ = ecx

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp-4]
	push	DWORD PTR ___$ReturnUdt$[esp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 245  : 			_STD forward<_Mappedty>(_Mapval)...));
; 246  : 		}

	ret	8
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::try_emplace<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z PROC ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z PROC ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 208  : 		{	// fail if _Keyval present, else emplace

	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	edi, DWORD PTR __Keyval$[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 208  : 		{	// fail if _Keyval present, else emplace

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	edi
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	esi, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 211  : 			|| _DEBUG_LT_PRED(_Mybase::_Getcomp(),

	je	SHORT $LN4@Try_emplac
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [esi+24]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LN4@Try_emplac
$LN177@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
$LN4@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	lea	eax, DWORD PTR $T2[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[esp+12], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, ebx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, ebx
	push	eax
	push	esi
	lea	eax, DWORD PTR $T1[esp+20]
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	ecx, DWORD PTR $T1[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 208  : 		{	// fail if _Keyval present, else emplace

	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	edi, DWORD PTR __Keyval$[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 208  : 		{	// fail if _Keyval present, else emplace

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	edi
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	esi, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 211  : 			|| _DEBUG_LT_PRED(_Mybase::_Getcomp(),

	je	SHORT $LN4@Try_emplac
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [esi+24]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LN4@Try_emplac
$LN177@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
$LN4@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	lea	eax, DWORD PTR $T2[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[esp+12], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, ebx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, ebx
	push	eax
	push	esi
	lea	eax, DWORD PTR $T1[esp+20]
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	ecx, DWORD PTR $T1[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 570  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 901  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Key, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2179 : 		}

	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	DWORD PTR __Keyval$[esp-4]
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	eax, ecx

; 1539 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 570  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 901  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Key, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2179 : 		}

	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	DWORD PTR __Keyval$[esp-4]
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	eax, ecx

; 1539 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2173 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[esp-4]

; 2174 : 		}

	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2173 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[esp-4]

; 2174 : 		}

	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$dead$ = 16					; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$dead$ = 24					; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1083 : 		{	// insert value_type(_Val...) at _Where

	push	edi

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	push	DWORD PTR _<_Val_1>$[esp+4]
	mov	edi, ecx
	push	ecx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, edi
	push	eax
	push	DWORD PTR __Where$[esp+8]
	push	DWORD PTR ___$ReturnUdt$[esp+12]
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	pop	edi

; 1086 : 			this->_Myval(_Newnode), _Newnode));
; 1087 : 		}

	ret	20					; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$dead$ = 16					; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$dead$ = 24					; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1083 : 		{	// insert value_type(_Val...) at _Where

	push	edi

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	push	DWORD PTR _<_Val_1>$[esp+4]
	mov	edi, ecx
	push	ecx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, edi
	push	eax
	push	DWORD PTR __Where$[esp+8]
	push	DWORD PTR ___$ReturnUdt$[esp+12]
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	pop	edi

; 1086 : 			this->_Myval(_Newnode), _Newnode));
; 1087 : 		}

	ret	20					; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 2059 : 		{	// find leftmost node not less than _Keyval

	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [ecx]

; 2060 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [edi+4]

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN110@Lbound
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	esi, DWORD PTR __Keyval$[esp+8]
	mov	ebx, DWORD PTR [esi+12]
$LL2@Lbound:
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, ebx
	jl	SHORT $LN66@Lbound
	cmp	ebx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [esi+8]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [esi+4]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LN66@Lbound
$LN4@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2068 : 				_Wherenode = _Pnode;

	mov	edi, eax

; 2069 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN5@Lbound
$LN66@Lbound:

; 2064 : 			if (_Compare(this->_Key(_Pnode), _Keyval))
; 2065 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN5@Lbound:

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Lbound
	pop	esi
	pop	ebx
$LN110@Lbound:

; 2070 : 				}
; 2071 : 
; 2072 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, edi
	pop	edi

; 2073 : 		}

	ret	4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 2059 : 		{	// find leftmost node not less than _Keyval

	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [ecx]

; 2060 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [edi+4]

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN110@Lbound
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	esi, DWORD PTR __Keyval$[esp+8]
	mov	ebx, DWORD PTR [esi+12]
$LL2@Lbound:
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, ebx
	jl	SHORT $LN66@Lbound
	cmp	ebx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [esi+8]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [esi+4]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LN66@Lbound
$LN4@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2068 : 				_Wherenode = _Pnode;

	mov	edi, eax

; 2069 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN5@Lbound
$LN66@Lbound:

; 2064 : 			if (_Compare(this->_Key(_Pnode), _Keyval))
; 2065 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN5@Lbound:

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Lbound
	pop	esi
	pop	ebx
$LN110@Lbound:

; 2070 : 				}
; 2071 : 
; 2072 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, edi
	pop	edi

; 2073 : 		}

	ret	4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z PROC ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>, COMDAT
; __Val$ = ecx

; 62   : 		return (_Val.first);

	mov	eax, ecx

; 63   : 		}

	ret	0
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ENDP ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z PROC ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>, COMDAT
; __Val$ = ecx

; 62   : 		return (_Val.first);

	mov	eax, ecx

; 63   : 		}

	ret	0
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ENDP ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Compare, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	push	esi
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [ecx+12]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx+4]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ecx]
	jl	SHORT $LN16@Compare
$LN15@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	xor	al, al
	pop	esi

; 2048 : 		}

	ret	8
$LN16@Compare:

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	mov	al, 1
	pop	esi

; 2048 : 		}

	ret	8
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Compare, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	push	esi
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [ecx+12]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx+4]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ecx]
	jl	SHORT $LN16@Compare
$LN15@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	xor	al, al
	pop	esi

; 2048 : 		}

	ret	8
$LN16@Compare:

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	mov	al, 1
	pop	esi

; 2048 : 		}

	ret	8
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 906  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 906  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$dead$ = 8					; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$dead$ = 16					; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

	push	esi

; 881  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode0
	mov	edx, eax

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edx+16]

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN65@Buynode
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	ecx, DWORD PTR _<_Val_1>$[esp]
	mov	ecx, DWORD PTR [ecx]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 895  : 		return (_Pnode);

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [esi+16], 0
$LN65@Buynode:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 896  : 		}

	pop	esi
	ret	12					; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
$T2 = -24						; size = 8
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1655 : 		{	// try to insert node using _Where as a hint

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx

; 1656 : 		const_iterator _Next;
; 1657 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1658 : 
; 1659 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1660 : 
; 1661 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1662 : 		if (_Where._Getcont() != &this->_Get_data())
; 1663 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1664 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1665 : 
; 1666 : 		if (size() == 0)

	cmp	DWORD PTR [ebx+4], 0
	mov	DWORD PTR _this$1$[ebp], ebx
	jne	SHORT $LN3@Insert_hin

; 1667 : 			return (_Insert_at(true, this->_Myhead(),

	push	DWORD PTR __Newnode$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	push	DWORD PTR [ebx]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@Insert_hin:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edi, DWORD PTR [ebx]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	esi, DWORD PTR __Where$[ebp]
	cmp	esi, DWORD PTR [edi]

; 1668 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1669 : 		else if (this->_Multi)
; 1670 : 			{	// insert even if duplicate
; 1671 : 			if (_Where == begin())
; 1672 : 				{	// insert at beginning if before first element
; 1673 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1674 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1675 : 					return (_Insert_at(true, _Where._Mynode(),
; 1676 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1677 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1678 : 				}
; 1679 : 			else if (_Where == end())
; 1680 : 				{	// insert at end if after last element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1683 : 					return (_Insert_at(false, _Rmost(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				}
; 1686 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1687 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1688 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1689 : 					this->_Kfn(_Val),
; 1690 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1691 : 				{	// insert before _Where
; 1692 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1693 : 					return (_Insert_at(false, _Next._Mynode(),
; 1694 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1695 : 				else
; 1696 : 					return (_Insert_at(true, _Where._Mynode(),
; 1697 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1698 : 				}
; 1699 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1701 : 				&& (++(_Next = _Where) == end()
; 1702 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1703 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1704 : 				{	// insert after _Where
; 1705 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1706 : 					return (_Insert_at(false, _Where._Mynode(),
; 1707 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1708 : 				else
; 1709 : 					return (_Insert_at(true, _Next._Mynode(),
; 1710 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1711 : 				}
; 1712 : 			else
; 1713 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1714 : 			}
; 1715 : 		else
; 1716 : 			{	// insert only if unique
; 1717 : 			if (_Where == begin())

	jne	SHORT $LN22@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1719 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1720 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1721 : 					return (_Insert_at(true, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN22@Insert_hin:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi

; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				}
; 1724 : 			else if (_Where == end())

	jne	SHORT $LN25@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1727 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1728 : 					return (_Insert_at(false, _Rmost(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN25@Insert_hin:

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	ebx, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	ebx
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN28@Insert_hin

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	DWORD PTR __Next$[ebp], esi

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	ebx, DWORD PTR __Next$[ebp]
	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN761@Insert_hin

; 1734 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1735 : 					this->_Kfn(_Val)))
; 1736 : 				{	// insert before _Where
; 1737 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [ebx+8]

; 1738 : 					return (_Insert_at(false, _Next._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN30@Insert_hin
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN30@Insert_hin:

; 1739 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1740 : 				else
; 1741 : 					return (_Insert_at(true, _Where._Mynode(),

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN761@Insert_hin:
	mov	ebx, DWORD PTR __Val$[ebp]
$LN28@Insert_hin:

; 1746 : 				&& (++(_Next = _Where) == end()

	push	ebx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1746 : 				&& (++(_Next = _Where) == end()

	mov	DWORD PTR __Next$[ebp], esi

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR __Next$[ebp]
	cmp	ebx, edi

; 1746 : 				&& (++(_Next = _Where) == end()

	je	SHORT $LN33@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1746 : 				&& (++(_Next = _Where) == end()

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN35@Insert_hin
$LN33@Insert_hin:

; 1747 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1749 : 				{	// insert after _Where
; 1750 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

	mov	eax, DWORD PTR [esi+8]

; 1751 : 					return (_Insert_at(false, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN34@Insert_hin
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN34@Insert_hin:

; 1752 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1753 : 				else
; 1754 : 					return (_Insert_at(true, _Next._Mynode(),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1760 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN764@Insert_hin:
$LN35@Insert_hin:

; 1761 : 		_CATCH_END
; 1762 : 
; 1763 : 		return (_Insert_nohint(_Leftish,

	push	DWORD PTR __Newnode$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	push	DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN763@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$dead$ = 8					; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$dead$ = 16					; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

	push	esi

; 881  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode0
	mov	edx, eax

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edx+16]

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN65@Buynode
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	ecx, DWORD PTR _<_Val_1>$[esp]
	mov	ecx, DWORD PTR [ecx]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 895  : 		return (_Pnode);

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [esi+16], 0
$LN65@Buynode:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 896  : 		}

	pop	esi
	ret	12					; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
$T2 = -24						; size = 8
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1655 : 		{	// try to insert node using _Where as a hint

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx

; 1656 : 		const_iterator _Next;
; 1657 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1658 : 
; 1659 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1660 : 
; 1661 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1662 : 		if (_Where._Getcont() != &this->_Get_data())
; 1663 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1664 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1665 : 
; 1666 : 		if (size() == 0)

	cmp	DWORD PTR [ebx+4], 0
	mov	DWORD PTR _this$1$[ebp], ebx
	jne	SHORT $LN3@Insert_hin

; 1667 : 			return (_Insert_at(true, this->_Myhead(),

	push	DWORD PTR __Newnode$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	push	DWORD PTR [ebx]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@Insert_hin:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edi, DWORD PTR [ebx]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	esi, DWORD PTR __Where$[ebp]
	cmp	esi, DWORD PTR [edi]

; 1668 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1669 : 		else if (this->_Multi)
; 1670 : 			{	// insert even if duplicate
; 1671 : 			if (_Where == begin())
; 1672 : 				{	// insert at beginning if before first element
; 1673 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1674 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1675 : 					return (_Insert_at(true, _Where._Mynode(),
; 1676 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1677 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1678 : 				}
; 1679 : 			else if (_Where == end())
; 1680 : 				{	// insert at end if after last element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1683 : 					return (_Insert_at(false, _Rmost(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				}
; 1686 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1687 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1688 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1689 : 					this->_Kfn(_Val),
; 1690 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1691 : 				{	// insert before _Where
; 1692 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1693 : 					return (_Insert_at(false, _Next._Mynode(),
; 1694 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1695 : 				else
; 1696 : 					return (_Insert_at(true, _Where._Mynode(),
; 1697 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1698 : 				}
; 1699 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1701 : 				&& (++(_Next = _Where) == end()
; 1702 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1703 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1704 : 				{	// insert after _Where
; 1705 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1706 : 					return (_Insert_at(false, _Where._Mynode(),
; 1707 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1708 : 				else
; 1709 : 					return (_Insert_at(true, _Next._Mynode(),
; 1710 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1711 : 				}
; 1712 : 			else
; 1713 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1714 : 			}
; 1715 : 		else
; 1716 : 			{	// insert only if unique
; 1717 : 			if (_Where == begin())

	jne	SHORT $LN22@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1719 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1720 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1721 : 					return (_Insert_at(true, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN22@Insert_hin:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi

; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				}
; 1724 : 			else if (_Where == end())

	jne	SHORT $LN25@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1727 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1728 : 					return (_Insert_at(false, _Rmost(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN25@Insert_hin:

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	ebx, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	ebx
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN28@Insert_hin

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	DWORD PTR __Next$[ebp], esi

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	ebx, DWORD PTR __Next$[ebp]
	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN761@Insert_hin

; 1734 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1735 : 					this->_Kfn(_Val)))
; 1736 : 				{	// insert before _Where
; 1737 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [ebx+8]

; 1738 : 					return (_Insert_at(false, _Next._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN30@Insert_hin
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN30@Insert_hin:

; 1739 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1740 : 				else
; 1741 : 					return (_Insert_at(true, _Where._Mynode(),

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN761@Insert_hin:
	mov	ebx, DWORD PTR __Val$[ebp]
$LN28@Insert_hin:

; 1746 : 				&& (++(_Next = _Where) == end()

	push	ebx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1746 : 				&& (++(_Next = _Where) == end()

	mov	DWORD PTR __Next$[ebp], esi

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator++

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR __Next$[ebp]
	cmp	ebx, edi

; 1746 : 				&& (++(_Next = _Where) == end()

	je	SHORT $LN33@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1746 : 				&& (++(_Next = _Where) == end()

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN35@Insert_hin
$LN33@Insert_hin:

; 1747 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1749 : 				{	// insert after _Where
; 1750 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

	mov	eax, DWORD PTR [esi+8]

; 1751 : 					return (_Insert_at(false, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN34@Insert_hin
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN34@Insert_hin:

; 1752 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1753 : 				else
; 1754 : 					return (_Insert_at(true, _Next._Mynode(),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1760 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN764@Insert_hin:
$LN35@Insert_hin:

; 1761 : 		_CATCH_END
; 1762 : 
; 1763 : 		return (_Insert_nohint(_Leftish,

	push	DWORD PTR __Newnode$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	push	DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN763@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

	mov	eax, esi
	pop	esi

; 314  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 210  : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Freenode0, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 876  : 		}

	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 849  : 		{	// allocate a non-value node

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN73@Buynode0
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
$LN73@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN187@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN187@Buynode0:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 864  : 		return (_Pnode);

	mov	eax, esi
	pop	esi

; 865  : 		}

	ret	0
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1645 : 		}

	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::size, COMDAT
; _this$ = ecx

; 1171 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1172 : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

	mov	eax, esi
	pop	esi

; 314  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 210  : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Freenode0, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 876  : 		}

	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 849  : 		{	// allocate a non-value node

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN73@Buynode0
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
$LN73@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN187@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN187@Buynode0:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 864  : 		return (_Pnode);

	mov	eax, esi
	pop	esi

; 865  : 		}

	ret	0
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1645 : 		}

	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::size, COMDAT
; _this$ = ecx

; 1171 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1172 : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 946  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 946  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN25@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN25@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z PROC ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@0@AAU10@@Z ENDP ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	push	edi
	mov	edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 119304646				; 071c71c6H
	jb	SHORT $LN5@Insert_at
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Node$[esp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1831 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN716@Insert_at:
$LN5@Insert_at:
	push	ebx

; 1832 : 			}
; 1833 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1834 : 			_STD forward<_Valty>(_Val));
; 1835 : 
; 1836 : 		++this->_Mysize();
; 1837 : 		_Newnode->_Parent = _Wherenode;

	mov	ebx, DWORD PTR __Node$[esp+4]
	inc	eax
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Wherenode$[esp+4]
	push	esi
	mov	DWORD PTR [ebx+4], eax

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1842 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+8], 0
	je	SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	ecx, DWORD PTR [edi]

; 1848 : 			if (_Wherenode == _Lmost())

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1850 : 			}
; 1851 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	ecx, DWORD PTR [edi]

; 1854 : 			if (_Wherenode == _Rmost())

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1855 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
	npad	1
$LL2@Insert_at:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN714@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1878 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN361@Insert_at

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN361@Insert_at:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2119 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN362@Insert_at

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN362@Insert_at:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN364@Insert_at

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN364@Insert_at:

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	SHORT $LN713@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN714@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1904 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN560@Insert_at

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN560@Insert_at:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2089 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN561@Insert_at

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN564@Insert_at
$LN561@Insert_at:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN563@Insert_at

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2093 : 		else

	jmp	SHORT $LN564@Insert_at
$LN563@Insert_at:

; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN564@Insert_at:

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN713@Insert_at:

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ebx
	pop	ebx
	pop	edi

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1916 : 		}

	ret	20					; 00000014H
$LN715@Insert_at:
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
tv1241 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
$T3 = 16						; size = 4
__Where$4 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	eax, ecx

; 1772 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	ebx
	push	esi
	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR [eax]

; 1773 : 		_Nodeptr _Trynode = _Root();
; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1771 : 		{	// try to insert node, on left if _Leftish

	mov	DWORD PTR _this$1$[ebp], eax

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	al, 1
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, DWORD PTR [ecx+4]

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv1241[ebp], ecx

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], al

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN3@Insert_noh
	mov	esi, DWORD PTR [edi+12]
$LL2@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1779 : 			_Wherenode = _Trynode;

	mov	ebx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	cmp	esi, eax
	jl	SHORT $LN142@Insert_noh
	cmp	eax, esi
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edx+24]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edx+20]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN142@Insert_noh
$LN141@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	mov	edx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	xor	al, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	jmp	SHORT $LN420@Insert_noh
$LN142@Insert_noh:
	mov	edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	al, 1
$LN420@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	BYTE PTR __Addleft$2[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	je	SHORT $LL2@Insert_noh
	mov	ecx, DWORD PTR tv1241[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	esi, ebx
	mov	DWORD PTR __Where$4[ebp], esi

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1798 : 			if (!_Addleft)

	test	al, al
	je	SHORT $LN12@Insert_noh

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ebx, DWORD PTR [ecx]

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	1
$LN421@Insert_noh:
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--
	mov	esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edi+4]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edi]
	jl	SHORT $LN296@Insert_noh
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN296@Insert_noh:

; 1802 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 			else
; 1804 : 				--_Where;	// need to test if insert before is okay
; 1805 : 
; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	DWORD PTR __Addleft$2[ebp]
	jmp	$LN421@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1819 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN422@Insert_noh:
$LN419@Insert_noh:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN25@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN25@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z PROC ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@0@AAU10@@Z ENDP ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	push	edi
	mov	edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 119304646				; 071c71c6H
	jb	SHORT $LN5@Insert_at
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Node$[esp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1831 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN716@Insert_at:
$LN5@Insert_at:
	push	ebx

; 1832 : 			}
; 1833 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1834 : 			_STD forward<_Valty>(_Val));
; 1835 : 
; 1836 : 		++this->_Mysize();
; 1837 : 		_Newnode->_Parent = _Wherenode;

	mov	ebx, DWORD PTR __Node$[esp+4]
	inc	eax
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Wherenode$[esp+4]
	push	esi
	mov	DWORD PTR [ebx+4], eax

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1842 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+8], 0
	je	SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	ecx, DWORD PTR [edi]

; 1848 : 			if (_Wherenode == _Lmost())

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1850 : 			}
; 1851 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	ecx, DWORD PTR [edi]

; 1854 : 			if (_Wherenode == _Rmost())

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1855 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
	npad	1
$LL2@Insert_at:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN714@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1878 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN361@Insert_at

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN361@Insert_at:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2119 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN362@Insert_at

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN362@Insert_at:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN364@Insert_at

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN364@Insert_at:

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	SHORT $LN713@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN714@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1904 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN560@Insert_at

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN560@Insert_at:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2089 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN561@Insert_at

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN564@Insert_at
$LN561@Insert_at:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN563@Insert_at

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2093 : 		else

	jmp	SHORT $LN564@Insert_at
$LN563@Insert_at:

; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN564@Insert_at:

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN713@Insert_at:

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ebx
	pop	ebx
	pop	edi

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1916 : 		}

	ret	20					; 00000014H
$LN715@Insert_at:
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
tv1241 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
$T3 = 16						; size = 4
__Where$4 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	eax, ecx

; 1772 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	ebx
	push	esi
	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR [eax]

; 1773 : 		_Nodeptr _Trynode = _Root();
; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1771 : 		{	// try to insert node, on left if _Leftish

	mov	DWORD PTR _this$1$[ebp], eax

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	al, 1
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, DWORD PTR [ecx+4]

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv1241[ebp], ecx

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], al

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN3@Insert_noh
	mov	esi, DWORD PTR [edi+12]
$LL2@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1779 : 			_Wherenode = _Trynode;

	mov	ebx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	cmp	esi, eax
	jl	SHORT $LN142@Insert_noh
	cmp	eax, esi
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edx+24]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edx+20]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN142@Insert_noh
$LN141@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	mov	edx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	xor	al, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	jmp	SHORT $LN420@Insert_noh
$LN142@Insert_noh:
	mov	edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	al, 1
$LN420@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	BYTE PTR __Addleft$2[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	je	SHORT $LL2@Insert_noh
	mov	ecx, DWORD PTR tv1241[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	esi, ebx
	mov	DWORD PTR __Where$4[ebp], esi

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1798 : 			if (!_Addleft)

	test	al, al
	je	SHORT $LN12@Insert_noh

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ebx, DWORD PTR [ecx]

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	1
$LN421@Insert_noh:
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--
	mov	esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edi+4]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edi]
	jl	SHORT $LN296@Insert_noh
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN296@Insert_noh:

; 1802 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 			else
; 1804 : 				--_Where;	// need to test if insert before is okay
; 1805 : 
; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	DWORD PTR __Addleft$2[ebp]
	jmp	$LN421@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1819 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN422@Insert_noh:
$LN419@Insert_noh:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--

; 425  : 		--static_cast<_Mybase&>(*this);
; 426  : 		return (*this);

	mov	eax, esi
	pop	esi

; 427  : 		}

	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1176 : 		return (this->_Getal().max_size());

	mov	eax, 119304647				; 071c71c7H

; 1177 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,std::_Iterator_base0>::operator--

; 425  : 		--static_cast<_Mybase&>(*this);
; 426  : 		return (*this);

	mov	eax, esi
	pop	esi

; 427  : 		}

	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1176 : 		return (this->_Getal().max_size());

	mov	eax, 119304647				; 071c71c7H

; 1177 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 119304647				; 071c71c7H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 119304647				; 071c71c7H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 119304647				; 071c71c7H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 119304647				; 071c71c7H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 119304647				; 071c71c7H

; 750  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 119304647				; 071c71c7H

; 750  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
_<_Args_2>$dead$ = 16					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN14@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN14@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &>, COMDAT
; _this$dead$ = ecx

; 1630 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[esp-4]

; 1631 : 		}

	ret	8
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
_<_Args_2>$dead$ = 16					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN14@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN14@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &>, COMDAT
; _this$dead$ = ecx

; 1630 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[esp-4]

; 1631 : 		}

	ret	8
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)><std::tuple<int,int,int,enum arch_t> &&>, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1197 : 		}

	mov	eax, ecx

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+16], 0

; 1197 : 		}

	ret	12					; 0000000cH
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)><std::tuple<int,int,int,enum arch_t> &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)><std::tuple<int,int,int,enum arch_t> &&>, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1197 : 		}

	mov	eax, ecx

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+16], 0

; 1197 : 		}

	ret	12					; 0000000cH
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)><std::tuple<int,int,int,enum arch_t> &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1183 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+16], 0
	ret	16					; 00000010H
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAHHPBE1HPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(int *,int,unsigned char const *,unsigned char const *,int,short *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1183 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+16], 0
	ret	16					; 00000010H
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAGHPBEHPAFH@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned short *,int,unsigned char const *,int,short *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
_TEXT	ENDS
END
