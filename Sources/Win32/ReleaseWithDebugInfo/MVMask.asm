; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvmask.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CB@BAJGEKBP@MMask?3?5time?5must?5be?50?40?5to?5100?40@ ; `string'
PUBLIC	??_R0?AVMVMask@@@8				; MVMask `RTTI Type Descriptor'
PUBLIC	??_R2MVMask@@8					; MVMask::`RTTI Base Class Array'
PUBLIC	??_R4MVMask@@6B@				; MVMask::`RTTI Complete Object Locator'
PUBLIC	??_R3MVMask@@8					; MVMask::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@MVMask@@8				; MVMask::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7MVMask@@6B@					; MVMask::`vftable'
;	COMDAT ??_7MVMask@@6B@
CONST	SEGMENT
??_7MVMask@@6B@ DD FLAT:??_R4MVMask@@6B@		; MVMask::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVMask@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVMask@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@MVMask@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVMask@@8 DD FLAT:??_R0?AVMVMask@@@8	; MVMask::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVMask@@8
rdata$r	ENDS
;	COMDAT ??_R3MVMask@@8
rdata$r	SEGMENT
??_R3MVMask@@8 DD 00H					; MVMask::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVMask@@8
rdata$r	ENDS
;	COMDAT ??_R4MVMask@@6B@
rdata$r	SEGMENT
??_R4MVMask@@6B@ DD 00H					; MVMask::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVMask@@@8
	DD	FLAT:??_R3MVMask@@8
rdata$r	ENDS
;	COMDAT ??_R2MVMask@@8
rdata$r	SEGMENT
??_R2MVMask@@8 DD FLAT:??_R1A@?0A@EA@MVMask@@8		; MVMask::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVMask@@@8
data$r	SEGMENT
??_R0?AVMVMask@@@8 DD FLAT:??_7type_info@@6B@		; MVMask `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVMask@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0CB@BAJGEKBP@MMask?3?5time?5must?5be?50?40?5to?5100?40@
CONST	SEGMENT
??_C@_0CB@BAJGEKBP@MMask?3?5time?5must?5be?50?40?5to?5100?40@ DB 'MMask: '
	DB	'time must be 0.0 to 100.0', 00H		; `string'
PUBLIC	?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVMask::GetFrame
PUBLIC	?Length@MVMask@@AAEEUVECTOR@@E@Z		; MVMask::Length
PUBLIC	??1MVMask@@UAE@XZ				; MVMask::~MVMask
PUBLIC	??_GMVMask@@UAEPAXI@Z				; MVMask::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVMask@@UAGHHH@Z			; MVMask::SetCacheHints
PUBLIC	??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z ; MVMask::MVMask
EXTRN	??_EMVMask@@UAEPAXI@Z:PROC			; MVMask::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVMask@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1MVMask@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVMask@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVMask@@UAE@XZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVMask@@UAE@XZ$13
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
;	COMDAT ??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_ml$1$ = -28						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
_vectors$ = 12						; size = 4
_gm$ = 16						; size = 8
__kind$ = 24						; size = 4
__time100$ = 28						; size = 8
_Ysc$ = 36						; size = 4
_nSCD1$ = 40						; size = 4
_nSCD2$ = 44						; size = 4
$T2 = 48						; size = 4
$T3 = 48						; size = 4
$T4 = 48						; size = 4
$T5 = 48						; size = 4
__isse$ = 48						; size = 1
__planar$ = 52						; size = 1
_env$ = 56						; size = 4
??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z PROC ; MVMask::MVMask, COMDAT
; _this$ = ecx
; _ml$ = xmm3l

; 40   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, ecx
	movsd	QWORD PTR _ml$1$[ebp], xmm3
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvmask.cpp

; 37   :   : GenericVideoFilter(_child)

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN29@MVMask
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN29@MVMask
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN29@MVMask:
; File c:\github\mvtools\sources\mvmask.cpp

; 37   :   : GenericVideoFilter(_child)

	mov	ecx, esi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 38   :   , mvClip(vectors, nSCD1, nSCD2, env, 1, 0)
; 39   :   , MVFilter(vectors, "MMask", env, 1, 0)

	mov	ebx, DWORD PTR _env$[ebp]
	lea	eax, DWORD PTR _vectors$[ebp]
	push	0
	push	1
	push	ebx
	push	OFFSET ??_C@_05OLMCPBF@MMask?$AA@
	push	eax
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter
	push	0
	push	1
	push	ebx
	push	DWORD PTR _nSCD2$[ebp]
	lea	eax, DWORD PTR _vectors$[ebp]

; 40   : {

	mov	DWORD PTR [esi], OFFSET ??_7MVMask@@6B@
	push	DWORD PTR _nSCD1$[ebp]
	lea	ecx, DWORD PTR [esi+152]
	push	eax
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	xorps	xmm2, xmm2

; 41   :   isse = _isse;
; 42   :   fMaskNormFactor = 1.0f / ml; // Fizick

	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	movaps	xmm0, xmm1
	mov	al, BYTE PTR __isse$[ebp]
	divsd	xmm0, QWORD PTR _ml$1$[ebp]
	mov	BYTE PTR [esi+488], al
	movsd	QWORD PTR [esi+408], xmm0

; 43   :   fMaskNormFactor2 = fMaskNormFactor*fMaskNormFactor;

	mulsd	xmm0, xmm0
	movsd	QWORD PTR [esi+416], xmm0

; 44   : 
; 45   : //	nLengthMax = pow((double(ml),gm);
; 46   : 
; 47   :   fGamma = gm;

	movsd	xmm0, QWORD PTR _gm$[ebp]

; 48   :   if (gm < 0)

	comisd	xmm2, xmm0
	movsd	QWORD PTR [esi+400], xmm0
	jbe	SHORT $LN2@MVMask

; 49   :     fGamma = 1;

	movsd	QWORD PTR [esi+400], xmm1
$LN2@MVMask:

; 50   :   fHalfGamma = fGamma*0.5f;

	movsd	xmm0, QWORD PTR [esi+400]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000

; 51   : 
; 52   :   kind = _kind; // inplace of showsad

	mov	eax, DWORD PTR __kind$[ebp]

; 53   : 
; 54   :   if (_time100 < 0 || _time100 > 100)

	movsd	xmm1, QWORD PTR __real@4059000000000000
	mov	DWORD PTR [esi+424], eax
	movsd	QWORD PTR [esi+392], xmm0
	movsd	xmm0, QWORD PTR __time100$[ebp]
	comisd	xmm2, xmm0
	ja	SHORT $LN4@MVMask
	comisd	xmm0, xmm1
	jbe	SHORT $LN3@MVMask
$LN4@MVMask:

; 55   :     env->ThrowError("MMask: time must be 0.0 to 100.0");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0CB@BAJGEKBP@MMask?3?5time?5must?5be?50?40?5to?5100?40@
	push	ebx
	call	DWORD PTR [eax+20]
	movsd	xmm0, QWORD PTR __time100$[ebp]
	add	esp, 8
	movsd	xmm1, QWORD PTR __real@4059000000000000
$LN3@MVMask:

; 56   :   time256 = int(256 * _time100 / 100);

	mulsd	xmm0, QWORD PTR __real@4070000000000000
	divsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR [esi+428], eax

; 57   : 
; 58   :   nSceneChangeValue = (Ysc < 0) ? 0 : ((Ysc > 255) ? 255 : Ysc);

	mov	eax, DWORD PTR _Ysc$[ebp]
	test	eax, eax
	jns	SHORT $LN8@MVMask
	xor	eax, eax
	jmp	SHORT $LN9@MVMask
$LN8@MVMask:
	mov	ecx, 255				; 000000ffH
	cmp	eax, ecx
	cmovg	eax, ecx
$LN9@MVMask:
	mov	BYTE PTR [esi+432], al

; 59   :   planar = _planar;

	mov	al, BYTE PTR __planar$[ebp]
	mov	BYTE PTR [esi+489], al

; 60   : 
; 61   :   smallMask = new unsigned char[nBlkX * nBlkY];

	mov	eax, DWORD PTR [esi+64]
	imul	eax, DWORD PTR [esi+68]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+436], eax

; 62   :   smallMaskV = new unsigned char[nBlkX * nBlkY];

	mov	eax, DWORD PTR [esi+64]
	imul	eax, DWORD PTR [esi+68]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 63   : 
; 64   :   nWidthB = nBlkX*(nBlkSizeX - nOverlapX) + nOverlapX;

	mov	ebx, DWORD PTR [esi+76]
	add	esp, 8

; 65   :   nHeightB = nBlkY*(nBlkSizeY - nOverlapY) + nOverlapY;

	mov	edi, DWORD PTR [esi+80]
	sub	edi, DWORD PTR [esi+112]
	sub	ebx, DWORD PTR [esi+108]
	imul	edi, DWORD PTR [esi+68]
	imul	ebx, DWORD PTR [esi+64]

; 66   : 
; 67   :   nHeightUV = nHeight / yRatioUV;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi+440], eax
	add	edi, DWORD PTR [esi+112]
	add	ebx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [ecx+96]
	cdq
	mov	DWORD PTR [esi+460], edi
	mov	DWORD PTR [esi+456], ebx
	mov	esi, DWORD PTR [esi+124]
	idiv	esi
	mov	DWORD PTR [ecx+476], eax

; 68   :   nWidthUV = nWidth / xRatioUV;// for YV12

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR [eax+92]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+472], eax

; 69   :   nHeightBUV = nHeightB / yRatioUV;

	mov	eax, edi
	cdq
	idiv	esi
	mov	edi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edi+468], eax

; 70   :   nWidthBUV = nWidthB / xRatioUV;

	mov	eax, ebx
	cdq
	idiv	ecx

; 71   : 
; 72   :   int CPUF_Resize = env->GetCPUFlags();

	mov	ecx, DWORD PTR _env$[ebp]
	mov	DWORD PTR [edi+464], eax
	push	ecx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	esi, eax

; 73   :   if (!isse) CPUF_Resize = (CPUF_Resize & !CPUF_INTEGER_SSE) & !CPUF_SSE2;

	xor	eax, eax
	cmp	BYTE PTR [edi+488], al

; 74   :  // old upsizer replaced by Fizick
; 75   :   upsizer = new SimpleResize(nWidthB, nHeightB, nBlkX, nBlkY, CPUF_Resize);

	push	40					; 00000028H
	cmove	esi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [edi+68]
	push	DWORD PTR [edi+64]
	push	DWORD PTR [edi+460]
	push	DWORD PTR [edi+456]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize

; 76   :   upsizerUV = new SimpleResize(nWidthBUV, nHeightBUV, nBlkX, nBlkY, CPUF_Resize);

	push	40					; 00000028H
	mov	DWORD PTR [edi+448], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [edi+68]
	push	DWORD PTR [edi+64]
	push	DWORD PTR [edi+468]
	push	DWORD PTR [edi+464]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize
	mov	DWORD PTR [edi+452], eax

; 77   : 
; 78   : 
; 79   :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN6@MVMask
	cmp	BYTE PTR [edi+489], 0
	jne	SHORT $LN6@MVMask

; 80   :   {
; 81   :     DstPlanes = new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes

; 82   :     SrcPlanes = new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	mov	DWORD PTR [edi+480], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes
	mov	DWORD PTR [edi+484], eax
$LN6@MVMask:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN33@MVMask
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN33@MVMask
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN33@MVMask:
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN41@MVMask
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN41@MVMask
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _vectors$[ebp]
	call	eax
$LN41@MVMask:
; File c:\github\mvtools\sources\mvmask.cpp

; 85   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _vectors$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z ENDP ; MVMask::MVMask
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvmask.h
;	COMDAT ?SetCacheHints@MVMask@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVMask@@UAGHHH@Z PROC			; MVMask::SetCacheHints, COMDAT

; 83   :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 84   :   }

	ret	12					; 0000000cH
?SetCacheHints@MVMask@@UAGHHH@Z ENDP			; MVMask::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVMask@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVMask@@UAEPAXI@Z PROC				; MVMask::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVMask@@UAE@XZ			; MVMask::~MVMask
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	496					; 000001f0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVMask@@UAEPAXI@Z ENDP				; MVMask::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
;	COMDAT ??1MVMask@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVMask@@UAE@XZ PROC					; MVMask::~MVMask, COMDAT
; _this$ = ecx

; 89   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVMask@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 90   :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	edi, DWORD PTR __imp___aligned_free
	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [esi], OFFSET ??_7MVMask@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN20@MVMask
	cmp	BYTE PTR [esi+489], 0
	jne	SHORT $LN20@MVMask

; 91   :   {
; 92   :     delete DstPlanes;

	mov	ebx, DWORD PTR [esi+480]
	test	ebx, ebx
	je	SHORT $LN13@MVMask
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN13@MVMask:
; File c:\github\mvtools\sources\mvmask.cpp

; 93   :     delete SrcPlanes;

	mov	ebx, DWORD PTR [esi+484]
	test	ebx, ebx
	je	SHORT $LN20@MVMask
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN20@MVMask:
; File c:\github\mvtools\sources\mvmask.cpp

; 95   :   delete[] smallMask;

	push	DWORD PTR [esi+436]
	call	??_V@YAXPAX@Z				; operator delete[]

; 96   :   delete[] smallMaskV;

	push	DWORD PTR [esi+440]
	call	??_V@YAXPAX@Z				; operator delete[]

; 97   :   delete upsizer;

	mov	ebx, DWORD PTR [esi+448]
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN27@MVMask
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN27@MVMask:
; File c:\github\mvtools\sources\mvmask.cpp

; 98   :   delete upsizerUV;

	mov	ebx, DWORD PTR [esi+452]
	test	ebx, ebx
	je	SHORT $LN34@MVMask
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN34@MVMask:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN48@MVMask
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN48@MVMask
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN48@MVMask:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN65@MVMask
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN65@MVMask
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN65@MVMask:
; File c:\github\mvtools\sources\mvmask.cpp

; 99   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvmask.cpp

; 99   : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVMask@@UAE@XZ$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVMask@@UAE@XZ$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVMask@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVMask@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVMask@@UAE@XZ ENDP					; MVMask::~MVMask
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvmask.cpp
;	COMDAT ?Length@MVMask@@AAEEUVECTOR@@E@Z
_TEXT	SEGMENT
_v$ = 8							; size = 12
_pel$ = 20						; size = 1
?Length@MVMask@@AAEEUVECTOR@@E@Z PROC			; MVMask::Length, COMDAT
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx

; 103  :   double norme = double(v.x * v.x + v.y * v.y) / (pel * pel);

	mov	edx, DWORD PTR _v$[ebp+4]
	mov	eax, DWORD PTR _v$[ebp]
	push	esi
	movzx	esi, BYTE PTR _pel$[ebp]
	imul	edx, edx
	imul	eax, eax
	imul	esi, esi
	add	edx, eax
	movd	xmm0, edx
	movd	xmm1, esi
	cvtdq2pd xmm0, xmm0
	cvtdq2pd xmm1, xmm1
	divsd	xmm0, xmm1

; 104  : 
; 105  : //	double l = 255 * pow(norme,nGamma) / nLengthMax;
; 106  :   double l = 255 * pow(norme*fMaskNormFactor2, fHalfGamma); //Fizick - simply rewritten

	movsd	xmm1, QWORD PTR [ecx+392]
	mulsd	xmm0, QWORD PTR [ecx+416]
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, xmm1

; 107  : 
; 108  :   return (unsigned char)((l > 255) ? 255 : l);
; 109  : }

	pop	esi
	minsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Length@MVMask@@AAEEUVECTOR@@E@Z ENDP			; MVMask::Length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvmask.cpp
;	COMDAT ?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_v$2 = -84						; size = 12
$T3 = -84						; size = 12
$T4 = -84						; size = 12
_nSrcPitches$ = -84					; size = 12
_pSrc$ = -84						; size = 12
_width$1$ = -72						; size = 4
_width$1$ = -72						; size = 4
tv2355 = -72						; size = 4
tv2341 = -72						; size = 4
tv2337 = -72						; size = 4
$T5 = -72						; size = 4
_width$1$ = -68						; size = 4
$T6 = -68						; size = 4
$T7 = -64						; size = 4
$T8 = -64						; size = 4
$T9 = -64						; size = 4
$T10 = -60						; size = 4
$T11 = -60						; size = 4
$T12 = -60						; size = 4
$T13 = -56						; size = 4
_mvn$ = -52						; size = 4
_nSrcPitches$1$ = -48					; size = 4
_pSrc$1$ = -44						; size = 4
_nDstPitches$3$ = -40					; size = 4
_nSrcPitchYUY2$1$ = -40					; size = 4
_src$ = -36						; size = 4
_pDst$2$ = -32						; size = 4
_pSrcYUY2$1$ = -32					; size = 4
_nDstPitches$2$ = -28					; size = 4
_pDst$1$ = -24						; size = 4
_pDst$3$ = -20						; size = 4
_nDstPitches$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_height$1$ = 16						; size = 4
_h$1$ = 16						; size = 4
_h$1$ = 16						; size = 4
tv2354 = 16						; size = 4
tv2353 = 16						; size = 4
$T14 = 16						; size = 4
$T15 = 16						; size = 4
$T16 = 16						; size = 4
$T17 = 16						; size = 4
_n$ = 16						; size = 4
_height$1$ = 20						; size = 4
_height$1$ = 20						; size = 4
_ptr$1$ = 20						; size = 4
_pDstYUY2$1$ = 20					; size = 4
_env$ = 20						; size = 4
?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVMask::GetFrame, COMDAT

; 120  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx

; 121  :   PVideoFrame	src = child->GetFrame(n, env);

	mov	ebx, DWORD PTR _env$[ebp]
	lea	edx, DWORD PTR _src$[ebp]
	push	esi
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	edi, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\mvmask.cpp

; 120  : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T13[ebp], 0

; 121  :   PVideoFrame	src = child->GetFrame(n, env);

	push	ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mvmask.cpp

; 121  :   PVideoFrame	src = child->GetFrame(n, env);

	push	DWORD PTR _n$[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]

; 122  :   PVideoFrame	dst = env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR [ebx]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	push	esi
	push	ebx
	call	DWORD PTR [ecx+56]

; 288  :   return dst;

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR $T13[ebp], 1
	cmp	eax, 1610612740				; 60000004H
	jne	$LN26@GetFrame

; 123  :   int dummyplane = PLANAR_Y; // use luma plane resizer code for all planes if we resize from luma small mask
; 124  :   const BYTE *pSrc[3];
; 125  :   BYTE *pDst[3];
; 126  :   int nDstPitches[3];
; 127  :   int nSrcPitches[3];
; 128  :   unsigned char *pDstYUY2;
; 129  :   const unsigned char *pSrcYUY2;
; 130  :   int nDstPitchYUY2;
; 131  :   int nSrcPitchYUY2;
; 132  : 
; 133  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)
; 134  :   {
; 135  :     if (!planar)

	cmp	BYTE PTR [edi+489], 0
	jne	$LN28@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN65@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN65@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	0
	call	eax
	mov	DWORD PTR _pSrcYUY2$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN66@GetFrame
$LN65@GetFrame:
	mov	DWORD PTR _pSrcYUY2$1$[ebp], 0
$LN66@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN71@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN71@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	0
	call	eax
	mov	DWORD PTR _nSrcPitchYUY2$1$[ebp], eax
	jmp	SHORT $LN72@GetFrame
$LN71@GetFrame:
	mov	DWORD PTR _nSrcPitchYUY2$1$[ebp], 0
$LN72@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	ecx, DWORD PTR [edi+484]
	mov	eax, DWORD PTR [ecx]

; 42   :    inline unsigned char *GetPtrU() const { return pSrcU; }

	mov	esi, DWORD PTR [ecx+4]

; 43   :    inline unsigned char *GetPtrV() const { return pSrcV; }

	mov	edx, DWORD PTR [ecx+8]

; 39   :    inline int GetPitch() const { return srcPitch; }

	mov	ebx, DWORD PTR [ecx+20]

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	ecx, DWORD PTR [ecx+24]

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	DWORD PTR _pSrc$1$[ebp], eax
; File c:\github\mvtools\sources\mvmask.cpp

; 145  :       YUY2ToPlanes(pSrcYUY2, nSrcPitchYUY2, nWidth, nHeight,

	movzx	eax, BYTE PTR [edi+488]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR _nSrcPitchYUY2$1$[ebp]
	push	esi
	push	ebx
	push	DWORD PTR _pSrc$1$[ebp]
	mov	DWORD PTR _pSrc$[ebp+4], esi
	push	DWORD PTR [edi+96]
	mov	DWORD PTR _nSrcPitches$[ebp+4], ecx
	push	DWORD PTR [edi+92]
	mov	ecx, DWORD PTR _pSrcYUY2$1$[ebp]
; File c:\github\mvtools\sources\yuy2planes.h

; 39   :    inline int GetPitch() const { return srcPitch; }

	mov	DWORD PTR _nSrcPitches$1$[ebp], ebx
; File c:\github\mvtools\sources\mvmask.cpp

; 145  :       YUY2ToPlanes(pSrcYUY2, nSrcPitchYUY2, nWidth, nHeight,

	call	?YUY2ToPlanes@@YAXPBEHHH0H00H_N@Z	; YUY2ToPlanes
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [edi+480]
; File c:\github\mvtools\sources\mvmask.cpp

; 145  :       YUY2ToPlanes(pSrcYUY2, nSrcPitchYUY2, nWidth, nHeight,

	add	esp, 32					; 00000020H

; 148  :       pDst[1] = DstPlanes->GetPtrU();

	mov	ecx, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax]

; 149  :       pDst[2] = DstPlanes->GetPtrV();

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _pDst$2$[ebp], ecx

; 150  :       nDstPitches[0] = DstPlanes->GetPitch();

	mov	ecx, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvmask.cpp

; 147  :       pDst[0] = DstPlanes->GetPtr();

	mov	DWORD PTR _pDst$1$[ebp], ebx

; 149  :       pDst[2] = DstPlanes->GetPtrV();

	mov	DWORD PTR _pDst$3$[ebp], esi

; 150  :       nDstPitches[0] = DstPlanes->GetPitch();

	mov	DWORD PTR _nDstPitches$1$[ebp], ecx
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	DWORD PTR _nDstPitches$2$[ebp], eax
; File c:\github\mvtools\sources\mvmask.cpp

; 152  :       nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 153  : //			YUY2ToPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,
; 154  : //				pDst[0], nDstPitches[0], pDst[1], pDst[2], nDstPitches[1], isse);
; 155  :     }
; 156  :     else

	jmp	$LN192@GetFrame
$LN28@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN101@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN101@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN360@GetFrame
$LN101@GetFrame:
	xor	ecx, ecx
$LN360@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 160  :       pSrc[1] = pSrc[0] + nWidth;

	mov	eax, DWORD PTR [edi+92]
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	DWORD PTR _pSrc$1$[ebp], ecx
; File c:\github\mvtools\sources\mvmask.cpp

; 160  :       pSrc[1] = pSrc[0] + nWidth;

	add	ecx, eax
	mov	DWORD PTR _pSrc$[ebp+4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN107@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN107@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN361@GetFrame
$LN107@GetFrame:
	xor	eax, eax
$LN361@GetFrame:
	mov	DWORD PTR _nSrcPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvmask.cpp

; 163  :       nSrcPitches[1] = nSrcPitches[0];

	mov	DWORD PTR _nSrcPitches$[ebp+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN113@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN113@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ebx, eax
	jmp	SHORT $LN362@GetFrame
$LN113@GetFrame:
	xor	ebx, ebx
$LN362@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 166  :       pDst[1] = pDst[0] + nWidth;

	mov	eax, DWORD PTR [edi+92]
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	DWORD PTR _pDst$1$[ebp], ebx
; File c:\github\mvtools\sources\mvmask.cpp

; 166  :       pDst[1] = pDst[0] + nWidth;

	lea	ecx, DWORD PTR [eax+ebx]

; 167  :       pDst[2] = pDst[1] + nWidth / 2; // YUY2

	cdq
	sub	eax, edx
	mov	DWORD PTR _pDst$2$[ebp], ecx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR _pDst$3$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN119@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN119@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
; File c:\github\mvtools\sources\mvmask.cpp

; 173  :   else

	mov	esi, DWORD PTR _pDst$3$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	mov	DWORD PTR _nDstPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvmask.cpp

; 169  :       nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$2$[ebp], eax

; 170  :       nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 173  :   else

	jmp	$LN192@GetFrame
$LN119@GetFrame:
	mov	esi, DWORD PTR _pDst$3$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	xor	eax, eax
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvmask.cpp

; 169  :       nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$2$[ebp], eax

; 170  :       nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 173  :   else

	jmp	$LN192@GetFrame
$LN26@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN125@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN125@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	1
	call	eax
	mov	DWORD PTR _pSrc$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN126@GetFrame
$LN125@GetFrame:
	mov	DWORD PTR _pSrc$1$[ebp], 0
$LN126@GetFrame:
	test	eax, eax
	je	SHORT $LN131@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN131@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN132@GetFrame
$LN131@GetFrame:
	xor	ecx, ecx
$LN132@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 176  :     pSrc[1] = URPLAN(src);

	mov	DWORD PTR _pSrc$[ebp+4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN143@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN138@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	4
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN138@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN143@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN143@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	DWORD PTR _nSrcPitches$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN144@GetFrame
$LN143@GetFrame:
	mov	DWORD PTR _nSrcPitches$1$[ebp], 0
$LN144@GetFrame:
	test	eax, eax
	je	SHORT $LN149@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN149@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN150@GetFrame
$LN149@GetFrame:
	xor	ecx, ecx
$LN150@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 179  :     nSrcPitches[1] = UPITCH(src);

	mov	DWORD PTR _nSrcPitches$[ebp+4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN161@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN156@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN156@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN161@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN161@GetFrame
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+220]
	push	1
	call	eax
	mov	ebx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN364@GetFrame
$LN161@GetFrame:
	xor	ebx, ebx
$LN364@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], ebx
	test	eax, eax
	je	SHORT $LN167@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN167@GetFrame
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+220]
	push	2
	call	eax
	mov	DWORD PTR _pDst$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN168@GetFrame
$LN167@GetFrame:
	mov	DWORD PTR _pDst$2$[ebp], 0
$LN168@GetFrame:
	test	eax, eax
	je	SHORT $LN173@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN173@GetFrame
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+220]
	push	4
	call	eax
	mov	esi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN365@GetFrame
$LN173@GetFrame:
	xor	esi, esi
$LN365@GetFrame:

; 976  :   VideoFrame* operator->() const { return p; }

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	DWORD PTR _pDst$3$[ebp], esi

; 976  :   VideoFrame* operator->() const { return p; }

	mov	edx, DWORD PTR [ecx]

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN179@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN179@GetFrame
	mov	eax, DWORD PTR [eax+192]
	mov	ecx, edx
	push	1
	call	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN180@GetFrame
$LN179@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], 0
$LN180@GetFrame:

; 976  :   VideoFrame* operator->() const { return p; }

	mov	edx, DWORD PTR [ecx]

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN185@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN185@GetFrame
	mov	eax, DWORD PTR [eax+192]
	mov	ecx, edx
	push	2
	call	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN186@GetFrame
$LN185@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN186@GetFrame:
	test	eax, eax
	je	SHORT $LN191@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN191@GetFrame
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	jmp	SHORT $LN192@GetFrame
$LN191@GetFrame:
	mov	DWORD PTR _nDstPitches$3$[ebp], 0
$LN192@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 189  :   PVideoFrame mvn = mvClip.GetFrame(n, env);

	push	DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edi+152]
	lea	ecx, DWORD PTR [edi+152]
	push	DWORD PTR _n$[ebp]
	lea	edx, DWORD PTR _mvn$[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 190  :   mvClip.Update(mvn, env);

	push	DWORD PTR _env$[ebp]
	lea	eax, DWORD PTR _mvn$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	eax
	lea	ecx, DWORD PTR [edi+152]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update

; 191  : #ifndef _M_X64
; 192  :   _mm_empty();

	emms
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	mov	ecx, DWORD PTR [edi+240]
	push	DWORD PTR [edi+372]
	mov	ecx, DWORD PTR [ecx]
	push	DWORD PTR [edi+368]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN30@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [edi+220]
	lea	ecx, DWORD PTR [edi+152]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN30@GetFrame
; File c:\github\mvtools\sources\mvmask.cpp

; 196  :     if (kind == 0) // vector length mask

	mov	eax, DWORD PTR [edi+424]
	test	eax, eax
	jne	SHORT $LN32@GetFrame

; 197  :     {
; 198  :       for (int j = 0; j < nBlkCount; j++)

	xor	esi, esi
	cmp	DWORD PTR [edi+72], esi
	jle	$LN12@GetFrame
	xor	ebx, ebx
	npad	9
$LL4@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [edi+240]
; File c:\github\mvtools\sources\mvmask.cpp

; 199  :         smallMask[j] = Length(mvClip.GetBlock(0, j).GetMV(), mvClip.GetPel());

	push	DWORD PTR [edi+284]
	sub	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvmask.cpp

; 199  :         smallMask[j] = Length(mvClip.GetBlock(0, j).GetMV(), mvClip.GetPel());

	mov	ecx, esp
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mvmask.cpp

; 199  :         smallMask[j] = Length(mvClip.GetBlock(0, j).GetMV(), mvClip.GetPel());

	movq	xmm0, QWORD PTR [eax+ebx+8]
	mov	eax, DWORD PTR [eax+ebx+16]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edi
	call	?Length@MVMask@@AAEEUVECTOR@@E@Z	; MVMask::Length
	mov	ecx, DWORD PTR [edi+436]
	lea	ebx, DWORD PTR [ebx+20]
	mov	BYTE PTR [esi+ecx], al
	inc	esi
	cmp	esi, DWORD PTR [edi+72]
	jl	SHORT $LL4@GetFrame

; 200  :     }
; 201  :     else if (kind == 1) // SAD mask

	jmp	$LN366@GetFrame
$LN32@GetFrame:
	cmp	eax, 1
	jne	$LN34@GetFrame

; 202  :     {
; 203  :       //for ( int j = 0; j < nBlkCount; j++)
; 204  :       //	smallMask[j] = SAD(mvClip.GetBlock(0, j).GetSAD()); // PF 161115 bits_per_pixel scale through dSADNormFactor
; 205  :       MakeSADMaskTime(mvClip, nBlkX, nBlkY, 4.0*fMaskNormFactor / (nBlkSizeX*nBlkSizeY) / (1 << (bits_per_pixel - 8)), fGamma, nPel, smallMask, nBlkX, time256, nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	mov	eax, DWORD PTR [edi+80]
	sub	eax, DWORD PTR [edi+112]
	mov	edx, DWORD PTR [edi+76]
	mov	esi, DWORD PTR [edi+64]
	movsd	xmm0, QWORD PTR [edi+400]
	push	eax
	movsd	xmm1, QWORD PTR [edi+408]
	mov	eax, edx
	sub	eax, DWORD PTR [edi+108]
	imul	edx, DWORD PTR [edi+80]
	mulsd	xmm1, QWORD PTR __real@4010000000000000
	push	eax
	push	DWORD PTR [edi+428]
	mov	ecx, DWORD PTR [edi+140]
	mov	eax, 1
	push	esi
	push	DWORD PTR [edi+436]
	sub	ecx, 8
	push	DWORD PTR [edi+104]
	shl	eax, cl
	lea	ecx, DWORD PTR [edi+152]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movd	xmm0, edx
	mov	edx, esi
	cvtdq2pd xmm0, xmm0
	push	DWORD PTR [edi+68]
	divsd	xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm1, xmm0
	movaps	xmm3, xmm1
	call	?MakeSADMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeSADMaskTime
	add	esp, 36					; 00000024H
	jmp	$LN12@GetFrame
$LN34@GetFrame:

; 206  :     }
; 207  :     else if (kind == 2) // occlusion mask

	cmp	eax, 2
	jne	SHORT $LN36@GetFrame

; 208  :     {
; 209  :       //MakeVectorOcclusionMaskTime(mvClip, nBlkX, nBlkY, fMaskNormFactor, fGamma, nPel, smallMask, nBlkX, 256, nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY) ;
; 210  :       MakeVectorOcclusionMaskTime(mvClip, nBlkX, nBlkY, 1.0 / fMaskNormFactor, fGamma, nPel, smallMask, nBlkX, time256, nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	mov	eax, DWORD PTR [edi+80]
	sub	eax, DWORD PTR [edi+112]
	mov	edx, DWORD PTR [edi+64]
	movsd	xmm0, QWORD PTR [edi+400]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	sub	eax, DWORD PTR [edi+108]
	push	eax
	push	DWORD PTR [edi+428]
	push	edx
	push	DWORD PTR [edi+436]
	push	DWORD PTR [edi+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	divsd	xmm0, QWORD PTR [edi+408]
	push	DWORD PTR [edi+68]
	movaps	xmm3, xmm0
	call	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime
	add	esp, 36					; 00000024H
	jmp	$LN12@GetFrame
$LN36@GetFrame:

; 211  :     }
; 212  :     else if (kind == 3) // vector x mask

	cmp	eax, 3
	jne	$LN38@GetFrame

; 213  :     {
; 214  :       for (int j = 0; j < nBlkCount; j++)

	xor	edx, edx
	cmp	DWORD PTR [edi+72], edx
	jle	$LN12@GetFrame
	movsd	xmm1, QWORD PTR __real@4059000000000000
	xor	esi, esi
	movsd	xmm2, QWORD PTR __real@4060000000000000

; 215  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().x * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	mov	DWORD PTR $T12[ebp], 255		; 000000ffH
	mov	DWORD PTR $T9[ebp], edx
$LL7@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [edi+240]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T17[ebp]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [eax+esi+8]
	movq	QWORD PTR $T4[ebp], xmm0
	movd	xmm0, DWORD PTR $T4[ebp]
; File c:\github\mvtools\sources\mvmask.cpp

; 215  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().x * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [edi+408]
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm2
	cvttsd2si eax, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 255				; 000000ffH
; File c:\github\mvtools\sources\mvmask.cpp

; 215  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().x * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	mov	DWORD PTR $T17[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T12[ebp]
	cmovge	ecx, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T9[ebp]
	cmp	DWORD PTR [ecx], 0
	cmovg	eax, ecx
; File c:\github\mvtools\sources\mvmask.cpp

; 215  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().x * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	mov	ecx, DWORD PTR [edi+436]
	add	esi, 20					; 00000014H
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx], al
	inc	edx
	cmp	edx, DWORD PTR [edi+72]
	jl	SHORT $LL7@GetFrame

; 216  :       //smallMask[j] = mvClip.GetBlock(0, j).GetMV().x + 128; // shited by 128 for signed support
; 217  :     }
; 218  :     else if (kind == 4) // vector y mask

	jmp	$LN366@GetFrame
$LN38@GetFrame:
	cmp	eax, 4
	jne	$LN40@GetFrame

; 219  :     {
; 220  :       for (int j = 0; j < nBlkCount; j++)

	xor	edx, edx
	cmp	DWORD PTR [edi+72], edx
	jle	$LN12@GetFrame
	movsd	xmm1, QWORD PTR __real@4059000000000000
	xor	esi, esi
	movsd	xmm2, QWORD PTR __real@4060000000000000

; 221  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().y * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	mov	DWORD PTR $T8[ebp], 255			; 000000ffH
	mov	DWORD PTR $T11[ebp], edx
	npad	9
$LL10@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [edi+240]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T16[ebp]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [eax+esi+8]
	movq	QWORD PTR $T3[ebp], xmm0
	movd	xmm0, DWORD PTR $T3[ebp+4]
; File c:\github\mvtools\sources\mvmask.cpp

; 221  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().y * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [edi+408]
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm2
	cvttsd2si eax, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 255				; 000000ffH
; File c:\github\mvtools\sources\mvmask.cpp

; 221  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().y * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	mov	DWORD PTR $T16[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T8[ebp]
	cmovge	ecx, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T11[ebp]
	cmp	DWORD PTR [ecx], 0
	cmovg	eax, ecx
; File c:\github\mvtools\sources\mvmask.cpp

; 221  :         smallMask[j] = std::max(int(0), std::min(255, int(mvClip.GetBlock(0, j).GetMV().y * fMaskNormFactor * 100 + 128))); // shited by 128 for signed support

	mov	ecx, DWORD PTR [edi+436]
	add	esi, 20					; 00000014H
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx], al
	inc	edx
	cmp	edx, DWORD PTR [edi+72]
	jl	SHORT $LL10@GetFrame

; 222  :       //smallMask[j] = mvClip.GetBlock(0, j).GetMV().y + 128; // shited by 128 for signed support
; 223  :     }
; 224  :     else if (kind == 5) // vector x mask in U, y mask in V

	jmp	$LN366@GetFrame
$LN40@GetFrame:
	cmp	eax, 5
	jne	$LN12@GetFrame

; 225  :     {
; 226  :       for (int j = 0; j < nBlkCount; j++) {

	xor	edx, edx
	cmp	DWORD PTR [edi+72], edx
	jle	$LN12@GetFrame
	movsd	xmm1, QWORD PTR __real@4059000000000000
	xor	esi, esi
	movsd	xmm2, QWORD PTR __real@4060000000000000

; 230  :         smallMask[j] = std::max(0, std::min(255, int(v.x * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	mov	DWORD PTR $T7[ebp], 255			; 000000ffH
	mov	DWORD PTR $T10[ebp], edx

; 231  :         smallMaskV[j] = std::max(0, std::min(255, int(v.y * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	mov	DWORD PTR $T6[ebp], 255			; 000000ffH
	mov	DWORD PTR $T5[ebp], edx
$LL13@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [edi+240]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T15[ebp]
	lea	ebx, DWORD PTR $T6[ebp]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [eax+esi+8]
	movq	QWORD PTR _v$2[ebp], xmm0
	movd	xmm0, DWORD PTR _v$2[ebp]
; File c:\github\mvtools\sources\mvmask.cpp

; 230  :         smallMask[j] = std::max(0, std::min(255, int(v.x * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [edi+408]
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm2
	cvttsd2si eax, xmm0
	movd	xmm0, DWORD PTR _v$2[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 255				; 000000ffH
; File c:\github\mvtools\sources\mvmask.cpp

; 230  :         smallMask[j] = std::max(0, std::min(255, int(v.x * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	mov	DWORD PTR $T15[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T7[ebp]
	cmovge	ecx, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T10[ebp]
; File c:\github\mvtools\sources\mvmask.cpp

; 231  :         smallMaskV[j] = std::max(0, std::min(255, int(v.y * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	cvtdq2pd xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	DWORD PTR [ecx], 0
	cmovg	eax, ecx
; File c:\github\mvtools\sources\mvmask.cpp

; 230  :         smallMask[j] = std::max(0, std::min(255, int(v.x * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	mov	ecx, DWORD PTR [edi+436]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T14[ebp]
; File c:\github\mvtools\sources\mvmask.cpp

; 231  :         smallMaskV[j] = std::max(0, std::min(255, int(v.y * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	mulsd	xmm0, QWORD PTR [edi+408]
	mulsd	xmm0, xmm1
	addsd	xmm0, xmm2
	cvttsd2si eax, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 255				; 000000ffH
; File c:\github\mvtools\sources\mvmask.cpp

; 231  :         smallMaskV[j] = std::max(0, std::min(255, int(v.y * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	mov	DWORD PTR $T14[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T5[ebp]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, ebx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	DWORD PTR [ecx], 0
	cmovg	eax, ecx
; File c:\github\mvtools\sources\mvmask.cpp

; 231  :         smallMaskV[j] = std::max(0, std::min(255, int(v.y * fMaskNormFactor * 100 + 128))); // shifted by 128 for signed support

	mov	ecx, DWORD PTR [edi+440]
	add	esi, 20					; 00000014H
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx], al
	inc	edx
	cmp	edx, DWORD PTR [edi+72]
	jl	$LL13@GetFrame
$LN366@GetFrame:
	mov	ebx, DWORD PTR _pDst$1$[ebp]
$LN12@GetFrame:

; 232  :       }
; 233  :     }
; 234  : 
; 235  :     if (kind == 5) { // do not change luma for kind=5

	cmp	DWORD PTR [edi+424], 5
	jne	SHORT $LN43@GetFrame

; 236  :       env->BitBlt(pDst[0], nDstPitches[0], pSrc[0], nSrcPitches[0], nWidth*pixelsize, nHeight);

	push	DWORD PTR [edi+96]
	mov	eax, DWORD PTR [edi+136]
	imul	eax, DWORD PTR [edi+92]
	mov	edx, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [edx]
	push	eax
	push	DWORD PTR _nSrcPitches$1$[ebp]
	push	DWORD PTR _pSrc$1$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	ebx
	push	edx

; 237  :     }
; 238  :     else {

	jmp	$LN367@GetFrame
$LN43@GetFrame:

; 239  :       upsizer->SimpleResizeDo_uint8(pDst[0], nWidthB, nHeightB, nDstPitches[0], smallMask, nBlkX, nBlkX, dummyplane);

	mov	eax, DWORD PTR [edi+64]
	push	ecx
	mov	ecx, DWORD PTR [edi+448]
	push	eax
	push	eax
	push	DWORD PTR [edi+436]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR [edi+460]
	push	DWORD PTR [edi+456]
	push	ebx
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 240  :       if (nWidth > nWidthB)

	mov	eax, DWORD PTR [edi+92]
	cmp	eax, DWORD PTR [edi+456]
	jle	SHORT $LN358@GetFrame

; 241  :         for (int h = 0; h < nHeight; h++)

	xor	ecx, ecx
	mov	DWORD PTR _h$1$[ebp], ecx
	cmp	DWORD PTR [edi+96], ecx
	jle	SHORT $LN358@GetFrame
	xor	esi, esi
$LL16@GetFrame:

; 242  :           for (int w = nWidthB; w < nWidth; w++)

	mov	edx, DWORD PTR [edi+456]
	cmp	edx, eax
	jge	SHORT $LN14@GetFrame
	lea	eax, DWORD PTR [ebx+esi]
	mov	DWORD PTR tv2341[ebp], eax
	npad	12
$LL19@GetFrame:

; 243  :             *(pDst[0] + h*nDstPitches[0] + w) = *(pDst[0] + h*nDstPitches[0] + nWidthB - 1);

	mov	eax, DWORD PTR [edi+456]
	lea	ecx, DWORD PTR [ebx+esi]
	mov	al, BYTE PTR [ecx+eax-1]
	mov	ecx, DWORD PTR tv2341[ebp]
	mov	BYTE PTR [ecx+edx], al
	inc	edx
	mov	eax, DWORD PTR [edi+92]
	cmp	edx, eax
	jl	SHORT $LL19@GetFrame
	mov	ecx, DWORD PTR _h$1$[ebp]
$LN14@GetFrame:

; 241  :         for (int h = 0; h < nHeight; h++)

	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
	inc	ecx
	add	esi, edx
	mov	DWORD PTR _h$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+96]
	jl	SHORT $LL16@GetFrame
	jmp	SHORT $LN15@GetFrame
$LN358@GetFrame:
	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
$LN15@GetFrame:

; 244  :       if (nHeight > nHeightB)

	mov	eax, DWORD PTR [edi+96]
	mov	esi, DWORD PTR [edi+460]
	cmp	eax, esi
	jle	SHORT $LN46@GetFrame

; 245  :         env->BitBlt(pDst[0] + nHeightB*nDstPitches[0], nDstPitches[0], pDst[0] + (nHeightB - 1)*nDstPitches[0], nDstPitches[0], nWidth, nHeight - nHeightB);

	mov	ecx, DWORD PTR _env$[ebp]
	sub	eax, esi
	push	eax
	push	DWORD PTR [edi+92]
	lea	eax, DWORD PTR [esi-1]
	imul	esi, edx
	mov	ecx, DWORD PTR [ecx]
	imul	eax, edx
	push	edx
	add	eax, ebx
	add	esi, ebx
	push	eax
	push	edx
	push	esi
	push	DWORD PTR _env$[ebp]
$LN367@GetFrame:
	call	DWORD PTR [ecx+64]
$LN46@GetFrame:

; 246  :     }
; 247  : 
; 248  :     // chroma
; 249  :     upsizerUV->SimpleResizeDo_uint8(pDst[1], nWidthBUV, nHeightBUV, nDstPitches[1], smallMask, nBlkX, nBlkX, dummyplane);

	mov	eax, DWORD PTR [edi+64]
	mov	esi, DWORD PTR _pDst$2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edi+452]
	push	eax
	push	eax
	push	DWORD PTR [edi+436]
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR [edi+468]
	push	DWORD PTR [edi+464]
	push	esi
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 250  : 
; 251  :     if (kind == 5)

	cmp	DWORD PTR [edi+424], 5

; 252  :       upsizerUV->SimpleResizeDo_uint8(pDst[2], nWidthBUV, nHeightBUV, nDstPitches[2], smallMaskV, nBlkX, nBlkX, dummyplane);

	mov	eax, DWORD PTR [edi+64]
	push	ecx
	mov	ecx, DWORD PTR [edi+452]
	push	eax
	push	eax
	jne	SHORT $LN47@GetFrame
	push	DWORD PTR [edi+440]

; 253  :     else

	jmp	SHORT $LN368@GetFrame
$LN47@GetFrame:

; 254  :       upsizerUV->SimpleResizeDo_uint8(pDst[2], nWidthBUV, nHeightBUV, nDstPitches[2], smallMask, nBlkX, nBlkX, dummyplane);

	push	DWORD PTR [edi+436]
$LN368@GetFrame:
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR [edi+468]
	push	DWORD PTR [edi+464]
	push	DWORD PTR _pDst$3$[ebp]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 255  : 
; 256  :     if (nWidthUV > nWidthBUV)

	mov	eax, DWORD PTR [edi+472]
	cmp	eax, DWORD PTR [edi+464]
	jle	$LN21@GetFrame

; 257  :       for (int h = 0; h < nHeightUV; h++)

	xor	ecx, ecx
	mov	DWORD PTR _h$1$[ebp], ecx
	cmp	DWORD PTR [edi+476], ecx
	jle	SHORT $LN21@GetFrame
	xor	esi, esi
	xor	ebx, ebx
	npad	9
$LL22@GetFrame:

; 258  :         for (int w = nWidthBUV; w < nWidthUV; w++)

	mov	edx, DWORD PTR [edi+464]
	cmp	edx, eax
	jge	SHORT $LN20@GetFrame
	mov	eax, DWORD PTR _pDst$3$[ebp]
	add	eax, esi
	mov	DWORD PTR tv2337[ebp], eax
$LL356@GetFrame:

; 259  :         {
; 260  :           *(pDst[1] + h*nDstPitches[1] + w) = *(pDst[1] + h*nDstPitches[1] + nWidthBUV - 1);

	mov	eax, DWORD PTR [edi+464]
	mov	ecx, DWORD PTR _pDst$2$[ebp]

; 261  :           *(pDst[2] + h*nDstPitches[2] + w) = *(pDst[2] + h*nDstPitches[2] + nWidthBUV - 1);

	mov	edi, DWORD PTR _this$[ebp]
	add	ecx, ebx
	mov	al, BYTE PTR [ecx+eax-1]
	mov	ecx, DWORD PTR _pDst$2$[ebp]
	add	ecx, ebx
	mov	BYTE PTR [ecx+edx], al
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	mov	eax, DWORD PTR [edi+464]
	add	ecx, esi
	mov	al, BYTE PTR [ecx+eax-1]
	mov	ecx, DWORD PTR tv2337[ebp]
	mov	BYTE PTR [ecx+edx], al
	inc	edx
	mov	eax, DWORD PTR [edi+472]
	cmp	edx, eax
	jl	SHORT $LL356@GetFrame
	mov	ecx, DWORD PTR _h$1$[ebp]
$LN20@GetFrame:

; 257  :       for (int h = 0; h < nHeightUV; h++)

	add	ebx, DWORD PTR _nDstPitches$2$[ebp]
	inc	ecx
	add	esi, DWORD PTR _nDstPitches$3$[ebp]
	mov	DWORD PTR _h$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+476]
	jl	SHORT $LL22@GetFrame
	mov	ebx, DWORD PTR _pDst$1$[ebp]
	mov	esi, DWORD PTR _pDst$2$[ebp]
$LN21@GetFrame:

; 262  :         }
; 263  :     if (nHeightUV > nHeightBUV)

	mov	eax, DWORD PTR [edi+476]
	mov	edx, DWORD PTR [edi+468]
	cmp	eax, edx
	jle	$LN277@GetFrame

; 264  :     {
; 265  :       env->BitBlt(pDst[1] + nHeightBUV*nDstPitches[1], nDstPitches[1], pDst[1] + (nHeightBUV - 1)*nDstPitches[1], nDstPitches[1], nWidthUV, nHeightUV - nHeightBUV);

	mov	ecx, DWORD PTR _env$[ebp]
	sub	eax, edx
	push	eax
	push	DWORD PTR [edi+472]
	lea	eax, DWORD PTR [edx-1]
	imul	eax, DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _nDstPitches$2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	eax, esi
	push	eax
	mov	eax, DWORD PTR _nDstPitches$2$[ebp]
	imul	edx, eax
	push	eax
	add	edx, esi
	mov	esi, DWORD PTR _env$[ebp]
	push	edx
	push	esi
	call	DWORD PTR [ecx+64]

; 266  :       env->BitBlt(pDst[2] + nHeightBUV*nDstPitches[2], nDstPitches[2], pDst[2] + (nHeightBUV - 1)*nDstPitches[2], nDstPitches[2], nWidthUV, nHeightUV - nHeightBUV);

	mov	ecx, DWORD PTR [edi+468]
	mov	eax, DWORD PTR [edi+476]
	mov	edx, DWORD PTR [esi]
	sub	eax, ecx
	mov	esi, DWORD PTR _nDstPitches$3$[ebp]
	push	eax
	push	DWORD PTR [edi+472]
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, esi
	push	esi
	add	eax, DWORD PTR _pDst$3$[ebp]
	push	eax
	mov	eax, esi
	imul	ecx, eax
	push	eax
	add	ecx, DWORD PTR _pDst$3$[ebp]
	push	ecx
	push	DWORD PTR _env$[ebp]
	call	DWORD PTR [edx+64]

; 267  :     }
; 268  : 
; 269  :   }
; 270  :   else {

	jmp	$LN277@GetFrame
$LN30@GetFrame:

; 271  :     if (kind == 5)

	cmp	DWORD PTR [edi+424], 5
	jne	SHORT $LN51@GetFrame

; 272  :       env->BitBlt(pDst[0], nDstPitches[0], pSrc[0], nSrcPitches[0], nWidth, nHeight);

	push	DWORD PTR [edi+96]
	mov	ecx, DWORD PTR _env$[ebp]
	push	DWORD PTR [edi+92]
	push	DWORD PTR _nSrcPitches$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _pSrc$1$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	ebx
	push	ecx
	call	DWORD PTR [eax+64]

; 273  :     else

	jmp	SHORT $LN267@GetFrame
$LN51@GetFrame:

; 274  :       MemZoneSet(pDst[0], nSceneChangeValue, nWidth, nHeight, 0, 0, nDstPitches[0]);

	mov	eax, DWORD PTR [edi+96]
	mov	ecx, DWORD PTR [edi+92]
	mov	dl, BYTE PTR [edi+432]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
	mov	DWORD PTR _ptr$1$[ebp], ebx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN267@GetFrame
	mov	esi, DWORD PTR _nDstPitches$1$[ebp]
	mov	edi, DWORD PTR _height$1$[ebp]
	movzx	eax, dl
	mov	DWORD PTR tv2355[ebp], eax
	npad	6
$LL268@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	eax
	push	ebx
	call	_memset
	mov	eax, DWORD PTR tv2355[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _width$1$[ebp]

; 108  : 		ptr += pitch;

	add	ebx, esi
	sub	edi, 1
	jne	SHORT $LL268@GetFrame
	mov	edi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR _pDst$1$[ebp]
	mov	esi, DWORD PTR _pDst$3$[ebp]
$LN267@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 276  :     MemZoneSet(pDst[1], nSceneChangeValue, nWidthUV, nHeightUV, 0, 0, nDstPitches[1]);

	mov	eax, DWORD PTR [edi+476]
	mov	ecx, DWORD PTR [edi+472]
	mov	dl, BYTE PTR [edi+432]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN272@GetFrame
	mov	ebx, DWORD PTR _pDst$2$[ebp]
	mov	esi, DWORD PTR _height$1$[ebp]
	mov	edi, DWORD PTR _nDstPitches$2$[ebp]
	movzx	eax, dl
	mov	DWORD PTR tv2354[ebp], eax
	npad	4
$LL273@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	eax
	push	ebx
	call	_memset
	mov	eax, DWORD PTR tv2354[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _width$1$[ebp]

; 108  : 		ptr += pitch;

	add	ebx, edi
	sub	esi, 1
	jne	SHORT $LL273@GetFrame
	mov	edi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR _pDst$1$[ebp]
	mov	esi, DWORD PTR _pDst$3$[ebp]
$LN272@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 277  :     MemZoneSet(pDst[2], nSceneChangeValue, nWidthUV, nHeightUV, 0, 0, nDstPitches[2]);

	mov	eax, DWORD PTR [edi+476]
	mov	ecx, DWORD PTR [edi+472]
	mov	dl, BYTE PTR [edi+432]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	DWORD PTR _width$1$[ebp], ecx
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN277@GetFrame
	mov	ebx, DWORD PTR _height$1$[ebp]
	mov	edi, DWORD PTR _nDstPitches$3$[ebp]
	movzx	eax, dl
	mov	DWORD PTR tv2353[ebp], eax
	npad	7
$LL278@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	ecx
	push	eax
	push	esi
	call	_memset
	mov	eax, DWORD PTR tv2353[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _width$1$[ebp]

; 108  : 		ptr += pitch;

	add	esi, edi
	sub	ebx, 1
	jne	SHORT $LL278@GetFrame
	mov	edi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR _pDst$1$[ebp]
$LN277@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 281  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN355@GetFrame
	cmp	BYTE PTR [edi+489], 0
	jne	$LN355@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage

; 976  :   VideoFrame* operator->() const { return p; }

	mov	ecx, DWORD PTR [eax]

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN284@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN284@GetFrame
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN285@GetFrame
$LN284@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN285@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN290@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN290@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN291@GetFrame
$LN290@GetFrame:
	xor	ecx, ecx
$LN291@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 285  :     YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	al, BYTE PTR [edi+488]
	mov	edx, DWORD PTR [edi+96]
	mov	edi, DWORD PTR [edi+92]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	test	al, al
	je	SHORT $LN293@GetFrame
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	bl, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	jne	SHORT $LN293@GetFrame

; 155  :     //U and V don't have to be aligned since we user movq to read from those
; 156  :     convert_yv16_to_yuy2_sse2(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	edx
	mov	edx, DWORD PTR _pDst$2$[ebp]
	push	edi
	push	ecx
	push	DWORD PTR _nDstPitches$2$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	call	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_sse2
	add	esp, 28					; 0000001cH

; 157  :   }
; 158  :   else

	jmp	SHORT $LN294@GetFrame
$LN293@GetFrame:

; 159  :   {
; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	edx
	mov	edx, DWORD PTR _pDst$2$[ebp]
	push	edi
	push	ecx
	push	DWORD PTR _nDstPitches$2$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	call	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_c
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN294@GetFrame
$LN355@GetFrame:
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN294@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	test	esi, esi
	je	SHORT $LN300@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN300@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvn$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN300@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	esi, esi
	je	SHORT $LN353@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN353@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	edx
$LN353@GetFrame:
; File c:\github\mvtools\sources\mvmask.cpp

; 288  :   return dst;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 289  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	mov	eax, DWORD PTR $T13[ebp]
	and	eax, 1
	je	$LN57@GetFrame
	and	DWORD PTR $T13[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN57@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _mvn$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVMask@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVMask::GetFrame
END
