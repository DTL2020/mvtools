; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvflowfps.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CD@INBMFCEN@MFlowFps?3?5Clip?5must?5be?5YUV?5or?5YU@ ; `string'
PUBLIC	??_C@_0CK@LFJKOOCJ@MFlowFps?3?5only?58?916?5bit?5clips?5ar@ ; `string'
PUBLIC	??_C@_0DE@LNOJLHHN@MFlowFps?3?5inconsistent?5source?5an@ ; `string'
PUBLIC	??_C@_0CJ@HICJCCD@MFlowFps?3?5inconsistent?5clips?5fra@ ; `string'
PUBLIC	??_C@_0CC@BMDBALEL@MFlowFps?5?3?5wrong?5super?5frame?5cli@ ; `string'
PUBLIC	??_C@_0EE@FHPELLEK@MFlowFps?3?5cannot?5use?5motion?5vect@ ; `string'
PUBLIC	??_C@_0CB@GFNLJBEK@MFlowFps?3?5wrong?5backward?5vectors@ ; `string'
PUBLIC	??_C@_0CA@HIOCHGAE@MFlowFps?3?5wrong?5forward?5vectors?$AA@ ; `string'
PUBLIC	??_R0?AVMVFlowFps@@@8				; MVFlowFps `RTTI Type Descriptor'
PUBLIC	??_R4MVFlowFps@@6B@				; MVFlowFps::`RTTI Complete Object Locator'
PUBLIC	??_7MVFlowFps@@6B@				; MVFlowFps::`vftable'
PUBLIC	??_R1A@?0A@EA@MVFlowFps@@8			; MVFlowFps::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3MVFlowFps@@8				; MVFlowFps::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MVFlowFps@@8				; MVFlowFps::`RTTI Base Class Array'
;	COMDAT ??_R2MVFlowFps@@8
rdata$r	SEGMENT
??_R2MVFlowFps@@8 DD FLAT:??_R1A@?0A@EA@MVFlowFps@@8	; MVFlowFps::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3MVFlowFps@@8
rdata$r	SEGMENT
??_R3MVFlowFps@@8 DD 00H				; MVFlowFps::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVFlowFps@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVFlowFps@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVFlowFps@@8 DD FLAT:??_R0?AVMVFlowFps@@@8 ; MVFlowFps::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVFlowFps@@8
rdata$r	ENDS
;	COMDAT ??_7MVFlowFps@@6B@
CONST	SEGMENT
??_7MVFlowFps@@6B@ DD FLAT:??_R4MVFlowFps@@6B@		; MVFlowFps::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVFlowFps@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVFlowFps@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4MVFlowFps@@6B@
rdata$r	SEGMENT
??_R4MVFlowFps@@6B@ DD 00H				; MVFlowFps::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVFlowFps@@@8
	DD	FLAT:??_R3MVFlowFps@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVFlowFps@@@8
data$r	SEGMENT
??_R0?AVMVFlowFps@@@8 DD FLAT:??_7type_info@@6B@	; MVFlowFps `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVFlowFps@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0CA@HIOCHGAE@MFlowFps?3?5wrong?5forward?5vectors?$AA@
CONST	SEGMENT
??_C@_0CA@HIOCHGAE@MFlowFps?3?5wrong?5forward?5vectors?$AA@ DB 'MFlowFps:'
	DB	' wrong forward vectors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GFNLJBEK@MFlowFps?3?5wrong?5backward?5vectors@
CONST	SEGMENT
??_C@_0CB@GFNLJBEK@MFlowFps?3?5wrong?5backward?5vectors@ DB 'MFlowFps: wr'
	DB	'ong backward vectors', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FHPELLEK@MFlowFps?3?5cannot?5use?5motion?5vect@
CONST	SEGMENT
??_C@_0EE@FHPELLEK@MFlowFps?3?5cannot?5use?5motion?5vect@ DB 'MFlowFps: c'
	DB	'annot use motion vectors with absolute frame references.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BMDBALEL@MFlowFps?5?3?5wrong?5super?5frame?5cli@
CONST	SEGMENT
??_C@_0CC@BMDBALEL@MFlowFps?5?3?5wrong?5super?5frame?5cli@ DB 'MFlowFps :'
	DB	' wrong super frame clip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HICJCCD@MFlowFps?3?5inconsistent?5clips?5fra@
CONST	SEGMENT
??_C@_0CJ@HICJCCD@MFlowFps?3?5inconsistent?5clips?5fra@ DB 'MFlowFps: inc'
	DB	'onsistent clips frame size!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LNOJLHHN@MFlowFps?3?5inconsistent?5source?5an@
CONST	SEGMENT
??_C@_0DE@LNOJLHHN@MFlowFps?3?5inconsistent?5source?5an@ DB 'MFlowFps: in'
	DB	'consistent source and vector frame size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LFJKOOCJ@MFlowFps?3?5only?58?916?5bit?5clips?5ar@
CONST	SEGMENT
??_C@_0CK@LFJKOOCJ@MFlowFps?3?5only?58?916?5bit?5clips?5ar@ DB 'MFlowFps:'
	DB	' only 8-16 bit clips are allowed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@INBMFCEN@MFlowFps?3?5Clip?5must?5be?5YUV?5or?5YU@
CONST	SEGMENT
??_C@_0CD@INBMFCEN@MFlowFps?3?5Clip?5must?5be?5YUV?5or?5YU@ DB 'MFlowFps:'
	DB	' Clip must be YUV or YUY2', 00H		; `string'
PUBLIC	?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVFlowFps::GetFrame
PUBLIC	??1MVFlowFps@@UAE@XZ				; MVFlowFps::~MVFlowFps
PUBLIC	??_GMVFlowFps@@UAEPAXI@Z			; MVFlowFps::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVFlowFps@@UAGHHH@Z		; MVFlowFps::SetCacheHints
PUBLIC	??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z ; MVFlowFps::MVFlowFps
EXTRN	??_EMVFlowFps@@UAEPAXI@Z:PROC			; MVFlowFps::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$9
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$12
	DD	09H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$14
	DD	0aH
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$15
	DD	0aH
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$19
	DD	09H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$20
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$21
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$22
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$24
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVFlowFps@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1MVFlowFps@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVFlowFps@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowFps@@UAE@XZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowFps@@UAE@XZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowFps@@UAE@XZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowFps@@UAE@XZ$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	025H
	DD	FLAT:__unwindtable$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9
	DD	0dH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10
	DD	0dH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$27
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$28
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$29
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$30
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$31
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$32
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11
	DD	016H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12
	DD	016H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$33
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$34
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$35
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$36
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$37
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$38
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$39
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$40
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$41
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$42
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$43
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$44
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$45
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
;	COMDAT ??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
_super$ = 12						; size = 4
__mvbw$ = 16						; size = 4
__mvfw$ = 20						; size = 4
__num$ = 24						; size = 4
__den$ = 28						; size = 4
__maskmode$ = 32					; size = 4
_cache_args$3 = 36					; size = 8
__ml$ = 36						; size = 8
tv2215 = 44						; size = 4
_nSuperPel$1$ = 44					; size = 4
__blend$ = 44						; size = 1
_nSCD1$ = 48						; size = 4
_nSCD2$ = 52						; size = 4
tv2221 = 56						; size = 4
_nHeightS$1$ = 56					; size = 4
$T4 = 56						; size = 4
$T5 = 56						; size = 4
$T6 = 56						; size = 4
$T7 = 56						; size = 4
$T8 = 56						; size = 4
__isse$ = 56						; size = 1
tv2106 = 60						; size = 4
_nSuperHPad$1$ = 60					; size = 4
__planar$ = 60						; size = 1
_env$ = 64						; size = 4
??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z PROC ; MVFlowFps::MVFlowFps, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowfps.cpp

; 32   :   GenericVideoFilter(_child),

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN62@MVFlowFps
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN62@MVFlowFps
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN62@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 32   :   GenericVideoFilter(_child),

	mov	ecx, ebx
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 33   :   MVFilter(_mvfw, "MFlowFps", env, 1, 0),

	mov	esi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	push	0
	push	1
	push	esi
	push	OFFSET ??_C@_08MJADCGCO@MFlowFps?$AA@
	push	ecx
	lea	ecx, DWORD PTR [ebx+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter

; 34   :   mvClipB(_mvbw, nSCD1, nSCD2, env, 1, 0),

	mov	edi, DWORD PTR _nSCD2$[ebp]
	lea	ecx, DWORD PTR __mvbw$[ebp]
	push	0
	push	1
	push	esi
	mov	esi, DWORD PTR _nSCD1$[ebp]
	push	edi
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [ebx+152]

; 36   : {

	mov	DWORD PTR [ebx], OFFSET ??_7MVFlowFps@@6B@
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	push	0
	push	1
	push	DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	edi
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [ebx+392]
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR [ebx+668]
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN66@MVFlowFps
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN66@MVFlowFps
	mov	eax, DWORD PTR [eax+228]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN66@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 36   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	test	eax, eax
	je	SHORT $LN163@MVFlowFps
	cmp	DWORD PTR [eax], 24			; 00000018H
	jbe	SHORT $LN162@MVFlowFps
	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 37   :   if (!vi.IsYUV() && !vi.IsYUVA())

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvflowfps.cpp

; 37   :   if (!vi.IsYUV() && !vi.IsYUVA())

	test	al, al
	jne	SHORT $LN168@MVFlowFps
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN162@MVFlowFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 716  :   bool IsYUVA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsYUVA, false) )

	test	eax, eax
	je	SHORT $LN163@MVFlowFps
	cmp	DWORD PTR [eax], 564			; 00000234H
	jbe	SHORT $LN163@MVFlowFps
	mov	eax, DWORD PTR [eax+564]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 37   :   if (!vi.IsYUV() && !vi.IsYUVA())

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 716  :   bool IsYUVA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsYUVA, false) )

	call	eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 37   :   if (!vi.IsYUV() && !vi.IsYUVA())

	test	al, al
	jne	SHORT $LN168@MVFlowFps
$LN163@MVFlowFps:

; 38   :     env->ThrowError("MFlowFps: Clip must be YUV or YUY2");

	mov	esi, DWORD PTR _env$[ebp]
	push	OFFSET ??_C@_0CD@INBMFCEN@MFlowFps?3?5Clip?5must?5be?5YUV?5or?5YU@
	push	esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+20]
	add	esp, 8
	jmp	SHORT $LN2@MVFlowFps
$LN168@MVFlowFps:
	mov	esi, DWORD PTR _env$[ebp]
$LN2@MVFlowFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN166@MVFlowFps
	cmp	DWORD PTR [eax], 536			; 00000218H
	jbe	SHORT $LN166@MVFlowFps
	mov	eax, DWORD PTR [eax+536]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 39   :   if (vi.BitsPerComponent() > 16)

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	call	eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 39   :   if (vi.BitsPerComponent() > 16)

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN166@MVFlowFps

; 40   :     env->ThrowError("MFlowFps: only 8-16 bit clips are allowed");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CK@LFJKOOCJ@MFlowFps?3?5only?58?916?5bit?5clips?5ar@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN166@MVFlowFps:

; 41   : 
; 42   :   numeratorOld = vi.fps_numerator;
; 43   :   denominatorOld = vi.fps_denominator;
; 44   : 
; 45   :   if (_num != 0 && _den != 0)

	mov	eax, DWORD PTR __num$[ebp]
	mov	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ebx+28]
	mov	DWORD PTR [ebx+640], ecx
	mov	DWORD PTR [ebx+644], esi
	test	eax, eax
	je	SHORT $LN4@MVFlowFps
	mov	edx, DWORD PTR __den$[ebp]
	test	edx, edx
	je	SHORT $LN4@MVFlowFps

; 46   :   {
; 47   :     numerator = _num;

	mov	DWORD PTR [ebx+632], eax

; 48   :     denominator = _den;

	mov	DWORD PTR [ebx+636], edx
	jmp	SHORT $LN7@MVFlowFps
$LN4@MVFlowFps:

; 49   :   }
; 50   :   else if (numeratorOld < (1 << 30))

	cmp	ecx, 1073741824				; 40000000H
	jae	SHORT $LN6@MVFlowFps

; 51   :   {
; 52   :     numerator = (numeratorOld << 1); // double fps by default

	lea	eax, DWORD PTR [ecx+ecx]

; 53   :     denominator = denominatorOld;

	mov	DWORD PTR [ebx+636], esi
	mov	DWORD PTR [ebx+632], eax

; 54   :   }
; 55   :   else // very big numerator

	jmp	SHORT $LN7@MVFlowFps
$LN6@MVFlowFps:

; 56   :   {
; 57   :     numerator = numeratorOld;
; 58   :     denominator = (denominatorOld >> 1);// double fps by default

	mov	eax, esi
	mov	DWORD PTR [ebx+632], ecx
	shr	eax, 1
	mov	DWORD PTR [ebx+636], eax
$LN7@MVFlowFps:

; 59   :   }
; 60   : 
; 61   :   //  safe for big numbers since v2.1
; 62   :   fa = __int64(denominator)*__int64(numeratorOld);

	mov	eax, DWORD PTR [ebx+636]
	mul	ecx
	mov	DWORD PTR [ebx+680], eax

; 63   :   fb = __int64(numerator)*__int64(denominatorOld);

	mov	eax, DWORD PTR [ebx+632]
	mov	DWORD PTR [ebx+684], edx
	mul	esi
	mov	DWORD PTR [ebx+688], eax

; 64   :   __int64 fgcd = gcd(fa, fb); // general common divisor

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ebx+692], edx
	mov	ebx, DWORD PTR [ebx+684]
	push	DWORD PTR [eax+692]
	push	DWORD PTR [eax+688]
	push	ebx
	push	DWORD PTR [eax+680]
	call	?gcd@@YA_J_J0@Z				; gcd
	add	esp, 16					; 00000010H
	mov	esi, edx
	mov	edi, eax

; 65   :   fa /= fgcd;

	push	esi
	push	edi
	push	ebx
	mov	ebx, DWORD PTR _this$[ebp]
	push	DWORD PTR [ebx+680]
	call	__alldiv

; 66   :   fb /= fgcd;

	push	esi
	push	edi
	push	DWORD PTR [ebx+692]
	mov	DWORD PTR [ebx+680], eax
	push	DWORD PTR [ebx+688]
	mov	DWORD PTR [ebx+684], edx
	call	__alldiv
	mov	DWORD PTR [ebx+688], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 668  :   void SetFPS(unsigned numerator, unsigned denominator) AVS_BakedCode(AVS_LinkCall(SetFPS)(numerator, denominator))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowfps.cpp

; 66   :   fb /= fgcd;

	mov	DWORD PTR [ebx+692], edx
; File c:\github\mvtools\sources\include\avisynth.h

; 668  :   void SetFPS(unsigned numerator, unsigned denominator) AVS_BakedCode(AVS_LinkCall(SetFPS)(numerator, denominator))

	test	eax, eax
	je	SHORT $LN82@MVFlowFps
	cmp	DWORD PTR [eax], 160			; 000000a0H
	jbe	SHORT $LN82@MVFlowFps
	push	DWORD PTR [ebx+636]
	mov	eax, DWORD PTR [eax+160]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 68   :   vi.SetFPS(numerator, denominator);

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 668  :   void SetFPS(unsigned numerator, unsigned denominator) AVS_BakedCode(AVS_LinkCall(SetFPS)(numerator, denominator))

	push	DWORD PTR [ebx+632]
	call	eax
$LN82@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 70   :   vi.num_frames = (int)(1 + __int64(vi.num_frames - 1) * fb / fa);

	push	DWORD PTR [ebx+692]
	mov	eax, DWORD PTR [ebx+32]
	push	DWORD PTR [ebx+688]
	dec	eax
	cdq
	push	edx
	push	eax
	call	__allmul
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+680]
	push	edx
	push	eax
	call	__alldiv

; 71   : 
; 72   :   maskmode = _maskmode; // speed mode
; 73   :   ml = _ml;
; 74   : //   nIdx = _nIdx;
; 75   :   isse = _isse;
; 76   :   planar = _planar;
; 77   :   blend = _blend;
; 78   : 
; 79   :   CheckSimilarity(mvClipB, "mvbw", env);

	mov	esi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR [ebx+64]
	movsd	xmm0, QWORD PTR __ml$[ebp]
	inc	eax
	mov	DWORD PTR [ebx+32], eax
	mov	eax, DWORD PTR __maskmode$[ebp]
	mov	DWORD PTR [ebx+648], eax
	mov	al, BYTE PTR __isse$[ebp]
	mov	BYTE PTR [ebx+664], al
	mov	al, BYTE PTR __planar$[ebp]
	mov	BYTE PTR [ebx+665], al
	mov	al, BYTE PTR __blend$[ebp]
	push	esi
	mov	BYTE PTR [ebx+666], al
	lea	eax, DWORD PTR [ebx+152]
	push	OFFSET ??_C@_04DNAGLECB@mvbw?$AA@
	push	eax
	movsd	QWORD PTR [ebx+656], xmm0
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity

; 80   :   CheckSimilarity(mvClipF, "mvfw", env);

	push	esi
	push	OFFSET ??_C@_04DKAPBMPN@mvfw?$AA@
	lea	eax, DWORD PTR [ebx+392]
	push	eax
	lea	ecx, DWORD PTR [ebx+64]
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity

; 81   : 
; 82   :   if (nWidth != vi.width || nHeight != vi.height)

	mov	eax, DWORD PTR [ebx+92]
	cmp	eax, DWORD PTR [ebx+16]
	jne	SHORT $LN9@MVFlowFps
	mov	eax, DWORD PTR [ebx+96]
	cmp	eax, DWORD PTR [ebx+20]
	je	SHORT $LN8@MVFlowFps
$LN9@MVFlowFps:

; 83   :     env->ThrowError("MFlowFps: inconsistent source and vector frame size");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0DE@LNOJLHHN@MFlowFps?3?5inconsistent?5source?5an@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN8@MVFlowFps:
	mov	eax, DWORD PTR _super$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN32@MVFlowFps
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edi, DWORD PTR [eax+16]
	jmp	SHORT $LN31@MVFlowFps
$LN32@MVFlowFps:
	push	eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 86   :   if (!((nWidth + nHPadding * 2) == super->GetVideoInfo().width && (nHeight + nVPadding * 2) <= super->GetVideoInfo().height))

	call	ecx
	mov	edi, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN31@MVFlowFps:
	mov	edx, DWORD PTR [ebx+84]
	mov	ecx, DWORD PTR [ebx+92]
	lea	ecx, DWORD PTR [ecx+edx*2]
	cmp	ecx, DWORD PTR [edi]
	jne	SHORT $LN11@MVFlowFps
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN34@MVFlowFps
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edi, DWORD PTR [eax+16]
	jmp	SHORT $LN33@MVFlowFps
$LN34@MVFlowFps:
	push	eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 86   :   if (!((nWidth + nHPadding * 2) == super->GetVideoInfo().width && (nHeight + nVPadding * 2) <= super->GetVideoInfo().height))

	call	ecx
	mov	edi, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN33@MVFlowFps:
	mov	edx, DWORD PTR [ebx+88]
	mov	ecx, DWORD PTR [ebx+96]
	lea	ecx, DWORD PTR [ecx+edx*2]
	cmp	ecx, DWORD PTR [edi+4]
	jle	SHORT $LN10@MVFlowFps
$LN11@MVFlowFps:

; 87   :     env->ThrowError("MFlowFps: inconsistent clips frame size!");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CJ@HICJCCD@MFlowFps?3?5inconsistent?5clips?5fra@
	push	esi
	call	DWORD PTR [eax+20]
	mov	eax, DWORD PTR _super$[ebp]
	add	esp, 8
$LN10@MVFlowFps:
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN36@MVFlowFps
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN35@MVFlowFps
$LN36@MVFlowFps:
	push	eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 93   :   memcpy(&params, &super->GetVideoInfo().num_audio_samples, 8);

	call	ecx
	mov	edx, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN35@MVFlowFps:
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [edx+36]

; 94   :   int nHeightS = params.nHeight;

	movzx	edi, cx

; 95   :   int nSuperHPad = params.nHPad;

	shr	ecx, 16					; 00000010H
	movzx	ecx, cl
	mov	DWORD PTR _nSuperHPad$1$[ebp], ecx

; 96   :   int nSuperVPad = params.nVPad;
; 97   :   int nSuperPel = params.nPel;

	movzx	ecx, dl
	mov	DWORD PTR _nSuperPel$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nHeightS$1$[ebp], edi
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN38@MVFlowFps
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edi, DWORD PTR [eax+16]
	jmp	SHORT $LN37@MVFlowFps
$LN38@MVFlowFps:
	push	eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 100  :   int nSuperWidth = super->GetVideoInfo().width; // really super

	call	ecx
	mov	edi, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN37@MVFlowFps:
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	je	SHORT $LN39@MVFlowFps

; 101  :   int nSuperHeight = super->GetVideoInfo().height;

	push	eax
	call	ecx
$LN39@MVFlowFps:

; 102  : //		pRefBGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse, yRatioUV);
; 103  : //		pRefFGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse, yRatioUV);
; 104  : 
; 105  :   if (nHeight != nHeightS
; 106  :     || nWidth != nSuperWidth - nSuperHPad * 2
; 107  :     || nPel != nSuperPel)

	mov	eax, DWORD PTR _nHeightS$1$[ebp]
	cmp	DWORD PTR [ebx+96], eax
	jne	SHORT $LN13@MVFlowFps
	mov	eax, DWORD PTR _nSuperHPad$1$[ebp]
	add	eax, eax
	sub	edi, eax
	cmp	DWORD PTR [ebx+92], edi
	jne	SHORT $LN13@MVFlowFps
	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	cmp	DWORD PTR [ebx+104], eax
	je	SHORT $LN12@MVFlowFps
$LN13@MVFlowFps:

; 108  :   {
; 109  :     env->ThrowError("MFlowFps : wrong super frame clip");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CC@BMDBALEL@MFlowFps?5?3?5wrong?5super?5frame?5cli@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN12@MVFlowFps:

; 110  :   }
; 111  : //	}
; 112  : 
; 113  :   if (nPel == 1)

	cmp	DWORD PTR [ebx+104], 1
	jne	SHORT $LN14@MVFlowFps
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	$LN15@MVFlowFps
	cmp	DWORD PTR [eax], 244			; 000000f4H
	jbe	$LN15@MVFlowFps
	mov	eax, DWORD PTR [eax+244]
	lea	ecx, DWORD PTR _super$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [ebx+668]
	call	eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 117  :   else

	jmp	$LN15@MVFlowFps
$LN14@MVFlowFps:

; 119  :     finest = new MVFinest(super, isse, env);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	mov	DWORD PTR $T8[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	movzx	ecx, BYTE PTR [ebx+664]
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowfps.cpp

; 119  :     finest = new MVFinest(super, isse, env);

	push	ecx
	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN110@MVFlowFps
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN110@MVFlowFps
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _super$[ebp]
	push	edx
	call	eax
$LN110@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 119  :     finest = new MVFinest(super, isse, env);

	mov	ecx, edi
	call	??0MVFinest@@QAE@VPClip@@_NPAVIScriptEnvironment@@@Z ; MVFinest::MVFinest
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 939  :   void operator=(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	lea	edi, DWORD PTR [ebx+668]
	test	eax, eax
	je	SHORT $LN118@MVFlowFps
	cmp	DWORD PTR [eax], 240			; 000000f0H
	jbe	SHORT $LN114@MVFlowFps
	mov	eax, DWORD PTR [eax+240]
	push	ecx
	mov	ecx, edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN114@MVFlowFps:

; 1000 :   AVSValue(const PClip& c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR2)(c) )

	test	eax, eax
	je	SHORT $LN118@MVFlowFps
	cmp	DWORD PTR [eax], 284			; 0000011cH
	jbe	SHORT $LN118@MVFlowFps
	mov	eax, DWORD PTR [eax+284]
	lea	ecx, DWORD PTR _cache_args$3[ebp]
	push	edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN118@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 123  :     finest = env->Invoke("InternalCache", AVSValue(cache_args, 1)).AsClip(); // add cache for speed

	lea	ecx, DWORD PTR $T7[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	ecx
	push	0
	sub	esp, 8
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 1007 :   AVSValue(const AVSValue* a, int size) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR8)(a, size) )

	test	eax, eax
	je	SHORT $LN122@MVFlowFps
	cmp	DWORD PTR [eax], 308			; 00000134H
	jbe	SHORT $LN122@MVFlowFps
	mov	eax, DWORD PTR [eax+308]
	lea	edx, DWORD PTR _cache_args$3[ebp]
	push	1
	push	edx
	call	eax
$LN122@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 123  :     finest = env->Invoke("InternalCache", AVSValue(cache_args, 1)).AsClip(); // add cache for speed

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T2[ebp]
	push	OFFSET ??_C@_0O@FPHICKBJ@InternalCache?$AA@
	push	ecx
	push	esi
	call	DWORD PTR [eax+32]
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN126@MVFlowFps
	cmp	DWORD PTR [eax], 244			; 000000f4H
	jbe	SHORT $LN126@MVFlowFps
	mov	eax, DWORD PTR [eax+244]
	push	ecx
	mov	ecx, edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN126@MVFlowFps:

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	eax, eax
	je	SHORT $LN130@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN130@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR $T7[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN130@MVFlowFps:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	eax, eax
	je	SHORT $LN135@MVFlowFps
	cmp	DWORD PTR [eax], 316			; 0000013cH
	jbe	SHORT $LN135@MVFlowFps
	mov	eax, DWORD PTR [eax+316]
	lea	ecx, DWORD PTR $T2[ebp]
	call	eax
$LN135@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 124  :   }

	push	OFFSET ??1AVSValue@@QAE@XZ		; AVSValue::~AVSValue
	push	1
	push	8
	lea	eax, DWORD PTR _cache_args$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
$LN15@MVFlowFps:

; 125  : 
; 126  :   // may be padded for full frame cover
; 127  :   nBlkXP = (nBlkX*(nBlkSizeX - nOverlapX) + nOverlapX < nWidth) ? nBlkX + 1 : nBlkX;

	mov	esi, DWORD PTR [ebx+76]
	sub	esi, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+64]
	mov	eax, ecx
	imul	eax, esi
	add	eax, DWORD PTR [ebx+108]
	cmp	eax, DWORD PTR [ebx+92]
	jge	SHORT $LN21@MVFlowFps
	inc	ecx
$LN21@MVFlowFps:

; 128  :   nBlkYP = (nBlkY*(nBlkSizeY - nOverlapY) + nOverlapY < nHeight) ? nBlkY + 1 : nBlkY;

	mov	eax, DWORD PTR [ebx+112]
	mov	edi, DWORD PTR [ebx+80]
	mov	edx, DWORD PTR [ebx+68]
	sub	edi, eax
	mov	DWORD PTR tv2221[ebp], eax
	mov	eax, edx
	imul	eax, edi
	mov	DWORD PTR [ebx+872], ecx
	add	eax, DWORD PTR [ebx+112]
	cmp	eax, DWORD PTR [ebx+96]
	jge	SHORT $LN23@MVFlowFps
	inc	edx
$LN23@MVFlowFps:

; 129  :   nWidthP = nBlkXP*(nBlkSizeX - nOverlapX) + nOverlapX;
; 130  :   nHeightP = nBlkYP*(nBlkSizeY - nOverlapY) + nOverlapY;

	mov	eax, DWORD PTR tv2221[ebp]
	mov	DWORD PTR [ebx+876], edx
	mov	ebx, DWORD PTR [ebx+108]
	imul	edx, edi
	imul	ecx, esi

; 147  :   VXFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	push	128					; 00000080H
	add	eax, edx
	mov	DWORD PTR tv2106[ebp], edx
	add	ebx, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+120]
	mov	DWORD PTR [ecx+884], eax
	mov	eax, ebx
	cdq
	idiv	esi
	mov	DWORD PTR tv2215[ebp], esi
	mov	esi, DWORD PTR tv2221[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR tv2106[ebp]
	mov	DWORD PTR [ecx+880], ebx
	mov	DWORD PTR [ecx+888], edi
	mov	ecx, DWORD PTR [ecx+124]
	lea	eax, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR _this$[ebp]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+892], eax
	mov	eax, DWORD PTR [edx+96]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+860], eax
	mov	eax, DWORD PTR [edx+92]
	cdq
	idiv	DWORD PTR tv2215[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+856], eax
	mov	eax, DWORD PTR [edx+84]
	cdq
	idiv	DWORD PTR tv2215[ebp]
	mov	DWORD PTR [esi+896], eax
	mov	eax, DWORD PTR [esi+88]
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	ecx, DWORD PTR [ebx+15]
	mov	ebx, esi
; File c:\github\mvtools\sources\mvflowfps.cpp

; 138  :   nVPaddingUV = nVPadding / yRatioUV;

	mov	DWORD PTR [esi+900], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	and	ecx, -16				; fffffff0H
; File c:\github\mvtools\sources\mvflowfps.cpp

; 147  :   VXFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	esi, DWORD PTR __imp___aligned_malloc
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [edi+15]
	and	eax, -16				; fffffff0H
; File c:\github\mvtools\sources\mvflowfps.cpp

; 141  :   VPitchUV = AlignNumber(nWidthPUV, 16);

	mov	DWORD PTR [ebx+868], eax

; 147  :   VXFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR tv2106[ebp]
	add	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebx+864], ecx
	imul	ecx, eax
	lea	eax, DWORD PTR [ecx*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+696], eax

; 148  :   VXFullUVB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+700], eax

; 149  :   VYFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+704], eax

; 150  :   VYFullUVB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+708], eax

; 151  : 
; 152  :   VXFullYF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+712], eax

; 153  :   VXFullUVF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+716], eax

; 154  :   VYFullYF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+720], eax

; 155  :   VYFullUVF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+724], eax
	add	esp, 64					; 00000040H

; 156  : 
; 157  :   VXSmallYB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+760], eax

; 158  :   VYSmallYB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+768], eax

; 159  :   VXSmallUVB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+764], eax

; 160  :   VYSmallUVB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+772], eax

; 161  : 
; 162  :   VXSmallYF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+776], eax

; 163  :   VYSmallYF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+784], eax

; 164  :   VXSmallUVF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+780], eax

; 165  :   VYSmallUVF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	push	128					; 00000080H
	imul	eax, DWORD PTR [ebx+872]
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+788], eax
	add	esp, 64					; 00000040H

; 166  : 
; 167  :   VXFullYBB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+728], eax

; 168  :   VXFullUVBB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+732], eax

; 169  :   VYFullYBB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+736], eax

; 170  :   VYFullUVBB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+740], eax

; 171  : 
; 172  :   VXFullYFF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+744], eax

; 173  :   VXFullUVFF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+748], eax

; 174  :   VYFullYFF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+752], eax

; 175  :   VYFullUVFF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+756], eax
	add	esp, 64					; 00000040H

; 176  : 
; 177  :   VXSmallYBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+792], eax

; 178  :   VYSmallYBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+800], eax

; 179  :   VXSmallUVBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+796], eax

; 180  :   VYSmallUVBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+804], eax

; 181  : 
; 182  :   VXSmallYFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+808], eax

; 183  :   VYSmallYFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+816], eax

; 184  :   VXSmallUVFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+812], eax

; 185  :   VYSmallUVFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+820], eax
	add	esp, 64					; 00000040H

; 186  : 
; 187  :   // PF remark: masks are 8 bits
; 188  :   MaskSmallB = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+824], eax

; 189  :   MaskFullYB = (unsigned char*)_aligned_malloc(nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+828], eax

; 190  :   MaskFullUVB = (unsigned char*)_aligned_malloc(nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+832], eax

; 191  : 
; 192  :   MaskSmallF = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+836], eax

; 193  :   MaskFullYF = (unsigned char*)_aligned_malloc(nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+884]
	imul	eax, DWORD PTR [ebx+864]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+840], eax

; 194  :   MaskFullUVF = (unsigned char*)_aligned_malloc(nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+892]
	imul	eax, DWORD PTR [ebx+868]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+844], eax

; 195  : 
; 196  :   SADMaskSmallB = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+848], eax

; 197  :   SADMaskSmallF = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+876]
	imul	eax, DWORD PTR [ebx+872]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi

; 198  : 
; 199  : 
; 200  :   int CPUF_Resize = env->GetCPUFlags();

	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 64					; 00000040H
	mov	DWORD PTR [ebx+852], eax
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+4]
	mov	esi, eax

; 201  :   if (!isse) CPUF_Resize = (CPUF_Resize & !CPUF_INTEGER_SSE) & !CPUF_SSE2;

	xor	eax, eax
	cmp	BYTE PTR [ebx+664], al

; 202  : 
; 203  :   upsizer = new SimpleResize(nWidthP, nHeightP, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	cmove	esi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+876]
	push	DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize

; 204  :   upsizerUV = new SimpleResize(nWidthPUV, nHeightPUV, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	mov	DWORD PTR [ebx+904], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+876]
	push	DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize
	mov	DWORD PTR [ebx+908], eax

; 205  : 
; 206  :   nleftLast = -1000;
; 207  :   nrightLast = -1000;
; 208  : 
; 209  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [ebx+672], -1000		; fffffc18H
	mov	DWORD PTR [ebx+676], -1000		; fffffc18H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN17@MVFlowFps
	cmp	BYTE PTR [ebx+665], 0
	jne	SHORT $LN17@MVFlowFps

; 210  :   {
; 211  :     DstPlanes = new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes
	mov	DWORD PTR [ebx+912], eax
$LN17@MVFlowFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN144@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN144@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN144@MVFlowFps:
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	eax, eax
	je	SHORT $LN149@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN149@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN149@MVFlowFps:
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	eax, eax
	je	SHORT $LN154@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN154@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mvbw$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN154@MVFlowFps:
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN164@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN164@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	call	eax
$LN164@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 214  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	60					; 0000003cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR __mvfw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR __mvbw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 668				; 0000029cH
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$9:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$12:
	push	OFFSET ??1AVSValue@@QAE@XZ		; AVSValue::~AVSValue
	push	1
	push	8
	lea	eax, DWORD PTR _cache_args$3[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$14:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$15:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$19:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$20:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$21:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$22:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z ENDP ; MVFlowFps::MVFlowFps
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?gcd@@YA_J_J0@Z
_TEXT	SEGMENT
_shift$1$ = -8						; size = 4
_u$1$ = -4						; size = 4
_u$ = 8							; size = 8
_v$ = 16						; size = 8
?gcd@@YA_J_J0@Z PROC					; gcd, COMDAT

; 41   :  {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 42   :      int shift;
; 43   : 
; 44   :      /* GCD(0,x) := x */
; 45   :      if (u == 0 || v == 0)

	mov	edx, DWORD PTR _u$[ebp]
	sub	esp, 12					; 0000000cH
	mov	eax, edx
	push	ebx
	mov	ebx, DWORD PTR _u$[ebp+4]
	or	eax, ebx
	mov	eax, DWORD PTR _v$[ebp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _v$[ebp]
	je	$LN13@gcd
	mov	ecx, edi
	or	ecx, eax
	je	$LN13@gcd

; 47   : 
; 48   :      /* Let shift := lg K, where K is the greatest power of 2
; 49   :         dividing both u and v. */
; 50   :      for (shift = 0; ((u | v) & 1) == 0; ++shift) {

	mov	ecx, edx
	xor	esi, esi
	or	ecx, edi
	mov	DWORD PTR _shift$1$[esp+24], esi
	and	ecx, 1
	or	ecx, esi
	jne	SHORT $LN18@gcd
	npad	3
$LL4@gcd:

; 51   :          u >>= 1;

	shrd	edx, ebx, 1

; 52   :          v >>= 1;

	shrd	edi, eax, 1
	mov	ecx, edx
	sar	ebx, 1
	or	ecx, edi
	sar	eax, 1
	and	ecx, 1
	inc	esi
	or	ecx, 0
	je	SHORT $LL4@gcd
	mov	DWORD PTR _shift$1$[esp+24], esi
$LN18@gcd:

; 53   :      }
; 54   : 
; 55   :      while ((u & 1) == 0)

	mov	ecx, edx
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LL9@gcd
$LL5@gcd:

; 56   :        u >>= 1;

	shrd	edx, ebx, 1
	mov	ecx, edx
	sar	ebx, 1
	and	ecx, 1
	or	ecx, 0
	je	SHORT $LL5@gcd
$LL9@gcd:

; 57   : 
; 58   :      /* From here on, u is always odd. */
; 59   :      do {
; 60   :          while ((v & 1) == 0)  /* Loop X */

	mov	ecx, edi
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN11@gcd
$LL10@gcd:

; 61   :            v >>= 1;

	shrd	edi, eax, 1
	mov	ecx, edi
	sar	eax, 1
	and	ecx, 1
	or	ecx, 0
	je	SHORT $LL10@gcd
$LN11@gcd:

; 62   : 
; 63   :          /* Now u and v are both odd, so diff(u, v) is even.
; 64   :             Let u = min(u, v), v = diff(u, v)/2. */
; 65   :          if (u < v) {

	cmp	ebx, eax
	jg	SHORT $LN14@gcd
	jl	SHORT $LN40@gcd
	cmp	edx, edi
	jae	SHORT $LN14@gcd
$LN40@gcd:

; 66   :              v -= u;

	sub	edi, edx
	sbb	eax, ebx

; 67   :          } else {

	jmp	SHORT $LN15@gcd
$LN14@gcd:

; 68   :              __int64 diff = u - v;

	sub	edx, edi

; 69   :              u = v;

	mov	DWORD PTR _u$1$[esp+24], edi
	mov	ecx, edx
	sbb	ebx, eax

; 70   :              v = diff;

	mov	edi, ecx
	mov	edx, ebx
	mov	ebx, eax
	mov	eax, edx
	mov	edx, DWORD PTR _u$1$[esp+24]
$LN15@gcd:

; 71   :          }
; 72   :          v >>= 1;

	shrd	edi, eax, 1
	sar	eax, 1

; 73   :      } while (v != 0);

	mov	esi, edi
	or	esi, eax
	jne	SHORT $LL9@gcd

; 74   : 
; 75   :      return u << shift;

	mov	ecx, DWORD PTR _shift$1$[esp+24]
	mov	eax, edx
	mov	edx, ebx
	call	__allshl

; 76   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@gcd:

; 46   :        return u | v;

	or	edx, edi
	or	ebx, eax

; 76   : }

	pop	edi
	mov	eax, edx
	mov	edx, ebx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?gcd@@YA_J_J0@Z ENDP					; gcd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowfps.h
;	COMDAT ?SetCacheHints@MVFlowFps@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVFlowFps@@UAGHHH@Z PROC			; MVFlowFps::SetCacheHints, COMDAT

; 106  :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 107  :   }

	ret	12					; 0000000cH
?SetCacheHints@MVFlowFps@@UAGHHH@Z ENDP			; MVFlowFps::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVFlowFps@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVFlowFps@@UAEPAXI@Z PROC				; MVFlowFps::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVFlowFps@@UAE@XZ			; MVFlowFps::~MVFlowFps
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	920					; 00000398H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVFlowFps@@UAEPAXI@Z ENDP				; MVFlowFps::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
;	COMDAT ??1MVFlowFps@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVFlowFps@@UAE@XZ PROC				; MVFlowFps::~MVFlowFps, COMDAT
; _this$ = ecx

; 217  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVFlowFps@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 218  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	edi, DWORD PTR __imp___aligned_free
	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [esi], OFFSET ??_7MVFlowFps@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN11@MVFlowFps
	cmp	BYTE PTR [esi+665], 0
	jne	SHORT $LN11@MVFlowFps

; 219  :   {
; 220  :     delete DstPlanes;

	mov	ebx, DWORD PTR [esi+912]
	test	ebx, ebx
	je	SHORT $LN11@MVFlowFps
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN11@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 223  :   delete upsizer;

	mov	ebx, DWORD PTR [esi+904]
	test	ebx, ebx
	je	SHORT $LN18@MVFlowFps
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN18@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 224  :   delete upsizerUV;

	mov	ebx, DWORD PTR [esi+908]
	test	ebx, ebx
	je	SHORT $LN25@MVFlowFps
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN25@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 226  :   _aligned_free(MaskSmallB);

	push	DWORD PTR [esi+824]
	call	edi

; 227  :   _aligned_free(MaskFullYB);

	push	DWORD PTR [esi+828]
	call	edi

; 228  :   _aligned_free(MaskFullUVB);

	push	DWORD PTR [esi+832]
	call	edi

; 229  :   _aligned_free(MaskSmallF);

	push	DWORD PTR [esi+836]
	call	edi

; 230  :   _aligned_free(MaskFullYF);

	push	DWORD PTR [esi+840]
	call	edi

; 231  :   _aligned_free(MaskFullUVF);

	push	DWORD PTR [esi+844]
	call	edi

; 232  : 
; 233  :   _aligned_free(VXFullYBB);

	push	DWORD PTR [esi+728]
	call	edi

; 234  :   _aligned_free(VXFullUVBB);

	push	DWORD PTR [esi+732]
	call	edi

; 235  :   _aligned_free(VYFullYBB);

	push	DWORD PTR [esi+736]
	call	edi

; 236  :   _aligned_free(VYFullUVBB);

	push	DWORD PTR [esi+740]
	call	edi

; 237  :   _aligned_free(VXSmallYBB);

	push	DWORD PTR [esi+792]
	call	edi

; 238  :   _aligned_free(VYSmallYBB);

	push	DWORD PTR [esi+800]
	call	edi

; 239  :   _aligned_free(VXSmallUVBB);

	push	DWORD PTR [esi+796]
	call	edi

; 240  :   _aligned_free(VYSmallUVBB);

	push	DWORD PTR [esi+804]
	call	edi

; 241  :   _aligned_free(VXFullYFF);

	push	DWORD PTR [esi+744]
	call	edi

; 242  :   _aligned_free(VXFullUVFF);

	push	DWORD PTR [esi+748]
	call	edi
	add	esp, 64					; 00000040H

; 243  :   _aligned_free(VYFullYFF);

	push	DWORD PTR [esi+752]
	call	edi

; 244  :   _aligned_free(VYFullUVFF);

	push	DWORD PTR [esi+756]
	call	edi

; 245  :   _aligned_free(VXSmallYFF);

	push	DWORD PTR [esi+808]
	call	edi

; 246  :   _aligned_free(VYSmallYFF);

	push	DWORD PTR [esi+816]
	call	edi

; 247  :   _aligned_free(VXSmallUVFF);

	push	DWORD PTR [esi+812]
	call	edi

; 248  :   _aligned_free(VYSmallUVFF);

	push	DWORD PTR [esi+820]
	call	edi

; 249  : 
; 250  :   _aligned_free(SADMaskSmallB);

	push	DWORD PTR [esi+848]
	call	edi

; 251  :   _aligned_free(SADMaskSmallF);

	push	DWORD PTR [esi+852]
	call	edi
	add	esp, 32					; 00000020H
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN33@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN33@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 253  : }

	lea	ecx, DWORD PTR [esi+668]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
$LN33@MVFlowFps:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+456]
	mov	DWORD PTR [esi+392], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN44@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN44@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+400]
	call	eax
$LN44@MVFlowFps:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+392], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN58@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN58@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN58@MVFlowFps:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN75@MVFlowFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN75@MVFlowFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN75@MVFlowFps:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 253  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvflowfps.cpp

; 253  : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVFlowFps@@UAE@XZ$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowFps@@UAE@XZ$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowFps@@UAE@XZ$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowFps@@UAE@XZ$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVFlowFps@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVFlowFps@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVFlowFps@@UAE@XZ ENDP				; MVFlowFps::~MVFlowFps
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowfps.cpp
;	COMDAT ?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -140						; size = 4
tv928 = -136						; size = 8
$T3 = -132						; size = 2
$T4 = -132						; size = 2
$T5 = -132						; size = 2
$T6 = -132						; size = 2
$T7 = -132						; size = 2
_nRefPitches$3$ = -128					; size = 4
_nRefPitches$2$ = -128					; size = 4
_off$1$ = -128						; size = 4
_mvFF$8 = -128						; size = 4
$T9 = -128						; size = 4
_nSrcPitches$2$ = -124					; size = 4
_nSrcPitches$1$ = -124					; size = 4
_mvBB$10 = -124						; size = 4
_nDstPitches$2$ = -120					; size = 4
_pRef$2$ = -120						; size = 4
_pDstYUY2$1$ = -120					; size = 4
_pRef$3$ = -116						; size = 4
_pSrc$2$ = -116						; size = 4
_nDstPitchYUY2$1$ = -116				; size = 4
_pSrc$3$ = -112						; size = 4
_i$1$ = -112						; size = 4
_i$1$ = -112						; size = 4
_pDstYUY2$2$ = -112					; size = 4
$T11 = -112						; size = 2
$T12 = -112						; size = 2
_mvF$ = -108						; size = 4
_mvB$ = -104						; size = 4
_pDst$2$ = -100						; size = 4
_nOffsetUV$1$ = -100					; size = 4
_nRefPitches$5$ = -96					; size = 4
_nOffsetY$1$ = -96					; size = 4
_nSrcPitches$3$ = -92					; size = 4
_nright$1$ = -92					; size = 4
_nDstPitches$4$ = -88					; size = 4
_nleft$1$ = -88						; size = 4
_pRef$6$ = -84						; size = 4
_pRef$5$ = -84						; size = 4
_pSrc$6$ = -80						; size = 4
_pSrc$5$ = -80						; size = 4
_pDst$4$ = -76						; size = 4
_nRefPitches$6$ = -76					; size = 4
_nRefPitches$7$ = -72					; size = 4
_pRef$4$ = -72						; size = 4
_nSrcPitches$4$ = -68					; size = 4
_pSrc$4$ = -68						; size = 4
_nDstPitches$6$ = -64					; size = 4
_time256$1$ = -64					; size = 4
_pDst$5$ = -60						; size = 4
_pRef$7$ = -60						; size = 4
_nDstPitches$5$ = -56					; size = 4
_pSrc$7$ = -56						; size = 4
_pDst$6$ = -52						; size = 4
_nRefPitches$4$ = -52					; size = 4
_pRef$1$ = -48						; size = 4
_pSrc$1$ = -44						; size = 4
_nRefPitches$1$ = -40					; size = 4
_pDst$3$ = -36						; size = 4
_nDstPitches$1$ = -32					; size = 4
_nDstPitches$3$ = -28					; size = 4
_pDst$1$ = -24						; size = 4
_src$ = -20						; size = 4
_ref$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_src$13 = 8						; size = 4
_nDstPitchYUY2$ = 8					; size = 4
_pDstYUY2$ = 8						; size = 4
$T14 = 8						; size = 4
$T15 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_dst$ = 16						; size = 4
_n$ = 16						; size = 4
_i$1$ = 20						; size = 4
$T16 = 20						; size = 2
_ref$17 = 20						; size = 4
_env$ = 20						; size = 4
?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVFlowFps::GetFrame, COMDAT

; 257  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T2[ebp], 0

; 258  : #ifndef _M_X64
; 259  :   _mm_empty();

	emms

; 260  : #endif
; 261  :   int nleft = (int)(__int64(n)* fa / fb);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _n$[ebp]
	mov	eax, esi
	cdq
	mov	edi, DWORD PTR [ecx+684]
	mov	ebx, DWORD PTR [ecx+692]
	push	edi
	push	DWORD PTR [ecx+680]
	push	edx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _this$[ebp]
	push	ebx
	push	DWORD PTR [ecx+688]
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR _nleft$1$[ebp], eax

; 263  :   int time256 = int((double(n)*double(fa) / double(fb) - nleft) * 256 + 0.5);

	mov	edx, edi
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	call	__ltod3
	movd	xmm1, esi
	mov	edx, ebx
	mov	ebx, DWORD PTR _this$[ebp]
	cvtdq2pd xmm1, xmm1
	mov	ecx, DWORD PTR [ebx+688]
	mulsd	xmm0, xmm1
	movsd	QWORD PTR tv928[ebp], xmm0
	call	__ltod3
	movsd	xmm2, QWORD PTR tv928[ebp]
	divsd	xmm2, xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	movd	xmm1, DWORD PTR _nleft$1$[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 263  :   int time256 = int((double(n)*double(fa) / double(fb) - nleft) * 256 + 0.5);

	cvtdq2pd xmm1, xmm1
	subsd	xmm2, xmm1
	mulsd	xmm2, QWORD PTR __real@4070000000000000
	addsd	xmm2, QWORD PTR __real@3fe0000000000000
	cvttsd2si edi, xmm2
	mov	DWORD PTR _time256$1$[ebp], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN91@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN91@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
$LN91@GetFrame:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 265  :   PVideoFrame dst;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	ecx, DWORD PTR [ebx+292]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 276  :     env->ThrowError("MFlowFps: cannot use motion vectors with absolute frame references.");

	mov	esi, DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	DWORD PTR _off$1$[ebp], ecx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 274  :   if (off <= 0)

	test	ecx, ecx
	jg	SHORT $LN32@GetFrame

; 276  :     env->ThrowError("MFlowFps: cannot use motion vectors with absolute frame references.");

	mov	ecx, DWORD PTR [esi]
	push	OFFSET ??_C@_0EE@FHPELLEK@MFlowFps?3?5cannot?5use?5motion?5vect@
	push	esi
	call	DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _off$1$[ebp]
	add	esp, 8
$LN32@GetFrame:

; 277  :   }
; 278  :   // usually off must be = 1
; 279  :   if (off > 1)

	cmp	ecx, 1
	jle	SHORT $LN33@GetFrame

; 280  :     time256 = time256 / off;

	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, eax
	mov	DWORD PTR _time256$1$[ebp], eax
$LN33@GetFrame:

; 281  : 
; 282  :   int nright = nleft + off;

	mov	edx, DWORD PTR _nleft$1$[ebp]

; 286  :     dst = child->GetFrame(nleft, env); // simply left

	push	esi
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR _nright$1$[ebp], eax
	test	edi, edi
	jne	$LN34@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 286  :     dst = child->GetFrame(nleft, env); // simply left

	push	edx
	lea	edx, DWORD PTR $T15[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN99@GetFrame
	cmp	DWORD PTR [edx], 268			; 0000010cH
	jbe	SHORT $LN99@GetFrame
	push	eax
	mov	eax, DWORD PTR [edx+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN99@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN103@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN103@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR $T15[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN103@GetFrame:

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN108@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN108@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN108@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\mvflowfps.cpp

; 287  :     return dst;

	jmp	$LN625@GetFrame
$LN34@GetFrame:

; 290  :     dst = child->GetFrame(nright, env); // simply right

	push	DWORD PTR _nright$1$[ebp]
	cmp	edi, 256				; 00000100H
	jne	$LN36@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 290  :     dst = child->GetFrame(nright, env); // simply right

	lea	edx, DWORD PTR $T14[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN119@GetFrame
	cmp	DWORD PTR [edx], 268			; 0000010cH
	jbe	SHORT $LN119@GetFrame
	push	eax
	mov	eax, DWORD PTR [edx+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN119@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	edx, edx
	je	SHORT $LN123@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN123@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR $T14[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN123@GetFrame:

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN128@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN128@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN128@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\mvflowfps.cpp

; 291  :     return dst;

	jmp	$LN625@GetFrame
$LN36@GetFrame:

; 292  :   }
; 293  : 
; 294  :   PVideoFrame mvF = mvClipF.GetFrame(nright, env);

	mov	eax, DWORD PTR [ebx+392]
	lea	ecx, DWORD PTR [ebx+392]
	lea	edx, DWORD PTR _mvF$[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 295  :   mvClipF.Update(mvF, env);// forward from current to next

	push	esi
	lea	eax, DWORD PTR _mvF$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	lea	ecx, DWORD PTR [ebx+392]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN137@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN137@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvF$[ebp]
	push	0
	call	eax
$LN137@GetFrame:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 297  :   PVideoFrame mvB = mvClipB.GetFrame(nleft, env);

	mov	eax, DWORD PTR [ebx+152]
	lea	ecx, DWORD PTR [ebx+152]
	push	esi
	push	DWORD PTR _nleft$1$[ebp]
	lea	edx, DWORD PTR _mvB$[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 298  :   mvClipB.Update(mvB, env);// backward from next to current

	push	esi
	lea	eax, DWORD PTR _mvB$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	eax
	lea	ecx, DWORD PTR [ebx+152]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN141@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN141@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvB$[ebp]
	push	0
	call	eax
$LN141@GetFrame:
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [ebx+296]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 304  :   if (!mvClipB.IsBackward())

	test	al, al
	jne	SHORT $LN37@GetFrame

; 305  :     env->ThrowError("MFlowFps: wrong backward vectors");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CB@GFNLJBEK@MFlowFps?3?5wrong?5backward?5vectors@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN37@GetFrame:
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [ebx+536]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 306  :   if (mvClipF.IsBackward())

	test	al, al
	je	SHORT $LN38@GetFrame

; 307  :     env->ThrowError("MFlowFps: wrong forward vectors");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CA@HIOCHGAE@MFlowFps?3?5wrong?5forward?5vectors?$AA@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN38@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+668]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 309  :   PVideoFrame	src = finest->GetFrame(nleft, env); // move here - v2.0

	lea	edx, DWORD PTR _src$[ebp]
	push	esi
	push	DWORD PTR _nleft$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 310  :   PVideoFrame ref = finest->GetFrame(nright, env);//  right frame for  compensation

	lea	edx, DWORD PTR _ref$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+668]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 310  :   PVideoFrame ref = finest->GetFrame(nright, env);//  right frame for  compensation

	push	esi
	push	DWORD PTR _nright$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]

; 311  : 
; 312  : // 2.5.11.22	Create_LUTV(time256, LUTVB, LUTVF); // lookup table
; 313  : // 2.5.11.22		const Time256ProviderCst	t256_prov_cst (time256, LUTVB, LUTVF);
; 314  : 
; 315  :   dst = env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [ebx+16]
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR [esi]
	push	eax
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	push	esi
	call	DWORD PTR [ecx+56]
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN153@GetFrame
	cmp	DWORD PTR [eax], 268			; 0000010cH
	jbe	SHORT $LN153@GetFrame
	mov	eax, DWORD PTR [eax+268]
	push	ecx
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN153@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	eax, eax
	je	SHORT $LN157@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN157@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR $T9[ebp]
	call	eax
$LN157@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [ebx+372]
	mov	ecx, DWORD PTR [ebx+240]
	push	DWORD PTR [ebx+368]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN39@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ebx+220]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN39@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [ebx+612]
	mov	ecx, DWORD PTR [ebx+480]
	push	DWORD PTR [ebx+608]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN39@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ebx+460]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN39@GetFrame
; File c:\github\mvtools\sources\mvflowfps.cpp

; 322  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN41@GetFrame

; 323  :     {
; 324  :             // planar data packed to interleaved format (same as interleved2planar by kassandro) - v2.0.0.5
; 325  :       pSrc[0] = src->GetReadPtr();

	mov	ecx, DWORD PTR _src$[ebp]
	push	0
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 326  :       pSrc[1] = pSrc[0] + src->GetRowSize() / 2;

	mov	ecx, DWORD PTR _src$[ebp]
	push	0
	mov	DWORD PTR _pSrc$1$[ebp], eax
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 327  :       pSrc[2] = pSrc[1] + src->GetRowSize() / 4;

	mov	ecx, DWORD PTR _src$[ebp]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	add	esi, DWORD PTR _pSrc$1$[ebp]
	push	0
	mov	DWORD PTR _pSrc$4$[ebp], esi
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 328  :       nSrcPitches[0] = src->GetPitch();

	mov	ecx, DWORD PTR _src$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, esi
	push	0
	mov	DWORD PTR _pSrc$6$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 329  :       nSrcPitches[1] = nSrcPitches[0];
; 330  :       nSrcPitches[2] = nSrcPitches[0];
; 331  :       // planar data packed to interleaved format (same as interleved2planar by kassandro) - v2.0.0.5
; 332  :       pRef[0] = ref->GetReadPtr();

	mov	ecx, DWORD PTR _ref$[ebp]
	push	0
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 333  :       pRef[1] = pRef[0] + ref->GetRowSize() / 2;

	mov	ecx, DWORD PTR _ref$[ebp]
	push	0
	mov	DWORD PTR _pRef$1$[ebp], eax
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 334  :       pRef[2] = pRef[1] + ref->GetRowSize() / 4;

	mov	ecx, DWORD PTR _ref$[ebp]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	add	esi, DWORD PTR _pRef$1$[ebp]
	push	0
	mov	DWORD PTR _pRef$4$[ebp], esi
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 335  :       nRefPitches[0] = ref->GetPitch();

	mov	ecx, DWORD PTR _ref$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, esi
	push	0
	mov	DWORD PTR _pRef$6$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 336  :       nRefPitches[1] = nRefPitches[0];
; 337  :       nRefPitches[2] = nRefPitches[0];
; 338  : 
; 339  :       if (!planar)

	cmp	BYTE PTR [ebx+665], 0

; 340  :       {
; 341  :         pDstYUY2 = dst->GetWritePtr();

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _nRefPitches$1$[ebp], eax
	mov	DWORD PTR _nRefPitches$4$[ebp], eax
	mov	DWORD PTR _nRefPitches$6$[ebp], eax
	push	0
	jne	SHORT $LN43@GetFrame
	call	?GetWritePtr@VideoFrame@@QBEPAEH@Z	; VideoFrame::GetWritePtr

; 342  :         nDstPitchYUY2 = dst->GetPitch();

	mov	ecx, DWORD PTR _dst$[ebp]
	push	0
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	ecx, DWORD PTR [ebx+912]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 342  :         nDstPitchYUY2 = dst->GetPitch();

	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax

; 343  :         pDst[0] = DstPlanes->GetPtr();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pDst$1$[ebp], eax

; 344  :         pDst[1] = DstPlanes->GetPtrU();

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _pDst$3$[ebp], eax

; 345  :         pDst[2] = DstPlanes->GetPtrV();

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _pDst$5$[ebp], eax

; 346  :         nDstPitches[0] = DstPlanes->GetPitch();

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 348  :         nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$5$[ebp], eax

; 349  :       }
; 350  :       else

	jmp	$LN42@GetFrame
$LN43@GetFrame:

; 351  :       {
; 352  :         pDst[0] = dst->GetWritePtr();

	call	?GetWritePtr@VideoFrame@@QBEPAEH@Z	; VideoFrame::GetWritePtr

; 353  :         pDst[1] = pDst[0] + dst->GetRowSize() / 2;

	mov	ecx, DWORD PTR _dst$[ebp]
	push	0
	mov	DWORD PTR _pDst$1$[ebp], eax
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 354  :         pDst[2] = pDst[1] + dst->GetRowSize() / 4;;

	mov	ecx, DWORD PTR _dst$[ebp]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	add	esi, DWORD PTR _pDst$1$[ebp]
	push	0
	mov	DWORD PTR _pDst$3$[ebp], esi
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 355  :         nDstPitches[0] = dst->GetPitch();

	mov	ecx, DWORD PTR _dst$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, esi
	push	0
	mov	DWORD PTR _pDst$5$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch
	mov	DWORD PTR _nDstPitches$1$[ebp], eax

; 356  :         nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 357  :         nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$5$[ebp], eax

; 358  :       }
; 359  :     }
; 360  :     else

	jmp	$LN626@GetFrame
$LN41@GetFrame:

; 361  :     {
; 362  :       pDst[0] = YWPLAN(dst);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	1
	call	?GetWritePtr@VideoFrame@@QBEPAEH@Z	; VideoFrame::GetWritePtr

; 363  :       pDst[1] = UWPLAN(dst);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	2
	mov	DWORD PTR _pDst$1$[ebp], eax
	call	?GetWritePtr@VideoFrame@@QBEPAEH@Z	; VideoFrame::GetWritePtr

; 364  :       pDst[2] = VWPLAN(dst);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	4
	mov	DWORD PTR _pDst$3$[ebp], eax
	call	?GetWritePtr@VideoFrame@@QBEPAEH@Z	; VideoFrame::GetWritePtr

; 365  :       nDstPitches[0] = YPITCH(dst);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	1
	mov	DWORD PTR _pDst$5$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 366  :       nDstPitches[1] = UPITCH(dst);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	2
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 367  :       nDstPitches[2] = VPITCH(dst);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	4
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 368  : 
; 369  :       pRef[0] = YRPLAN(ref);

	mov	ecx, DWORD PTR _ref$[ebp]
	push	1
	mov	DWORD PTR _nDstPitches$5$[ebp], eax
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 370  :       pRef[1] = URPLAN(ref);

	mov	ecx, DWORD PTR _ref$[ebp]
	push	2
	mov	DWORD PTR _pRef$1$[ebp], eax
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 371  :       pRef[2] = VRPLAN(ref);

	mov	ecx, DWORD PTR _ref$[ebp]
	push	4
	mov	DWORD PTR _pRef$4$[ebp], eax
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 372  :       nRefPitches[0] = YPITCH(ref);

	mov	ecx, DWORD PTR _ref$[ebp]
	push	1
	mov	DWORD PTR _pRef$6$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 373  :       nRefPitches[1] = UPITCH(ref);

	mov	ecx, DWORD PTR _ref$[ebp]
	push	2
	mov	DWORD PTR _nRefPitches$1$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 374  :       nRefPitches[2] = VPITCH(ref);

	mov	ecx, DWORD PTR _ref$[ebp]
	push	4
	mov	DWORD PTR _nRefPitches$4$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 375  : 
; 376  :       pSrc[0] = YRPLAN(src);

	mov	ecx, DWORD PTR _src$[ebp]
	push	1
	mov	DWORD PTR _nRefPitches$6$[ebp], eax
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 377  :       pSrc[1] = URPLAN(src);

	mov	ecx, DWORD PTR _src$[ebp]
	push	2
	mov	DWORD PTR _pSrc$1$[ebp], eax
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 378  :       pSrc[2] = VRPLAN(src);

	mov	ecx, DWORD PTR _src$[ebp]
	push	4
	mov	DWORD PTR _pSrc$4$[ebp], eax
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 379  :       nSrcPitches[0] = YPITCH(src);

	mov	ecx, DWORD PTR _src$[ebp]
	push	1
	mov	DWORD PTR _pSrc$6$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 380  :       nSrcPitches[1] = UPITCH(src);

	mov	ecx, DWORD PTR _src$[ebp]
	push	2
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 381  :       nSrcPitches[2] = VPITCH(src);

	mov	ecx, DWORD PTR _src$[ebp]
	push	4
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch
$LN626@GetFrame:
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN42@GetFrame:

; 382  :     }
; 383  : 
; 384  :     PROFILE_STOP(MOTION_PROFILE_YUY2CONVERT);
; 385  : 
; 386  :     int nOffsetY = nRefPitches[0] * nVPadding*nPel + nHPadding*nPel*pixelsize;

	mov	ecx, DWORD PTR [ebx+136]
	mov	esi, DWORD PTR [ebx+88]
	imul	esi, DWORD PTR _nRefPitches$1$[ebp]
	mov	eax, DWORD PTR [ebx+84]
	imul	eax, ecx
	add	esi, eax

; 387  :     int nOffsetUV = nRefPitches[1] * nVPaddingUV*nPel + nHPaddingUV*nPel*pixelsize;

	mov	eax, DWORD PTR [ebx+896]
	imul	esi, DWORD PTR [ebx+104]
	imul	eax, ecx
	mov	DWORD PTR _nOffsetY$1$[ebp], esi
	mov	esi, DWORD PTR [ebx+900]
	imul	esi, DWORD PTR _nRefPitches$4$[ebp]
	add	esi, eax

; 388  : 
; 389  :     int dummyplane = PLANAR_Y; // use luma plane resizer code for all planes if we resize from luma small mask
; 390  : 
; 391  :     if (nright != nrightLast)

	mov	eax, DWORD PTR _nright$1$[ebp]
	imul	esi, DWORD PTR [ebx+104]
	mov	DWORD PTR _nOffsetUV$1$[ebp], esi
	cmp	eax, DWORD PTR [ebx+676]
	je	$LN45@GetFrame

; 392  :     {
; 393  :       PROFILE_START(MOTION_PROFILE_MASK);
; 394  :       // make  vector vx and vy small masks
; 395  :       MakeVectorSmallMasks(mvClipB, nBlkX, nBlkY, VXSmallYB, nBlkXP, VYSmallYB, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	lea	ecx, DWORD PTR [ebx+152]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	DWORD PTR [ebx+768]
	push	eax
	push	DWORD PTR [ebx+760]
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 396  :       if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 20					; 00000014H
	cmp	eax, DWORD PTR [ebx+64]
	jle	SHORT $LN3@GetFrame

; 397  :       {
; 398  :         for (int j = 0; j < nBlkY; j++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+68], edi
	jle	SHORT $LN3@GetFrame

; 400  :           VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	DWORD PTR $T12[ebp], edi
	npad	6
$LL4@GetFrame:
	mov	esi, DWORD PTR [ebx+872]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T12[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 400  :           VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	edx, DWORD PTR [ebx+760]
	imul	esi, edi
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 400  :           VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [edx+ecx*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 400  :           VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [edx+ecx*2]

; 401  :           //VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX-1], uint8_t (128));
; 402  :           VYSmallYB[j*nBlkXP + nBlkX] = VYSmallYB[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 400  :           VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 401  :           //VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX-1], uint8_t (128));
; 402  :           VYSmallYB[j*nBlkXP + nBlkX] = VYSmallYB[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+768]
	imul	edx, edi
	inc	edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
	cmp	edi, DWORD PTR [ebx+68]
	jl	SHORT $LL4@GetFrame
$LN3@GetFrame:

; 403  :         }
; 404  :       }
; 405  :       if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+876]
	cmp	eax, DWORD PTR [ebx+68]
	jle	$LN6@GetFrame

; 407  :         for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [ebx+872], edi
	jle	SHORT $LN6@GetFrame

; 411  :           VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0));  // 2.5.11.22

	mov	DWORD PTR $T7[ebp], edi
$LL7@GetFrame:

; 409  :           VXSmallYB[nBlkXP*nBlkY + i] = VXSmallYB[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+872]
	mov	edx, DWORD PTR [ebx+760]
	lea	ecx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	ecx, eax
	add	esi, edi
	add	ecx, edi
	movzx	eax, WORD PTR [edx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T7[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 409  :           VXSmallYB[nBlkXP*nBlkY + i] = VXSmallYB[nBlkXP*(nBlkY - 1) + i];

	mov	WORD PTR [edx+esi*2], ax

; 411  :           VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0));  // 2.5.11.22

	mov	edi, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+872]
	mov	esi, DWORD PTR [ebx+768]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 411  :           VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0));  // 2.5.11.22

	lea	eax, DWORD PTR [edi-1]
	imul	eax, edx
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 407  :         for (int i = 0; i < nBlkXP; i++)

	mov	ebx, DWORD PTR _this$[ebp]

; 411  :           VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0));  // 2.5.11.22

	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 411  :           VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0));  // 2.5.11.22

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax
	mov	edi, DWORD PTR _i$1$[ebp]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [ebx+872]
	jl	SHORT $LL7@GetFrame
$LN6@GetFrame:

; 412  :         }
; 413  :       }
; 414  :       VectorSmallMaskYToHalfUV(VXSmallYB, nBlkXP, nBlkYP, VXSmallUVB, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+764]
	mov	ecx, DWORD PTR [ebx+760]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 415  :       VectorSmallMaskYToHalfUV(VYSmallYB, nBlkXP, nBlkYP, VYSmallUVB, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+772]
	mov	ecx, DWORD PTR [ebx+768]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 416  : 
; 417  :       PROFILE_STOP(MOTION_PROFILE_MASK);
; 418  :       // upsize (bilinear interpolate) vector masks to fullframe size
; 419  :       PROFILE_START(MOTION_PROFILE_RESIZE);
; 420  : 
; 421  :       upsizer->SimpleResizeDo_uint16(VXFullYB, nWidthP, nHeightP, VPitchY, VXSmallYB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+760]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+696]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 422  :       upsizer->SimpleResizeDo_uint16(VYFullYB, nWidthP, nHeightP, VPitchY, VYSmallYB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+768]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+704]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 423  :       upsizerUV->SimpleResizeDo_uint16(VXFullUVB, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+764]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+700]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 424  :       upsizerUV->SimpleResizeDo_uint16(VYFullUVB, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+772]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+708]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16
	mov	edi, DWORD PTR _time256$1$[ebp]
$LN45@GetFrame:

; 425  :       PROFILE_STOP(MOTION_PROFILE_RESIZE);
; 426  : 
; 427  :     }
; 428  :    // analyse vectors field to detect occlusion
; 429  :     PROFILE_START(MOTION_PROFILE_MASK);
; 430  : //		double occNormB = (256-time256)/(256*ml);
; 431  : //		MakeVectorOcclusionMask(mvClipB, nBlkX, nBlkY, occNormB, 1.0, nPel, MaskSmallB, nBlkXP);
; 432  :     MakeVectorOcclusionMaskTime(mvClipB, nBlkX, nBlkY, ml, 1.0, nPel, MaskSmallB, nBlkXP, (256 - time256), nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	mov	eax, DWORD PTR [ebx+80]
	lea	ecx, DWORD PTR [ebx+152]
	sub	eax, DWORD PTR [ebx+112]
	push	eax
	mov	eax, DWORD PTR [ebx+76]
	sub	eax, DWORD PTR [ebx+108]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	xmm3, QWORD PTR [ebx+656]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	mov	eax, 256				; 00000100H
	sub	eax, edi
	push	eax
	push	DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [ebx+68]
	call	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime

; 433  :     if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 36					; 00000024H
	cmp	eax, DWORD PTR [ebx+64]
	jle	SHORT $LN9@GetFrame

; 434  :     {
; 435  :       for (int j = 0; j < nBlkY; j++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+68], esi
	jle	SHORT $LN9@GetFrame
	npad	5
$LL10@GetFrame:

; 436  :       {
; 437  :         MaskSmallB[j*nBlkXP + nBlkX] = MaskSmallB[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+824]
	imul	edx, esi
	inc	esi
	add	edx, DWORD PTR [ebx+64]
	mov	al, BYTE PTR [edx+ecx-1]
	mov	BYTE PTR [edx+ecx], al
	cmp	esi, DWORD PTR [ebx+68]
	jl	SHORT $LL10@GetFrame
$LN9@GetFrame:

; 438  :       }
; 439  :     }
; 440  :     if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+876]
	cmp	eax, DWORD PTR [ebx+68]
	jle	SHORT $LN12@GetFrame

; 441  :     {
; 442  :       for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+872], edi
	jle	SHORT $LN12@GetFrame
	npad	12
$LL13@GetFrame:

; 443  :       {
; 444  :         MaskSmallB[nBlkXP*nBlkY + i] = MaskSmallB[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+824]
	lea	edx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	edx, eax
	add	esi, ecx
	add	edx, ecx
	mov	al, BYTE PTR [edx+edi]
	mov	BYTE PTR [esi+edi], al
	inc	edi
	cmp	edi, DWORD PTR [ebx+872]
	jl	SHORT $LL13@GetFrame
$LN12@GetFrame:

; 445  :       }
; 446  :     }
; 447  :     PROFILE_STOP(MOTION_PROFILE_MASK);
; 448  :     PROFILE_START(MOTION_PROFILE_RESIZE);
; 449  :   // upsize (bilinear interpolate) vector masks to fullframe size
; 450  :     upsizer->SimpleResizeDo_uint8(MaskFullYB, nWidthP, nHeightP, VPitchY, MaskSmallB, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+872]
	push	ecx
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+828]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 451  :     upsizerUV->SimpleResizeDo_uint8(MaskFullUVB, nWidthPUV, nHeightPUV, VPitchUV, MaskSmallB, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+872]
	push	ecx
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+832]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 452  :     PROFILE_STOP(MOTION_PROFILE_RESIZE);
; 453  : 
; 454  :     nrightLast = nright;

	mov	eax, DWORD PTR _nright$1$[ebp]
	mov	DWORD PTR [ebx+676], eax

; 455  : 
; 456  : 
; 457  :     if (nleft != nleftLast)

	mov	eax, DWORD PTR _nleft$1$[ebp]
	cmp	eax, DWORD PTR [ebx+672]
	je	$LN50@GetFrame

; 458  :     {
; 459  :      // make  vector vx and vy small masks
; 460  :       PROFILE_START(MOTION_PROFILE_MASK);
; 461  :       MakeVectorSmallMasks(mvClipF, nBlkX, nBlkY, VXSmallYF, nBlkXP, VYSmallYF, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	lea	ecx, DWORD PTR [ebx+392]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	DWORD PTR [ebx+784]
	push	eax
	push	DWORD PTR [ebx+776]
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 462  :       if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 20					; 00000014H
	cmp	eax, DWORD PTR [ebx+64]
	jle	SHORT $LN15@GetFrame

; 463  :       {
; 464  :         for (int j = 0; j < nBlkY; j++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+68], edi
	jle	SHORT $LN15@GetFrame

; 466  :           VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	DWORD PTR $T6[ebp], edi
	npad	9
$LL16@GetFrame:
	mov	esi, DWORD PTR [ebx+872]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T6[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 466  :           VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	edx, DWORD PTR [ebx+776]
	imul	esi, edi
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 466  :           VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [edx+ecx*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 466  :           VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [edx+ecx*2]

; 467  :           //VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX-1], uint8_t (128));
; 468  :           VYSmallYF[j*nBlkXP + nBlkX] = VYSmallYF[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 466  :           VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 467  :           //VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX-1], uint8_t (128));
; 468  :           VYSmallYF[j*nBlkXP + nBlkX] = VYSmallYF[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+784]
	imul	edx, edi
	inc	edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
	cmp	edi, DWORD PTR [ebx+68]
	jl	SHORT $LL16@GetFrame
$LN15@GetFrame:

; 469  :         }
; 470  :       }
; 471  :       if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+876]
	cmp	eax, DWORD PTR [ebx+68]
	jle	$LN18@GetFrame

; 473  :         for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [ebx+872], edi
	jle	$LN18@GetFrame

; 477  :           VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 Line 458

	mov	DWORD PTR $T5[ebp], edi
	npad	8
$LL19@GetFrame:

; 475  :           VXSmallYF[nBlkXP*nBlkY + i] = VXSmallYF[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+872]
	mov	edx, DWORD PTR [ebx+776]
	lea	ecx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	ecx, eax
	add	esi, edi
	add	ecx, edi
	movzx	eax, WORD PTR [edx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T5[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 475  :           VXSmallYF[nBlkXP*nBlkY + i] = VXSmallYF[nBlkXP*(nBlkY - 1) + i];

	mov	WORD PTR [edx+esi*2], ax

; 477  :           VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 Line 458

	mov	edi, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+872]
	mov	esi, DWORD PTR [ebx+784]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 477  :           VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 Line 458

	lea	eax, DWORD PTR [edi-1]
	imul	eax, edx
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 473  :         for (int i = 0; i < nBlkXP; i++)

	mov	ebx, DWORD PTR _this$[ebp]

; 477  :           VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 Line 458

	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 477  :           VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 Line 458

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax
	mov	edi, DWORD PTR _i$1$[ebp]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [ebx+872]
	jl	SHORT $LL19@GetFrame
$LN18@GetFrame:

; 478  :         }
; 479  :       }
; 480  :       VectorSmallMaskYToHalfUV(VXSmallYF, nBlkXP, nBlkYP, VXSmallUVF, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+780]
	mov	ecx, DWORD PTR [ebx+776]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 481  :       VectorSmallMaskYToHalfUV(VYSmallYF, nBlkXP, nBlkYP, VYSmallUVF, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+788]
	mov	ecx, DWORD PTR [ebx+784]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 482  : 
; 483  :       PROFILE_STOP(MOTION_PROFILE_MASK);
; 484  :       // upsize (bilinear interpolate) vector masks to fullframe size
; 485  :       PROFILE_START(MOTION_PROFILE_RESIZE);
; 486  : 
; 487  :       upsizer->SimpleResizeDo_uint16(VXFullYF, nWidthP, nHeightP, VPitchY, VXSmallYF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+776]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+712]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 488  :       upsizer->SimpleResizeDo_uint16(VYFullYF, nWidthP, nHeightP, VPitchY, VYSmallYF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+784]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+720]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 489  :       upsizerUV->SimpleResizeDo_uint16(VXFullUVF, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+780]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+716]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 490  :       upsizerUV->SimpleResizeDo_uint16(VYFullUVF, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+788]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+724]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16
$LN50@GetFrame:

; 491  :       PROFILE_STOP(MOTION_PROFILE_RESIZE);
; 492  : 
; 493  :     }
; 494  :    // analyse vectors field to detect occlusion
; 495  :     PROFILE_START(MOTION_PROFILE_MASK);
; 496  :     MakeVectorOcclusionMaskTime(mvClipF, nBlkX, nBlkY, ml, 1.0, nPel, MaskSmallF, nBlkXP, time256, nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	mov	eax, DWORD PTR [ebx+80]
	lea	ecx, DWORD PTR [ebx+392]
	sub	eax, DWORD PTR [ebx+112]
	mov	edi, DWORD PTR _time256$1$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	push	eax
	mov	eax, DWORD PTR [ebx+76]
	sub	eax, DWORD PTR [ebx+108]
	movsd	xmm3, QWORD PTR [ebx+656]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	edi
	push	DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [ebx+68]
	call	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime

; 497  :     if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 36					; 00000024H
	cmp	eax, DWORD PTR [ebx+64]
	jle	SHORT $LN21@GetFrame

; 498  :     {
; 499  :       for (int j = 0; j < nBlkY; j++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+68], esi
	jle	SHORT $LN21@GetFrame
$LL22@GetFrame:

; 500  :       {
; 501  :         MaskSmallF[j*nBlkXP + nBlkX] = MaskSmallF[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+64]
	imul	edx, esi
	inc	esi
	add	edx, DWORD PTR [ebx+836]
	mov	al, BYTE PTR [edx+ecx-1]
	mov	BYTE PTR [edx+ecx], al
	cmp	esi, DWORD PTR [ebx+68]
	jl	SHORT $LL22@GetFrame
$LN21@GetFrame:

; 502  :       }
; 503  :     }
; 504  :     if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+876]
	cmp	eax, DWORD PTR [ebx+68]
	jle	SHORT $LN24@GetFrame

; 505  :     {
; 506  :       for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+872], edi
	jle	SHORT $LN619@GetFrame
	npad	9
$LL25@GetFrame:

; 507  :       {
; 508  :         MaskSmallF[nBlkXP*nBlkY + i] = MaskSmallF[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+836]
	lea	edx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	edx, eax
	add	esi, ecx
	add	edx, ecx
	mov	al, BYTE PTR [edx+edi]
	mov	BYTE PTR [esi+edi], al
	inc	edi
	cmp	edi, DWORD PTR [ebx+872]
	jl	SHORT $LL25@GetFrame
$LN619@GetFrame:
	mov	edi, DWORD PTR _time256$1$[ebp]
$LN24@GetFrame:

; 509  :       }
; 510  :     }
; 511  :     PROFILE_STOP(MOTION_PROFILE_MASK);
; 512  :     PROFILE_START(MOTION_PROFILE_RESIZE);
; 513  :   // upsize (bilinear interpolate) vector masks to fullframe size
; 514  :     upsizer->SimpleResizeDo_uint8(MaskFullYF, nWidthP, nHeightP, VPitchY, MaskSmallF, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+872]
	push	ecx
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+840]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 515  :     upsizerUV->SimpleResizeDo_uint8(MaskFullUVF, nWidthPUV, nHeightPUV, VPitchUV, MaskSmallF, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+872]
	push	ecx
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+844]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 516  :     PROFILE_STOP(MOTION_PROFILE_RESIZE);
; 517  : 
; 518  :     nleftLast = nleft;

	mov	edx, DWORD PTR _nleft$1$[ebp]

; 519  : 
; 520  :    // Get motion info from more frames for occlusion areas
; 521  :     PVideoFrame mvFF = mvClipF.GetFrame(nleft, env);

	lea	ecx, DWORD PTR [ebx+392]
	mov	esi, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	esi
	push	edx
	mov	DWORD PTR [ebx+672], edx
	lea	edx, DWORD PTR _mvFF$8[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 522  :     mvClipF.Update(mvFF, env);// forward from prev to cur

	push	esi
	lea	eax, DWORD PTR _mvFF$8[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	push	eax
	lea	ecx, DWORD PTR [ebx+392]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN270@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN270@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvFF$8[ebp]
	push	0
	call	eax
$LN270@GetFrame:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 525  :     PVideoFrame mvBB = mvClipB.GetFrame(nright, env);

	mov	eax, DWORD PTR [ebx+152]
	lea	ecx, DWORD PTR [ebx+152]
	push	esi
	push	DWORD PTR _nright$1$[ebp]
	lea	edx, DWORD PTR _mvBB$10[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 526  :     mvClipB.Update(mvBB, env);// backward from next next to next

	push	esi
	lea	eax, DWORD PTR _mvBB$10[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	esi, DWORD PTR [ebx+152]
	push	eax
	mov	ecx, esi
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN274@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN274@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvBB$10[ebp]
	push	0
	call	eax
$LN274@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [esi+88]
	push	DWORD PTR [esi+216]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN55@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [esi+68]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN55@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [ebx+612]
	mov	ecx, DWORD PTR [ebx+480]
	push	DWORD PTR [ebx+608]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN55@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ebx+460]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN55@GetFrame
; File c:\github\mvtools\sources\mvflowfps.cpp

; 529  :     if (mvClipB.IsUsable() && mvClipF.IsUsable() && maskmode == 2) // slow method with extra frames

	cmp	DWORD PTR [ebx+648], 2
	jne	$LN55@GetFrame

; 530  :     {
; 531  :      // get vector mask from extra frames
; 532  :       PROFILE_START(MOTION_PROFILE_MASK);
; 533  :       MakeVectorSmallMasks(mvClipB, nBlkX, nBlkY, VXSmallYBB, nBlkXP, VYSmallYBB, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, esi
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	DWORD PTR [ebx+800]
	push	eax
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 534  :       MakeVectorSmallMasks(mvClipF, nBlkX, nBlkY, VXSmallYFF, nBlkXP, VYSmallYFF, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	lea	ecx, DWORD PTR [ebx+392]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	DWORD PTR [ebx+816]
	push	eax
	push	DWORD PTR [ebx+808]
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 535  :       if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 40					; 00000028H
	cmp	eax, DWORD PTR [ebx+64]
	jle	$LN27@GetFrame

; 536  :       {
; 537  :         for (int j = 0; j < nBlkY; j++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+68], edi
	jle	$LN27@GetFrame

; 539  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	DWORD PTR $T16[ebp], edi

; 542  :           VXSmallYFF[j*nBlkXP + nBlkX] = std::min(VXSmallYFF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22 Line 522

	mov	DWORD PTR $T4[ebp], edi
	npad	1
$LL28@GetFrame:

; 539  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	esi, DWORD PTR [ebx+872]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T16[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 539  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	edx, DWORD PTR [ebx+792]
	imul	esi, edi
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 539  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [edx+ecx*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 539  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [edx+ecx*2]

; 540  :           //VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX-1], uint8_t (128));
; 541  :           VYSmallYBB[j*nBlkXP + nBlkX] = VYSmallYBB[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 539  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 540  :           //VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX-1], uint8_t (128));
; 541  :           VYSmallYBB[j*nBlkXP + nBlkX] = VYSmallYBB[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+800]
	imul	edx, edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T4[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 542  :           VXSmallYFF[j*nBlkXP + nBlkX] = std::min(VXSmallYFF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22 Line 522

	mov	esi, DWORD PTR [ebx+872]
	mov	edx, DWORD PTR [ebx+808]
	imul	esi, edi
	lea	ecx, DWORD PTR [edx-2]
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
	cmp	bx, WORD PTR [ecx+esi*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 544  :           VYSmallYFF[j*nBlkXP + nBlkX] = VYSmallYFF[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+esi*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 542  :           VXSmallYFF[j*nBlkXP + nBlkX] = std::min(VXSmallYFF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22 Line 522

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 544  :           VYSmallYFF[j*nBlkXP + nBlkX] = VYSmallYFF[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+816]
	imul	edx, edi
	inc	edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
	cmp	edi, DWORD PTR [ebx+68]
	jl	$LL28@GetFrame
$LN27@GetFrame:

; 545  :         }
; 546  :       }
; 547  :       if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+876]
	cmp	eax, DWORD PTR [ebx+68]
	jle	$LN30@GetFrame

; 549  :         for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [ebx+872], edi
	jle	$LN30@GetFrame

; 553  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	mov	DWORD PTR $T3[ebp], edi

; 556  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	mov	DWORD PTR $T11[ebp], edi
	npad	8
$LL31@GetFrame:

; 551  :           VXSmallYBB[nBlkXP*nBlkY + i] = VXSmallYBB[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+872]
	mov	edx, DWORD PTR [ebx+792]
	lea	ecx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	ecx, eax
	add	esi, edi
	add	ecx, edi
	movzx	eax, WORD PTR [edx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T3[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 551  :           VXSmallYBB[nBlkXP*nBlkY + i] = VXSmallYBB[nBlkXP*(nBlkY - 1) + i];

	mov	WORD PTR [edx+esi*2], ax

; 553  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	mov	edi, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+872]
	mov	esi, DWORD PTR [ebx+800]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 553  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	lea	eax, DWORD PTR [edi-1]
	imul	eax, edx
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 554  :           VXSmallYFF[nBlkXP*nBlkY + i] = VXSmallYFF[nBlkXP*(nBlkY - 1) + i];

	mov	ebx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 553  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax

; 554  :           VXSmallYFF[nBlkXP*nBlkY + i] = VXSmallYFF[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+872]
	mov	edx, DWORD PTR [ebx+808]
	lea	ecx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	ecx, eax
	add	esi, DWORD PTR _i$1$[ebp]
	add	ecx, DWORD PTR _i$1$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T11[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 554  :           VXSmallYFF[nBlkXP*nBlkY + i] = VXSmallYFF[nBlkXP*(nBlkY - 1) + i];

	mov	WORD PTR [edx+esi*2], ax

; 556  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	mov	edi, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+872]
	mov	esi, DWORD PTR [ebx+816]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowfps.cpp

; 556  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	lea	eax, DWORD PTR [edi-1]
	imul	eax, edx
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 549  :         for (int i = 0; i < nBlkXP; i++)

	mov	ebx, DWORD PTR _this$[ebp]

; 556  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowfps.cpp

; 556  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22 typecast needed in vs2015

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax
	mov	edi, DWORD PTR _i$1$[ebp]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [ebx+872]
	jl	$LL31@GetFrame
$LN30@GetFrame:

; 557  :         }
; 558  :       }
; 559  :       VectorSmallMaskYToHalfUV(VXSmallYBB, nBlkXP, nBlkYP, VXSmallUVBB, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+796]
	mov	ecx, DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 560  :       VectorSmallMaskYToHalfUV(VYSmallYBB, nBlkXP, nBlkYP, VYSmallUVBB, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+804]
	mov	ecx, DWORD PTR [ebx+800]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 561  :       VectorSmallMaskYToHalfUV(VXSmallYFF, nBlkXP, nBlkYP, VXSmallUVFF, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+812]
	mov	ecx, DWORD PTR [ebx+808]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 562  :       VectorSmallMaskYToHalfUV(VYSmallYFF, nBlkXP, nBlkYP, VYSmallUVFF, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+872]
	push	DWORD PTR [ebx+820]
	mov	ecx, DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+876]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 563  :       PROFILE_STOP(MOTION_PROFILE_MASK);
; 564  : 
; 565  :       PROFILE_START(MOTION_PROFILE_RESIZE);
; 566  :     // upsize vectors to full frame
; 567  :       upsizer->SimpleResizeDo_uint16(VXFullYBB, nWidthP, nHeightP, VPitchY, VXSmallYBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	add	esp, 48					; 00000030H
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+728]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 568  :       upsizer->SimpleResizeDo_uint16(VYFullYBB, nWidthP, nHeightP, VPitchY, VYSmallYBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+800]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+736]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 569  :       upsizerUV->SimpleResizeDo_uint16(VXFullUVBB, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+796]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+732]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 570  :       upsizerUV->SimpleResizeDo_uint16(VYFullUVBB, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+740]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 571  : 
; 572  :       upsizer->SimpleResizeDo_uint16(VXFullYFF, nWidthP, nHeightP, VPitchY, VXSmallYFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+904]
	push	eax
	push	eax
	push	DWORD PTR [ebx+808]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	push	DWORD PTR [ebx+744]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 573  :       upsizer->SimpleResizeDo_uint16(VYFullYFF, nWidthP, nHeightP, VPitchY, VYSmallYFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	push	eax
	push	eax
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+884]
	push	DWORD PTR [ebx+880]
	mov	ecx, DWORD PTR [ebx+904]
	push	DWORD PTR [ebx+752]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 574  :       upsizerUV->SimpleResizeDo_uint16(VXFullUVFF, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+812]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+748]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 575  :       upsizerUV->SimpleResizeDo_uint16(VYFullUVFF, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+872]
	mov	ecx, DWORD PTR [ebx+908]
	push	eax
	push	eax
	push	DWORD PTR [ebx+820]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+892]
	push	DWORD PTR [ebx+888]
	push	DWORD PTR [ebx+756]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 576  :       PROFILE_STOP(MOTION_PROFILE_RESIZE);
; 577  : 
; 578  :       PROFILE_START(MOTION_PROFILE_FLOWINTER);
; 579  :       {
; 580  :         if (pixelsize == 1) {
; 581  :           FlowInterExtra<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	push	DWORD PTR [ebx+752]
	mov	esi, DWORD PTR _time256$1$[ebp]
	push	DWORD PTR [ebx+736]
	mov	eax, DWORD PTR _pSrc$1$[ebp]
	push	DWORD PTR [ebx+744]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	DWORD PTR [ebx+728]
	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR [ebx+104]
	mov	ecx, DWORD PTR _pDst$1$[ebp]
	push	esi
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	push	DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+720]
	push	DWORD PTR [ebx+704]
	push	DWORD PTR [ebx+712]
	push	DWORD PTR [ebx+696]
	push	DWORD PTR _nRefPitches$1$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	cmp	DWORD PTR [ebx+136], 1
	push	eax
	jne	$LN59@GetFrame
	call	??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned char>

; 582  :             VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 583  :             nWidth, nHeight, time256, nPel, VXFullYBB, VXFullYFF, VYFullYBB, VYFullYFF);
; 584  :           FlowInterExtra<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+756]
	mov	edi, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [ebx+740]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+748]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	add	eax, edi
	push	DWORD PTR [ebx+732]
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR [ebx+104]
	push	esi
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, edi
	push	eax
	call	??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned char>
	add	esp, 144				; 00000090H

; 585  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 586  :             nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 587  :           FlowInterExtra<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, edi
	push	DWORD PTR [ebx+756]
	push	DWORD PTR [ebx+740]
	push	DWORD PTR [ebx+748]
	push	DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+104]
	push	esi
	push	DWORD PTR [ebx+860]
	mov	esi, DWORD PTR _pDst$5$[ebp]
	mov	ecx, esi
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, edi
	push	eax
	call	??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned char>
	add	esp, 72					; 00000048H

; 588  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 589  :             nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 590  :         }
; 591  :         else {

	jmp	$LN66@GetFrame
$LN59@GetFrame:

; 592  :           FlowInterExtra<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	call	??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned short>

; 593  :             VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 594  :             nWidth, nHeight, time256, nPel, VXFullYBB, VXFullYFF, VYFullYBB, VYFullYFF);
; 595  :           FlowInterExtra<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+756]
	mov	edi, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [ebx+740]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+748]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	add	eax, edi
	push	DWORD PTR [ebx+732]
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR [ebx+104]
	push	esi
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, edi
	push	eax
	call	??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned short>
	add	esp, 144				; 00000090H

; 596  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 597  :             nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 598  :           FlowInterExtra<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, edi
	push	DWORD PTR [ebx+756]
	push	DWORD PTR [ebx+740]
	push	DWORD PTR [ebx+748]
	push	DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+104]
	push	esi
	push	DWORD PTR [ebx+860]
	mov	esi, DWORD PTR _pDst$5$[ebp]
	mov	ecx, esi
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, edi
	push	eax
	call	??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned short>
	add	esp, 72					; 00000048H

; 599  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 600  :             nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 601  :         }

	jmp	$LN66@GetFrame
$LN55@GetFrame:

; 610  :           FlowInter<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	push	DWORD PTR [ebx+104]
	mov	eax, DWORD PTR _pSrc$1$[ebp]
	push	edi
	push	DWORD PTR [ebx+96]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	DWORD PTR [ebx+92]
	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR [ebx+864]
	mov	ecx, DWORD PTR _pDst$1$[ebp]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+720]
	push	DWORD PTR [ebx+704]
	push	DWORD PTR [ebx+712]
	push	DWORD PTR [ebx+696]
	push	DWORD PTR _nRefPitches$1$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	cmp	DWORD PTR [ebx+648], 1
	push	eax
	jne	$LN61@GetFrame

; 602  :       }
; 603  :       PROFILE_STOP(MOTION_PROFILE_FLOWINTER);
; 604  :     }
; 605  :     else if (maskmode == 1) // old method without extra frames
; 606  :     {
; 607  :       PROFILE_START(MOTION_PROFILE_FLOWINTER);
; 608  :       {
; 609  :         if (pixelsize == 1) {

	cmp	DWORD PTR [ebx+136], 1
	jne	$LN63@GetFrame

; 610  :           FlowInter<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	call	??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned char>

; 611  :             VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 612  :             nWidth, nHeight, time256, nPel);
; 613  :           FlowInter<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+104]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	edi
	push	DWORD PTR [ebx+860]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+856]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+868]
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned char>
	add	esp, 112				; 00000070H

; 614  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 615  :             nWidthUV, nHeightUV, time256, nPel);
; 616  :           FlowInter<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+104]
	push	edi
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned char>

; 617  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 618  :             nWidthUV, nHeightUV, time256, nPel);
; 619  :         }
; 620  :         else { // pixelsize==2

	jmp	$LN627@GetFrame
$LN63@GetFrame:

; 621  :           FlowInter<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	call	??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned short>

; 622  :             VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 623  :             nWidth, nHeight, time256, nPel);
; 624  :           FlowInter<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+104]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	edi
	push	DWORD PTR [ebx+860]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+856]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+868]
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned short>
	add	esp, 112				; 00000070H

; 625  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 626  :             nWidthUV, nHeightUV, time256, nPel);
; 627  :           FlowInter<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+104]
	push	edi
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned short>

; 628  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 629  :             nWidthUV, nHeightUV, time256, nPel);
; 630  :         }
; 631  :       }
; 632  :       PROFILE_STOP(MOTION_PROFILE_FLOWINTER);
; 633  :     }
; 634  :     else // mode=0, faster simple method

	jmp	$LN627@GetFrame
$LN61@GetFrame:

; 635  :     {
; 636  : 
; 637  :       PROFILE_START(MOTION_PROFILE_FLOWINTER);
; 638  :       {
; 639  :         if (pixelsize == 1) {

	cmp	DWORD PTR [ebx+136], 1
	jne	$LN65@GetFrame

; 640  :           FlowInterSimple<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	call	??$FlowInterSimple@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned char>

; 641  :             VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 642  :             nWidth, nHeight, time256, nPel);
; 643  :           FlowInterSimple<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+104]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	edi
	push	DWORD PTR [ebx+860]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+856]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+868]
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInterSimple@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned char>
	add	esp, 112				; 00000070H

; 644  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 645  :             nWidthUV, nHeightUV, time256, nPel);
; 646  :           FlowInterSimple<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+104]
	push	edi
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInterSimple@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned char>

; 647  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 648  :             nWidthUV, nHeightUV, time256, nPel); // 2.5.11.22 Line 598
; 649  :         }
; 650  :         else { // pixelsize==2

	jmp	$LN627@GetFrame
$LN65@GetFrame:

; 651  :           FlowInterSimple<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	call	??$FlowInterSimple@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned short>

; 652  :             VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 653  :             nWidth, nHeight, time256, nPel);
; 654  :           FlowInterSimple<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+104]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	edi
	push	DWORD PTR [ebx+860]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+856]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+868]
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInterSimple@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned short>
	add	esp, 112				; 00000070H

; 655  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 656  :             nWidthUV, nHeightUV, time256, nPel);
; 657  :           FlowInterSimple<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+104]
	push	edi
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+868]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInterSimple@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned short>
$LN627@GetFrame:
	add	esp, 56					; 00000038H
$LN66@GetFrame:

; 658  :             VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 659  :             nWidthUV, nHeightUV, time256, nPel); // 2.5.11.22 Line 598
; 660  :         }
; 661  :       }
; 662  :       PROFILE_STOP(MOTION_PROFILE_FLOWINTER);
; 663  :     }
; 664  :     PROFILE_START(MOTION_PROFILE_YUY2CONVERT);
; 665  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN310@GetFrame
	cmp	BYTE PTR [ebx+665], 0
	jne	SHORT $LN310@GetFrame

; 667  :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	al, BYTE PTR [ebx+664]
	mov	ecx, DWORD PTR [ebx+96]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	test	al, al
; File c:\github\mvtools\sources\mvflowfps.cpp

; 667  :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	edx, DWORD PTR [ebx+92]
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	mov	eax, DWORD PTR _pDst$1$[ebp]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	je	SHORT $LN309@GetFrame
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	al, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	jne	SHORT $LN309@GetFrame

; 155  :     //U and V don't have to be aligned since we user movq to read from those
; 156  :     convert_yv16_to_yuy2_sse2(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	ecx
	push	edx
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	edx, DWORD PTR _pDst$3$[ebp]
	mov	ecx, eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	esi
	call	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_sse2

; 157  :   }
; 158  :   else

	jmp	SHORT $LN628@GetFrame
$LN309@GetFrame:

; 159  :   {
; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	ecx
	push	edx
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	edx, DWORD PTR _pDst$3$[ebp]
	mov	ecx, eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	esi
	call	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_c
$LN628@GetFrame:
	add	esp, 28					; 0000001cH
$LN310@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	eax, eax
	je	SHORT $LN316@GetFrame
	cmp	DWORD PTR [eax], 256			; 00000100H
	jbe	SHORT $LN316@GetFrame
	mov	eax, DWORD PTR [eax+256]
	lea	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	ecx, esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN316@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	eax, eax
	je	SHORT $LN320@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN320@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvBB$10[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN320@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	eax, eax
	je	SHORT $LN325@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN325@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvFF$8[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN325@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN330@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN330@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN330@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	test	eax, eax
	je	SHORT $LN335@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN335@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN335@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	test	eax, eax
	je	SHORT $LN340@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN340@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN340@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	test	eax, eax
	je	SHORT $LN345@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN345@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN345@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 21		; 00000015H
	test	eax, eax
	je	$LN571@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	$LN571@GetFrame
	mov	edx, DWORD PTR [eax+272]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 671  :     return dst;

	jmp	$LN629@GetFrame
$LN39@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 678  :     PVideoFrame src = child->GetFrame(nleft, env); // it is easy to use child here - v2.0

	lea	edx, DWORD PTR _src$13[ebp]
	push	esi
	push	DWORD PTR _nleft$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H

; 679  : 
; 680  :     if (blend) //let's blend src with ref frames like ConvertFPS

	cmp	BYTE PTR [ebx+666], 0
	je	$LN68@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 682  :       PVideoFrame ref = child->GetFrame(nright, env);

	lea	edx, DWORD PTR _ref$17[ebp]
	push	esi
	push	DWORD PTR _nright$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H

; 684  :       if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [ebx+116]
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowfps.cpp

; 684  :       if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN70@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN361@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN361@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$2$[ebp], eax
	jmp	SHORT $LN362@GetFrame
$LN361@GetFrame:
	mov	DWORD PTR _pSrc$2$[ebp], 0
$LN362@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN367@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN367@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$1$[ebp], eax
	jmp	SHORT $LN368@GetFrame
$LN367@GetFrame:
	mov	DWORD PTR _nSrcPitches$1$[ebp], 0
$LN368@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN373@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN373@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$2$[ebp], eax
	jmp	SHORT $LN374@GetFrame
$LN373@GetFrame:
	mov	DWORD PTR _pRef$2$[ebp], 0
$LN374@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN379@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN379@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$2$[ebp], eax
	jmp	SHORT $LN380@GetFrame
$LN379@GetFrame:
	mov	DWORD PTR _nRefPitches$2$[ebp], 0
$LN380@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN385@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN385@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$2$[ebp], eax
	jmp	SHORT $LN386@GetFrame
$LN385@GetFrame:
	mov	DWORD PTR _pDstYUY2$2$[ebp], 0
$LN386@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN391@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN391@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN392@GetFrame
$LN391@GetFrame:
	xor	eax, eax
$LN392@GetFrame:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 693  :         Blend<uint8_t>(pDstYUY2, pSrc[0], pRef[0], nHeight, nWidth * 2, nDstPitchYUY2, nSrcPitches[0], nRefPitches[0], time256, isse);

	mov	edx, DWORD PTR _pSrc$2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDstYUY2$2$[ebp]
	push	edi
	push	DWORD PTR _nRefPitches$2$[ebp]
	push	DWORD PTR _nSrcPitches$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	add	eax, eax
	push	eax
	push	DWORD PTR [ebx+96]
	push	DWORD PTR _pRef$2$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 694  :       }
; 695  :       else

	jmp	$LN630@GetFrame
$LN70@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN397@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN397@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$2$[ebp], eax
	jmp	SHORT $LN398@GetFrame
$LN397@GetFrame:
	mov	DWORD PTR _pDst$2$[ebp], 0
$LN398@GetFrame:
	test	esi, esi
	je	SHORT $LN403@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN403@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$4$[ebp], eax
	jmp	SHORT $LN404@GetFrame
$LN403@GetFrame:
	mov	DWORD PTR _pDst$4$[ebp], 0
$LN404@GetFrame:
	test	esi, esi
	je	SHORT $LN409@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN409@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$6$[ebp], eax
	jmp	SHORT $LN410@GetFrame
$LN409@GetFrame:
	mov	DWORD PTR _pDst$6$[ebp], 0
$LN410@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN415@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN415@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	jmp	SHORT $LN416@GetFrame
$LN415@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN416@GetFrame:
	test	esi, esi
	je	SHORT $LN421@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN421@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$4$[ebp], eax
	jmp	SHORT $LN422@GetFrame
$LN421@GetFrame:
	mov	DWORD PTR _nDstPitches$4$[ebp], 0
$LN422@GetFrame:
	test	esi, esi
	je	SHORT $LN427@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN427@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$6$[ebp], eax
	jmp	SHORT $LN428@GetFrame
$LN427@GetFrame:
	mov	DWORD PTR _nDstPitches$6$[ebp], 0
$LN428@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN433@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN433@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$3$[ebp], eax
	jmp	SHORT $LN434@GetFrame
$LN433@GetFrame:
	mov	DWORD PTR _pRef$3$[ebp], 0
$LN434@GetFrame:
	test	esi, esi
	je	SHORT $LN439@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN439@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$5$[ebp], eax
	jmp	SHORT $LN440@GetFrame
$LN439@GetFrame:
	mov	DWORD PTR _pRef$5$[ebp], 0
$LN440@GetFrame:
	test	esi, esi
	je	SHORT $LN445@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN445@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$7$[ebp], eax
	jmp	SHORT $LN446@GetFrame
$LN445@GetFrame:
	mov	DWORD PTR _pRef$7$[ebp], 0
$LN446@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN451@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN451@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$3$[ebp], eax
	jmp	SHORT $LN452@GetFrame
$LN451@GetFrame:
	mov	DWORD PTR _nRefPitches$3$[ebp], 0
$LN452@GetFrame:
	test	esi, esi
	je	SHORT $LN457@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN457@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$5$[ebp], eax
	jmp	SHORT $LN458@GetFrame
$LN457@GetFrame:
	mov	DWORD PTR _nRefPitches$5$[ebp], 0
$LN458@GetFrame:
	test	esi, esi
	je	SHORT $LN463@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN463@GetFrame
	mov	ecx, DWORD PTR _ref$17[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$7$[ebp], eax
	jmp	SHORT $LN464@GetFrame
$LN463@GetFrame:
	mov	DWORD PTR _nRefPitches$7$[ebp], 0
$LN464@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN469@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN469@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$3$[ebp], eax
	jmp	SHORT $LN470@GetFrame
$LN469@GetFrame:
	mov	DWORD PTR _pSrc$3$[ebp], 0
$LN470@GetFrame:
	test	esi, esi
	je	SHORT $LN475@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN475@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$5$[ebp], eax
	jmp	SHORT $LN476@GetFrame
$LN475@GetFrame:
	mov	DWORD PTR _pSrc$5$[ebp], 0
$LN476@GetFrame:
	test	esi, esi
	je	SHORT $LN481@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN481@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$7$[ebp], eax
	jmp	SHORT $LN482@GetFrame
$LN481@GetFrame:
	mov	DWORD PTR _pSrc$7$[ebp], 0
$LN482@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN487@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN487@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$2$[ebp], eax
	jmp	SHORT $LN488@GetFrame
$LN487@GetFrame:
	mov	DWORD PTR _nSrcPitches$2$[ebp], 0
$LN488@GetFrame:
	test	esi, esi
	je	SHORT $LN493@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN493@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$3$[ebp], eax
	jmp	SHORT $LN494@GetFrame
$LN493@GetFrame:
	mov	DWORD PTR _nSrcPitches$3$[ebp], 0
$LN494@GetFrame:
	test	esi, esi
	je	SHORT $LN499@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN499@GetFrame
	mov	ecx, DWORD PTR _src$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$4$[ebp], eax
	jmp	SHORT $LN500@GetFrame
$LN499@GetFrame:
	mov	DWORD PTR _nSrcPitches$4$[ebp], 0
$LN500@GetFrame:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 723  :         if (pixelsize == 1) {

	cmp	DWORD PTR [ebx+136], 1

; 724  :           Blend<uint8_t>(pDst[0], pSrc[0], pRef[0], nHeight, nWidth, nDstPitches[0], nSrcPitches[0], nRefPitches[0], time256, isse);

	mov	edx, DWORD PTR _pSrc$3$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDst$2$[ebp]
	push	edi
	push	DWORD PTR _nRefPitches$3$[ebp]
	push	DWORD PTR _nSrcPitches$2$[ebp]
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR [ebx+92]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR _pRef$3$[ebp]
	jne	SHORT $LN72@GetFrame
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 725  :           Blend<uint8_t>(pDst[1], pSrc[1], pRef[1], nHeightUV, nWidthUV, nDstPitches[1], nSrcPitches[1], nRefPitches[1], time256, isse);

	mov	edx, DWORD PTR _pSrc$5$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$4$[ebp]
	push	edi
	push	DWORD PTR _nRefPitches$5$[ebp]
	push	DWORD PTR _nSrcPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$4$[ebp]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+860]
	push	DWORD PTR _pRef$5$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 726  :           Blend<uint8_t>(pDst[2], pSrc[2], pRef[2], nHeightUV, nWidthUV, nDstPitches[2], nSrcPitches[2], nRefPitches[2], time256, isse);

	mov	edx, DWORD PTR _pSrc$7$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$6$[ebp]
	push	edi
	push	DWORD PTR _nRefPitches$7$[ebp]
	push	DWORD PTR _nSrcPitches$4$[ebp]
	push	DWORD PTR _nDstPitches$6$[ebp]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+860]
	push	DWORD PTR _pRef$7$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 727  :         }
; 728  :         else {

	jmp	SHORT $LN630@GetFrame
$LN72@GetFrame:

; 729  :           Blend<uint16_t>(pDst[0], pSrc[0], pRef[0], nHeight, nWidth, nDstPitches[0], nSrcPitches[0], nRefPitches[0], time256, isse);

	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>

; 730  :           Blend<uint16_t>(pDst[1], pSrc[1], pRef[1], nHeightUV, nWidthUV, nDstPitches[1], nSrcPitches[1], nRefPitches[1], time256, isse);

	mov	edx, DWORD PTR _pSrc$5$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$4$[ebp]
	push	edi
	push	DWORD PTR _nRefPitches$5$[ebp]
	push	DWORD PTR _nSrcPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$4$[ebp]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+860]
	push	DWORD PTR _pRef$5$[ebp]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>

; 731  :           Blend<uint16_t>(pDst[2], pSrc[2], pRef[2], nHeightUV, nWidthUV, nDstPitches[2], nSrcPitches[2], nRefPitches[2], time256, isse);

	mov	edx, DWORD PTR _pSrc$7$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$6$[ebp]
	push	edi
	push	DWORD PTR _nRefPitches$7$[ebp]
	push	DWORD PTR _nSrcPitches$4$[ebp]
	push	DWORD PTR _nDstPitches$6$[ebp]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR [ebx+860]
	push	DWORD PTR _pRef$7$[ebp]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
$LN630@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\mvflowfps.cpp

; 731  :           Blend<uint16_t>(pDst[2], pSrc[2], pRef[2], nHeightUV, nWidthUV, nDstPitches[2], nSrcPitches[2], nRefPitches[2], time256, isse);

	add	esp, 32					; 00000020H
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	esi, esi
	je	SHORT $LN503@GetFrame
	cmp	DWORD PTR [esi], 256			; 00000100H
	jbe	SHORT $LN503@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN503@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	test	esi, esi
	je	SHORT $LN507@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN507@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _ref$17[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN507@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	test	esi, esi
	je	SHORT $LN512@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN512@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$13[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN512@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	test	esi, esi
	je	SHORT $LN517@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN517@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN517@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	test	esi, esi
	je	SHORT $LN522@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN522@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN522@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	test	esi, esi
	je	SHORT $LN527@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN527@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN527@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	test	esi, esi
	je	SHORT $LN532@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN532@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN532@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 30		; 0000001eH
	test	esi, esi
	je	SHORT $LN537@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN537@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN537@GetFrame:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 736  :       return dst;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 745  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN68@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	edx, edx
	je	SHORT $LN542@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN542@GetFrame
	lea	eax, DWORD PTR _src$13[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN542@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	test	edx, edx
	je	SHORT $LN546@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN546@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$13[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN546@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	test	edx, edx
	je	SHORT $LN551@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN551@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN551@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	test	edx, edx
	je	SHORT $LN556@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN556@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN556@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 34		; 00000022H
	test	edx, edx
	je	SHORT $LN561@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN561@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN561@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 35		; 00000023H
	test	edx, edx
	je	SHORT $LN566@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN566@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN566@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 36		; 00000024H
$LN625@GetFrame:
	test	edx, edx
	je	SHORT $LN571@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN571@GetFrame
	mov	edx, DWORD PTR [edx+272]
$LN629@GetFrame:
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN571@GetFrame:
; File c:\github\mvtools\sources\mvflowfps.cpp

; 745  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _dst$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$14:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR _mvF$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	lea	ecx, DWORD PTR _mvB$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7:
	lea	ecx, DWORD PTR _ref$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9:
	lea	ecx, DWORD PTR _mvFF$8[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10:
	lea	ecx, DWORD PTR _mvBB$10[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$27:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$28:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$29:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$30:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$31:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$32:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11:
	lea	ecx, DWORD PTR _src$13[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12:
	lea	ecx, DWORD PTR _ref$17[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$33:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$34:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$35:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$36:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$37:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$38:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$39:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$40:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$41:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$42:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$43:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$44:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$45:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVFlowFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVFlowFps::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ??$AlignNumber@H@@YAHHH@Z
_TEXT	SEGMENT
??$AlignNumber@H@@YAHHH@Z PROC				; AlignNumber<int>, COMDAT
; _n$ = ecx
; _align$dead$ = edx

; 137  :   assert(IS_POWER2(align));
; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [ecx+15]
	and	eax, -16				; fffffff0H

; 139  : }

	ret	0
??$AlignNumber@H@@YAHHH@Z ENDP				; AlignNumber<int>
_TEXT	ENDS
END
