; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvshow.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BP@MBCMIOJD@MShow?5?3?5wrong?5super?5frame?5clip?$AA@ ; `string'
PUBLIC	??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0CC@DAHFCELA@n?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5vx?$DN?$CFd?5vy?$DN?$CFd?5sad?$DN?$CF@ ; `string'
PUBLIC	??_R1A@?0A@EA@MVShow@@8				; MVShow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2MVShow@@8					; MVShow::`RTTI Base Class Array'
PUBLIC	??_R3MVShow@@8					; MVShow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7MVShow@@6B@					; MVShow::`vftable'
PUBLIC	??_R0?AVMVShow@@@8				; MVShow `RTTI Type Descriptor'
PUBLIC	??_R4MVShow@@6B@				; MVShow::`RTTI Complete Object Locator'
;	COMDAT ??_R4MVShow@@6B@
rdata$r	SEGMENT
??_R4MVShow@@6B@ DD 00H					; MVShow::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVShow@@@8
	DD	FLAT:??_R3MVShow@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVShow@@@8
data$r	SEGMENT
??_R0?AVMVShow@@@8 DD FLAT:??_7type_info@@6B@		; MVShow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVShow@@', 00H
data$r	ENDS
;	COMDAT ??_7MVShow@@6B@
CONST	SEGMENT
??_7MVShow@@6B@ DD FLAT:??_R4MVShow@@6B@		; MVShow::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVShow@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVShow@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3MVShow@@8
rdata$r	SEGMENT
??_R3MVShow@@8 DD 00H					; MVShow::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVShow@@8
rdata$r	ENDS
;	COMDAT ??_R2MVShow@@8
rdata$r	SEGMENT
??_R2MVShow@@8 DD FLAT:??_R1A@?0A@EA@MVShow@@8		; MVShow::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVShow@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVShow@@8 DD FLAT:??_R0?AVMVShow@@@8	; MVShow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVShow@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CC@DAHFCELA@n?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5vx?$DN?$CFd?5vy?$DN?$CFd?5sad?$DN?$CF@
CONST	SEGMENT
??_C@_0CC@DAHFCELA@n?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5vx?$DN?$CFd?5vy?$DN?$CFd?5sad?$DN?$CF@ DB 'n'
	DB	'=%d x=%d y=%d vx=%d vy=%d sad=%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@ DB '%d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MBCMIOJD@MShow?5?3?5wrong?5super?5frame?5clip?$AA@
CONST	SEGMENT
??_C@_0BP@MBCMIOJD@MShow?5?3?5wrong?5super?5frame?5clip?$AA@ DB 'MShow : '
	DB	'wrong super frame clip', 00H		; `string'
PUBLIC	??$DrawPixel@G@MVShow@@QAEXPAEHHHHHH@Z		; MVShow::DrawPixel<unsigned short>
PUBLIC	??$DrawPixel@E@MVShow@@QAEXPAEHHHHHH@Z		; MVShow::DrawPixel<unsigned char>
PUBLIC	??$sprintf_s@$0FA@@@YAHAAY0FA@DPBDZZ		; sprintf_s<80>
PUBLIC	?DrawMVs@MVShow@@QAEXPAEHPBEH@Z			; MVShow::DrawMVs
PUBLIC	?DrawMV@MVShow@@QAEXPAEHHHHHHHHUVECTOR@@H@Z	; MVShow::DrawMV
PUBLIC	?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVShow::GetFrame
PUBLIC	??1MVShow@@UAE@XZ				; MVShow::~MVShow
PUBLIC	??_GMVShow@@UAEPAXI@Z				; MVShow::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVShow@@UAGHHH@Z			; MVShow::SetCacheHints
PUBLIC	?GetOverlapY@FakePlaneOfBlocks@@QBEHXZ		; FakePlaneOfBlocks::GetOverlapY
PUBLIC	?GetOverlapX@FakePlaneOfBlocks@@QBEHXZ		; FakePlaneOfBlocks::GetOverlapX
PUBLIC	?GetPel@FakePlaneOfBlocks@@QBEHXZ		; FakePlaneOfBlocks::GetPel
PUBLIC	?GetBlockSizeY@FakePlaneOfBlocks@@QBEHXZ	; FakePlaneOfBlocks::GetBlockSizeY
PUBLIC	?GetBlockSizeX@FakePlaneOfBlocks@@QBEHXZ	; FakePlaneOfBlocks::GetBlockSizeX
PUBLIC	?GetEffectiveScale@FakePlaneOfBlocks@@QBEHXZ	; FakePlaneOfBlocks::GetEffectiveScale
PUBLIC	?GetHeight@FakePlaneOfBlocks@@QBEHXZ		; FakePlaneOfBlocks::GetHeight
PUBLIC	?GetWidth@FakePlaneOfBlocks@@QBEHXZ		; FakePlaneOfBlocks::GetWidth
PUBLIC	?GetBlockCount@FakePlaneOfBlocks@@QBEHXZ	; FakePlaneOfBlocks::GetBlockCount
PUBLIC	??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z ; MVShow::MVShow
EXTRN	??_EMVShow@@UAEPAXI@Z:PROC			; MVShow::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVShow@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1MVShow@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVShow@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVShow@@UAE@XZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVShow@@UAE@XZ$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
;	COMDAT ??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__super$ = 8						; size = 4
_vectors$ = 12						; size = 4
__scale$ = 16						; size = 4
__plane$ = 20						; size = 4
__tol$ = 24						; size = 4
__showsad$ = 28						; size = 1
__number$ = 32						; size = 4
_nSCD1$ = 36						; size = 4
_nSCD2$ = 40						; size = 4
$T2 = 44						; size = 4
__isse$ = 44						; size = 1
__planar$ = 48						; size = 1
_env$ = 52						; size = 4
??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z PROC ; MVShow::MVShow, COMDAT
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvshow.cpp

; 35   : GenericVideoFilter(_super),

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN20@MVShow
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN20@MVShow
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __super$[ebp]
	push	edx
	call	eax
$LN20@MVShow:
; File c:\github\mvtools\sources\mvshow.cpp

; 35   : GenericVideoFilter(_super),

	mov	ecx, esi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 36   : mvClip(vectors, nSCD1, nSCD2, env, 1, 0),
; 37   : MVFilter(vectors, "MShow", env, 1, 0)

	mov	edi, DWORD PTR _env$[ebp]
	lea	eax, DWORD PTR _vectors$[ebp]
	push	0
	push	1
	push	edi
	push	OFFSET ??_C@_05FPCPEODF@MShow?$AA@
	push	eax
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter
	push	0
	push	1
	push	edi
	push	DWORD PTR _nSCD2$[ebp]
	lea	eax, DWORD PTR _vectors$[ebp]

; 38   : {

	mov	DWORD PTR [esi], OFFSET ??_7MVShow@@6B@
	push	DWORD PTR _nSCD1$[ebp]
	lea	ecx, DWORD PTR [esi+152]
	push	eax
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip

; 39   : 	isse = _isse;

	mov	al, BYTE PTR __isse$[ebp]

; 40   : 	nScale = _scale;
; 41   : 	if ( nScale < 1 )

	mov	ecx, 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR [esi+424], al
	mov	eax, DWORD PTR __scale$[ebp]
	cmp	eax, ecx
	cmovl	eax, ecx

; 45   : 	if ( nPlane < 0 )

	xor	ecx, ecx
	mov	DWORD PTR [esi+392], eax
	mov	eax, DWORD PTR __plane$[ebp]
	test	eax, eax
	cmovs	eax, ecx
; File c:\github\mvtools\sources\mvanalysisdata.h

; 115  :    inline int GetLevelCount() const { return nLvCount; }

	mov	ecx, DWORD PTR [esi+288]
; File c:\github\mvtools\sources\mvshow.cpp

; 45   : 	if ( nPlane < 0 )

	mov	DWORD PTR [esi+396], eax

; 46   :       nPlane = 0;
; 47   :    if ( nPlane >= mvClip.GetLevelCount() - 1 )

	lea	eax, DWORD PTR [ecx-1]
	cmp	DWORD PTR [esi+396], eax
	jl	SHORT $LN4@MVShow

; 48   :       nPlane = mvClip.GetLevelCount() - 1;

	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR [esi+396], eax
$LN4@MVShow:

; 49   : 
; 50   : 	nTolerance = _tol;
; 51   :    if ( nTolerance < 0 )

	mov	eax, DWORD PTR __tol$[ebp]
	xor	ecx, ecx
	test	eax, eax
	cmovs	eax, ecx

; 52   :       nTolerance = 0;
; 53   : 
; 54   : 	showSad = _showsad;
; 55   : 	planar =_planar;
; 56   : 	number = _number;
; 57   : 
; 58   : 	// get parameters of prepared super clip - v2.0
; 59   : 	SuperParams64Bits params;
; 60   : 	memcpy(&params, &vi.num_audio_samples, 8);

	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+400], eax
	mov	al, BYTE PTR __showsad$[ebp]
	mov	BYTE PTR [esi+404], al
	mov	al, BYTE PTR __planar$[ebp]
	mov	BYTE PTR [esi+425], al
	mov	eax, DWORD PTR __number$[ebp]
	mov	DWORD PTR [esi+408], eax

; 61   : 	int nHeightS = params.nHeight;
; 62   : 	nSuperHPad = params.nHPad;

	mov	eax, ecx
	movzx	edx, cx
	shr	eax, 16					; 00000010H

; 63   : 	nSuperVPad = params.nVPad;

	shr	ecx, 24					; 00000018H
	movzx	eax, al
	mov	DWORD PTR [esi+416], ecx

; 64   : 	int nSuperPel = params.nPel;
; 65   : 	int nSuperModeYUV = params.nModeYUV;
; 66   : 	int nSuperLevels = params.nLevels;
; 67   : 	int nSuperWidth = vi.width; // really super

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+412], eax

; 68   : 	int nSuperHeight = vi.height;
; 69   : 
; 70   : 	if (nHeight != nHeightS || nWidth != nSuperWidth-nSuperHPad*2)

	cmp	DWORD PTR [esi+96], edx
	jne	SHORT $LN7@MVShow
	add	eax, eax
	sub	ecx, eax
	cmp	DWORD PTR [esi+92], ecx
	je	SHORT $LN6@MVShow
$LN7@MVShow:

; 71   : 		env->ThrowError("MShow : wrong super frame clip");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BP@MBCMIOJD@MShow?5?3?5wrong?5super?5frame?5clip?$AA@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN6@MVShow:

; 72   : 
; 73   :     vi.height = nHeight + nSuperVPad*2; // one level only (may be redesigned to show all levels with vectors at once)

	mov	ecx, DWORD PTR [esi+416]
	mov	eax, DWORD PTR [esi+96]
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR [esi+20], eax

; 74   : 
; 75   : 	if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN8@MVShow
	cmp	BYTE PTR [esi+425], 0
	jne	SHORT $LN8@MVShow

; 76   :    {
; 77   : 		DstPlanes =  new YUY2Planes(vi.width, vi.height);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes
	mov	DWORD PTR [esi+420], eax
$LN8@MVShow:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN28@MVShow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN28@MVShow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN28@MVShow:
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN36@MVShow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN36@MVShow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _vectors$[ebp]
	call	eax
$LN36@MVShow:
; File c:\github\mvtools\sources\mvshow.cpp

; 79   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _vectors$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR __super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z ENDP ; MVShow::MVShow
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetBlockCount@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetBlockCount@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetBlockCount, COMDAT
; _this$ = ecx

; 63   : 	inline int GetBlockCount() const { return nBlkCount; }

	mov	eax, DWORD PTR [ecx+24]
	ret	0
?GetBlockCount@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetBlockCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetWidth@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetWidth@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetWidth, COMDAT
; _this$ = ecx

; 66   : 	inline int GetWidth() const { return nWidth_Bi; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetWidth@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetHeight@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetHeight@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetHeight, COMDAT
; _this$ = ecx

; 67   : 	inline int GetHeight() const { return nHeight_Bi; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetHeight@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetEffectiveScale@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetEffectiveScale@FakePlaneOfBlocks@@QBEHXZ PROC	; FakePlaneOfBlocks::GetEffectiveScale, COMDAT
; _this$ = ecx

; 69   : 	inline int GetEffectiveScale() const { return nScale; }

	mov	eax, DWORD PTR [ecx+36]
	ret	0
?GetEffectiveScale@FakePlaneOfBlocks@@QBEHXZ ENDP	; FakePlaneOfBlocks::GetEffectiveScale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetBlockSizeX@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetBlockSizeX@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetBlockSizeX, COMDAT
; _this$ = ecx

; 70   : 	inline int GetBlockSizeX() const { return nBlkSizeX; }

	mov	eax, DWORD PTR [ecx+16]
	ret	0
?GetBlockSizeX@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetBlockSizeX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetBlockSizeY@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetBlockSizeY@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetBlockSizeY, COMDAT
; _this$ = ecx

; 71   : 	inline int GetBlockSizeY() const { return nBlkSizeY; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?GetBlockSizeY@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetBlockSizeY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetPel@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetPel@FakePlaneOfBlocks@@QBEHXZ PROC			; FakePlaneOfBlocks::GetPel, COMDAT
; _this$ = ecx

; 72   : 	inline int GetPel() const { return nPel; }

	mov	eax, DWORD PTR [ecx+28]
	ret	0
?GetPel@FakePlaneOfBlocks@@QBEHXZ ENDP			; FakePlaneOfBlocks::GetPel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetOverlapX@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetOverlapX@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetOverlapX, COMDAT
; _this$ = ecx

; 74   : 	inline int GetOverlapX() const { return nOverlapX; }

	mov	eax, DWORD PTR [ecx+44]
	ret	0
?GetOverlapX@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetOverlapX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ?GetOverlapY@FakePlaneOfBlocks@@QBEHXZ
_TEXT	SEGMENT
?GetOverlapY@FakePlaneOfBlocks@@QBEHXZ PROC		; FakePlaneOfBlocks::GetOverlapY, COMDAT
; _this$ = ecx

; 75   : 	inline int GetOverlapY() const { return nOverlapY; }

	mov	eax, DWORD PTR [ecx+48]
	ret	0
?GetOverlapY@FakePlaneOfBlocks@@QBEHXZ ENDP		; FakePlaneOfBlocks::GetOverlapY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.h
;	COMDAT ?SetCacheHints@MVShow@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVShow@@UAGHHH@Z PROC			; MVShow::SetCacheHints, COMDAT

; 73   :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 74   :   }

	ret	12					; 0000000cH
?SetCacheHints@MVShow@@UAGHHH@Z ENDP			; MVShow::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVShow@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVShow@@UAEPAXI@Z PROC				; MVShow::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVShow@@UAE@XZ			; MVShow::~MVShow
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	432					; 000001b0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVShow@@UAEPAXI@Z ENDP				; MVShow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
;	COMDAT ??1MVShow@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVShow@@UAE@XZ PROC					; MVShow::~MVShow, COMDAT
; _this$ = ecx

; 82   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVShow@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 83   :    if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2  && !planar)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [edi], OFFSET ??_7MVShow@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN7@MVShow
	cmp	BYTE PTR [edi+425], 0
	jne	SHORT $LN7@MVShow

; 84   :    {
; 85   : 	delete DstPlanes;

	mov	ebx, DWORD PTR [edi+420]
	test	ebx, ebx
	je	SHORT $LN7@MVShow
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	mov	esi, DWORD PTR __imp___aligned_free
	call	esi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	esi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN7@MVShow:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [edi+216]
	mov	DWORD PTR [edi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN21@MVShow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN21@MVShow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [edi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN21@MVShow:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [edi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN38@MVShow
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN38@MVShow
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [edi+8]
	call	eax
$LN38@MVShow:
; File c:\github\mvtools\sources\mvshow.cpp

; 87   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [edi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvshow.cpp

; 87   : }

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVShow@@UAE@XZ$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVShow@@UAE@XZ$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVShow@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVShow@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVShow@@UAE@XZ ENDP					; MVShow::~MVShow
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\mvclip.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvshow.cpp
;	COMDAT ?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_buf$2 = -172						; size = 80
_buf$3 = -92						; size = 80
__$EHRec$ = -12						; size = 12
$T4 = 0							; size = 4
_mvn$ = 4						; size = 4
_pSrc$3$ = 8						; size = 4
_nSrcPitches$3$ = 12					; size = 4
_pSrc$2$ = 16						; size = 4
_nSrcPitches$2$ = 20					; size = 4
_nDstPitches$3$ = 24					; size = 4
_pDst$3$ = 28						; size = 4
_nDstPitches$2$ = 32					; size = 4
_pSrc$1$ = 36						; size = 4
_pDst$2$ = 40						; size = 4
_nDstPitches$1$ = 44					; size = 4
_src$ = 56						; size = 4
_this$ = 56						; size = 4
___$ReturnUdt$ = 60					; size = 4
_pDst$1$ = 64						; size = 4
_block$1$ = 64						; size = 4
_n$ = 64						; size = 4
_block$2$ = 68						; size = 4
_h$1$ = 68						; size = 4
_pDstYUY2$1$ = 68					; size = 4
_env$ = 68						; size = 4
?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVShow::GetFrame, COMDAT

; 90   : {

	push	ebp
	lea	ebp, DWORD PTR [esp-48]
	sub	esp, 48					; 00000030H
	push	-1
	push	__ehhandler$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 91   : 	PVideoFrame	src = child->GetFrame(n, env);

	lea	edx, DWORD PTR _src$[ebp]
	push	edi
	mov	DWORD PTR $T4[ebp], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	edi, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\mvshow.cpp

; 91   : 	PVideoFrame	src = child->GetFrame(n, env);

	push	DWORD PTR _env$[ebp]
	mov	esi, DWORD PTR _n$[ebp]
	push	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mvshow.cpp

; 91   : 	PVideoFrame	src = child->GetFrame(n, env);

	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 92   : 	PVideoFrame	dst = env->NewVideoFrame(vi);

	lea	edx, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR _env$[ebp]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	32					; 00000020H
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	ebx
	push	ecx
	call	DWORD PTR [eax+56]

; 222  : 	return dst;

	push	DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edi+152]
	lea	ecx, DWORD PTR [edi+152]
	push	esi
	lea	edx, DWORD PTR _mvn$[ebp]
	mov	DWORD PTR $T4[ebp], 1
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	eax, DWORD PTR _mvn$[ebp]
	push	DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR [edi+152]
	push	eax
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN17@GetFrame

; 112  :           }
; 113  :           else

	cmp	BYTE PTR [edi+425], 0
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jne	SHORT $LN19@GetFrame
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [edi+420]
; File c:\github\mvtools\sources\mvshow.cpp

; 106  : 			pDst[0] = DstPlanes->GetPtr();

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDst$1$[ebp], ecx

; 107  : 			pDst[1] = DstPlanes->GetPtrU();

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pDst$2$[ebp], ecx

; 108  : 			pDst[2] = DstPlanes->GetPtrV();

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pDst$3$[ebp], ecx

; 109  : 			nDstPitches[0]  = DstPlanes->GetPitch();

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _nDstPitches$1$[ebp], ecx
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _nDstPitches$2$[ebp], ecx
; File c:\github\mvtools\sources\mvshow.cpp

; 111  : 			nDstPitches[2]  = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$3$[ebp], ecx

; 112  :           }
; 113  :           else

	jmp	$LN20@GetFrame
$LN19@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN56@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN56@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN57@GetFrame
$LN56@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN57@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN62@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN62@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN63@GetFrame
$LN62@GetFrame:
	xor	eax, eax
$LN63@GetFrame:
; File c:\github\mvtools\sources\mvshow.cpp

; 117  :                 pDst[1] = pDst[0] + dst->GetRowSize()/2;

	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _pDst$1$[ebp]
	mov	DWORD PTR _pDst$2$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN68@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN68@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN69@GetFrame
$LN68@GetFrame:
	xor	eax, eax
$LN69@GetFrame:
; File c:\github\mvtools\sources\mvshow.cpp

; 118  :                 pDst[2] = pDst[1] + dst->GetRowSize()/4;

	cdq
	and	edx, 3
	add	edx, eax
	sar	edx, 2
	add	edx, DWORD PTR _pDst$2$[ebp]
	mov	DWORD PTR _pDst$3$[ebp], edx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN74@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN74@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN272@GetFrame
$LN74@GetFrame:
	xor	eax, eax
$LN272@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvshow.cpp

; 120  :                 nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$2$[ebp], eax

; 121  :                 nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$3$[ebp], eax
$LN20@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN80@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN80@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$1$[ebp], eax
	jmp	SHORT $LN81@GetFrame
$LN80@GetFrame:
	mov	DWORD PTR _pSrc$1$[ebp], 0
$LN81@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN86@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN86@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN87@GetFrame
$LN86@GetFrame:
	xor	eax, eax
$LN87@GetFrame:
; File c:\github\mvtools\sources\mvshow.cpp

; 124  :             pSrc[1] = pSrc[0] + src->GetRowSize()/2;

	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	add	ebx, DWORD PTR _pSrc$1$[ebp]
	mov	DWORD PTR _pSrc$2$[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN92@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN92@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN93@GetFrame
$LN92@GetFrame:
	xor	eax, eax
$LN93@GetFrame:
; File c:\github\mvtools\sources\mvshow.cpp

; 125  :             pSrc[2] = pSrc[1] + src->GetRowSize()/4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, ebx
	mov	DWORD PTR _pSrc$3$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN98@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN98@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, eax
; File c:\github\mvtools\sources\mvshow.cpp

; 127  :             nSrcPitches[1] = nSrcPitches[0];

	mov	DWORD PTR _nSrcPitches$2$[ebp], esi

; 128  :             nSrcPitches[2] = nSrcPitches[0];

	mov	DWORD PTR _nSrcPitches$3$[ebp], esi

; 129  : 		}
; 130  : 		else

	jmp	$LN171@GetFrame
$LN98@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	xor	esi, esi
; File c:\github\mvtools\sources\mvshow.cpp

; 127  :             nSrcPitches[1] = nSrcPitches[0];

	mov	DWORD PTR _nSrcPitches$2$[ebp], esi

; 128  :             nSrcPitches[2] = nSrcPitches[0];

	mov	DWORD PTR _nSrcPitches$3$[ebp], esi

; 129  : 		}
; 130  : 		else

	jmp	$LN171@GetFrame
$LN17@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN104@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN104@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	1
	call	eax
	mov	DWORD PTR _pSrc$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN105@GetFrame
$LN104@GetFrame:
	mov	DWORD PTR _pSrc$1$[ebp], 0
$LN105@GetFrame:
	test	eax, eax
	je	SHORT $LN110@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN110@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	2
	call	eax
	mov	DWORD PTR _pSrc$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN111@GetFrame
$LN110@GetFrame:
	mov	DWORD PTR _pSrc$2$[ebp], 0
$LN111@GetFrame:
	test	eax, eax
	je	SHORT $LN116@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN116@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	4
	call	eax
	mov	DWORD PTR _pSrc$3$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN117@GetFrame
$LN116@GetFrame:
	mov	DWORD PTR _pSrc$3$[ebp], 0
$LN117@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN122@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN122@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	esi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN123@GetFrame
$LN122@GetFrame:
	xor	esi, esi
$LN123@GetFrame:
	test	eax, eax
	je	SHORT $LN128@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN128@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	DWORD PTR _nSrcPitches$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN129@GetFrame
$LN128@GetFrame:
	mov	DWORD PTR _nSrcPitches$2$[ebp], 0
$LN129@GetFrame:
	test	eax, eax
	je	SHORT $LN134@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN134@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	DWORD PTR _nSrcPitches$3$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN135@GetFrame
$LN134@GetFrame:
	mov	DWORD PTR _nSrcPitches$3$[ebp], 0
$LN135@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN140@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN140@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+220]
	push	1
	call	eax
	mov	DWORD PTR _pDst$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN141@GetFrame
$LN140@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN141@GetFrame:
	test	eax, eax
	je	SHORT $LN146@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN146@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+220]
	push	2
	call	eax
	mov	DWORD PTR _pDst$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN147@GetFrame
$LN146@GetFrame:
	mov	DWORD PTR _pDst$2$[ebp], 0
$LN147@GetFrame:
	test	eax, eax
	je	SHORT $LN152@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN152@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+220]
	push	4
	call	eax
	mov	DWORD PTR _pDst$3$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN153@GetFrame
$LN152@GetFrame:
	mov	DWORD PTR _pDst$3$[ebp], 0
$LN153@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN158@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN158@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN159@GetFrame
$LN158@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], 0
$LN159@GetFrame:
	test	eax, eax
	je	SHORT $LN164@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN164@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN165@GetFrame
$LN164@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN165@GetFrame:
	test	eax, eax
	je	SHORT $LN170@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN170@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	jmp	SHORT $LN171@GetFrame
$LN170@GetFrame:
	mov	DWORD PTR _nDstPitches$3$[ebp], 0
$LN171@GetFrame:
; File c:\github\mvtools\sources\mvshow.cpp

; 148  :    env->BitBlt(pDst[0], nDstPitches[0], pSrc[0], nSrcPitches[0], vi.width*pixelsize, vi.height);

	push	DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edi+16]
	imul	eax, DWORD PTR [edi+136]
	mov	edx, DWORD PTR _env$[ebp]
	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
	mov	ecx, DWORD PTR [edx]
	push	eax
	push	esi
	push	DWORD PTR _pSrc$1$[ebp]
	mov	esi, DWORD PTR _pDst$1$[ebp]
	push	ebx
	push	esi
	push	edx
	call	DWORD PTR [ecx+64]
; File c:\github\mvtools\sources\include\avisynth.h

; 707  :   bool IsY()   const AVS_BakedCode( return AVS_LinkCallOpt(IsY, IsY8) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN265@GetFrame
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 552				; 00000228H
	ja	SHORT $LN176@GetFrame
	cmp	ecx, 48					; 00000030H
	jbe	SHORT $LN265@GetFrame
	mov	eax, DWORD PTR [eax+48]
	jmp	SHORT $LN273@GetFrame
$LN176@GetFrame:
	mov	eax, DWORD PTR [eax+552]
$LN273@GetFrame:
	lea	ecx, DWORD PTR [edi+16]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvshow.cpp

; 149  :    if (!vi.IsY()) {

	test	al, al
	jne	SHORT $LN21@GetFrame
$LN265@GetFrame:

; 150  :       env->BitBlt(pDst[1], nDstPitches[1], pSrc[1], nSrcPitches[1], vi.width / xRatioUV * pixelsize, vi.height / yRatioUV);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+20]
	cdq
	idiv	DWORD PTR [edi+124]
	push	eax
	mov	eax, DWORD PTR [edi+16]
	cdq
	idiv	DWORD PTR [edi+120]
	imul	eax, DWORD PTR [edi+136]
	push	eax
	push	DWORD PTR _nSrcPitches$2$[ebp]
	push	DWORD PTR _pSrc$2$[ebp]
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	push	DWORD PTR _env$[ebp]
	call	DWORD PTR [ecx+64]

; 151  :       env->BitBlt(pDst[2], nDstPitches[2], pSrc[2], nSrcPitches[2], vi.width / xRatioUV * pixelsize, vi.height / yRatioUV);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+20]
	cdq
	idiv	DWORD PTR [edi+124]
	push	eax
	mov	eax, DWORD PTR [edi+16]
	cdq
	idiv	DWORD PTR [edi+120]
	imul	eax, DWORD PTR [edi+136]
	push	eax
	push	DWORD PTR _nSrcPitches$3$[ebp]
	push	DWORD PTR _pSrc$3$[ebp]
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR _env$[ebp]
	call	DWORD PTR [ecx+64]
$LN21@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [edi+372]
	mov	ecx, DWORD PTR [edi+240]
	push	DWORD PTR [edi+368]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	SHORT $LN22@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [edi+220]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	SHORT $LN22@GetFrame
; File c:\github\mvtools\sources\mvshow.cpp

; 156  :       DrawMVs(pDst[0] + nDstPitches[0]*nSuperVPad + nHPadding*pixelsize, nDstPitches[0], pSrc[0] + nSrcPitches[0]*nSuperVPad + nHPadding*pixelsize, nSrcPitches[0]);

	mov	ecx, DWORD PTR [edi+84]
	sub	esp, 8
	imul	ecx, DWORD PTR [edi+136]
	mov	eax, DWORD PTR [edi+416]
	imul	eax, ebx
	push	ebx
	add	ecx, esi
	add	eax, ecx
	mov	ecx, edi
	push	eax
	call	?DrawMVs@MVShow@@QAEXPAEHPBEH@Z		; MVShow::DrawMVs
$LN22@GetFrame:

; 157  : 
; 158  : 
; 159  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN269@GetFrame
	cmp	BYTE PTR [edi+425], 0
	jne	$LN269@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage

; 976  :   VideoFrame* operator->() const { return p; }

	mov	ecx, DWORD PTR [eax]

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN194@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN194@GetFrame
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN195@GetFrame
$LN194@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN195@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN200@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN200@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edx, eax
	jmp	SHORT $LN201@GetFrame
$LN200@GetFrame:
	xor	edx, edx
$LN201@GetFrame:
; File c:\github\mvtools\sources\mvshow.cpp

; 163  : 			YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, vi.width, vi.height,

	movzx	eax, BYTE PTR [edi+424]
	mov	ecx, DWORD PTR _pDstYUY2$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	push	ebx
	push	DWORD PTR _pDst$1$[ebp]
	push	DWORD PTR [edi+20]
	push	DWORD PTR [edi+16]
	call	?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z	; YUY2FromPlanes
	add	esp, 32					; 00000020H
	jmp	SHORT $LN23@GetFrame
$LN269@GetFrame:
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN23@GetFrame:

; 164  : 								  pDst[0], nDstPitches[0], pDst[1], pDst[2], nDstPitches[1], isse);
; 165  : 		}
; 166  : 
; 167  : 	if ( showSad ) {

	cmp	BYTE PTR [edi+404], 0
	je	$LN27@GetFrame

; 168  : 		char buf[80];
; 169  : #ifndef _M_X64
; 170  :     _mm_empty();

	emms

; 171  : #endif
; 172  : 		double mean = 0;
; 173  : 		int nsc = 0;

	xor	esi, esi
	xorps	xmm1, xmm1

; 175  :       for ( int i = 0; i < mvClip.GetBlkCount(); i++ )

	cmp	DWORD PTR [edi+356], esi
	jle	SHORT $LN3@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [edi+240]
; File c:\github\mvtools\sources\mvshow.cpp

; 177  :          sad_t sad = mvClip.GetBlock(0, i).GetSAD();

	mov	ebx, DWORD PTR [edi+356]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvshow.cpp

; 177  :          sad_t sad = mvClip.GetBlock(0, i).GetSAD();

	mov	edx, DWORD PTR [eax+52]
	add	edx, 16					; 00000010H
$LL4@GetFrame:
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	ecx, DWORD PTR [edx]
	lea	eax, DWORD PTR [esi+1]
; File c:\github\mvtools\sources\mvshow.cpp

; 175  :       for ( int i = 0; i < mvClip.GetBlkCount(); i++ )

	add	edx, 20					; 00000014H
	cmp	ecx, DWORD PTR [edi+368]
	cmovle	eax, esi
	movd	xmm0, ecx
; File c:\github\mvtools\sources\mvclip.h

; 80   :    inline int GetBlkCount() const { return nBlkCount; }

	mov	esi, eax
; File c:\github\mvtools\sources\mvshow.cpp

; 179  : 		 mean += sad;

	cvtdq2pd xmm0, xmm0
	addsd	xmm1, xmm0
	sub	ebx, 1
	jne	SHORT $LL4@GetFrame
	mov	ebx, DWORD PTR _nDstPitches$1$[ebp]
$LN3@GetFrame:

; 180  : 		 if (sad > ThSCD1)
; 181  :             nsc += 1;
; 182  : 	  }
; 183  : 		sprintf_s(buf, "%d %d", int(mean / nBlkCount)*8/nBlkSizeX*8/nBlkSizeY, nsc*256/nBlkCount);

	mov	ecx, DWORD PTR [edi+72]
	shl	esi, 8
	mov	eax, esi
	cdq
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	idiv	ecx
	divsd	xmm1, xmm0
	push	eax
	cvttsd2si eax, xmm1
	shl	eax, 3
	cdq
	idiv	DWORD PTR [edi+76]
	shl	eax, 3
	cdq
	idiv	DWORD PTR [edi+80]
	push	eax
	lea	eax, DWORD PTR _buf$3[ebp]
	push	OFFSET ??_C@_05OKMLJOMC@?$CFd?5?$CFd?$AA@
	push	eax
	call	??$sprintf_s@$0FA@@@YAHAAY0FA@DPBDZZ	; sprintf_s<80>

; 184  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [edi+116]
	add	esp, 16					; 00000010H
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN26@GetFrame
	cmp	BYTE PTR [edi+425], 0
	jne	SHORT $LN26@GetFrame

; 185  : 			DrawStringYUY2(dst, 0, 0, buf);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	lea	eax, DWORD PTR _buf$3[ebp]
	push	eax
	push	0
	call	?DrawStringYUY2@@YAXAAVPVideoFrame@@HHPBD@Z ; DrawStringYUY2
	add	esp, 8

; 186  : 		else

	jmp	SHORT $LN274@GetFrame
$LN26@GetFrame:

; 187  : 			DrawString(dst, vi, 0, 0, buf);

	lea	eax, DWORD PTR _buf$3[ebp]
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	lea	edx, DWORD PTR [edi+16]
	call	?DrawString@@YAXAAVPVideoFrame@@AAUVideoInfo@@HHPBD@Z ; DrawString
	add	esp, 12					; 0000000cH
$LN274@GetFrame:
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN27@GetFrame:

; 188  : 	}
; 189  : 
; 190  : 	if ( number>0 && number <= mvClip.GetBlkCount()) {

	mov	edx, DWORD PTR [edi+408]
	test	edx, edx
	jle	$LN12@GetFrame
	cmp	edx, DWORD PTR [edi+356]
	jg	$LN12@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [edi+240]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	ecx, DWORD PTR [edx+edx*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mvshow.cpp

; 192  : 		FakeBlockData block = mvClip.GetBlock(0, number);

	movups	xmm1, XMMWORD PTR [eax+ecx*4]

; 193  :          int x = block.GetX();
; 194  :          int y = block.GetY();
; 195  : 		sprintf_s(buf, "n=%d x=%d y=%d vx=%d vy=%d sad=%d",number, x, y, block.GetMV().x, block.GetMV().y, block.GetSAD());

	push	DWORD PTR [eax+ecx*4+16]
	movaps	xmm0, xmm1
	movd	esi, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movd	eax, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	push	eax
	movd	eax, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	push	eax
	movd	eax, xmm0
	push	eax
	push	esi
	push	edx
	mov	DWORD PTR _block$2$[ebp], eax
	lea	eax, DWORD PTR _buf$2[ebp]
	push	OFFSET ??_C@_0CC@DAHFCELA@n?$DN?$CFd?5x?$DN?$CFd?5y?$DN?$CFd?5vx?$DN?$CFd?5vy?$DN?$CFd?5sad?$DN?$CF@
	push	eax
	call	??$sprintf_s@$0FA@@@YAHAAY0FA@DPBDZZ	; sprintf_s<80>

; 196  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [edi+116]
	add	esp, 32					; 00000020H
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN29@GetFrame
	cmp	BYTE PTR [edi+425], 0
	jne	SHORT $LN29@GetFrame

; 197  : 			DrawStringYUY2(dst, 0, 0, buf);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax
	push	0
	call	?DrawStringYUY2@@YAXAAVPVideoFrame@@HHPBD@Z ; DrawStringYUY2
	add	esp, 8

; 198  : 		else

	jmp	SHORT $LN30@GetFrame
$LN29@GetFrame:

; 199  : 			DrawString(dst, vi, 0, 0, buf);

	lea	eax, DWORD PTR _buf$2[ebp]
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	lea	edx, DWORD PTR [edi+16]
	call	?DrawString@@YAXAAVPVideoFrame@@AAUVideoInfo@@HHPBD@Z ; DrawString
	add	esp, 12					; 0000000cH
$LN30@GetFrame:

; 200  :     if (pixelsize == 1) {

	mov	edx, DWORD PTR [edi+136]
	cmp	edx, 1
	jne	SHORT $LN31@GetFrame

; 201  :       BYTE *pDstWork = pDst[0] + x + y*nDstPitches[0] + nDstPitches[0] * nSuperVPad + nHPadding;

	mov	edx, DWORD PTR [edi+416]
	add	edx, DWORD PTR _block$2$[ebp]
	imul	edx, ebx
	add	edx, DWORD PTR [edi+84]
	add	edx, DWORD PTR _pDst$1$[ebp]
	add	edx, esi

; 202  :       for (int h = 0; h < nBlkSizeX; h++)

	xor	esi, esi
	cmp	DWORD PTR [edi+76], esi
	jle	$LN270@GetFrame
	mov	ecx, DWORD PTR [edi+80]
$LL7@GetFrame:

; 203  :       {
; 204  :         for (int w = 0; w < nBlkSizeY; w++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN9@GetFrame
	npad	5
$LL10@GetFrame:

; 205  :           pDstWork[w] = 255; // todo pixelsize aware

	mov	BYTE PTR [eax+edx], 255			; 000000ffH
	inc	eax
	mov	ecx, DWORD PTR [edi+80]
	cmp	eax, ecx
	jl	SHORT $LL10@GetFrame
$LN9@GetFrame:

; 202  :       for (int h = 0; h < nBlkSizeX; h++)

	inc	esi

; 206  :         pDstWork += nDstPitches[0];

	add	edx, ebx
	cmp	esi, DWORD PTR [edi+76]
	jl	SHORT $LL7@GetFrame

; 207  :       }
; 208  :     }
; 209  :     else { // pixelsize == 2

	jmp	SHORT $LN270@GetFrame
$LN31@GetFrame:

; 210  :       uint16_t *pDstWork = (uint16_t *)(pDst[0] + x * pixelsize + y*nDstPitches[0] + nDstPitches[0] * nSuperVPad + nHPadding * pixelsize);

	mov	ecx, DWORD PTR [edi+84]
	mov	eax, DWORD PTR [edi+416]
	imul	eax, ebx
	imul	esi, edx
	imul	ecx, edx
	add	DWORD PTR _pDst$1$[ebp], esi
	mov	esi, ebx
	imul	esi, DWORD PTR _block$2$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR _block$1$[ebp]

; 211  :       int pixel_max = (1 << bits_per_pixel) - 1;

	mov	ebx, 1
	add	eax, ecx

; 212  :       for (int h = 0; h < nBlkSizeX; h++)

	mov	DWORD PTR _h$1$[ebp], 0
	mov	ecx, DWORD PTR [edi+140]
	shl	ebx, cl
	add	esi, eax
	dec	ebx
	cmp	DWORD PTR [edi+76], 0
	jle	SHORT $LN270@GetFrame
	mov	ecx, DWORD PTR [edi+80]
$LL13@GetFrame:

; 213  :       {
; 214  :         for (int w = 0; w < nBlkSizeY; w++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN15@GetFrame
	npad	2
$LL16@GetFrame:

; 215  :           pDstWork[w] = pixel_max; // todo pixelsize aware

	mov	WORD PTR [esi+eax*2], bx
	inc	eax
	mov	ecx, DWORD PTR [edi+80]
	cmp	eax, ecx
	jl	SHORT $LL16@GetFrame
$LN15@GetFrame:

; 216  :         pDstWork += nDstPitches[0] / pixelsize;

	mov	eax, DWORD PTR _nDstPitches$1$[ebp]
	cdq
	idiv	DWORD PTR [edi+136]
	mov	edx, DWORD PTR _h$1$[ebp]
	inc	edx
	mov	DWORD PTR _h$1$[ebp], edx
	lea	esi, DWORD PTR [esi+eax*2]
	cmp	edx, DWORD PTR [edi+76]
	jl	SHORT $LL13@GetFrame
$LN270@GetFrame:

; 212  :       for (int h = 0; h < nBlkSizeX; h++)

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN12@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	test	esi, esi
	je	SHORT $LN237@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN237@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvn$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN237@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	esi, esi
	je	SHORT $LN267@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN267@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	edx
$LN267@GetFrame:
; File c:\github\mvtools\sources\mvshow.cpp

; 222  : 	return dst;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 223  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	lea	esp, DWORD PTR [ebp+48]
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN36@GetFrame
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN36@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _mvn$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVShow@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVShow::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.cpp
;	COMDAT ?DrawMV@MVShow@@QAEXPAEHHHHHHHHUVECTOR@@H@Z
_TEXT	SEGMENT
_yLonger$1$ = -9					; size = 1
_pixel160$1$ = -8					; size = 4
_max_pixel_value$1$ = -8				; size = 4
tv593 = -8						; size = 4
tv584 = -8						; size = 4
_this$1$ = -8						; size = 4
_max_pixel_value$1$ = -4				; size = 4
_pDst$ = 8						; size = 4
tv591 = 12						; size = 4
tv590 = 12						; size = 4
_nDstPitch$ = 12					; size = 4
_i$1$ = 16						; size = 4
_decInc$1$ = 16						; size = 4
_scale$ = 16						; size = 4
_x$ = 20						; size = 4
_nDstPitch$2$ = 24					; size = 4
_y$ = 24						; size = 4
_sizex$dead$ = 28					; size = 4
_sizey$dead$ = 32					; size = 4
_w$dead$ = 36						; size = 4
_h$dead$ = 40						; size = 4
_pixel160$1$ = 44					; size = 4
tv596 = 44						; size = 4
tv592 = 44						; size = 4
tv587 = 44						; size = 4
tv585 = 44						; size = 4
_vector$ = 44						; size = 12
_i$1$ = 56						; size = 4
_i$1$ = 56						; size = 4
tv589 = 56						; size = 4
tv586 = 56						; size = 4
_pel$ = 56						; size = 4
?DrawMV@MVShow@@QAEXPAEHHHHHHHHUVECTOR@@H@Z PROC	; MVShow::DrawMV, COMDAT
; _this$ = ecx

; 235  : {

	sub	esp, 12					; 0000000cH

; 236  : 	int x0 =  x; // changed in v1.8, now pDdst is the center of first block
; 237  : 	int y0 =  y;
; 238  : 
; 239  :    bool yLonger = false;
; 240  : 	int incrementVal, endVal;
; 241  : 	int shortLen =  scale*vector.y / pel; // added missed scale - Fizick

	mov	eax, DWORD PTR _vector$[esp+12]
	imul	eax, DWORD PTR _scale$[esp+8]
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$1$[esp+24], ecx
	cdq
	idiv	DWORD PTR _pel$[esp+20]
	push	edi
	mov	ebp, eax
	mov	BYTE PTR _yLonger$1$[esp+28], 0

; 242  : 	int longLen = scale*vector.x / pel;   //

	mov	eax, DWORD PTR _vector$[esp+24]
	imul	eax, DWORD PTR _scale$[esp+24]
	cdq
	idiv	DWORD PTR _pel$[esp+24]
	mov	esi, eax

; 243  : 	if ( abs(shortLen) > abs(longLen)) {

	cdq
	mov	ecx, eax
	mov	eax, ebp
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	jle	SHORT $LN50@DrawMV

; 244  : 		int swap = shortLen;

	mov	eax, ebp

; 245  : 		shortLen = longLen;
; 246  : 		longLen = swap;
; 247  : 		yLonger = true;

	mov	cl, 1
	mov	ebp, esi
	mov	esi, eax
	jmp	SHORT $LN14@DrawMV
$LN50@DrawMV:
	mov	cl, BYTE PTR _yLonger$1$[esp+28]
$LN14@DrawMV:

; 248  : 	}
; 249  : 	endVal = longLen;

	mov	edi, esi

; 250  : 	if (longLen < 0) {

	test	esi, esi
	jns	SHORT $LN15@DrawMV

; 251  : 		incrementVal = -1;

	or	ebx, -1

; 252  : 		longLen = -longLen;

	neg	esi
	jmp	SHORT $LN16@DrawMV
$LN15@DrawMV:

; 253  : 	} else incrementVal = 1;

	mov	ebx, 1
$LN16@DrawMV:

; 254  : 	int decInc;
; 255  : 	if (longLen==0) decInc=0;

	test	esi, esi
	jne	SHORT $LN17@DrawMV
	xor	ebp, ebp
	mov	DWORD PTR _decInc$1$[esp+24], ebp
	jmp	SHORT $LN18@DrawMV
$LN17@DrawMV:

; 256  : 	else decInc = (shortLen << 16) / longLen;

	shl	ebp, 16					; 00000010H
	mov	eax, ebp
	cdq
	idiv	esi
	mov	ebp, eax
	mov	DWORD PTR _decInc$1$[esp+24], eax
$LN18@DrawMV:

; 257  : 	int j=0;
; 258  : 	if (yLonger) {
; 259  :     if (pixelsize == 1) {

	mov	eax, DWORD PTR _this$1$[esp+28]
	xor	esi, esi
	test	cl, cl
	je	$LN19@DrawMV
	cmp	DWORD PTR [eax+136], 1
	jne	SHORT $LN21@DrawMV

; 260  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	DWORD PTR _i$1$[esp+24], esi
	test	edi, edi
	je	$LN12@DrawMV
	mov	ebp, DWORD PTR _nDstPitch$[esp+24]
	xor	ecx, ecx
	imul	eax, ebx, 95
	mov	DWORD PTR tv596[esp+24], ecx
	mov	DWORD PTR tv593[esp+28], eax
	mov	eax, ebx
	imul	eax, ebp
	imul	ebp, DWORD PTR _y$[esp+24]
	mov	DWORD PTR tv591[esp+24], eax
	npad	2
$LL4@DrawMV:

; 261  :         int luma = 255 - i *(255 - 160) / endVal;

	mov	eax, ecx
	or	cl, 255					; 000000ffH
	cdq
	idiv	edi

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	mov	edx, DWORD PTR _x$[esp+24]

; 261  :         int luma = 255 - i *(255 - 160) / endVal;

	sub	cl, al

; 262  :         DrawPixel<uint8_t>(pDst, nDstPitch, x0 + (j >> 16), y0 + i, w, h, luma);

	mov	eax, esi

; 263  :         j += decInc;

	add	esi, DWORD PTR _decInc$1$[esp+24]
	sar	eax, 16					; 00000010H

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	add	eax, ebp

; 260  :       for (int i = 0; i != endVal; i += incrementVal) {

	add	ebp, DWORD PTR tv591[esp+24]

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	add	eax, DWORD PTR _pDst$[esp+24]
	mov	BYTE PTR [eax+edx], cl

; 260  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	eax, DWORD PTR _i$1$[esp+24]
	mov	ecx, DWORD PTR tv596[esp+24]
	add	eax, ebx
	add	ecx, DWORD PTR tv593[esp+28]
	mov	DWORD PTR _i$1$[esp+24], eax
	mov	DWORD PTR tv596[esp+24], ecx
	cmp	eax, edi
	jne	SHORT $LL4@DrawMV
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 290  :       }
; 291  :     }
; 292  : 	}
; 293  : }

	add	esp, 12					; 0000000cH
	ret	52					; 00000034H
$LN21@DrawMV:

; 264  :       }
; 265  :     }
; 266  :     else { // pixelsize == 2
; 267  :       const int max_pixel_value = (1 << bits_per_pixel) - 1;

	mov	ecx, DWORD PTR [eax+140]

; 268  :       const int pixel160 = 160 << (bits_per_pixel - 8);

	mov	edx, 160				; 000000a0H
	mov	eax, 1

; 269  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	DWORD PTR _i$1$[esp+24], esi
	shl	eax, cl
	add	ecx, -8					; fffffff8H
	dec	eax
	shl	edx, cl
	mov	DWORD PTR _max_pixel_value$1$[esp+28], eax
	mov	DWORD PTR _pixel160$1$[esp+24], edx
	test	edi, edi
	je	$LN12@DrawMV

; 264  :       }
; 265  :     }
; 266  :     else { // pixelsize == 2
; 267  :       const int max_pixel_value = (1 << bits_per_pixel) - 1;

	sub	eax, DWORD PTR _pixel160$1$[esp+24]
	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[esp+24]
	imul	eax, ebx
	mov	DWORD PTR tv589[esp+24], edx
	mov	DWORD PTR tv587[esp+24], eax
	mov	eax, ebx
	imul	eax, ecx
	imul	ecx, DWORD PTR _y$[esp+24]
	mov	DWORD PTR tv590[esp+24], eax
	mov	DWORD PTR _nDstPitch$2$[esp+24], ecx
	npad	5
$LL7@DrawMV:

; 270  :         int luma = max_pixel_value - i *(max_pixel_value - pixel160) / endVal;

	mov	eax, edx

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	shr	ecx, 1

; 270  :         int luma = max_pixel_value - i *(max_pixel_value - pixel160) / endVal;

	cdq
	idiv	edi
	mov	edx, DWORD PTR _max_pixel_value$1$[esp+28]

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	add	ecx, DWORD PTR _x$[esp+24]

; 270  :         int luma = max_pixel_value - i *(max_pixel_value - pixel160) / endVal;

	sub	edx, eax

; 271  :         DrawPixel<uint16_t>(pDst, nDstPitch, x0 + (j >> 16), y0 + i, w, h, luma);

	mov	eax, esi

; 272  :         j += decInc;

	add	esi, ebp
	sar	eax, 16					; 00000010H

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	add	eax, ecx
	mov	ecx, DWORD PTR _pDst$[esp+24]
	mov	WORD PTR [ecx+eax*2], dx

; 269  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	eax, DWORD PTR _i$1$[esp+24]
	mov	ecx, DWORD PTR _nDstPitch$2$[esp+24]
	add	eax, ebx
	mov	edx, DWORD PTR tv589[esp+24]
	add	ecx, DWORD PTR tv590[esp+24]
	add	edx, DWORD PTR tv587[esp+24]
	mov	DWORD PTR _i$1$[esp+24], eax
	mov	DWORD PTR _nDstPitch$2$[esp+24], ecx
	mov	DWORD PTR tv589[esp+24], edx
	cmp	eax, edi
	jne	SHORT $LL7@DrawMV
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 290  :       }
; 291  :     }
; 292  : 	}
; 293  : }

	add	esp, 12					; 0000000cH
	ret	52					; 00000034H
$LN19@DrawMV:

; 273  :       }
; 274  :     }
; 275  : 	} else {
; 276  :     if (pixelsize == 1) {

	cmp	DWORD PTR [eax+136], 1
	jne	SHORT $LN23@DrawMV

; 277  :       for (int i = 0; i != endVal; i += incrementVal) {

	xor	ebp, ebp
	test	edi, edi
	je	$LN12@DrawMV
	xor	eax, eax
	imul	ecx, ebx, 95
	mov	DWORD PTR tv586[esp+24], eax
	mov	DWORD PTR tv592[esp+24], ecx
$LL10@DrawMV:

; 278  :         int luma = 255 - i *(255 - 160) / endVal;

	cdq
	or	cl, 255					; 000000ffH
	idiv	edi

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	mov	edx, DWORD PTR _x$[esp+24]

; 278  :         int luma = 255 - i *(255 - 160) / endVal;

	sub	cl, al

; 279  :         DrawPixel<uint8_t>(pDst, nDstPitch, x0 + i, y0 + (j >> 16), w, h, luma);

	mov	eax, esi

; 280  :         j += decInc;

	add	esi, DWORD PTR _decInc$1$[esp+24]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _y$[esp+24]

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	imul	eax, DWORD PTR _nDstPitch$[esp+24]
	add	eax, ebp

; 277  :       for (int i = 0; i != endVal; i += incrementVal) {

	add	ebp, ebx

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	add	eax, DWORD PTR _pDst$[esp+24]
	mov	BYTE PTR [eax+edx], cl

; 277  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	eax, DWORD PTR tv586[esp+24]
	add	eax, DWORD PTR tv592[esp+24]
	mov	DWORD PTR tv586[esp+24], eax
	cmp	ebp, edi
	jne	SHORT $LL10@DrawMV
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 290  :       }
; 291  :     }
; 292  : 	}
; 293  : }

	add	esp, 12					; 0000000cH
	ret	52					; 00000034H
$LN23@DrawMV:

; 281  :       }
; 282  :     }
; 283  :     else { // pixelsize == 2
; 284  :       const int max_pixel_value = (1 << bits_per_pixel) - 1;

	mov	ecx, DWORD PTR [eax+140]
	mov	edx, 1
	shl	edx, cl

; 285  :       const int pixel160 = 160 << (bits_per_pixel - 8);

	mov	eax, 160				; 000000a0H
	add	ecx, -8					; fffffff8H

; 286  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	DWORD PTR _i$1$[esp+24], esi
	dec	edx
	shl	eax, cl
	mov	DWORD PTR _max_pixel_value$1$[esp+28], edx
	mov	DWORD PTR _pixel160$1$[esp+28], eax
	test	edi, edi
	je	SHORT $LN12@DrawMV

; 281  :       }
; 282  :     }
; 283  :     else { // pixelsize == 2
; 284  :       const int max_pixel_value = (1 << bits_per_pixel) - 1;

	mov	ecx, edx
	xor	eax, eax
	sub	ecx, DWORD PTR _pixel160$1$[esp+28]
	imul	ecx, ebx
	mov	DWORD PTR tv585[esp+24], eax
	mov	DWORD PTR tv584[esp+28], ecx
$LL13@DrawMV:

; 287  :         int luma = max_pixel_value - i *(max_pixel_value - pixel160) / endVal;

	cdq
	idiv	edi
	mov	ecx, DWORD PTR _max_pixel_value$1$[esp+28]

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	mov	edx, DWORD PTR _i$1$[esp+24]

; 287  :         int luma = max_pixel_value - i *(max_pixel_value - pixel160) / endVal;

	sub	ecx, eax

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	mov	ebp, DWORD PTR _pDst$[esp+24]

; 288  :         DrawPixel<uint16_t>(pDst, nDstPitch, x0 + i, y0 + (j >> 16), w, h, luma);

	mov	eax, esi

; 289  :         j += decInc;

	add	esi, DWORD PTR _decInc$1$[esp+24]
	sar	eax, 16					; 00000010H
	add	eax, DWORD PTR _y$[esp+24]

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	imul	eax, DWORD PTR _nDstPitch$[esp+24]
	shr	eax, 1
	add	eax, edx

; 286  :       for (int i = 0; i != endVal; i += incrementVal) {

	add	edx, ebx

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	add	eax, DWORD PTR _x$[esp+24]

; 286  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	DWORD PTR _i$1$[esp+24], edx

; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	mov	WORD PTR [ebp+eax*2], cx

; 286  :       for (int i = 0; i != endVal; i += incrementVal) {

	mov	eax, DWORD PTR tv585[esp+24]
	add	eax, DWORD PTR tv584[esp+28]
	mov	DWORD PTR tv585[esp+24], eax
	cmp	edx, edi
	jne	SHORT $LL13@DrawMV
$LN12@DrawMV:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 290  :       }
; 291  :     }
; 292  : 	}
; 293  : }

	add	esp, 12					; 0000000cH
	ret	52					; 00000034H
?DrawMV@MVShow@@QAEXPAEHHHHHHHHUVECTOR@@H@Z ENDP	; MVShow::DrawMV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvshow.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvshow.cpp
;	COMDAT ?DrawMVs@MVShow@@QAEXPAEHPBEH@Z
_TEXT	SEGMENT
_effectiveScale$1$ = -4					; size = 4
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_pSrc$dead$ = 16					; size = 4
_nSrcPitch$dead$ = 20					; size = 4
?DrawMVs@MVShow@@QAEXPAEHPBEH@Z PROC			; MVShow::DrawMVs, COMDAT
; _this$ = ecx

; 297  : {

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi

; 322  : 	for ( int i = 0; i < plane.GetBlockCount(); i++ )

	xor	edi, edi
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebp+396]
	mov	esi, DWORD PTR [ebp+240]
	mov	esi, DWORD PTR [esi+eax*4]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 69   : 	inline int GetEffectiveScale() const { return nScale; }

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR _effectiveScale$1$[esp+20], eax
; File c:\github\mvtools\sources\mvshow.cpp

; 322  : 	for ( int i = 0; i < plane.GetBlockCount(); i++ )

	cmp	DWORD PTR [esi+24], edi
	jle	$LN3@DrawMVs

; 298  : 	const FakePlaneOfBlocks &plane = mvClip.GetPlane(nPlane);

	xor	ebx, ebx
	npad	6
$LL4@DrawMVs:
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edx, DWORD PTR [esi+52]
	add	edx, ebx
; File c:\github\mvtools\sources\mvshow.cpp

; 323  : 		if ( plane[i].GetSAD() < nTolerance )

	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [ebp+400]
	jge	SHORT $LN2@DrawMVs

; 324  :       // /2: center
; 325  : 			DrawMV(pDst + plane.GetBlockSizeX() / 2 * effectiveScale * pixelsize + plane.GetBlockSizeY()/ 2 * effectiveScale*nDstPitch, // changed in v1.8, now address is the center of first block

	push	DWORD PTR [esi+28]
	movq	xmm0, QWORD PTR [edx+8]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	sub	esp, 16					; 00000010H
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _effectiveScale$1$[esp+52]
	imul	eax, ecx
	push	eax
	mov	eax, DWORD PTR [edx]
	imul	eax, ecx
	push	eax
	mov	eax, DWORD PTR [ebp+392]
	imul	eax, ecx
	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	DWORD PTR _nDstPitch$[esp+60]
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+20]
	cdq
	sar	ecx, 1
	sub	eax, edx
	imul	ecx, DWORD PTR [ebp+136]
	sar	eax, 1
	imul	eax, DWORD PTR _nDstPitch$[esp+64]
	add	ecx, eax
	imul	ecx, DWORD PTR _effectiveScale$1$[esp+68]
	add	ecx, DWORD PTR _pDst$[esp+64]
	push	ecx
	mov	ecx, ebp
	call	?DrawMV@MVShow@@QAEXPAEHHHHHHHHUVECTOR@@H@Z ; MVShow::DrawMV
$LN2@DrawMVs:

; 322  : 	for ( int i = 0; i < plane.GetBlockCount(); i++ )

	inc	edi
	add	ebx, 20					; 00000014H
	cmp	edi, DWORD PTR [esi+24]
	jl	SHORT $LL4@DrawMVs
$LN3@DrawMVs:

; 326  : 			    nDstPitch, nScale * effectiveScale, plane[i].GetX() * effectiveScale,
; 327  : 				plane[i].GetY() * effectiveScale, (plane.GetBlockSizeX() - plane.GetOverlapX())* effectiveScale,
; 328  : 				(plane.GetBlockSizeY() - plane.GetOverlapY())* effectiveScale,
; 329  :                 plane.GetWidth() * effectiveScale, plane.GetHeight() * effectiveScale,
; 330  :                 plane[i].GetMV(), plane.GetPel());
; 331  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
?DrawMVs@MVShow@@QAEXPAEHPBEH@Z ENDP			; MVShow::DrawMVs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT ??$sprintf_s@$0FA@@@YAHAAY0FA@DPBDZZ
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0FA@@@YAHAAY0FA@DPBDZZ PROC		; sprintf_s<80>, COMDAT

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	80					; 00000050H
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1499 : }
; 1500 : #endif
; 1501 : 
; 1502 : #if __STDC_WANT_SECURE_LIB__
; 1503 : 
; 1504 :     _Success_(return >= 0)
; 1505 :     _Check_return_opt_
; 1506 :     _CRT_STDIO_INLINE int __CRTDECL vsprintf_s(
; 1507 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1508 :         _In_                          size_t      const _BufferCount,
; 1509 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1510 :                                       va_list           _ArgList
; 1511 :         )
; 1512 : #if defined _NO_CRT_STDIO_INLINE
; 1513 : ;
; 1514 : #else
; 1515 :     {
; 1516 :         return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1517 :     }
; 1518 : #endif
; 1519 :     
; 1520 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
; 1521 :         _Success_(return >= 0)
; 1522 :         int, vsprintf_s,
; 1523 :         _Post_z_                      char,        _Buffer,
; 1524 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1525 :                                       va_list,     _ArgList
; 1526 :         )
; 1527 : 
; 1528 : #endif
; 1529 : 
; 1530 : _Success_(return >= 0)
; 1531 : _Check_return_opt_
; 1532 : _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p_l(
; 1533 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1534 :     _In_                                    size_t      const _BufferCount,
; 1535 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1536 :     _In_opt_                                _locale_t   const _Locale,
; 1537 :                                             va_list           _ArgList
; 1538 :     )
; 1539 : #if defined _NO_CRT_STDIO_INLINE
; 1540 : ;
; 1541 : #else
; 1542 : {
; 1543 :     int const _Result = __stdio_common_vsprintf_p(
; 1544 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1545 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1546 : 
; 1547 :     return _Result < 0 ? -1 : _Result;
; 1548 : }
; 1549 : #endif
; 1550 : 
; 1551 : _Success_(return >= 0)
; 1552 : _Check_return_opt_
; 1553 : _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p(
; 1554 :     _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1555 :     _In_                          size_t      const _BufferCount,
; 1556 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1557 :                                   va_list           _ArgList
; 1558 :     )
; 1559 : #if defined _NO_CRT_STDIO_INLINE
; 1560 : ;
; 1561 : #else
; 1562 : {
; 1563 :     return _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1564 : }
; 1565 : #endif
; 1566 : 
; 1567 : _Success_(return >= 0)
; 1568 : _Check_return_opt_
; 1569 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s_l(
; 1570 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1571 :     _In_                                    size_t      const _BufferCount,
; 1572 :     _In_                                    size_t      const _MaxCount,
; 1573 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1574 :     _In_opt_                                _locale_t   const _Locale,
; 1575 :                                             va_list          _ArgList
; 1576 :     )
; 1577 : #if defined _NO_CRT_STDIO_INLINE
; 1578 : ;
; 1579 : #else
; 1580 : {
; 1581 :     int const _Result = __stdio_common_vsnprintf_s(
; 1582 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1583 :         _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1584 : 
; 1585 :     return _Result < 0 ? -1 : _Result;
; 1586 : }
; 1587 : #endif
; 1588 : 
; 1589 : _Success_(return >= 0)
; 1590 : _Check_return_opt_
; 1591 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s(
; 1592 :     _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1593 :     _In_                          size_t      const _BufferCount,
; 1594 :     _In_                          size_t      const _MaxCount,
; 1595 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1596 :                                   va_list           _ArgList
; 1597 :     )
; 1598 : #if defined _NO_CRT_STDIO_INLINE
; 1599 : ;
; 1600 : #else
; 1601 : {
; 1602 :     return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1603 : }
; 1604 : #endif
; 1605 : 
; 1606 : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1607 :     _Success_(return >= 0)
; 1608 :     int, _vsnprintf_s,
; 1609 :     _Post_z_                      char,        _Buffer,
; 1610 :     _In_                          size_t,      _BufferCount,
; 1611 :     _In_z_ _Printf_format_string_ char const*, _Format,
; 1612 :                                   va_list,     _ArgList
; 1613 :     )
; 1614 : 
; 1615 : #if __STDC_WANT_SECURE_LIB__
; 1616 : 
; 1617 :     _Success_(return >= 0)
; 1618 :     _Check_return_opt_
; 1619 :     _CRT_STDIO_INLINE int __CRTDECL vsnprintf_s(
; 1620 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1621 :         _In_                          size_t      const _BufferCount,
; 1622 :         _In_                          size_t      const _MaxCount,
; 1623 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1624 :                                       va_list           _ArgList
; 1625 :         )
; 1626 : #if defined _NO_CRT_STDIO_INLINE
; 1627 : ;
; 1628 : #else
; 1629 :     {
; 1630 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1631 :     }
; 1632 : #endif
; 1633 :     
; 1634 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1635 :         _Success_(return >= 0)
; 1636 :         int, vsnprintf_s,
; 1637 :         _Post_z_                      char,        _Buffer,
; 1638 :         _In_                          size_t,      _BufferCount,
; 1639 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1640 :                                       va_list,     _ArgList
; 1641 :         )
; 1642 : 
; 1643 : #endif
; 1644 : 
; 1645 : _Check_return_opt_
; 1646 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_l(
; 1647 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1648 :     _In_opt_                                _locale_t   const _Locale,
; 1649 :                                             va_list           _ArgList
; 1650 :     )
; 1651 : #if defined _NO_CRT_STDIO_INLINE
; 1652 : ;
; 1653 : #else
; 1654 : {
; 1655 :     int const _Result = __stdio_common_vsprintf(
; 1656 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1657 :         NULL, 0, _Format, _Locale, _ArgList);
; 1658 : 
; 1659 :     return _Result < 0 ? -1 : _Result;
; 1660 : }
; 1661 : #endif
; 1662 : 
; 1663 : _Check_return_
; 1664 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf(
; 1665 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1666 :                                   va_list           _ArgList
; 1667 :     )
; 1668 : #if defined _NO_CRT_STDIO_INLINE
; 1669 : ;
; 1670 : #else
; 1671 : {
; 1672 :     return _vscprintf_l(_Format, NULL, _ArgList);
; 1673 : }
; 1674 : #endif
; 1675 : 
; 1676 : _Check_return_opt_
; 1677 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p_l(
; 1678 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1679 :     _In_opt_                                _locale_t   const _Locale,
; 1680 :                                             va_list           _ArgList
; 1681 :     )
; 1682 : #if defined _NO_CRT_STDIO_INLINE
; 1683 : ;
; 1684 : #else
; 1685 : {
; 1686 :     int const _Result = __stdio_common_vsprintf_p(
; 1687 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1688 :         NULL, 0, _Format, _Locale, _ArgList);
; 1689 : 
; 1690 :     return _Result < 0 ? -1 : _Result;
; 1691 : }
; 1692 : #endif
; 1693 : 
; 1694 : _Check_return_
; 1695 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p(
; 1696 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1697 :                                   va_list           _ArgList
; 1698 :     )
; 1699 : #if defined _NO_CRT_STDIO_INLINE
; 1700 : ;
; 1701 : #else
; 1702 : {
; 1703 :     return _vscprintf_p_l(_Format, NULL, _ArgList);
; 1704 : }
; 1705 : #endif
; 1706 : 
; 1707 : _Check_return_opt_
; 1708 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c_l(
; 1709 :     _Out_writes_(_BufferCount)              char*       const _Buffer,
; 1710 :     _In_                                    size_t      const _BufferCount,
; 1711 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1712 :     _In_opt_                                _locale_t   const _Locale,
; 1713 :                                             va_list           _ArgList
; 1714 :     )
; 1715 : #if defined _NO_CRT_STDIO_INLINE
; 1716 : ;
; 1717 : #else
; 1718 : {
; 1719 :     int const _Result = __stdio_common_vsprintf(
; 1720 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1721 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1722 : 
; 1723 :     return _Result < 0 ? -1 : _Result;
; 1724 : }
; 1725 : #endif
; 1726 : 
; 1727 : _Success_(return >= 0)
; 1728 : _Check_return_opt_
; 1729 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c(
; 1730 :     _Out_writes_(_BufferCount)    char*       const _Buffer,
; 1731 :     _In_                          size_t      const _BufferCount,
; 1732 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1733 :                                   va_list           _ArgList
; 1734 :     )
; 1735 : #if defined _NO_CRT_STDIO_INLINE
; 1736 : ;
; 1737 : #else
; 1738 : {
; 1739 :     return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1740 : }
; 1741 : #endif
; 1742 : 
; 1743 : _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l)
; 1744 : _CRT_STDIO_INLINE int __CRTDECL _sprintf_l(
; 1745 :     _Pre_notnull_ _Post_z_                  char*       const _Buffer,
; 1746 :     _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1747 :     _In_opt_                                _locale_t   const _Locale,
; 1748 :     ...)
; 1749 : #if defined _NO_CRT_STDIO_INLINE
; 1750 : ;
; 1751 : #else
; 1752 : {
; 1753 :     int _Result;
; 1754 :     va_list _ArgList;
; 1755 :     __crt_va_start(_ArgList, _Locale);
; 1756 : 
; 1757 :     #pragma warning(push)
; 1758 :     #pragma warning(disable: 4996) // Deprecation
; 1759 :     _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
; 1760 :     #pragma warning(pop)
; 1761 : 
; 1762 :     __crt_va_end(_ArgList);
; 1763 :     return _Result;
; 1764 : }
; 1765 : #endif
; 1766 : 
; 1767 : _Success_(return >= 0)
; 1768 : _Check_return_opt_
; 1769 : _CRT_STDIO_INLINE int __CRTDECL sprintf(
; 1770 :     _Pre_notnull_ _Post_z_        char*       const _Buffer,
; 1771 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1772 :     ...)
; 1773 : #if defined _NO_CRT_STDIO_INLINE
; 1774 : ;
; 1775 : #else
; 1776 : {
; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }
; 1789 : #endif
; 1790 : 
; 1791 : #pragma warning(push)
; 1792 : #pragma warning(disable: 4996)
; 1793 : __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(
; 1794 :     _Success_(return >= 0)
; 1795 :     int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, sprintf, vsprintf,
; 1796 :     _Pre_notnull_ _Post_z_,       char,        _Buffer,
; 1797 :     _In_z_ _Printf_format_string_ char const*, _Format
; 1798 :     )
; 1799 : #pragma warning(pop)
; 1800 : 
; 1801 : _Success_(return >= 0)
; 1802 : _Check_return_opt_
; 1803 : _CRT_STDIO_INLINE int __CRTDECL _sprintf_s_l(
; 1804 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1805 :     _In_                                    size_t      const _BufferCount,
; 1806 :     _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1807 :     _In_opt_                                _locale_t   const _Locale,
; 1808 :     ...)
; 1809 : #if defined _NO_CRT_STDIO_INLINE
; 1810 : ;
; 1811 : #else
; 1812 : {
; 1813 :     int _Result;
; 1814 :     va_list _ArgList;
; 1815 :     __crt_va_start(_ArgList, _Locale);
; 1816 :     _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1817 :     __crt_va_end(_ArgList);
; 1818 :     return _Result;
; 1819 : }
; 1820 : #endif
; 1821 : 
; 1822 : #if __STDC_WANT_SECURE_LIB__
; 1823 : 
; 1824 :     _Success_(return >= 0)
; 1825 :     _Check_return_opt_
; 1826 :     _CRT_STDIO_INLINE int __CRTDECL sprintf_s(
; 1827 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1828 :         _In_                          size_t      const _BufferCount,
; 1829 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1830 :         ...)
; 1831 : #if defined _NO_CRT_STDIO_INLINE
; 1832 : ;
; 1833 : #else
; 1834 :     {
; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }
; 1842 : #endif
; 1843 : 
; 1844 : #endif
; 1845 : 
; 1846 : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(

	ret	0
??$sprintf_s@$0FA@@@YAHAAY0FA@DPBDZZ ENDP		; sprintf_s<80>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.cpp
;	COMDAT ??$DrawPixel@E@MVShow@@QAEXPAEHHHHHH@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_w$dead$ = 24						; size = 4
_h$dead$ = 28						; size = 4
_luma$ = 32						; size = 4
??$DrawPixel@E@MVShow@@QAEXPAEHHHHHH@Z PROC		; MVShow::DrawPixel<unsigned char>, COMDAT
; _this$dead$ = ecx

; 228  : //	if (( x >= 0 ) && ( x < w ) && ( y >= 0 ) && ( y < h )) // disababled in v.2 - it is no more needed with super clip
; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	mov	edx, DWORD PTR _nDstPitch$[esp-4]
	imul	edx, DWORD PTR _y$[esp-4]
	mov	eax, DWORD PTR _x$[esp-4]
	mov	cl, BYTE PTR _luma$[esp-4]
	add	edx, DWORD PTR _pDst$[esp-4]
	mov	BYTE PTR [edx+eax], cl

; 230  : }

	ret	28					; 0000001cH
??$DrawPixel@E@MVShow@@QAEXPAEHHHHHH@Z ENDP		; MVShow::DrawPixel<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvshow.cpp
;	COMDAT ??$DrawPixel@G@MVShow@@QAEXPAEHHHHHH@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_nDstPitch$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_w$dead$ = 24						; size = 4
_h$dead$ = 28						; size = 4
_luma$ = 32						; size = 4
??$DrawPixel@G@MVShow@@QAEXPAEHHHHHH@Z PROC		; MVShow::DrawPixel<unsigned short>, COMDAT
; _this$dead$ = ecx

; 228  : //	if (( x >= 0 ) && ( x < w ) && ( y >= 0 ) && ( y < h )) // disababled in v.2 - it is no more needed with super clip
; 229  : 		reinterpret_cast<pixel_t *>(pDst)[x + y * nDstPitch / sizeof(pixel_t)] = luma;

	mov	edx, DWORD PTR _nDstPitch$[esp-4]
	imul	edx, DWORD PTR _y$[esp-4]
	mov	eax, DWORD PTR _pDst$[esp-4]
	mov	cx, WORD PTR _luma$[esp-4]
	shr	edx, 1
	add	edx, DWORD PTR _x$[esp-4]
	mov	WORD PTR [eax+edx*2], cx

; 230  : }

	ret	28					; 0000001cH
??$DrawPixel@G@MVShow@@QAEXPAEHHHHHH@Z ENDP		; MVShow::DrawPixel<unsigned short>
_TEXT	ENDS
END
