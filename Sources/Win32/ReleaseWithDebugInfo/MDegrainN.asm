; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mdegrainn.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04DNAGLECB@mvbw?$AA@			; `string'
PUBLIC	??_C@_04DKAPBMPN@mvfw?$AA@			; `string'
PUBLIC	??_C@_0CO@DEKDPFLP@MDegrainN?3?5temporal?5radius?5too?5l@ ; `string'
PUBLIC	??_C@_0CP@EGMOGFCC@MDegrainN?3?5temporal?5radius?5must?5@ ; `string'
PUBLIC	??_C@_04HGGBINEM@?$CFs?$CFd?$AA@		; `string'
PUBLIC	??_C@_0CN@LKJJHKJJ@MDegrainN?5?3?5wrong?5source?5or?5supe@ ; `string'
PUBLIC	??_C@_0CM@JJAGFGCG@MDegrainN?5?3?5lsb_flag?5only?5for?58?5@ ; `string'
PUBLIC	??_C@_0FG@FPIOMAPB@MDegrainN?5?3?5no?5valid?5_oversluma_@ ; `string'
PUBLIC	??_C@_0FI@JLEGDAGJ@MDegrainN?5?3?5no?5valid?5_overschrom@ ; `string'
PUBLIC	??_C@_0FC@HLHCAJJK@MDegrainN?5?3?5no?5valid?5_oversluma_@ ; `string'
PUBLIC	??_C@_0FE@LMEDIIDI@MDegrainN?5?3?5no?5valid?5_overschrom@ ; `string'
PUBLIC	??_C@_0FE@HBFDJOBA@MDegrainN?5?3?5no?5valid?5_degrainlum@ ; `string'
PUBLIC	??_C@_0FG@BDEEPEDP@MDegrainN?5?3?5no?5valid?5_degrainchr@ ; `string'
PUBLIC	??_R1A@?0A@EA@IClip@@8				; IClip::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$AioAdd@H@conc@@8				; conc::AioAdd<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$MTSlicer@VMDegrainN@@V1@$0EA@@@8		; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7IClip@@6B@					; IClip::`vftable'
PUBLIC	??_R1A@?0A@EA@MVFilter@@8			; MVFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2GenericVideoFilter@@8			; GenericVideoFilter::`RTTI Base Class Array'
PUBLIC	??_R4IClip@@6B@					; IClip::`RTTI Complete Object Locator'
PUBLIC	??_R2MVFilter@@8				; MVFilter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$MTSlicer@VMDegrainN@@V1@$0EA@@@8 ; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_R1EA@?0A@EA@MVFilter@@8			; MVFilter::`RTTI Base Class Descriptor at (64,-1,0,64)'
PUBLIC	??_R0?AV?$MTSlicer@VMDegrainN@@V1@$0EA@@@@8	; MTSlicer<MDegrainN,MDegrainN,64> `RTTI Type Descriptor'
PUBLIC	??_R0?AVMVFilter@@@8				; MVFilter `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@GenericVideoFilter@@8		; GenericVideoFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVGenericVideoFilter@@@8			; GenericVideoFilter `RTTI Type Descriptor'
PUBLIC	??_R3MDegrainN@@8				; MDegrainN::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@	; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Complete Object Locator'
PUBLIC	??_R2?$AioAdd@H@conc@@8				; conc::AioAdd<int>::`RTTI Base Class Array'
PUBLIC	??_R2IClip@@8					; IClip::`RTTI Base Class Array'
PUBLIC	??_R4?$AioAdd@H@conc@@6B@			; conc::AioAdd<int>::`RTTI Complete Object Locator'
PUBLIC	??_R2MDegrainN@@8				; MDegrainN::`RTTI Base Class Array'
PUBLIC	??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@	; MTSlicer<MDegrainN,MDegrainN,64>::`vftable'
PUBLIC	??_R3MVFilter@@8				; MVFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVMDegrainN@@@8				; MDegrainN `RTTI Type Descriptor'
PUBLIC	??_7?$AioAdd@H@conc@@6B@			; conc::AioAdd<int>::`vftable'
PUBLIC	??_R2?$MTSlicer@VMDegrainN@@V1@$0EA@@@8		; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Base Class Array'
PUBLIC	??_7GenericVideoFilter@@6B@			; GenericVideoFilter::`vftable'
PUBLIC	??_R3GenericVideoFilter@@8			; GenericVideoFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4MDegrainN@@6B@				; MDegrainN::`RTTI Complete Object Locator'
PUBLIC	??_R4GenericVideoFilter@@6B@			; GenericVideoFilter::`RTTI Complete Object Locator'
PUBLIC	??_R3IClip@@8					; IClip::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$AioAdd@H@conc@@8		; conc::AioAdd<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AioAdd@H@conc@@@8			; conc::AioAdd<int> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@MDegrainN@@8			; MDegrainN::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7MDegrainN@@6B@				; MDegrainN::`vftable'
PUBLIC	??_R0?AVIClip@@@8				; IClip `RTTI Type Descriptor'
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__memmove:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R0?AVIClip@@@8
data$r	SEGMENT
??_R0?AVIClip@@@8 DD FLAT:??_7type_info@@6B@		; IClip `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIClip@@', 00H
data$r	ENDS
;	COMDAT ??_7MDegrainN@@6B@
CONST	SEGMENT
??_7MDegrainN@@6B@ DD FLAT:??_R4MDegrainN@@6B@		; MDegrainN::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MDegrainN@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMDegrainN@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@MDegrainN@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MDegrainN@@8 DD FLAT:??_R0?AVMDegrainN@@@8 ; MDegrainN::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MDegrainN@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AioAdd@H@conc@@@8
data$r	SEGMENT
??_R0?AV?$AioAdd@H@conc@@@8 DD FLAT:??_7type_info@@6B@	; conc::AioAdd<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AioAdd@H@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AioAdd@H@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AioAdd@H@conc@@8 DD FLAT:??_R0?AV?$AioAdd@H@conc@@@8 ; conc::AioAdd<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AioAdd@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3IClip@@8
rdata$r	SEGMENT
??_R3IClip@@8 DD 00H					; IClip::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IClip@@8
rdata$r	ENDS
;	COMDAT ??_R4GenericVideoFilter@@6B@
rdata$r	SEGMENT
??_R4GenericVideoFilter@@6B@ DD 00H			; GenericVideoFilter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVGenericVideoFilter@@@8
	DD	FLAT:??_R3GenericVideoFilter@@8
rdata$r	ENDS
;	COMDAT ??_R4MDegrainN@@6B@
rdata$r	SEGMENT
??_R4MDegrainN@@6B@ DD 00H				; MDegrainN::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMDegrainN@@@8
	DD	FLAT:??_R3MDegrainN@@8
rdata$r	ENDS
;	COMDAT ??_R3GenericVideoFilter@@8
rdata$r	SEGMENT
??_R3GenericVideoFilter@@8 DD 00H			; GenericVideoFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2GenericVideoFilter@@8
rdata$r	ENDS
;	COMDAT ??_7GenericVideoFilter@@6B@
CONST	SEGMENT
??_7GenericVideoFilter@@6B@ DD FLAT:??_R4GenericVideoFilter@@6B@ ; GenericVideoFilter::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@GenericVideoFilter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@GenericVideoFilter@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EGenericVideoFilter@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$MTSlicer@VMDegrainN@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R2?$MTSlicer@VMDegrainN@@V1@$0EA@@@8 DD FLAT:??_R1A@?0A@EA@?$MTSlicer@VMDegrainN@@V1@$0EA@@@8 ; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$AioAdd@H@conc@@6B@
CONST	SEGMENT
??_7?$AioAdd@H@conc@@6B@ DD FLAT:??_R4?$AioAdd@H@conc@@6B@ ; conc::AioAdd<int>::`vftable'
	DD	FLAT:??_E?$AioAdd@H@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AVMDegrainN@@@8
data$r	SEGMENT
??_R0?AVMDegrainN@@@8 DD FLAT:??_7type_info@@6B@	; MDegrainN `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMDegrainN@@', 00H
data$r	ENDS
;	COMDAT ??_R3MVFilter@@8
rdata$r	SEGMENT
??_R3MVFilter@@8 DD 00H					; MVFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MVFilter@@8
rdata$r	ENDS
;	COMDAT ?name_0@?L@???0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z@4PAPBDA
CONST	SEGMENT
?name_0@?L@???0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z@4PAPBDA DD FLAT:??_C@_04DNAGLECB@mvbw?$AA@ ; `MDegrainN::MDegrainN'::`11'::name_0
	DD	FLAT:??_C@_04DKAPBMPN@mvfw?$AA@
CONST	ENDS
;	COMDAT ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@
CONST	SEGMENT
??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@ DD FLAT:??_R4?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@ ; MTSlicer<MDegrainN,MDegrainN,64>::`vftable'
	DD	FLAT:??_E?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2MDegrainN@@8
rdata$r	SEGMENT
??_R2MDegrainN@@8 DD FLAT:??_R1A@?0A@EA@MDegrainN@@8	; MDegrainN::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R4?$AioAdd@H@conc@@6B@
rdata$r	SEGMENT
??_R4?$AioAdd@H@conc@@6B@ DD 00H			; conc::AioAdd<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AioAdd@H@conc@@@8
	DD	FLAT:??_R3?$AioAdd@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2IClip@@8
rdata$r	SEGMENT
??_R2IClip@@8 DD FLAT:??_R1A@?0A@EA@IClip@@8		; IClip::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2?$AioAdd@H@conc@@8
rdata$r	SEGMENT
??_R2?$AioAdd@H@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AioAdd@H@conc@@8 ; conc::AioAdd<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@
rdata$r	SEGMENT
??_R4?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@ DD 00H	; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$MTSlicer@VMDegrainN@@V1@$0EA@@@@8
	DD	FLAT:??_R3?$MTSlicer@VMDegrainN@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R3MDegrainN@@8
rdata$r	SEGMENT
??_R3MDegrainN@@8 DD 00H				; MDegrainN::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MDegrainN@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVGenericVideoFilter@@@8
data$r	SEGMENT
??_R0?AVGenericVideoFilter@@@8 DD FLAT:??_7type_info@@6B@ ; GenericVideoFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVGenericVideoFilter@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@GenericVideoFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@GenericVideoFilter@@8 DD FLAT:??_R0?AVGenericVideoFilter@@@8 ; GenericVideoFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3GenericVideoFilter@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVFilter@@@8
data$r	SEGMENT
??_R0?AVMVFilter@@@8 DD FLAT:??_7type_info@@6B@		; MVFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVFilter@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$MTSlicer@VMDegrainN@@V1@$0EA@@@@8
data$r	SEGMENT
??_R0?AV?$MTSlicer@VMDegrainN@@V1@$0EA@@@@8 DD FLAT:??_7type_info@@6B@ ; MTSlicer<MDegrainN,MDegrainN,64> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$MTSlicer@VMDegrainN@@V1@$0EA@@@', 00H
data$r	ENDS
;	COMDAT ??_R1EA@?0A@EA@MVFilter@@8
rdata$r	SEGMENT
??_R1EA@?0A@EA@MVFilter@@8 DD FLAT:??_R0?AVMVFilter@@@8	; MVFilter::`RTTI Base Class Descriptor at (64,-1,0,64)'
	DD	00H
	DD	040H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$MTSlicer@VMDegrainN@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$MTSlicer@VMDegrainN@@V1@$0EA@@@8 DD FLAT:??_R0?AV?$MTSlicer@VMDegrainN@@V1@$0EA@@@@8 ; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$MTSlicer@VMDegrainN@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R2MVFilter@@8
rdata$r	SEGMENT
??_R2MVFilter@@8 DD FLAT:??_R1A@?0A@EA@MVFilter@@8	; MVFilter::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4IClip@@6B@
rdata$r	SEGMENT
??_R4IClip@@6B@ DD 00H					; IClip::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIClip@@@8
	DD	FLAT:??_R3IClip@@8
rdata$r	ENDS
;	COMDAT ??_R2GenericVideoFilter@@8
rdata$r	SEGMENT
??_R2GenericVideoFilter@@8 DD FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8 ; GenericVideoFilter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVFilter@@8 DD FLAT:??_R0?AVMVFilter@@@8	; MVFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_7IClip@@6B@
CONST	SEGMENT
??_7IClip@@6B@ DD FLAT:??_R4IClip@@6B@			; IClip::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EIClip@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$MTSlicer@VMDegrainN@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R3?$MTSlicer@VMDegrainN@@V1@$0EA@@@8 DD 00H		; MTSlicer<MDegrainN,MDegrainN,64>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$MTSlicer@VMDegrainN@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AioAdd@H@conc@@8
rdata$r	SEGMENT
??_R3?$AioAdd@H@conc@@8 DD 00H				; conc::AioAdd<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AioAdd@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IClip@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IClip@@8 DD FLAT:??_R0?AVIClip@@@8	; IClip::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IClip@@8
rdata$r	ENDS
;	COMDAT ??_C@_0FG@BDEEPEDP@MDegrainN?5?3?5no?5valid?5_degrainchr@
CONST	SEGMENT
??_C@_0FG@BDEEPEDP@MDegrainN?5?3?5no?5valid?5_degrainchr@ DB 'MDegrainN :'
	DB	' no valid _degrainchroma_ptr function for %dx%d, pixelsize=%d'
	DB	', lsb_flag=%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@HBFDJOBA@MDegrainN?5?3?5no?5valid?5_degrainlum@
CONST	SEGMENT
??_C@_0FE@HBFDJOBA@MDegrainN?5?3?5no?5valid?5_degrainlum@ DB 'MDegrainN :'
	DB	' no valid _degrainluma_ptr function for %dx%d, pixelsize=%d, '
	DB	'lsb_flag=%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@LMEDIIDI@MDegrainN?5?3?5no?5valid?5_overschrom@
CONST	SEGMENT
??_C@_0FE@LMEDIIDI@MDegrainN?5?3?5no?5valid?5_overschrom@ DB 'MDegrainN :'
	DB	' no valid _overschroma_ptr function for %dx%d, pixelsize=%d, '
	DB	'lsb_flag=%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@HLHCAJJK@MDegrainN?5?3?5no?5valid?5_oversluma_@
CONST	SEGMENT
??_C@_0FC@HLHCAJJK@MDegrainN?5?3?5no?5valid?5_oversluma_@ DB 'MDegrainN :'
	DB	' no valid _oversluma_ptr function for %dx%d, pixelsize=%d, ls'
	DB	'b_flag=%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@JLEGDAGJ@MDegrainN?5?3?5no?5valid?5_overschrom@
CONST	SEGMENT
??_C@_0FI@JLEGDAGJ@MDegrainN?5?3?5no?5valid?5_overschrom@ DB 'MDegrainN :'
	DB	' no valid _overschroma_lsb_ptr function for %dx%d, pixelsize='
	DB	'%d, lsb_flag=%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@FPIOMAPB@MDegrainN?5?3?5no?5valid?5_oversluma_@
CONST	SEGMENT
??_C@_0FG@FPIOMAPB@MDegrainN?5?3?5no?5valid?5_oversluma_@ DB 'MDegrainN :'
	DB	' no valid _oversluma_lsb_ptr function for %dx%d, pixelsize=%d'
	DB	', lsb_flag=%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JJAGFGCG@MDegrainN?5?3?5lsb_flag?5only?5for?58?5@
CONST	SEGMENT
??_C@_0CM@JJAGFGCG@MDegrainN?5?3?5lsb_flag?5only?5for?58?5@ DB 'MDegrainN'
	DB	' : lsb_flag only for 8 bit sources', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LKJJHKJJ@MDegrainN?5?3?5wrong?5source?5or?5supe@
CONST	SEGMENT
??_C@_0CN@LKJJHKJJ@MDegrainN?5?3?5wrong?5source?5or?5supe@ DB 'MDegrainN '
	DB	': wrong source or super frame size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
CONST	SEGMENT
??_C@_04HGGBINEM@?$CFs?$CFd?$AA@ DB '%s%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EGMOGFCC@MDegrainN?3?5temporal?5radius?5must?5@
CONST	SEGMENT
??_C@_0CP@EGMOGFCC@MDegrainN?3?5temporal?5radius?5must?5@ DB 'MDegrainN: '
	DB	'temporal radius must be at least 1.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DEKDPFLP@MDegrainN?3?5temporal?5radius?5too?5l@
CONST	SEGMENT
??_C@_0CO@DEKDPFLP@MDegrainN?3?5temporal?5radius?5too?5l@ DB 'MDegrainN: '
	DB	'temporal radius too large (max %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DKAPBMPN@mvfw?$AA@
CONST	SEGMENT
??_C@_04DKAPBMPN@mvfw?$AA@ DB 'mvfw', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DNAGLECB@mvbw?$AA@
CONST	SEGMENT
??_C@_04DNAGLECB@mvbw?$AA@ DB 'mvbw', 00H		; `string'
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
PUBLIC	??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
PUBLIC	??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)><std::tuple<int,int,int,enum arch_t> &&>
PUBLIC	??0?$AtomicInt@H@conc@@QAE@ABV01@@Z		; conc::AtomicInt<int>::AtomicInt<int>
PUBLIC	??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@ABV0@@Z	; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>
PUBLIC	??0?$SharedPtr@VMVClip@@@@QAE@ABV0@@Z		; SharedPtr<MVClip>::SharedPtr<MVClip>
PUBLIC	??0MvClipInfo@MDegrainN@@QAE@$$QAV01@@Z		; MDegrainN::MvClipInfo::MvClipInfo
PUBLIC	??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z ; std::allocator<MDegrainN::MvClipInfo>::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
PUBLIC	??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z ; std::allocator<conc::AtomicInt<int> >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@$$QAV34@@Z ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
PUBLIC	??$forward@VMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z ; std::forward<MDegrainN::MvClipInfo>
PUBLIC	??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@$$QAV34@@Z ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >
PUBLIC	??$forward@V?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z ; std::forward<conc::AtomicInt<int> >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??0?$AtomicInt@H@conc@@QAE@XZ			; conc::AtomicInt<int>::AtomicInt<int>
PUBLIC	??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ	; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>
PUBLIC	??0?$SharedPtr@VMVClip@@@@QAE@XZ		; SharedPtr<MVClip>::SharedPtr<MVClip>
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_first
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator--
PUBLIC	??1MvClipInfo@MDegrainN@@QAE@XZ			; MDegrainN::MvClipInfo::~MvClipInfo
PUBLIC	??_GMvClipInfo@MDegrainN@@QAEPAXI@Z		; MDegrainN::MvClipInfo::`scalar deleting destructor'
PUBLIC	??0MvClipInfo@MDegrainN@@QAE@XZ			; MDegrainN::MvClipInfo::MvClipInfo
PUBLIC	??$destroy@VMvClipInfo@MDegrainN@@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ; std::allocator<MDegrainN::MvClipInfo>::destroy<MDegrainN::MvClipInfo>
PUBLIC	??$construct@VMvClipInfo@MDegrainN@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
PUBLIC	??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z	; std::_Copy_memmove<unsigned short *,unsigned short *>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$construct@V?$AtomicInt@H@conc@@V12@@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >
PUBLIC	??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ; std::allocator<MDegrainN::MvClipInfo>::construct<MDegrainN::MvClipInfo>
PUBLIC	??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z ; std::allocator<conc::AtomicInt<int> >::construct<conc::AtomicInt<int> >
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$move@AAVMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z ; std::move<MDegrainN::MvClipInfo &>
PUBLIC	??$move@AAV?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z ; std::move<conc::AtomicInt<int> &>
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Mysize
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator--
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::size
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Freenode0
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator--
PUBLIC	??$destroy@VMvClipInfo@MDegrainN@@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::destroy<MDegrainN::MvClipInfo>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	??$_Ptr_move_cat@VMvClipInfo@MDegrainN@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MDegrainN@@0@Z ; std::_Ptr_move_cat<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
PUBLIC	??$_Uninitialized_move_al_unchecked1@GGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked1<unsigned short,unsigned short,std::allocator<unsigned short> >
PUBLIC	??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ; std::_Ptr_move_cat<unsigned short,unsigned short>
PUBLIC	??$_Uninitialized_move_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked1<int,int,std::allocator<int> >
PUBLIC	??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ; std::_Ptr_move_cat<int,int>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
PUBLIC	??$_Ptr_move_cat@V?$AtomicInt@H@conc@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$AtomicInt@H@conc@@0@Z ; std::_Ptr_move_cat<conc::AtomicInt<int>,conc::AtomicInt<int> >
PUBLIC	??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo>
PUBLIC	??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@@Z ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int> >
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	?cas@?$AtomicMem@$01@conc@@SAHACHHH@Z		; conc::AtomicMem<2>::cas
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_first
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getcomp
PUBLIC	?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Compare
PUBLIC	??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>
PUBLIC	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
PUBLIC	??$destroy@VMvClipInfo@MDegrainN@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::destroy<MDegrainN::MvClipInfo>
PUBLIC	??$_Rechecked@PAVMvClipInfo@MDegrainN@@PAV12@@std@@YAAAPAVMvClipInfo@MDegrainN@@AAPAV12@PAV12@@Z ; std::_Rechecked<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	??$_Unchecked@PAVMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z ; std::_Unchecked<MDegrainN::MvClipInfo *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned short *,unsigned short *,std::allocator<unsigned short> >
PUBLIC	??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z	; std::_Rechecked<int *,int *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<int *,int *,std::allocator<int> >
PUBLIC	??$_Unchecked@PAH@std@@YAPAHPAH@Z		; std::_Unchecked<int *>
PUBLIC	??$_Rechecked@PAV?$AtomicInt@H@conc@@PAV12@@std@@YAAAPAV?$AtomicInt@H@conc@@AAPAV12@PAV12@@Z ; std::_Rechecked<conc::AtomicInt<int> *,conc::AtomicInt<int> *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
PUBLIC	??$_Unchecked@PAV?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z ; std::_Unchecked<conc::AtomicInt<int> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
PUBLIC	??$construct@VMvClipInfo@MDegrainN@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo>
PUBLIC	??$construct@V?$AtomicInt@H@conc@@$$V@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int> >
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > &,bool,void,0>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool,void,0>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<2>
PUBLIC	??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<1>
PUBLIC	??$_Unfancy@VMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z ; std::_Unfancy<MDegrainN::MvClipInfo>
PUBLIC	??$_Unfancy@V?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z ; std::_Unfancy<conc::AtomicInt<int> >
PUBLIC	??R?$AioAdd@H@conc@@QBEHH@Z			; conc::AioAdd<int>::operator()
PUBLIC	?cas@?$AtomicInt@H@conc@@QAEHHH@Z		; conc::AtomicInt<int>::cas
PUBLIC	??B?$AtomicInt@H@conc@@QBEHXZ			; conc::AtomicInt<int>::operator int
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Kfn
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_first
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::lower_bound
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Key
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getcomp
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >
PUBLIC	??_GMVGroupOfFrames@@QAEPAXI@Z			; MVGroupOfFrames::`scalar deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
PUBLIC	??$_Destroy_range1@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MDegrainN::MvClipInfo>,MDegrainN::MvClipInfo *>
PUBLIC	??$_Uninitialized_move@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ; std::_Uninitialized_move<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	??$_Destroy_range1@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned short>,unsigned short *>
PUBLIC	??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
PUBLIC	??$_Destroy_range1@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<int>,int *>
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
PUBLIC	??$_Destroy_range1@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<conc::AtomicInt<int> >,conc::AtomicInt<int> *>
PUBLIC	??$_Uninitialized_move@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ; std::_Uninitialized_move<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1><>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
PUBLIC	??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_default_fill_n1<unsigned short *,unsigned int,std::allocator<unsigned short> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_default_fill_n1<int *,unsigned int,std::allocator<int> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >
PUBLIC	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$exec_both@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@AAH2@Z ; conc::AtomicIntOp::exec_both<int,conc::AioAdd<int> const >
PUBLIC	??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_overlap_slice<2>
PUBLIC	??$process_chroma_normal_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_normal_slice<2>
PUBLIC	??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_overlap_slice<1>
PUBLIC	??$process_chroma_normal_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_normal_slice<1>
PUBLIC	??A?$Array@VTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@J@Z ; conc::Array<MTSlicer<MDegrainN,MDegrainN,64>::TaskData,64>::operator[]
PUBLIC	?redirect_task@?$MTSlicer@VMDegrainN@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<MDegrainN,MDegrainN,64>::redirect_task
PUBLIC	?destroy_complete@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ ; SharedPtr<MVGroupOfFrames>::destroy_complete
PUBLIC	?add_ref@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ	; SharedPtr<MVGroupOfFrames>::add_ref
PUBLIC	?destroy_complete@?$SharedPtr@VMVClip@@@@AAEXXZ	; SharedPtr<MVClip>::destroy_complete
PUBLIC	?add_ref@?$SharedPtr@VMVClip@@@@AAEXXZ		; SharedPtr<MVClip>::add_ref
PUBLIC	??0?$allocator@VMvClipInfo@MDegrainN@@@std@@QAE@XZ ; std::allocator<MDegrainN::MvClipInfo>::allocator<MDegrainN::MvClipInfo>
PUBLIC	??0?$allocator@G@std@@QAE@XZ			; std::allocator<unsigned short>::allocator<unsigned short>
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	??0?$allocator@V?$AtomicInt@H@conc@@@std@@QAE@XZ ; std::allocator<conc::AtomicInt<int> >::allocator<conc::AtomicInt<int> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >
PUBLIC	??0?$auto_ptr_ref@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z ; std::auto_ptr_ref<YUY2Planes>::auto_ptr_ref<YUY2Planes>
PUBLIC	??0?$auto_ptr_ref@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z ; std::auto_ptr_ref<OverlapWindows>::auto_ptr_ref<OverlapWindows>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned short> >::_Wrap_alloc<std::allocator<unsigned short> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >
PUBLIC	?access@?$MTSlicer_Access@VMDegrainN@@V1@@@SAPAVMDegrainN@@PAV2@@Z ; MTSlicer_Access<MDegrainN,MDegrainN>::access
PUBLIC	??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z	; MTSlicer<MDegrainN,MDegrainN,64>::`scalar deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
PUBLIC	??$_Destroy_range@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<MDegrainN::MvClipInfo>,MDegrainN::MvClipInfo *>
PUBLIC	??$_Umove@PAVMvClipInfo@MDegrainN@@@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEPAVMvClipInfo@MDegrainN@@PAV23@00@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Umove<MDegrainN::MvClipInfo *>
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ; std::_Destroy_range<std::allocator<unsigned short>,unsigned short *>
PUBLIC	??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Destroy_range<std::allocator<int>,int *>
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
PUBLIC	??$_Destroy_range@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<conc::AtomicInt<int> >,conc::AtomicInt<int> *>
PUBLIC	??$_Umove@PAV?$AtomicInt@H@conc@@@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEPAV?$AtomicInt@H@conc@@PAV23@00@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Umove<conc::AtomicInt<int> *>
PUBLIC	??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
PUBLIC	??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1><>
PUBLIC	??$_Uninitialized_default_fill_n@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	??$_Uninitialized_default_fill_n@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ; std::_Uninitialized_default_fill_n<unsigned short *,unsigned int,std::allocator<unsigned short> >
PUBLIC	??$_Uninitialized_default_fill_n@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_default_fill_n<int *,unsigned int,std::allocator<int> >
PUBLIC	??$_Uninitialized_default_fill_n@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >
PUBLIC	??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::try_emplace<>
PUBLIC	??$exec_new@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@@Z ; conc::AtomicIntOp::exec_new<int,conc::AioAdd<int> const >
PUBLIC	??0?$AioAdd@H@conc@@QAE@H@Z			; conc::AioAdd<int>::AioAdd<int>
PUBLIC	??$process_chroma@$01@MDegrainN@@AAEXH@Z	; MDegrainN::process_chroma<2>
PUBLIC	??$process_chroma@$00@MDegrainN@@AAEXH@Z	; MDegrainN::process_chroma<1>
PUBLIC	??$DegrainN_sse2@$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<2,2>
PUBLIC	??$DegrainN_sse2@$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<2,4>
PUBLIC	??$DegrainN_sse2@$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<4,2>
PUBLIC	??$DegrainN_sse2@$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<4,4>
PUBLIC	??$DegrainN_sse2@$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<4,8>
PUBLIC	??$DegrainN_sse2@$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,1>
PUBLIC	??$DegrainN_sse2@$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,2>
PUBLIC	??$DegrainN_sse2@$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,4>
PUBLIC	??$DegrainN_sse2@$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,8>
PUBLIC	??$DegrainN_sse2@$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,16>
PUBLIC	??$DegrainN_sse2@$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,2>
PUBLIC	??$DegrainN_sse2@$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,4>
PUBLIC	??$DegrainN_sse2@$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,8>
PUBLIC	??$DegrainN_sse2@$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,16>
PUBLIC	??$DegrainN_sse2@$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,32>
PUBLIC	??$DegrainN_sse2@$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<32,8>
PUBLIC	??$DegrainN_sse2@$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<32,16>
PUBLIC	??$DegrainN_sse2@$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<32,32>
PUBLIC	??$DegrainN_C@G$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,2,2>
PUBLIC	??$DegrainN_C@G$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,2,4>
PUBLIC	??$DegrainN_C@G$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,4,2>
PUBLIC	??$DegrainN_C@G$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,4,4>
PUBLIC	??$DegrainN_C@G$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,4,8>
PUBLIC	??$DegrainN_C@G$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,1>
PUBLIC	??$DegrainN_C@G$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,2>
PUBLIC	??$DegrainN_C@G$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,4>
PUBLIC	??$DegrainN_C@G$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,8>
PUBLIC	??$DegrainN_C@G$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,16>
PUBLIC	??$DegrainN_C@G$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,2>
PUBLIC	??$DegrainN_C@G$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,4>
PUBLIC	??$DegrainN_C@G$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,8>
PUBLIC	??$DegrainN_C@G$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,16>
PUBLIC	??$DegrainN_C@G$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,32>
PUBLIC	??$DegrainN_C@G$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,32,8>
PUBLIC	??$DegrainN_C@G$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,32,16>
PUBLIC	??$DegrainN_C@G$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,32,32>
PUBLIC	??$DegrainN_C@E$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,2,2>
PUBLIC	??$DegrainN_C@E$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,2,4>
PUBLIC	??$DegrainN_C@E$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,4,2>
PUBLIC	??$DegrainN_C@E$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,4,4>
PUBLIC	??$DegrainN_C@E$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,4,8>
PUBLIC	??$DegrainN_C@E$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,1>
PUBLIC	??$DegrainN_C@E$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,2>
PUBLIC	??$DegrainN_C@E$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,4>
PUBLIC	??$DegrainN_C@E$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,8>
PUBLIC	??$DegrainN_C@E$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,16>
PUBLIC	??$DegrainN_C@E$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,2>
PUBLIC	??$DegrainN_C@E$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,4>
PUBLIC	??$DegrainN_C@E$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,8>
PUBLIC	??$DegrainN_C@E$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,16>
PUBLIC	??$DegrainN_C@E$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,32>
PUBLIC	??$DegrainN_C@E$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,32,8>
PUBLIC	??$DegrainN_C@E$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,32,16>
PUBLIC	??$DegrainN_C@E$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,32,32>
PUBLIC	??$GetAbsolutePointerPel@$01@MVPlane@@QBEPBEHH@Z ; MVPlane::GetAbsolutePointerPel<2>
PUBLIC	??$GetAbsolutePointerPel@$00@MVPlane@@QBEPBEHH@Z ; MVPlane::GetAbsolutePointerPel<1>
PUBLIC	??$?BVOverlapWindows@@@?$auto_ptr@VOverlapWindows@@@std@@QAE?AU?$auto_ptr_ref@VOverlapWindows@@@1@XZ ; std::auto_ptr<OverlapWindows>::operator<OverlapWindows> std::auto_ptr_ref<OverlapWindows>
PUBLIC	??$?BVYUY2Planes@@@?$auto_ptr@VYUY2Planes@@@std@@QAE?AU?$auto_ptr_ref@VYUY2Planes@@@1@XZ ; std::auto_ptr<YUY2Planes>::operator<YUY2Planes> std::auto_ptr_ref<YUY2Planes>
PUBLIC	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ	; MTSlicer<MDegrainN,MDegrainN,64>::wait
PUBLIC	?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MDegrainN,MDegrainN,64>::start
PUBLIC	??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ	; MTSlicer<MDegrainN,MDegrainN,64>::~MTSlicer<MDegrainN,MDegrainN,64>
PUBLIC	??0?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAE@_N@Z	; MTSlicer<MDegrainN,MDegrainN,64>::MTSlicer<MDegrainN,MDegrainN,64>
PUBLIC	??D?$SharedPtr@VMVGroupOfFrames@@@@QBEAAVMVGroupOfFrames@@XZ ; SharedPtr<MVGroupOfFrames>::operator*
PUBLIC	??4?$SharedPtr@VMVGroupOfFrames@@@@QAEAAV0@ABV0@@Z ; SharedPtr<MVGroupOfFrames>::operator=
PUBLIC	??1?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ	; SharedPtr<MVGroupOfFrames>::~SharedPtr<MVGroupOfFrames>
PUBLIC	??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@PAVMVGroupOfFrames@@@Z ; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>
PUBLIC	??D?$SharedPtr@VMVClip@@@@QBEAAVMVClip@@XZ	; SharedPtr<MVClip>::operator*
PUBLIC	??C?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ	; SharedPtr<MVClip>::operator->
PUBLIC	??4?$SharedPtr@VMVClip@@@@QAEAAV0@ABV0@@Z	; SharedPtr<MVClip>::operator=
PUBLIC	??1?$SharedPtr@VMVClip@@@@QAE@XZ		; SharedPtr<MVClip>::~SharedPtr<MVClip>
PUBLIC	??0?$SharedPtr@VMVClip@@@@QAE@PAVMVClip@@@Z	; SharedPtr<MVClip>::SharedPtr<MVClip>
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::allocate
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_second
PUBLIC	?max_size@?$allocator@VMvClipInfo@MDegrainN@@@std@@QBEIXZ ; std::allocator<MDegrainN::MvClipInfo>::max_size
PUBLIC	?max_size@?$allocator@G@std@@QBEIXZ		; std::allocator<unsigned short>::max_size
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
PUBLIC	?max_size@?$allocator@V?$AtomicInt@H@conc@@@std@@QBEIXZ ; std::allocator<conc::AtomicInt<int> >::max_size
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Get_data
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::allocate
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Isnil
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Min
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator++
PUBLIC	?allocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z ; std::allocator<MDegrainN::MvClipInfo>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MDegrainN@@@2@@Z ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_second
PUBLIC	?allocate@?$allocator@G@std@@QAEPAGI@Z		; std::allocator<unsigned short>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z ; std::allocator_traits<std::allocator<unsigned short> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::allocator_traits<std::allocator<int> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?allocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z ; std::allocator<conc::AtomicInt<int> >::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAIABV?$allocator@V?$AtomicInt@H@conc@@@2@@Z ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_first
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rrotate
PUBLIC	?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Color
PUBLIC	?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Isnil
PUBLIC	?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myval
PUBLIC	?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Min
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myhead
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Mysize
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::deallocate
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Myval
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator++
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_second
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Mynode
PUBLIC	?deallocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z ; std::allocator<MDegrainN::MvClipInfo>::deallocate
PUBLIC	?capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@G@std@@QAEXPAGI@Z	; std::allocator<unsigned short>::deallocate
PUBLIC	?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z ; std::_Wrap_alloc<std::allocator<unsigned short> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<unsigned short> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<int> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z ; std::allocator<conc::AtomicInt<int> >::deallocate
PUBLIC	?capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_second
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::clear
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lmost
PUBLIC	?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Right
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Construct
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::deallocate
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >
PUBLIC	?_Unused_capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Unused_capacity
PUBLIC	?max_size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::max_size
PUBLIC	?_Destroy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXPAVMvClipInfo@MDegrainN@@0@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Destroy
PUBLIC	?_Grow_to@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEII@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reallocate
PUBLIC	?_Xlen@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEXXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myend
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_first
PUBLIC	?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Unused_capacity
PUBLIC	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
PUBLIC	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
PUBLIC	?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reallocate
PUBLIC	?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z ; std::_Wrap_alloc<std::allocator<unsigned short> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
PUBLIC	?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::_Unused_capacity
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reallocate
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Unused_capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Unused_capacity
PUBLIC	?max_size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::max_size
PUBLIC	?_Destroy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXPAV?$AtomicInt@H@conc@@0@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Destroy
PUBLIC	?_Grow_to@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEII@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Grow_to
PUBLIC	?_Reallocate@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reallocate
PUBLIC	?_Xlen@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEXXZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myend
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_first
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::end
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Freeheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myhead
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator*
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@AAU32@@Z ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> *>::pointer_to
PUBLIC	?size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::size
PUBLIC	?_Pop_back_n@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Pop_back_n
PUBLIC	?_Reserve@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reserve
PUBLIC	?_Tidy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Mylast
PUBLIC	?get@?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ ; std::auto_ptr<YUY2Planes>::get
PUBLIC	?reset@?$auto_ptr@VYUY2Planes@@@std@@QAEXPAVYUY2Planes@@@Z ; std::auto_ptr<YUY2Planes>::reset
PUBLIC	?get@?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ ; std::auto_ptr<OverlapWindows>::get
PUBLIC	?reset@?$auto_ptr@VOverlapWindows@@@std@@QAEXPAVOverlapWindows@@@Z ; std::auto_ptr<OverlapWindows>::reset
PUBLIC	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
PUBLIC	?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Pop_back_n
PUBLIC	?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
PUBLIC	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::_Pop_back_n
PUBLIC	?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
PUBLIC	?_Pop_back_n@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Pop_back_n
PUBLIC	?_Reserve@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reserve
PUBLIC	?_Tidy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXXZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Mylast
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tidy
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator->
PUBLIC	??_GYUY2Planes@@QAEPAXI@Z			; YUY2Planes::`scalar deleting destructor'
PUBLIC	??_GOverlapWindows@@QAEPAXI@Z			; OverlapWindows::`scalar deleting destructor'
PUBLIC	??_G?$AioAdd@H@conc@@UAEPAXI@Z			; conc::AioAdd<int>::`scalar deleting destructor'
PUBLIC	??0?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	??1?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::~vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >
PUBLIC	?resize@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::resize
PUBLIC	??A?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEAAVMvClipInfo@MDegrainN@@I@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::operator[]
PUBLIC	??0?$auto_ptr@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z ; std::auto_ptr<YUY2Planes>::auto_ptr<YUY2Planes>
PUBLIC	??4?$auto_ptr@VYUY2Planes@@@std@@QAEAAV01@U?$auto_ptr_ref@VYUY2Planes@@@1@@Z ; std::auto_ptr<YUY2Planes>::operator=
PUBLIC	??1?$auto_ptr@VYUY2Planes@@@std@@QAE@XZ		; std::auto_ptr<YUY2Planes>::~auto_ptr<YUY2Planes>
PUBLIC	??C?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ ; std::auto_ptr<YUY2Planes>::operator->
PUBLIC	??0?$auto_ptr@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z ; std::auto_ptr<OverlapWindows>::auto_ptr<OverlapWindows>
PUBLIC	??4?$auto_ptr@VOverlapWindows@@@std@@QAEAAV01@U?$auto_ptr_ref@VOverlapWindows@@@1@@Z ; std::auto_ptr<OverlapWindows>::operator=
PUBLIC	??1?$auto_ptr@VOverlapWindows@@@std@@QAE@XZ	; std::auto_ptr<OverlapWindows>::~auto_ptr<OverlapWindows>
PUBLIC	??C?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ ; std::auto_ptr<OverlapWindows>::operator->
PUBLIC	??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
PUBLIC	??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
PUBLIC	?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
PUBLIC	?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::empty
PUBLIC	??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize
PUBLIC	?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ; std::vector<int,std::allocator<int> >::empty
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	??0?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >
PUBLIC	??1?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::~vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >
PUBLIC	?resize@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::resize
PUBLIC	?size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::size
PUBLIC	??A?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEAAV?$AtomicInt@H@conc@@I@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::operator[]
PUBLIC	??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >
PUBLIC	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
PUBLIC	??1?$AioAdd@H@conc@@UAE@XZ			; conc::AioAdd<int>::~AioAdd<int>
PUBLIC	?norm_weights@MDegrainN@@CAXQAHH@Z		; MDegrainN::norm_weights
PUBLIC	?use_block_uv@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z ; MDegrainN::use_block_uv
PUBLIC	?use_block_y@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z ; MDegrainN::use_block_y
PUBLIC	?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z	; MDegrainN::process_luma_overlap_slice
PUBLIC	?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_luma_overlap_slice
PUBLIC	?process_luma_normal_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_luma_normal_slice
PUBLIC	?reorder_ref@MDegrainN@@ABEHH@Z			; MDegrainN::reorder_ref
PUBLIC	?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MDegrainN::GetFrame
PUBLIC	??1MDegrainN@@UAE@XZ				; MDegrainN::~MDegrainN
PUBLIC	??_GMDegrainN@@UAEPAXI@Z			; MDegrainN::`scalar deleting destructor'
PUBLIC	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >
PUBLIC	?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z ; MDegrainN::get_denoiseN_function
PUBLIC	?GetPitch@MVPlane@@QBEHXZ			; MVPlane::GetPitch
PUBLIC	?GetPointer@MVPlane@@QBEPBEHH@Z			; MVPlane::GetPointer
PUBLIC	?GetAbsolutePointer@MVPlane@@QBEPBEHH@Z		; MVPlane::GetAbsolutePointer
PUBLIC	??$GetAbsolutePointerPel@$0A@@MVPlane@@QBEPBEHH@Z ; MVPlane::GetAbsolutePointerPel<0>
PUBLIC	?GetPlane@MVFrame@@QAEPAVMVPlane@@W4MVPlaneSet@@@Z ; MVFrame::GetPlane
PUBLIC	?DegrainWeight@@YAHHHH@Z			; DegrainWeight
PUBLIC	??0TmpBlock@MDegrainN@@QAE@XZ			; MDegrainN::TmpBlock::TmpBlock
PUBLIC	?SetCacheHints@MDegrainN@@UAGHHH@Z		; MDegrainN::SetCacheHints
PUBLIC	?GetPtrV@YUY2Planes@@QBEPAEXZ			; YUY2Planes::GetPtrV
PUBLIC	?GetPtrU@YUY2Planes@@QBEPAEXZ			; YUY2Planes::GetPtrU
PUBLIC	?GetPtr@YUY2Planes@@QBEPAEXZ			; YUY2Planes::GetPtr
PUBLIC	?GetPitchUV@YUY2Planes@@QBEHXZ			; YUY2Planes::GetPitchUV
PUBLIC	?GetPitch@YUY2Planes@@QBEHXZ			; YUY2Planes::GetPitch
PUBLIC	?GetWindow@OverlapWindows@@QBEPAFH@Z		; OverlapWindows::GetWindow
PUBLIC	?IsUsable@MVClip@@QBE_NXZ			; MVClip::IsUsable
PUBLIC	?GetThSCD1@MVClip@@QBEHXZ			; MVClip::GetThSCD1
PUBLIC	?GetY@FakeBlockData@@QBEHXZ			; FakeBlockData::GetY
PUBLIC	?GetX@FakeBlockData@@QBEHXZ			; FakeBlockData::GetX
PUBLIC	??1GenericVideoFilter@@UAE@XZ			; GenericVideoFilter::~GenericVideoFilter
PUBLIC	??_GGenericVideoFilter@@UAEPAXI@Z		; GenericVideoFilter::`scalar deleting destructor'
PUBLIC	?SetCacheHints@GenericVideoFilter@@UAGHHH@Z	; GenericVideoFilter::SetCacheHints
PUBLIC	?GetParity@GenericVideoFilter@@UAG_NH@Z		; GenericVideoFilter::GetParity
PUBLIC	?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
PUBLIC	?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z ; GenericVideoFilter::GetAudio
PUBLIC	?GetFrame@GenericVideoFilter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; GenericVideoFilter::GetFrame
PUBLIC	??0GenericVideoFilter@@QAE@VPClip@@@Z		; GenericVideoFilter::GenericVideoFilter
PUBLIC	??1PVideoFrame@@QAE@XZ				; PVideoFrame::~PVideoFrame
PUBLIC	??0PVideoFrame@@QAE@ABV0@@Z			; PVideoFrame::PVideoFrame
PUBLIC	??0PVideoFrame@@QAE@XZ				; PVideoFrame::PVideoFrame
PUBLIC	??_GIClip@@UAEPAXI@Z				; IClip::`scalar deleting destructor'
PUBLIC	??1IClip@@UAE@XZ				; IClip::~IClip
PUBLIC	?GetVersion@IClip@@UAGHXZ			; IClip::GetVersion
PUBLIC	??0IClip@@QAE@XZ				; IClip::IClip
PUBLIC	?GetReadPtr@VideoFrame@@QBEPBEH@Z		; VideoFrame::GetReadPtr
PUBLIC	?GetRowSize@VideoFrame@@QBEHH@Z			; VideoFrame::GetRowSize
PUBLIC	?ComponentSize@VideoInfo@@QBEHXZ		; VideoInfo::ComponentSize
PUBLIC	_sprintf
PUBLIC	__vsprintf_l
PUBLIC	__vsnprintf_l
PUBLIC	___local_stdio_printf_options
PUBLIC	??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z ; MDegrainN::MDegrainN
EXTRN	??_E?$AioAdd@H@conc@@UAEPAXI@Z:PROC		; conc::AioAdd<int>::`vector deleting destructor'
EXTRN	??_EMDegrainN@@UAEPAXI@Z:PROC			; MDegrainN::`vector deleting destructor'
EXTRN	??_EIClip@@UAEPAXI@Z:PROC			; IClip::`vector deleting destructor'
EXTRN	??_E?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z:PROC ; MTSlicer<MDegrainN,MDegrainN,64>::`vector deleting destructor'
EXTRN	??_EGenericVideoFilter@@UAEPAXI@Z:PROC		; GenericVideoFilter::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z DD 019930522H
	DD	014H
	DD	FLAT:__unwindtable$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$10
	DD	09H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$13
	DD	0cH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$14
	DD	0cH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$16
	DD	0cH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$22
	DD	0cH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$24
	DD	01H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$88
	DD	00H
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$89
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$90
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1PVideoFrame@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0GenericVideoFilter@@QAE@VPClip@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0GenericVideoFilter@@QAE@VPClip@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0GenericVideoFilter@@QAE@VPClip@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GGenericVideoFilter@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GGenericVideoFilter@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_GGenericVideoFilter@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GGenericVideoFilter@@UAEPAXI@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1GenericVideoFilter@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1GenericVideoFilter@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1GenericVideoFilter@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1GenericVideoFilter@@UAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MDegrainN@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1MDegrainN@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MDegrainN@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MDegrainN@@UAE@XZ$102
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MDegrainN@@UAE@XZ$105
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$81
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$82
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$process_chroma@$00@MDegrainN@@AAEXH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$process_chroma@$00@MDegrainN@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$process_chroma@$00@MDegrainN@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$process_chroma@$00@MDegrainN@@AAEXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$process_chroma@$00@MDegrainN@@AAEXH@Z$43
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$process_chroma@$01@MDegrainN@@AAEXH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$process_chroma@$01@MDegrainN@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$process_chroma@$01@MDegrainN@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$process_chroma@$01@MDegrainN@@AAEXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$process_chroma@$01@MDegrainN@@AAEXH@Z$43
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$120
__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$120 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$71
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$71 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\overlap.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_txt_0$2 = -168						; size = 128
$T3 = -40						; size = 4
_thsadc$2$ = -36					; size = 4
_thsadc2$2$ = -32					; size = 4
_c_info$1$ = -28					; size = 4
_nHeightS$1$ = -24					; size = 4
$T4 = -20						; size = 4
_thsad$2$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_child$ = 8						; size = 4
_super$ = 12						; size = 4
_mvmulti$ = 16						; size = 4
_i$1$ = 20						; size = 4
$T5 = 20						; size = 4
$T6 = 20						; size = 4
_thsadc$1$ = 20						; size = 4
_trad$ = 20						; size = 4
_nSuperVPad$1$ = 24					; size = 4
_thsad$ = 24						; size = 4
_nSuperLevels$1$ = 28					; size = 4
_thsadc$ = 28						; size = 4
tv2851 = 32						; size = 4
_k$1$ = 32						; size = 4
_thsad2$1$ = 32						; size = 4
_yuvplanes$ = 32					; size = 4
_this$1$ = 36						; size = 4
_vi_super$1$ = 36					; size = 4
_nlimit$ = 36						; size = 4
_nSuperHPad$1$ = 40					; size = 4
$T7 = 40						; size = 4
_nlimitc$ = 40						; size = 4
_k$1$ = 44						; size = 4
_thsad$1$ = 44						; size = 4
_nscd1$ = 44						; size = 4
_nSuperPel$1$ = 48					; size = 4
_nscd2$ = 48						; size = 4
tv2859 = 52						; size = 4
_isse_flag$ = 52					; size = 1
$T8 = 56						; size = 4
$T9 = 56						; size = 4
tv2852 = 56						; size = 4
tv2679 = 56						; size = 4
$T10 = 56						; size = 4
$T11 = 56						; size = 4
$T12 = 56						; size = 4
$T13 = 56						; size = 4
_planar_flag$ = 56					; size = 1
_lsb_flag$ = 60						; size = 1
$T14 = 64						; size = 4
_thsad2$ = 64						; size = 4
_thsad2$2$ = 68						; size = 4
_thsadc2$ = 68						; size = 4
_mt_flag$ = 72						; size = 1
_env_ptr$ = 76						; size = 4
??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z PROC ; MDegrainN::MDegrainN, COMDAT
; _this$ = ecx

; 440  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mdegrainn.cpp

; 398  :   : GenericVideoFilter(child)

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN79@MDegrainN
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN79@MDegrainN
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _child$[ebp]
	push	edx
	call	eax
$LN79@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 398  :   : GenericVideoFilter(child)

	mov	ecx, ebx
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 399  :   , MVFilter(mvmulti, "MDegrainN", env_ptr, 1, 0)

	mov	edi, DWORD PTR _env_ptr$[ebp]
	lea	ecx, DWORD PTR _mvmulti$[ebp]
	push	0
	push	1
	push	edi
	push	OFFSET ??_C@_09KKHAFLDJ@MDegrainN?$AA@
	push	ecx
	lea	ecx, DWORD PTR [ebx+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter

; 400  :   , _mv_clip_arr()

	lea	eax, DWORD PTR [ebx+152]

; 440  : {

	mov	DWORD PTR [ebx], OFFSET ??_7MDegrainN@@6B@
	mov	DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [eax], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [eax+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [eax+8], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 402  :   , _yuvplanes(yuvplanes)

	mov	eax, DWORD PTR _yuvplanes$[ebp]

; 403  :   , _nlimit(nlimit)
; 404  :   , _nlimitc(nlimitc)
; 405  :   , _super(super)

	lea	ecx, DWORD PTR [ebx+180]
	mov	esi, DWORD PTR _trad$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	DWORD PTR [ebx+168], eax
	mov	eax, DWORD PTR _nlimit$[ebp]
	mov	DWORD PTR [ebx+172], eax
	mov	eax, DWORD PTR _nlimitc$[ebp]
	mov	DWORD PTR [ebx+176], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mdegrainn.cpp

; 401  :   , _trad(trad)

	mov	DWORD PTR [ebx+164], esi

; 403  :   , _nlimit(nlimit)
; 404  :   , _nlimitc(nlimitc)
; 405  :   , _super(super)

	mov	DWORD PTR _this$1$[ebp], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN92@MDegrainN
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN92@MDegrainN
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _super$[ebp]
	push	edx
	call	eax
$LN92@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 406  :   , _isse_flag(isse_flag)

	mov	al, BYTE PTR _isse_flag$[ebp]

; 407  :   , _planar_flag(planar_flag)
; 408  :   , _lsb_flag(lsb_flag)

	mov	cl, BYTE PTR _lsb_flag$[ebp]
	mov	BYTE PTR [ebx+184], al
	mov	al, BYTE PTR _planar_flag$[ebp]
	mov	BYTE PTR [ebx+185], al

; 409  :   , _mt_flag(mt_flag)

	mov	eax, DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR [ebx+187], al

; 410  :   , _height_lsb_mul((lsb_flag) ? 2 : 1)

	xor	eax, eax
	test	cl, cl
	mov	BYTE PTR [ebx+186], cl

; 411  :   , _xratiouv_log((xRatioUV == 2) ? 1 : 0)
; 412  :   , _yratiouv_log((yRatioUV == 2) ? 1 : 0)
; 413  :   , _nsupermodeyuv(-1)

	mov	DWORD PTR [ebx+208], -1
	setne	al
	inc	eax
	mov	DWORD PTR [ebx+188], eax
	xor	eax, eax
	cmp	DWORD PTR [ebx+120], 2
	sete	al
	mov	DWORD PTR [ebx+200], eax
	xor	eax, eax
	cmp	DWORD PTR [ebx+124], 2
	sete	al
	mov	DWORD PTR [ebx+204], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 697  : 		: _Myptr(_Ptr)

	mov	DWORD PTR [ebx+212], 0
	mov	DWORD PTR [ebx+216], 0
	mov	DWORD PTR [ebx+220], 0
	mov	DWORD PTR [ebx+224], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 418  :   , _oversluma_ptr(0)

	mov	DWORD PTR [ebx+228], 0

; 419  :   , _overschroma_ptr(0)

	mov	DWORD PTR [ebx+232], 0

; 420  :   , _oversluma16_ptr(0)

	mov	DWORD PTR [ebx+236], 0

; 421  :   , _overschroma16_ptr(0)

	mov	DWORD PTR [ebx+240], 0

; 422  :   , _oversluma_lsb_ptr(0)

	mov	DWORD PTR [ebx+244], 0

; 423  :   , _overschroma_lsb_ptr(0)

	mov	DWORD PTR [ebx+248], 0

; 424  :   , _degrainluma_ptr(0)

	mov	DWORD PTR [ebx+252], 0

; 425  :   , _degrainchroma_ptr(0)

	mov	DWORD PTR [ebx+256], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ebx+260], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ebx+264], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ebx+268], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 427  :   , _dst_short_pitch()

	mov	DWORD PTR [ebx+272], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ebx+276], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ebx+280], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ebx+284], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 429  :   , _dst_int_pitch()

	mov	DWORD PTR [ebx+288], 0

; 430  :   //,	_usable_flag_arr ()
; 431  :   //,	_planes_ptr ()
; 432  :   //,	_dst_ptr_arr ()
; 433  :   //,	_src_ptr_arr ()
; 434  :   //,	_dst_pitch_arr ()
; 435  :   //,	_src_pitch_arr ()
; 436  :   //,	_lsb_offset_arr ()
; 437  :   , _covered_width(0)

	mov	DWORD PTR [ebx+3680], 0

; 438  :   , _covered_height(0)

	mov	DWORD PTR [ebx+3684], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ebx+3688], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ebx+3692], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ebx+3696], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 439  :   , _boundary_cnt_arr()

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH

; 441  :   if (trad > MAX_TEMP_RAD)

	cmp	esi, 128				; 00000080H
	jle	SHORT $LN8@MDegrainN

; 442  :   {
; 443  :     env_ptr->ThrowError(

	mov	eax, DWORD PTR [edi]
	push	128					; 00000080H
	push	OFFSET ??_C@_0CO@DEKDPFLP@MDegrainN?3?5temporal?5radius?5too?5l@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@MDegrainN
$LN8@MDegrainN:

; 444  :       "MDegrainN: temporal radius too large (max %d)",
; 445  :       MAX_TEMP_RAD
; 446  :     );
; 447  :   }
; 448  :   else if (trad < 1)

	cmp	esi, 1
	jge	SHORT $LN10@MDegrainN

; 449  :   {
; 450  :     env_ptr->ThrowError("MDegrainN: temporal radius must be at least 1.");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CP@EGMOGFCC@MDegrainN?3?5temporal?5radius?5must?5@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN10@MDegrainN:

; 451  :   }
; 452  : 
; 453  :   _mv_clip_arr.resize(_trad * 2);

	mov	eax, DWORD PTR [ebx+164]
	lea	ecx, DWORD PTR [ebx+152]
	add	eax, eax
	push	eax
	call	?resize@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::resize

; 454  :   for (int k = 0; k < _trad * 2; ++k)

	mov	eax, DWORD PTR [ebx+164]
	xor	esi, esi
	add	eax, eax
	mov	DWORD PTR _k$1$[ebp], esi
	test	eax, eax
	jle	$LN3@MDegrainN

; 451  :   }
; 452  : 
; 453  :   _mv_clip_arr.resize(_trad * 2);

	mov	DWORD PTR tv2852[ebp], esi
	jmp	SHORT $LN4@MDegrainN
	npad	8
$LL473@MDegrainN:
	mov	edi, DWORD PTR _env_ptr$[ebp]
$LN4@MDegrainN:

; 456  :     _mv_clip_arr[k]._clip_sptr = SharedPtr <MVClip>(

	push	240					; 000000f0H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T7[ebp], ecx
	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	eax, DWORD PTR [ebx+164]
	add	eax, eax
	push	eax
	push	edi
	push	DWORD PTR _nscd2$[ebp]
	lea	eax, DWORD PTR _mvmulti$[ebp]
	push	DWORD PTR _nscd1$[ebp]
	push	eax
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	DWORD PTR $T6[ebp], ecx
; File c:\github\mvtools\sources\sharedptr.hpp

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	test	ecx, ecx
	je	SHORT $LN137@MDegrainN
	push	4
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR $T6[ebp]
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR [edi], 1
	jmp	SHORT $LN138@MDegrainN
$LN137@MDegrainN:
	xor	edi, edi
$LN138@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 456  :     _mv_clip_arr[k]._clip_sptr = SharedPtr <MVClip>(

	mov	esi, DWORD PTR [ebx+152]
	add	esi, DWORD PTR tv2852[ebp]
; File c:\github\mvtools\sources\sharedptr.hpp

; 81   : 	if (other._obj_ptr != _obj_ptr)

	mov	eax, DWORD PTR [esi]
	cmp	ecx, eax
	je	SHORT $LN160@MDegrainN

; 284  : 	if (_obj_ptr != 0)

	test	eax, eax
	je	SHORT $LN155@MDegrainN

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN155@MDegrainN

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN157@MDegrainN
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN157@MDegrainN:

; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR $T6[ebp]
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN155@MDegrainN:

; 84   : 		_obj_ptr = other._obj_ptr;

	mov	DWORD PTR [esi], ecx

; 85   : 		_count_ptr = other._count_ptr;

	mov	DWORD PTR [esi+4], edi

; 259  : 	if (_count_ptr != 0)

	test	edi, edi
	je	SHORT $LN160@MDegrainN

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [edi]
$LN160@MDegrainN:

; 284  : 	if (_obj_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN167@MDegrainN

; 285  : 	{
; 286  : 		-- *_count_ptr;

	add	DWORD PTR [edi], -1

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	jne	SHORT $LN167@MDegrainN

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]

; 293  : 			delete _count_ptr;

	push	4
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN167@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 462  :     sprintf(txt_0, "%s%d", name_0[k & 1], 1 + k / 2);

	mov	esi, DWORD PTR _k$1$[ebp]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	inc	eax
	push	eax
	mov	eax, esi
	and	eax, 1
	push	DWORD PTR ?name_0@?L@???0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z@4PAPBDA[eax*4]
	lea	eax, DWORD PTR _txt_0$2[ebp]
	push	OFFSET ??_C@_04HGGBINEM@?$CFs?$CFd?$AA@
	push	eax
	call	_sprintf
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [ebx+152]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 463  :     CheckSimilarity(*(_mv_clip_arr[k]._clip_sptr), txt_0, env_ptr);

	lea	ecx, DWORD PTR _txt_0$2[ebp]
	mov	edi, DWORD PTR tv2852[ebp]
	add	esp, 16					; 00000010H
	push	DWORD PTR _env_ptr$[ebp]
	push	ecx
	push	DWORD PTR [edi+eax]
	lea	ecx, DWORD PTR [ebx+64]
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity
	mov	eax, DWORD PTR [ebx+164]
	inc	esi
	add	edi, 24					; 00000018H
	mov	DWORD PTR _k$1$[ebp], esi
	add	eax, eax
	mov	DWORD PTR tv2852[ebp], edi
	cmp	esi, eax
	jl	$LL473@MDegrainN
$LN3@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR $T4[ebp]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\sharedptr.hpp

; 171  : 	return (_obj_ptr);

	mov	ecx, DWORD PTR [ecx]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 467  :   thsad = (uint64_t)thsad   * mv_thscd1 / nscd1;	// normalize to block SAD

	mov	eax, DWORD PTR [ecx+216]
	cdq
	mov	edi, eax
	mov	esi, edx
	mov	eax, DWORD PTR _nscd1$[ebp]
	cdq
	mov	DWORD PTR tv2679[ebp], eax
	mov	ebx, edx
	mov	eax, DWORD PTR _thsad$[ebp]
	push	esi
	cdq
	push	edi
	push	edx
	push	eax
	call	__allmul
	push	ebx
	push	DWORD PTR tv2679[ebp]
	push	edx
	push	eax
	call	__aulldiv
	mov	DWORD PTR _thsad$1$[ebp], eax

; 468  :   thsadc = (uint64_t)thsadc  * mv_thscd1 / nscd1;	// chroma

	mov	eax, DWORD PTR _thsadc$[ebp]
	push	esi
	cdq
	push	edi
	push	edx
	push	eax
	call	__allmul
	push	ebx
	push	DWORD PTR tv2679[ebp]
	push	edx
	push	eax
	call	__aulldiv
	mov	DWORD PTR _thsadc$1$[ebp], eax

; 469  :   thsad2 = (uint64_t)thsad2  * mv_thscd1 / nscd1;

	mov	eax, DWORD PTR _thsad2$[ebp]
	push	esi
	cdq
	push	edi
	push	edx
	push	eax
	call	__allmul
	push	ebx
	push	DWORD PTR tv2679[ebp]
	push	edx
	push	eax
	call	__aulldiv
	mov	DWORD PTR _thsad2$1$[ebp], eax

; 470  :   thsadc2 = (uint64_t)thsadc2 * mv_thscd1 / nscd1;

	mov	eax, DWORD PTR _thsadc2$[ebp]
	push	esi
	cdq
	push	edi
	push	edx
	push	eax
	call	__allmul
	push	ebx
	push	DWORD PTR tv2679[ebp]
	push	edx
	push	eax
	call	__aulldiv
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	edx, DWORD PTR _this$1$[ebp]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 470  :   thsadc2 = (uint64_t)thsadc2 * mv_thscd1 / nscd1;

	mov	esi, eax
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN50@MDegrainN

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	ebx, DWORD PTR [edx+16]
	mov	DWORD PTR _vi_super$1$[ebp], ebx
	jmp	SHORT $LN49@MDegrainN
$LN50@MDegrainN:
	push	edx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 472  :   const ::VideoInfo &vi_super = _super->GetVideoInfo();

	call	ecx
	mov	ebx, eax
	mov	DWORD PTR _vi_super$1$[ebp], eax
$LN49@MDegrainN:
; File c:\github\mvtools\sources\include\avisynth.h

; 692  :   int ComponentSize() const AVS_BakedCode(return AVS_LinkCallOptDefault(ComponentSize, 1))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN205@MDegrainN
	cmp	DWORD PTR [eax], 532			; 00000214H
	jbe	SHORT $LN205@MDegrainN
	mov	eax, DWORD PTR [eax+532]
	mov	ecx, ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN206@MDegrainN
$LN205@MDegrainN:
	mov	ecx, 1
$LN206@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 474  :   pixelsize_super = vi_super.ComponentSize(); // of MVFilter

	mov	edi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edi+192], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	test	eax, eax
	je	SHORT $LN209@MDegrainN
	cmp	DWORD PTR [eax], 536			; 00000218H
	jbe	SHORT $LN209@MDegrainN
	mov	eax, DWORD PTR [eax+536]
	mov	ecx, ebx
	call	eax
	jmp	SHORT $LN210@MDegrainN
$LN209@MDegrainN:
	mov	eax, 8
$LN210@MDegrainN:
	movd	xmm0, DWORD PTR _thsad$1$[ebp]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 488  :   thsad = sad_t(thsad / 255.0 * ((1 << bits_per_pixel) - 1));

	movsd	xmm1, QWORD PTR __real@406fe00000000000
	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [edi+196], eax
	mov	edx, DWORD PTR [ebx+32]
	mov	ecx, DWORD PTR [ebx+36]
	movzx	eax, dx
	mov	DWORD PTR _nHeightS$1$[ebp], eax
	mov	eax, edx
	shr	eax, 16					; 00000010H
	divsd	xmm0, xmm1
	movzx	eax, al
	mov	DWORD PTR _nSuperHPad$1$[ebp], eax
	movzx	eax, cl
	mov	DWORD PTR _nSuperPel$1$[ebp], eax
	mov	eax, ecx
	shr	eax, 16					; 00000010H
	movzx	eax, al
	mov	DWORD PTR _nSuperLevels$1$[ebp], eax
	shr	ecx, 8
	movzx	eax, cl
	mov	ecx, DWORD PTR [edi+140]
	mov	DWORD PTR [edi+208], eax
	mov	eax, 1
	shl	eax, cl
	dec	eax
	shr	edx, 24					; 00000018H
	mov	DWORD PTR _nSuperVPad$1$[ebp], edx

; 489  :   thsadc = sad_t(thsadc / 255.0 * ((1 << bits_per_pixel) - 1));
; 490  :   thsad2 = sad_t(thsad2 / 255.0 * ((1 << bits_per_pixel) - 1));
; 491  :   thsadc2 = sad_t(thsadc2 / 255.0 * ((1 << bits_per_pixel) - 1));
; 492  : 
; 493  :   for (int k = 0; k < _trad * 2; ++k)

	mov	DWORD PTR _k$1$[ebp], 0
	movd	xmm2, eax
	cvtdq2pd xmm2, xmm2
	mulsd	xmm0, xmm2
	cvttsd2si eax, xmm0
	movd	xmm0, DWORD PTR _thsadc$1$[ebp]
	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR _thsad$2$[ebp], eax
	divsd	xmm0, xmm1
	mulsd	xmm0, xmm2
	cvttsd2si eax, xmm0
	movd	xmm0, DWORD PTR _thsad2$1$[ebp]
	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR _thsadc$2$[ebp], eax
	divsd	xmm0, xmm1
	mulsd	xmm0, xmm2
	cvttsd2si eax, xmm0
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR _thsad2$2$[ebp], eax
	divsd	xmm0, xmm1
	mulsd	xmm0, xmm2
	cvttsd2si eax, xmm0
	mov	DWORD PTR _thsadc2$2$[ebp], eax
	mov	eax, DWORD PTR [edi+164]
	add	eax, eax
	test	eax, eax
	jle	$LN6@MDegrainN

; 475  :   bits_per_pixel_super = vi_super.BitsPerComponent();

	xor	edx, edx
	mov	DWORD PTR tv2851[ebp], edx
	npad	3
$LL7@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	esi, DWORD PTR [edi+152]
	add	esi, edx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 497  :     c_info._gof_sptr = SharedPtr <MVGroupOfFrames>(new MVGroupOfFrames(

	push	44					; 0000002cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	DWORD PTR _c_info$1$[ebp], esi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 497  :     c_info._gof_sptr = SharedPtr <MVGroupOfFrames>(new MVGroupOfFrames(

	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T3[ebp], ecx
	push	DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	push	DWORD PTR [edi+196]
	movzx	eax, BYTE PTR [edi+184]
	push	DWORD PTR [edi+192]
	push	DWORD PTR [edi+124]
	push	DWORD PTR [edi+120]
	push	eax
	push	DWORD PTR [edi+208]
	push	DWORD PTR _nSuperVPad$1$[ebp]
	push	DWORD PTR _nSuperHPad$1$[ebp]
	push	DWORD PTR _nSuperPel$1$[ebp]
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	push	DWORD PTR _nSuperLevels$1$[ebp]
	call	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ; MVGroupOfFrames::MVGroupOfFrames
	mov	ebx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	DWORD PTR $T14[ebp], ebx
; File c:\github\mvtools\sources\sharedptr.hpp

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	test	ebx, ebx
	je	SHORT $LN226@MDegrainN
	push	4
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR [ecx], 1
	jmp	SHORT $LN475@MDegrainN
$LN226@MDegrainN:
	xor	ecx, ecx
$LN475@MDegrainN:

; 81   : 	if (other._obj_ptr != _obj_ptr)

	mov	eax, DWORD PTR [esi+8]

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	mov	DWORD PTR $T8[ebp], ecx

; 81   : 	if (other._obj_ptr != _obj_ptr)

	cmp	ebx, eax
	je	SHORT $LN242@MDegrainN

; 284  : 	if (_obj_ptr != 0)

	test	eax, eax
	je	SHORT $LN233@MDegrainN

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+12]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN233@MDegrainN

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T5[ebp], eax
	test	eax, eax
	je	SHORT $LN238@MDegrainN
	mov	ecx, eax
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	DWORD PTR $T5[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN238@MDegrainN:

; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 0
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR $T8[ebp]
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+12], 0
$LN233@MDegrainN:

; 84   : 		_obj_ptr = other._obj_ptr;

	mov	DWORD PTR [esi+8], ebx

; 85   : 		_count_ptr = other._count_ptr;

	mov	DWORD PTR [esi+12], ecx

; 259  : 	if (_count_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN242@MDegrainN

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [ecx]
$LN242@MDegrainN:

; 284  : 	if (_obj_ptr != 0)

	test	ebx, ebx
	je	$LN249@MDegrainN

; 285  : 	{
; 286  : 		-- *_count_ptr;

	add	DWORD PTR [ecx], -1

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	jne	$LN249@MDegrainN
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 72   :    for ( int i = 0; i < nLevelCount; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [ebx], ecx
	jle	$LN259@MDegrainN
	npad	4
$LL260@MDegrainN:

; 73   : 	{
; 74   :       delete pFrames[i];

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [eax+ecx*4]
	test	esi, esi
	je	SHORT $LN258@MDegrainN
; File c:\github\mvtools\sources\mvframe.cpp

; 79   :    if ( nMode & YPLANE )

	test	BYTE PTR [esi+12], 1
	je	SHORT $LN282@MDegrainN

; 80   :       delete pYPlane;

	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN282@MDegrainN
	mov	ecx, ebx
	call	??1MVPlane@@QAE@XZ			; MVPlane::~MVPlane
	push	2088					; 00000828H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN282@MDegrainN:

; 81   : 
; 82   :    if ( nMode & UPLANE )

	test	BYTE PTR [esi+12], 2
	je	SHORT $LN286@MDegrainN

; 83   :       delete pUPlane;

	mov	ebx, DWORD PTR [esi+4]
	test	ebx, ebx
	je	SHORT $LN286@MDegrainN
	mov	ecx, ebx
	call	??1MVPlane@@QAE@XZ			; MVPlane::~MVPlane
	push	2088					; 00000828H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN286@MDegrainN:

; 84   : 
; 85   :    if ( nMode & VPLANE )

	test	BYTE PTR [esi+12], 4
	je	SHORT $LN290@MDegrainN

; 86   :       delete pVPlane;

	mov	ebx, DWORD PTR [esi+8]
	test	ebx, ebx
	je	SHORT $LN290@MDegrainN
	mov	ecx, ebx
	call	??1MVPlane@@QAE@XZ			; MVPlane::~MVPlane
	push	2088					; 00000828H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN290@MDegrainN:
	push	36					; 00000024H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR _i$1$[ebp]
	add	esp, 8
	mov	ebx, DWORD PTR $T14[ebp]
$LN258@MDegrainN:
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 72   :    for ( int i = 0; i < nLevelCount; i++ )

	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx]
	jl	$LL260@MDegrainN
$LN259@MDegrainN:

; 75   : 	}
; 76   : 
; 77   :    delete[] pFrames;

	push	DWORD PTR [ebx+4]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	44					; 0000002cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
; File c:\github\mvtools\sources\sharedptr.hpp

; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR $T8[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN249@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 515  :     const int		d = k / 2 + 1;

	mov	eax, DWORD PTR _k$1$[ebp]

; 516  :     c_info._thsad = ClipFnc::interpolate_thsad(thsad, thsad2, d, _trad);

	push	DWORD PTR [edi+164]
	mov	ecx, DWORD PTR _thsad$2$[ebp]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _thsad2$2$[ebp]
	mov	esi, eax
	sar	esi, 1
	inc	esi
	push	esi
	call	?interpolate_thsad@ClipFnc@@SAHHHHH@Z	; ClipFnc::interpolate_thsad
	mov	ebx, DWORD PTR _c_info$1$[ebp]

; 517  :     c_info._thsadc = ClipFnc::interpolate_thsad(thsadc, thsadc2, d, _trad);

	mov	edx, DWORD PTR _thsadc2$2$[ebp]
	mov	ecx, DWORD PTR _thsadc$2$[ebp]
	mov	DWORD PTR [ebx+16], eax
	push	DWORD PTR [edi+164]
	push	esi
	call	?interpolate_thsad@ClipFnc@@SAHHHHH@Z	; ClipFnc::interpolate_thsad
	mov	ecx, DWORD PTR _k$1$[ebp]
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR tv2851[ebp]
	inc	ecx
	mov	DWORD PTR [ebx+20], eax
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR [edi+164]
	add	eax, eax
	mov	DWORD PTR _k$1$[ebp], ecx
	mov	DWORD PTR tv2851[ebp], edx
	cmp	ecx, eax
	jl	$LL7@MDegrainN
	mov	ebx, DWORD PTR _vi_super$1$[ebp]
$LN6@MDegrainN:

; 518  :   }
; 519  : 
; 520  :   const int nSuperWidth = vi_super.width;
; 521  :   const int nSuperHeight = vi_super.height;
; 522  : 
; 523  :   if (nHeight != nHeightS
; 524  :     || nHeight != vi.height
; 525  :     || nWidth != nSuperWidth - nSuperHPad * 2
; 526  :     || nWidth != vi.width
; 527  :     || nPel != nSuperPel)

	mov	eax, DWORD PTR [edi+96]
	mov	ecx, DWORD PTR [ebx]
	cmp	eax, DWORD PTR _nHeightS$1$[ebp]
	jne	SHORT $LN12@MDegrainN
	cmp	eax, DWORD PTR [edi+20]
	jne	SHORT $LN12@MDegrainN
	mov	eax, DWORD PTR _nSuperHPad$1$[ebp]
	mov	edx, DWORD PTR [edi+92]
	add	eax, eax
	sub	ecx, eax
	cmp	edx, ecx
	jne	SHORT $LN12@MDegrainN
	cmp	edx, DWORD PTR [edi+16]
	jne	SHORT $LN12@MDegrainN
	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	cmp	DWORD PTR [edi+104], eax
	je	SHORT $LN472@MDegrainN
$LN12@MDegrainN:

; 528  :   {
; 529  :     env_ptr->ThrowError("MDegrainN : wrong source or super frame size");

	mov	ebx, DWORD PTR _env_ptr$[ebp]
	push	OFFSET ??_C@_0CN@LKJJHKJJ@MDegrainN?5?3?5wrong?5source?5or?5supe@
	push	ebx
	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax+20]
	add	esp, 8
	jmp	SHORT $LN11@MDegrainN
$LN472@MDegrainN:
	mov	ebx, DWORD PTR _env_ptr$[ebp]
$LN11@MDegrainN:

; 530  :   }
; 531  : 
; 532  :   if(lsb_flag && pixelsize != 1)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	je	SHORT $LN13@MDegrainN
	cmp	DWORD PTR [edi+136], 1
	je	SHORT $LN13@MDegrainN

; 533  :     env_ptr->ThrowError("MDegrainN : lsb_flag only for 8 bit sources");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0CM@JJAGFGCG@MDegrainN?5?3?5lsb_flag?5only?5for?58?5@
	push	ebx
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN13@MDegrainN:

; 534  : 
; 535  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !_planar_flag)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN367@MDegrainN
	cmp	BYTE PTR [edi+185], 0
	jne	$LN367@MDegrainN

; 536  :   {
; 537  :     _dst_planes = std::auto_ptr <YUY2Planes>(

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	mov	DWORD PTR $T13[ebp], ebx
	mov	eax, DWORD PTR [edi+92]
	mov	esi, DWORD PTR [edi+188]
	imul	esi, DWORD PTR [edi+96]
	mov	DWORD PTR [ebx+12], eax
; File c:\github\mvtools\sources\yuy2planes.cpp

; 28   :   srcPitch = (nWidth + 15) & (~15);

	lea	ecx, DWORD PTR [eax+15]

; 29   :   srcPitchUV = (nWidth / 2 + 15) & (~15); //v 1.2.1

	cdq
	and	ecx, -16				; fffffff0H
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [ebx+16], esi
	add	eax, 15					; 0000000fH

; 30   :   pSrc = (unsigned char*)_aligned_malloc(srcPitch*nHeight, 128);   //v 1.2.1

	imul	esi, ecx
	and	eax, -16				; fffffff0H
	push	128					; 00000080H
	mov	DWORD PTR [ebx+20], ecx

; 29   :   srcPitchUV = (nWidth / 2 + 15) & (~15); //v 1.2.1

	mov	DWORD PTR [ebx+24], eax

; 30   :   pSrc = (unsigned char*)_aligned_malloc(srcPitch*nHeight, 128);   //v 1.2.1

	push	esi
	mov	esi, DWORD PTR __imp___aligned_malloc
	call	esi
	mov	DWORD PTR [ebx], eax

; 31   :   pSrcU = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [ebx+24]
	imul	eax, DWORD PTR [ebx+16]
	push	128					; 00000080H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+4], eax

; 32   :   pSrcV = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [ebx+24]
	imul	eax, DWORD PTR [ebx+16]
	push	128					; 00000080H
	push	eax
	call	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	esi, DWORD PTR __imp___aligned_free
; File c:\github\mvtools\sources\yuy2planes.cpp

; 32   :   pSrcV = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	add	esp, 28					; 0000001cH
	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	eax, DWORD PTR [edi+212]
	mov	DWORD PTR $T9[ebp], eax
	cmp	ebx, eax
	je	SHORT $LN318@MDegrainN

; 795  : 			delete _Myptr;

	test	eax, eax
	je	SHORT $LN318@MDegrainN
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [eax]
	call	esi

; 38   :   _aligned_free(pSrcU);

	mov	eax, DWORD PTR $T9[ebp]
	push	DWORD PTR [eax+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	mov	eax, DWORD PTR $T9[ebp]
	push	DWORD PTR [eax+8]
	call	esi
	push	28					; 0000001cH
	push	DWORD PTR $T9[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN318@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 540  :     _src_planes = std::auto_ptr <YUY2Planes>(

	push	28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+212], ebx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 540  :     _src_planes = std::auto_ptr <YUY2Planes>(

	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	mov	DWORD PTR $T12[ebp], ebx
	mov	eax, DWORD PTR [edi+92]
	mov	esi, DWORD PTR [edi+96]
	mov	DWORD PTR [ebx+12], eax
	mov	DWORD PTR [ebx+16], esi
; File c:\github\mvtools\sources\yuy2planes.cpp

; 28   :   srcPitch = (nWidth + 15) & (~15);

	lea	ecx, DWORD PTR [eax+15]

; 29   :   srcPitchUV = (nWidth / 2 + 15) & (~15); //v 1.2.1

	cdq
	and	ecx, -16				; fffffff0H
	sub	eax, edx

; 30   :   pSrc = (unsigned char*)_aligned_malloc(srcPitch*nHeight, 128);   //v 1.2.1

	imul	esi, ecx
	sar	eax, 1
	add	eax, 15					; 0000000fH
	mov	DWORD PTR [ebx+20], ecx

; 29   :   srcPitchUV = (nWidth / 2 + 15) & (~15); //v 1.2.1

	and	eax, -16				; fffffff0H

; 30   :   pSrc = (unsigned char*)_aligned_malloc(srcPitch*nHeight, 128);   //v 1.2.1

	push	128					; 00000080H
	push	esi
	mov	esi, DWORD PTR __imp___aligned_malloc
	mov	DWORD PTR [ebx+24], eax
	call	esi
	mov	DWORD PTR [ebx], eax

; 31   :   pSrcU = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, DWORD PTR [ebx+24]
	push	128					; 00000080H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+4], eax

; 32   :   pSrcV = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, DWORD PTR [ebx+24]
	push	128					; 00000080H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+8], eax
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	esi, DWORD PTR [edi+216]
	cmp	ebx, esi
	je	SHORT $LN355@MDegrainN

; 795  : 			delete _Myptr;

	test	esi, esi
	je	SHORT $LN355@MDegrainN
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [esi]
	call	DWORD PTR __imp___aligned_free

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [esi+4]
	call	DWORD PTR __imp___aligned_free

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp___aligned_free
	push	28					; 0000001cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN355@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+216], ebx
$LN367@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 544  :   _dst_short_pitch = ((nWidth + 15) / 16) * 16;

	mov	eax, DWORD PTR [edi+92]
	add	eax, 15					; 0000000fH
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	and	eax, -16				; fffffff0H

; 545  :   _dst_int_pitch = _dst_short_pitch;
; 546  :   if (nOverlapX > 0 || nOverlapY > 0)

	cmp	DWORD PTR [edi+108], 0
	mov	DWORD PTR [edi+272], eax
	mov	DWORD PTR [edi+288], eax
	jg	SHORT $LN16@MDegrainN
	cmp	DWORD PTR [edi+112], 0
	jle	$LN20@MDegrainN
$LN16@MDegrainN:

; 547  :   {
; 548  :     _overwins = std::auto_ptr <OverlapWindows>(

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, eax
	push	DWORD PTR [edi+112]
	push	DWORD PTR [edi+108]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [edi+76]
	call	??0OverlapWindows@@QAE@HHHH@Z		; OverlapWindows::OverlapWindows
	mov	ebx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	esi, DWORD PTR [edi+220]
	cmp	ebx, esi
	je	SHORT $LN390@MDegrainN

; 795  : 			delete _Myptr;

	test	esi, esi
	je	SHORT $LN390@MDegrainN
; File c:\github\mvtools\sources\overlap.cpp

; 136  : 	delete [] Overlap9Windows;

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 137  : 	delete [] fWin1UVx;

	push	DWORD PTR [esi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 138  : 	delete [] fWin1UVxfirst;

	push	DWORD PTR [esi+28]
	call	??_V@YAXPAX@Z				; operator delete[]

; 139  : 	delete [] fWin1UVxlast;

	push	DWORD PTR [esi+32]
	call	??_V@YAXPAX@Z				; operator delete[]

; 140  : 	delete [] fWin1UVy;

	push	DWORD PTR [esi+36]
	call	??_V@YAXPAX@Z				; operator delete[]

; 141  : 	delete [] fWin1UVyfirst;

	push	DWORD PTR [esi+40]
	call	??_V@YAXPAX@Z				; operator delete[]

; 142  : 	delete [] fWin1UVylast;

	push	DWORD PTR [esi+44]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	48					; 00000030H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 36					; 00000024H
$LN390@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 551  :     _overwins_uv = std::auto_ptr <OverlapWindows>(new OverlapWindows(

	push	48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+220], ebx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 551  :     _overwins_uv = std::auto_ptr <OverlapWindows>(new OverlapWindows(

	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T10[ebp], ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+204]
	mov	ecx, esi
	mov	edi, DWORD PTR [edi+200]
	mov	edx, DWORD PTR [edx+112]
	sar	edx, cl
	mov	ecx, edi
	push	edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	sar	eax, cl
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+80]
	sar	eax, cl
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [edx+76]
	sar	eax, cl
	mov	ecx, ebx
	push	eax
	call	??0OverlapWindows@@QAE@HHHH@Z		; OverlapWindows::OverlapWindows
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi+224]
	cmp	ebx, esi
	je	SHORT $LN425@MDegrainN

; 795  : 			delete _Myptr;

	test	esi, esi
	je	SHORT $LN425@MDegrainN
; File c:\github\mvtools\sources\overlap.cpp

; 136  : 	delete [] Overlap9Windows;

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 137  : 	delete [] fWin1UVx;

	push	DWORD PTR [esi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 138  : 	delete [] fWin1UVxfirst;

	push	DWORD PTR [esi+28]
	call	??_V@YAXPAX@Z				; operator delete[]

; 139  : 	delete [] fWin1UVxlast;

	push	DWORD PTR [esi+32]
	call	??_V@YAXPAX@Z				; operator delete[]

; 140  : 	delete [] fWin1UVy;

	push	DWORD PTR [esi+36]
	call	??_V@YAXPAX@Z				; operator delete[]

; 141  : 	delete [] fWin1UVyfirst;

	push	DWORD PTR [esi+40]
	call	??_V@YAXPAX@Z				; operator delete[]

; 142  : 	delete [] fWin1UVylast;

	push	DWORD PTR [esi+44]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	48					; 00000030H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 36					; 00000024H
$LN425@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+224], ebx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 555  :     if (_lsb_flag || pixelsize_super > 1) // PF or pixelsize?

	cmp	BYTE PTR [edi+186], 0
	jne	SHORT $LN19@MDegrainN
	cmp	DWORD PTR [edi+192], 1
	jg	SHORT $LN19@MDegrainN

; 558  :     }
; 559  :     else
; 560  :     {
; 561  :       _dst_short.resize(_dst_short_pitch * nHeight);

	mov	eax, DWORD PTR [edi+272]
	lea	ecx, DWORD PTR [edi+260]
	imul	eax, DWORD PTR [edi+96]
	push	eax
	call	?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
	jmp	SHORT $LN18@MDegrainN
$LN19@MDegrainN:

; 556  :     {
; 557  :       _dst_int.resize(_dst_int_pitch * nHeight);

	mov	eax, DWORD PTR [edi+288]
	lea	ecx, DWORD PTR [edi+276]
	imul	eax, DWORD PTR [edi+96]
	push	eax
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize
$LN18@MDegrainN:

; 562  :     }
; 563  :   }
; 564  :   if (nOverlapY > 0)

	cmp	DWORD PTR [edi+112], 0
	jle	SHORT $LN20@MDegrainN

; 565  :   {
; 566  :     _boundary_cnt_arr.resize(nBlkY);

	push	DWORD PTR [edi+68]
	lea	ecx, DWORD PTR [edi+3688]
	call	?resize@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::resize
$LN20@MDegrainN:

; 567  :   }
; 568  : 
; 569  :     // in overlaps.h
; 570  :     // OverlapsLsbFunction
; 571  :     // OverlapsFunction
; 572  :     // in M(V)DegrainX: DenoiseXFunction
; 573  :   arch_t arch;
; 574  :   if ((((env_ptr->GetCPUFlags() & CPUF_AVX2) != 0) & isse_flag))

	mov	ebx, DWORD PTR _env_ptr$[ebp]
	movzx	eax, BYTE PTR _isse_flag$[ebp]
	mov	DWORD PTR tv2859[ebp], eax
	push	ebx
	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax+4]
	mov	esi, DWORD PTR tv2859[ebp]
	shr	eax, 13					; 0000000dH
	and	eax, esi
	test	al, 1
	je	SHORT $LN21@MDegrainN

; 575  :     arch = USE_AVX2;

	mov	esi, 6
	jmp	SHORT $LN27@MDegrainN
$LN21@MDegrainN:

; 576  :   else if ((((env_ptr->GetCPUFlags() & CPUF_AVX) != 0) & isse_flag))

	mov	eax, DWORD PTR [ebx]
	push	ebx
	call	DWORD PTR [eax+4]
	shr	eax, 11					; 0000000bH
	and	eax, esi
	test	al, 1
	je	SHORT $LN23@MDegrainN

; 577  :     arch = USE_AVX;

	mov	esi, 5
	jmp	SHORT $LN27@MDegrainN
$LN23@MDegrainN:

; 578  :   else if ((((env_ptr->GetCPUFlags() & CPUF_SSE4_1) != 0) & isse_flag))

	mov	eax, DWORD PTR [ebx]
	push	ebx
	call	DWORD PTR [eax+4]
	shr	eax, 10					; 0000000aH
	and	eax, esi
	test	al, 1
	je	SHORT $LN25@MDegrainN

; 579  :     arch = USE_SSE41;

	mov	esi, 3
	jmp	SHORT $LN27@MDegrainN
$LN25@MDegrainN:

; 580  :   else if ((((env_ptr->GetCPUFlags() & CPUF_SSE2) != 0) & isse_flag))

	mov	eax, DWORD PTR [ebx]
	push	ebx
	call	DWORD PTR [eax+4]
	shr	eax, 5
	movzx	esi, al
	mov	eax, DWORD PTR tv2859[ebp]
	movzx	eax, al
	and	esi, eax
	and	esi, 1
	add	esi, esi
$LN27@MDegrainN:

; 581  :     arch = USE_SSE2;
; 582  : /*  else if ((pixelsize == 1) && _isse_flag) // PF no MMX support
; 583  :     arch = USE_MMX;*/
; 584  :   else
; 585  :     arch = NO_SIMD;
; 586  : 
; 587  : // C only -> NO_SIMD
; 588  :   _oversluma_lsb_ptr = get_overlaps_lsb_function(nBlkSizeX, nBlkSizeY, sizeof(uint8_t), NO_SIMD);

	mov	edx, DWORD PTR [edi+80]
	sub	esp, 8
	mov	ecx, DWORD PTR [edi+76]
	call	?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_lsb_function
	mov	DWORD PTR [edi+244], eax

; 589  :   _overschroma_lsb_ptr = get_overlaps_lsb_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, sizeof(uint8_t), NO_SIMD);

	mov	eax, DWORD PTR [edi+80]
	cdq
	idiv	DWORD PTR [edi+124]
	mov	ecx, eax
	mov	eax, DWORD PTR [edi+76]
	cdq
	idiv	DWORD PTR [edi+120]
	mov	edx, ecx
	mov	ecx, eax
	call	?get_overlaps_lsb_function@@YAP6AXPAHHPBE1HPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_lsb_function

; 590  : 
; 591  :   _oversluma_ptr = get_overlaps_function(nBlkSizeX, nBlkSizeY, pixelsize_super, arch);

	mov	edx, DWORD PTR [edi+80]
	mov	ecx, DWORD PTR [edi+76]
	push	esi
	push	DWORD PTR [edi+192]
	mov	DWORD PTR [edi+248], eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function
	mov	DWORD PTR [edi+228], eax

; 592  :   _overschroma_ptr = get_overlaps_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, pixelsize_super, arch);

	mov	eax, DWORD PTR [edi+80]
	cdq
	idiv	DWORD PTR [edi+124]
	push	esi
	mov	ecx, eax
	mov	eax, DWORD PTR [edi+76]
	cdq
	idiv	DWORD PTR [edi+120]
	push	DWORD PTR [edi+192]
	mov	edx, ecx
	mov	ecx, eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 593  : 
; 594  :   _oversluma16_ptr = get_overlaps_function(nBlkSizeX, nBlkSizeY, sizeof(uint16_t), arch);

	mov	edx, DWORD PTR [edi+80]
	mov	ecx, DWORD PTR [edi+76]
	push	esi
	push	2
	mov	DWORD PTR [edi+232], eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 595  :   _overschroma16_ptr = get_overlaps_function(nBlkSizeX >> nLogxRatioUV, nBlkSizeY >> nLogyRatioUV, sizeof(uint16_t), arch);

	mov	edx, DWORD PTR [edi+80]
	mov	ecx, DWORD PTR [edi+132]
	mov	DWORD PTR [edi+236], eax
	mov	eax, DWORD PTR [edi+76]
	sar	edx, cl
	mov	ecx, DWORD PTR [edi+128]
	sar	eax, cl
	push	esi
	push	2
	mov	ecx, eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function
	add	esp, 40					; 00000028H
	mov	DWORD PTR [edi+240], eax

; 596  : 
; 597  :   _degrainluma_ptr = get_denoiseN_function(nBlkSizeX, nBlkSizeY, pixelsize_super, arch);

	push	esi
	push	ecx
	push	DWORD PTR [edi+80]
	mov	ecx, edi
	push	DWORD PTR [edi+76]
	call	?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z ; MDegrainN::get_denoiseN_function
	mov	DWORD PTR [edi+252], eax

; 598  :   _degrainchroma_ptr = get_denoiseN_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, pixelsize_super, arch);

	mov	eax, DWORD PTR [edi+80]
	cdq
	idiv	DWORD PTR [edi+124]
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edi+76]
	mov	ecx, edi
	cdq
	idiv	DWORD PTR [edi+120]
	push	eax
	call	?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z ; MDegrainN::get_denoiseN_function

; 599  : 
; 600  :   if (!_oversluma_lsb_ptr)

	cmp	DWORD PTR [edi+244], 0
	mov	DWORD PTR [edi+256], eax
	jne	SHORT $LN29@MDegrainN

; 601  :     env_ptr->ThrowError("MDegrainN : no valid _oversluma_lsb_ptr function for %dx%d, pixelsize=%d, lsb_flag=%d", nBlkSizeX, nBlkSizeY, pixelsize_super, (int)lsb_flag);

	movzx	eax, BYTE PTR _lsb_flag$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR [edi+192]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [edi+76]
	push	OFFSET ??_C@_0FG@FPIOMAPB@MDegrainN?5?3?5no?5valid?5_oversluma_@
	push	ebx
	call	DWORD PTR [ecx+20]
	add	esp, 24					; 00000018H
$LN29@MDegrainN:

; 602  :   if (!_overschroma_lsb_ptr)

	cmp	DWORD PTR [edi+248], 0
	jne	SHORT $LN30@MDegrainN

; 603  :     env_ptr->ThrowError("MDegrainN : no valid _overschroma_lsb_ptr function for %dx%d, pixelsize=%d, lsb_flag=%d", nBlkSizeX, nBlkSizeY, pixelsize_super, (int)lsb_flag);

	movzx	eax, BYTE PTR _lsb_flag$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR [edi+192]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [edi+76]
	push	OFFSET ??_C@_0FI@JLEGDAGJ@MDegrainN?5?3?5no?5valid?5_overschrom@
	push	ebx
	call	DWORD PTR [ecx+20]
	add	esp, 24					; 00000018H
$LN30@MDegrainN:

; 604  :   if (!_oversluma_ptr)

	cmp	DWORD PTR [edi+228], 0
	jne	SHORT $LN31@MDegrainN

; 605  :     env_ptr->ThrowError("MDegrainN : no valid _oversluma_ptr function for %dx%d, pixelsize=%d, lsb_flag=%d", nBlkSizeX, nBlkSizeY, pixelsize_super, (int)lsb_flag);

	movzx	eax, BYTE PTR _lsb_flag$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR [edi+192]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [edi+76]
	push	OFFSET ??_C@_0FC@HLHCAJJK@MDegrainN?5?3?5no?5valid?5_oversluma_@
	push	ebx
	call	DWORD PTR [ecx+20]
	add	esp, 24					; 00000018H
$LN31@MDegrainN:

; 606  :   if (!_overschroma_ptr)

	cmp	DWORD PTR [edi+232], 0
	jne	SHORT $LN32@MDegrainN

; 607  :     env_ptr->ThrowError("MDegrainN : no valid _overschroma_ptr function for %dx%d, pixelsize=%d, lsb_flag=%d", nBlkSizeX, nBlkSizeY, pixelsize_super, (int)lsb_flag);

	movzx	eax, BYTE PTR _lsb_flag$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR [edi+192]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [edi+76]
	push	OFFSET ??_C@_0FE@LMEDIIDI@MDegrainN?5?3?5no?5valid?5_overschrom@
	push	ebx
	call	DWORD PTR [ecx+20]
	add	esp, 24					; 00000018H
$LN32@MDegrainN:

; 608  :   if (!_degrainluma_ptr)

	cmp	DWORD PTR [edi+252], 0
	jne	SHORT $LN33@MDegrainN

; 609  :     env_ptr->ThrowError("MDegrainN : no valid _degrainluma_ptr function for %dx%d, pixelsize=%d, lsb_flag=%d", nBlkSizeX, nBlkSizeY, pixelsize_super, (int)lsb_flag);

	movzx	eax, BYTE PTR _lsb_flag$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR [edi+192]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [edi+76]
	push	OFFSET ??_C@_0FE@HBFDJOBA@MDegrainN?5?3?5no?5valid?5_degrainlum@
	push	ebx
	call	DWORD PTR [ecx+20]
	add	esp, 24					; 00000018H
$LN33@MDegrainN:

; 610  :   if (!_degrainchroma_ptr)

	cmp	DWORD PTR [edi+256], 0
	jne	SHORT $LN34@MDegrainN

; 611  :     env_ptr->ThrowError("MDegrainN : no valid _degrainchroma_ptr function for %dx%d, pixelsize=%d, lsb_flag=%d", nBlkSizeX, nBlkSizeY, pixelsize_super, (int)lsb_flag);

	movzx	eax, BYTE PTR _lsb_flag$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR [edi+192]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [edi+76]
	push	OFFSET ??_C@_0FG@BDEEPEDP@MDegrainN?5?3?5no?5valid?5_degrainchr@
	push	ebx
	call	DWORD PTR [ecx+20]
	add	esp, 24					; 00000018H
$LN34@MDegrainN:

; 612  : 
; 613  :   //---------- end of functions
; 614  : 
; 615  :   // 16 bit output hack
; 616  :   if (_lsb_flag)

	cmp	BYTE PTR [edi+186], 0
	je	SHORT $LN35@MDegrainN

; 617  :   {
; 618  :     vi.height <<= 1;

	shl	DWORD PTR [edi+20], 1
$LN35@MDegrainN:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN445@MDegrainN
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN445@MDegrainN
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN445@MDegrainN:
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	test	eax, eax
	je	SHORT $LN450@MDegrainN
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN450@MDegrainN
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN450@MDegrainN:
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	test	eax, eax
	je	SHORT $LN470@MDegrainN
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN470@MDegrainN
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _mvmulti$[ebp]
	call	eax
$LN470@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 620  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	72					; 00000048H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _mvmulti$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::~vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	jmp	??1?$auto_ptr@VYUY2Planes@@@std@@QAE@XZ	; std::auto_ptr<YUY2Planes>::~auto_ptr<YUY2Planes>
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	jmp	??1?$auto_ptr@VYUY2Planes@@@std@@QAE@XZ	; std::auto_ptr<YUY2Planes>::~auto_ptr<YUY2Planes>
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 220				; 000000dcH
	jmp	??1?$auto_ptr@VOverlapWindows@@@std@@QAE@XZ ; std::auto_ptr<OverlapWindows>::~auto_ptr<OverlapWindows>
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 224				; 000000e0H
	jmp	??1?$auto_ptr@VOverlapWindows@@@std@@QAE@XZ ; std::auto_ptr<OverlapWindows>::~auto_ptr<OverlapWindows>
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	jmp	??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 276				; 00000114H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3688				; 00000e68H
	jmp	??1?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::~vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$14:
	push	240					; 000000f0H
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$16:
	push	44					; 0000002cH
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$22:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$24:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$88:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$89:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z$90:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z ENDP ; MDegrainN::MDegrainN
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$dead$ = 12					; size = 4
__ArgList$ = 16						; size = 4
__vsnprintf_l PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$dead$ = edx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[esp-4]
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	-1
	push	ecx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vsprintf_l PROC					; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[esp-4]
	push	0
	push	edx
	push	-1
	push	ecx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	-1
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?ComponentSize@VideoInfo@@QBEHXZ
_TEXT	SEGMENT
?ComponentSize@VideoInfo@@QBEHXZ PROC			; VideoInfo::ComponentSize, COMDAT
; _this$ = ecx

; 692  :   int ComponentSize() const AVS_BakedCode(return AVS_LinkCallOptDefault(ComponentSize, 1))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@ComponentS
	cmp	DWORD PTR [eax], 532			; 00000214H
	jbe	SHORT $LN3@ComponentS
	mov	eax, DWORD PTR [eax+532]
	jmp	eax
$LN3@ComponentS:
	mov	eax, 1
	ret	0
?ComponentSize@VideoInfo@@QBEHXZ ENDP			; VideoInfo::ComponentSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetRowSize@VideoFrame@@QBEHH@Z
_TEXT	SEGMENT
_plane$ = 8						; size = 4
?GetRowSize@VideoFrame@@QBEHH@Z PROC			; VideoFrame::GetRowSize, COMDAT
; _this$ = ecx

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@GetRowSize
	cmp	DWORD PTR [eax], 196			; 000000c4H
	jbe	SHORT $LN3@GetRowSize
	mov	eax, DWORD PTR [eax+196]
	jmp	eax
$LN3@GetRowSize:
	xor	eax, eax
	ret	4
?GetRowSize@VideoFrame@@QBEHH@Z ENDP			; VideoFrame::GetRowSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetReadPtr@VideoFrame@@QBEPBEH@Z
_TEXT	SEGMENT
_plane$ = 8						; size = 4
?GetReadPtr@VideoFrame@@QBEPBEH@Z PROC			; VideoFrame::GetReadPtr, COMDAT
; _this$ = ecx

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@GetReadPtr
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN3@GetReadPtr
	mov	eax, DWORD PTR [eax+212]
	jmp	eax
$LN3@GetReadPtr:
	xor	eax, eax
	ret	4
?GetReadPtr@VideoFrame@@QBEPBEH@Z ENDP			; VideoFrame::GetReadPtr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0IClip@@QAE@XZ
_TEXT	SEGMENT
??0IClip@@QAE@XZ PROC					; IClip::IClip, COMDAT
; _this$ = ecx

; 911  :   IClip() : refcnt(0) {}

	mov	DWORD PTR [ecx], OFFSET ??_7IClip@@6B@
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0IClip@@QAE@XZ ENDP					; IClip::IClip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetVersion@IClip@@UAGHXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?GetVersion@IClip@@UAGHXZ PROC				; IClip::GetVersion, COMDAT

; 912  :   virtual int __stdcall GetVersion() { return AVISYNTH_INTERFACE_VERSION; }

	mov	eax, 6
	ret	4
?GetVersion@IClip@@UAGHXZ ENDP				; IClip::GetVersion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??1IClip@@UAE@XZ
_TEXT	SEGMENT
??1IClip@@UAE@XZ PROC					; IClip::~IClip, COMDAT
; _this$ = ecx

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [ecx], OFFSET ??_7IClip@@6B@
	ret	0
??1IClip@@UAE@XZ ENDP					; IClip::~IClip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??_GIClip@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GIClip@@UAEPAXI@Z PROC				; IClip::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	je	SHORT $LN7@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GIClip@@UAEPAXI@Z ENDP				; IClip::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0PVideoFrame@@QAE@XZ
_TEXT	SEGMENT
??0PVideoFrame@@QAE@XZ PROC				; PVideoFrame::PVideoFrame, COMDAT
; _this$ = ecx

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@PVideoFram
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN5@PVideoFram
	mov	eax, DWORD PTR [eax+252]
	call	eax
$LN5@PVideoFram:
	mov	eax, esi
	pop	esi
	ret	0
??0PVideoFrame@@QAE@XZ ENDP				; PVideoFrame::PVideoFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0PVideoFrame@@QAE@ABV0@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??0PVideoFrame@@QAE@ABV0@@Z PROC			; PVideoFrame::PVideoFrame, COMDAT
; _this$ = ecx

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@PVideoFram
	cmp	DWORD PTR [eax], 256			; 00000100H
	jbe	SHORT $LN5@PVideoFram
	push	DWORD PTR _x$[esp]
	mov	eax, DWORD PTR [eax+256]
	call	eax
$LN5@PVideoFram:
	mov	eax, esi
	pop	esi
	ret	4
??0PVideoFrame@@QAE@ABV0@@Z ENDP			; PVideoFrame::PVideoFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??1PVideoFrame@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1PVideoFrame@@QAE@XZ PROC				; PVideoFrame::~PVideoFrame, COMDAT
; _this$ = ecx

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1PVideoFrame@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@PVideoFram
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN3@PVideoFram
	mov	eax, DWORD PTR [eax+272]
	call	eax
$LN3@PVideoFram:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1PVideoFrame@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1PVideoFrame@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1PVideoFrame@@QAE@XZ ENDP				; PVideoFrame::~PVideoFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0GenericVideoFilter@@QAE@VPClip@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
??0GenericVideoFilter@@QAE@VPClip@@@Z PROC		; GenericVideoFilter::GenericVideoFilter, COMDAT
; _this$ = ecx

; 1105 :   GenericVideoFilter(PClip _child) : child(_child) { vi = child->GetVideoInfo(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0GenericVideoFilter@@QAE@VPClip@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 911  :   IClip() : refcnt(0) {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	mov	DWORD PTR [esi+4], 0

; 1105 :   GenericVideoFilter(PClip _child) : child(_child) { vi = child->GetVideoInfo(); }

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage

; 1105 :   GenericVideoFilter(PClip _child) : child(_child) { vi = child->GetVideoInfo(); }

	mov	DWORD PTR [esi], OFFSET ??_7GenericVideoFilter@@6B@

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN12@GenericVid
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN12@GenericVid
	lea	eax, DWORD PTR __child$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+232]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN12@GenericVid:

; 1105 :   GenericVideoFilter(PClip _child) : child(_child) { vi = child->GetVideoInfo(); }

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN4@GenericVid

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN3@GenericVid
$LN4@GenericVid:
	push	ecx

; 1105 :   GenericVideoFilter(PClip _child) : child(_child) { vi = child->GetVideoInfo(); }

	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN3@GenericVid:
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [esi+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR [esi+48], xmm0

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN23@GenericVid
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN23@GenericVid
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
$LN23@GenericVid:

; 1105 :   GenericVideoFilter(PClip _child) : child(_child) { vi = child->GetVideoInfo(); }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$0:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1IClip@@UAE@XZ			; IClip::~IClip
__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0GenericVideoFilter@@QAE@VPClip@@@Z$3:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0GenericVideoFilter@@QAE@VPClip@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0GenericVideoFilter@@QAE@VPClip@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0GenericVideoFilter@@QAE@VPClip@@@Z ENDP		; GenericVideoFilter::GenericVideoFilter
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetFrame@GenericVideoFilter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_n$ = 16						; size = 4
_env$ = 20						; size = 4
?GetFrame@GenericVideoFilter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; GenericVideoFilter::GetFrame, COMDAT

; 1106 :   PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env) { return child->GetFrame(n, env); }

	push	ecx

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR _this$[esp]

; 1106 :   PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env) { return child->GetFrame(n, env); }

	push	DWORD PTR _env$[esp]
	mov	DWORD PTR $T1[esp+8], 0
	push	DWORD PTR _n$[esp+4]

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [eax+8]

; 1106 :   PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env) { return child->GetFrame(n, env); }

	push	DWORD PTR ___$ReturnUdt$[esp+8]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	pop	ecx
	ret	16					; 00000010H
?GetFrame@GenericVideoFilter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; GenericVideoFilter::GetFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_buf$ = 12						; size = 4
_start$ = 16						; size = 8
_count$ = 24						; size = 8
_env$ = 32						; size = 4
?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z PROC ; GenericVideoFilter::GetAudio, COMDAT

; 1107 :   void __stdcall GetAudio(void* buf, __int64 start, __int64 count, IScriptEnvironment* env) { child->GetAudio(buf, start, count, env); }

	push	DWORD PTR _env$[esp-4]

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR _this$[esp]

; 1107 :   void __stdcall GetAudio(void* buf, __int64 start, __int64 count, IScriptEnvironment* env) { child->GetAudio(buf, start, count, env); }

	push	DWORD PTR _count$[esp+4]
	push	DWORD PTR _count$[esp+4]

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [eax+8]

; 1107 :   void __stdcall GetAudio(void* buf, __int64 start, __int64 count, IScriptEnvironment* env) { child->GetAudio(buf, start, count, env); }

	push	DWORD PTR _start$[esp+12]
	push	DWORD PTR _start$[esp+12]
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR _buf$[esp+16]
	push	eax
	call	DWORD PTR [ecx+12]
	ret	28					; 0000001cH
?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z ENDP ; GenericVideoFilter::GetAudio
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ PROC ; GenericVideoFilter::GetVideoInfo, COMDAT

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	mov	eax, DWORD PTR _this$[esp-4]
	add	eax, 16					; 00000010H
	ret	4
?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ENDP ; GenericVideoFilter::GetVideoInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetParity@GenericVideoFilter@@UAG_NH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_n$ = 12						; size = 4
?GetParity@GenericVideoFilter@@UAG_NH@Z PROC		; GenericVideoFilter::GetParity, COMDAT

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR [eax+8]

; 1109 :   bool __stdcall GetParity(int n) { return child->GetParity(n); }

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _this$[esp-4], eax
	jmp	DWORD PTR [ecx+8]
?GetParity@GenericVideoFilter@@UAG_NH@Z ENDP		; GenericVideoFilter::GetParity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?SetCacheHints@GenericVideoFilter@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@GenericVideoFilter@@UAGHHH@Z PROC	; GenericVideoFilter::SetCacheHints, COMDAT

; 1110 :   int __stdcall SetCacheHints(int cachehints,int frame_range) { return 0; } ;  // We do not pass cache requests upwards, only to the next filter.

	xor	eax, eax
	ret	12					; 0000000cH
?SetCacheHints@GenericVideoFilter@@UAGHHH@Z ENDP	; GenericVideoFilter::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??_GGenericVideoFilter@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GGenericVideoFilter@@UAEPAXI@Z PROC			; GenericVideoFilter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_GGenericVideoFilter@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN9@scalar
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN9@scalar
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN9@scalar:
	test	BYTE PTR ___flags$[ebp], 1

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	je	SHORT $LN15@scalar
	push	64					; 00000040H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN15@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GGenericVideoFilter@@UAEPAXI@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_GGenericVideoFilter@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GGenericVideoFilter@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GGenericVideoFilter@@UAEPAXI@Z ENDP			; GenericVideoFilter::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??1GenericVideoFilter@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1GenericVideoFilter@@UAE@XZ PROC			; GenericVideoFilter::~GenericVideoFilter, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1GenericVideoFilter@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN11@GenericVid
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN11@GenericVid
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN11@GenericVid:
	mov	ecx, DWORD PTR __$EHRec$[ebp]

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1GenericVideoFilter@@UAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1GenericVideoFilter@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1GenericVideoFilter@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1GenericVideoFilter@@UAE@XZ ENDP			; GenericVideoFilter::~GenericVideoFilter
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeblockdata.h
;	COMDAT ?GetX@FakeBlockData@@QBEHXZ
_TEXT	SEGMENT
?GetX@FakeBlockData@@QBEHXZ PROC			; FakeBlockData::GetX, COMDAT
; _this$ = ecx

; 52   : 	inline int GetX() const { return x; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetX@FakeBlockData@@QBEHXZ ENDP			; FakeBlockData::GetX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeblockdata.h
;	COMDAT ?GetY@FakeBlockData@@QBEHXZ
_TEXT	SEGMENT
?GetY@FakeBlockData@@QBEHXZ PROC			; FakeBlockData::GetY, COMDAT
; _this$ = ecx

; 53   : 	inline int GetY() const { return y; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetY@FakeBlockData@@QBEHXZ ENDP			; FakeBlockData::GetY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.h
;	COMDAT ?GetThSCD1@MVClip@@QBEHXZ
_TEXT	SEGMENT
?GetThSCD1@MVClip@@QBEHXZ PROC				; MVClip::GetThSCD1, COMDAT
; _this$ = ecx

; 83   :    inline sad_t GetThSCD1() const { return nSCD1; }

	mov	eax, DWORD PTR [ecx+216]
	ret	0
?GetThSCD1@MVClip@@QBEHXZ ENDP				; MVClip::GetThSCD1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.h
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvclip.h
;	COMDAT ?IsUsable@MVClip@@QBE_NXZ
_TEXT	SEGMENT
?IsUsable@MVClip@@QBE_NXZ PROC				; MVClip::IsUsable, COMDAT
; _this$ = ecx

; 87   :    bool IsUsable() const { return IsUsable(nSCD1, nSCD2); }

	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [esi+88]
	push	DWORD PTR [esi+216]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	SHORT $LN5@IsUsable
	cmp	BYTE PTR [esi+68], al
	je	SHORT $LN5@IsUsable
; File c:\github\mvtools\sources\mvclip.h

; 87   :    bool IsUsable() const { return IsUsable(nSCD1, nSCD2); }

	mov	al, 1
	pop	esi
	ret	0
$LN5@IsUsable:
	xor	al, al
	pop	esi
	ret	0
?IsUsable@MVClip@@QBE_NXZ ENDP				; MVClip::IsUsable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.h
;	COMDAT ?GetWindow@OverlapWindows@@QBEPAFH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetWindow@OverlapWindows@@QBEPAFH@Z PROC		; OverlapWindows::GetWindow, COMDAT
; _this$ = ecx

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	edx, DWORD PTR [ecx+16]
	imul	edx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [ecx+20]
	lea	eax, DWORD PTR [eax+edx*2]
	ret	4
?GetWindow@OverlapWindows@@QBEPAFH@Z ENDP		; OverlapWindows::GetWindow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.h
;	COMDAT ?GetPitch@YUY2Planes@@QBEHXZ
_TEXT	SEGMENT
?GetPitch@YUY2Planes@@QBEHXZ PROC			; YUY2Planes::GetPitch, COMDAT
; _this$ = ecx

; 39   :    inline int GetPitch() const { return srcPitch; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?GetPitch@YUY2Planes@@QBEHXZ ENDP			; YUY2Planes::GetPitch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.h
;	COMDAT ?GetPitchUV@YUY2Planes@@QBEHXZ
_TEXT	SEGMENT
?GetPitchUV@YUY2Planes@@QBEHXZ PROC			; YUY2Planes::GetPitchUV, COMDAT
; _this$ = ecx

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [ecx+24]
	ret	0
?GetPitchUV@YUY2Planes@@QBEHXZ ENDP			; YUY2Planes::GetPitchUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.h
;	COMDAT ?GetPtr@YUY2Planes@@QBEPAEXZ
_TEXT	SEGMENT
?GetPtr@YUY2Planes@@QBEPAEXZ PROC			; YUY2Planes::GetPtr, COMDAT
; _this$ = ecx

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetPtr@YUY2Planes@@QBEPAEXZ ENDP			; YUY2Planes::GetPtr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.h
;	COMDAT ?GetPtrU@YUY2Planes@@QBEPAEXZ
_TEXT	SEGMENT
?GetPtrU@YUY2Planes@@QBEPAEXZ PROC			; YUY2Planes::GetPtrU, COMDAT
; _this$ = ecx

; 42   :    inline unsigned char *GetPtrU() const { return pSrcU; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetPtrU@YUY2Planes@@QBEPAEXZ ENDP			; YUY2Planes::GetPtrU
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.h
;	COMDAT ?GetPtrV@YUY2Planes@@QBEPAEXZ
_TEXT	SEGMENT
?GetPtrV@YUY2Planes@@QBEPAEXZ PROC			; YUY2Planes::GetPtrV, COMDAT
; _this$ = ecx

; 43   :    inline unsigned char *GetPtrV() const { return pSrcV; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?GetPtrV@YUY2Planes@@QBEPAEXZ ENDP			; YUY2Planes::GetPtrV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.h
;	COMDAT ?SetCacheHints@MDegrainN@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MDegrainN@@UAGHHH@Z PROC			; MDegrainN::SetCacheHints, COMDAT

; 42   :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 43   :   }

	ret	12					; 0000000cH
?SetCacheHints@MDegrainN@@UAGHHH@Z ENDP			; MDegrainN::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.h
;	COMDAT ??0TmpBlock@MDegrainN@@QAE@XZ
_TEXT	SEGMENT
??0TmpBlock@MDegrainN@@QAE@XZ PROC			; MDegrainN::TmpBlock::TmpBlock, COMDAT
; _this$ = ecx

; 78   :     TmpBlock() : _lsb_ptr(&_d[AREA]) {}

	lea	eax, DWORD PTR [ecx+1024]
	mov	DWORD PTR [ecx+2048], eax
	mov	eax, ecx
	ret	0
??0TmpBlock@MDegrainN@@QAE@XZ ENDP			; MDegrainN::TmpBlock::TmpBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdegrain3.h
;	COMDAT ?DegrainWeight@@YAHHHH@Z
_TEXT	SEGMENT
_bits_per_pixels$ = 8					; size = 4
?DegrainWeight@@YAHHHH@Z PROC				; DegrainWeight, COMDAT
; _thSAD$ = ecx
; _blockSAD$ = edx

; 912  :   // Returning directly prevents a divide by 0 if thSAD == blockSAD == 0.
; 913  :   if (thSAD <= blockSAD)

	cmp	ecx, edx
	jg	SHORT $LN2@DegrainWei

; 914  :   {
; 915  :     return 0;

	xor	eax, eax

; 938  :   }
; 939  : }

	ret	0
$LN2@DegrainWei:

; 916  :   }
; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR _bits_per_pixels$[esp-4], 8
	jg	SHORT $LN3@DegrainWei

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	ecx, ecx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edx, edx

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, ecx
	sub	eax, edx

; 921  :     const int den = thSAD2 + blockSAD2;

	add	ecx, edx

; 922  :     // res = num*256/den
; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN6@DegrainWei
	shl	eax, 8
	cdq
	idiv	ecx

; 938  :   }
; 939  : }

	ret	0
$LN6@DegrainWei:

; 922  :     // res = num*256/den
; 923  :     const int      res = int((num < (1<<23))

	sar	ecx, 8
	cdq
	idiv	ecx

; 938  :   }
; 939  : }

	ret	0
$LN3@DegrainWei:
	movd	xmm2, ecx

; 924  :       ? (num<<8) /  den      // small numerator
; 925  :       :  num     / (den>>8)); // very large numerator, prevent overflow
; 926  :     return (res);
; 927  :   } else {
; 928  :     // int overflows with 8+ bits_per_pixel scaled power of 2
; 929  :     /* float is faster
; 930  :     const int64_t sq_thSAD = int64_t(thSAD) * thSAD;
; 931  :     const int64_t sq_blockSAD = int64_t(blockSAD) * blockSAD;
; 932  :     return (int)((256*(sq_thSAD - sq_blockSAD)) / (sq_thSAD + sq_blockSAD));
; 933  :     */
; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
	movd	xmm1, edx

; 935  :                                                         // smart compiler makes x*x, VS2015 calls __libm_sse2_pow_precise, way too slow
; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, DWORD PTR __real@43800000
	divss	xmm0, xmm1
	cvttss2si eax, xmm0

; 938  :   }
; 939  : }

	ret	0
?DegrainWeight@@YAHHHH@Z ENDP				; DegrainWeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvframe.h
;	COMDAT ?GetPlane@MVFrame@@QAEPAVMVPlane@@W4MVPlaneSet@@@Z
_TEXT	SEGMENT
__nMode$ = 8						; size = 4
?GetPlane@MVFrame@@QAEPAVMVPlane@@W4MVPlaneSet@@@Z PROC	; MVFrame::GetPlane, COMDAT
; _this$ = ecx

; 63   :       // no reason to test for nMode because returning NULL isn't expected in other parts
; 64   :       // assert(nMode & _nMode & (YPLANE | UPLANE | VPLANE));
; 65   : 
; 66   :       if ( _nMode & YPLANE ) // ( nMode & _nMode & YPLANE )

	mov	eax, DWORD PTR __nMode$[esp-4]
	test	al, 1
	je	SHORT $LN2@GetPlane

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [ecx]

; 76   :    }

	ret	4
$LN2@GetPlane:

; 68   : 
; 69   :       if ( _nMode & UPLANE ) // ( nMode & _nMode & UPLANE )

	test	al, 2
	je	SHORT $LN3@GetPlane

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [ecx+4]

; 76   :    }

	ret	4
$LN3@GetPlane:

; 71   : 
; 72   :       if ( _nMode & VPLANE ) // ( nMode & _nMode & VPLANE )

	test	al, 4
	je	SHORT $LN4@GetPlane

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [ecx+8]

; 76   :    }

	ret	4
$LN4@GetPlane:

; 74   : 
; 75   :       return 0;

	xor	eax, eax

; 76   :    }

	ret	4
?GetPlane@MVFrame@@QAEPAVMVPlane@@W4MVPlaneSet@@@Z ENDP	; MVFrame::GetPlane
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ??$GetAbsolutePointerPel@$0A@@MVPlane@@QBEPBEHH@Z
_TEXT	SEGMENT
_nX$ = 8						; size = 4
_nY$ = 12						; size = 4
??$GetAbsolutePointerPel@$0A@@MVPlane@@QBEPBEHH@Z PROC	; MVPlane::GetAbsolutePointerPel<0>, COMDAT
; _this$ = ecx

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR _nX$[esp-4]
	push	esi
	mov	esi, ecx
	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+52]
	imul	edx, DWORD PTR _nY$[esp]
	shl	eax, cl
	mov	ecx, DWORD PTR [esi]
	pop	esi
	add	eax, edx
	add	eax, DWORD PTR [ecx]

; 78   :    }

	ret	8
??$GetAbsolutePointerPel@$0A@@MVPlane@@QBEPBEHH@Z ENDP	; MVPlane::GetAbsolutePointerPel<0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ?GetAbsolutePointer@MVPlane@@QBEPBEHH@Z
_TEXT	SEGMENT
_nX$ = 8						; size = 4
_nY$ = 12						; size = 4
?GetAbsolutePointer@MVPlane@@QBEPBEHH@Z PROC		; MVPlane::GetAbsolutePointer, COMDAT
; _this$ = ecx

; 81   :    {

	push	ebx
	mov	ebx, ecx

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ebx+56]

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN2@GetAbsolut

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edx, DWORD PTR [ebx+12]
	imul	edx, DWORD PTR _nY$[esp]
	mov	eax, DWORD PTR _nX$[esp]
	shl	eax, cl
	mov	ecx, DWORD PTR [ebx]
	pop	ebx
	add	eax, edx
	add	eax, DWORD PTR [ecx]

; 93   :       }
; 94   :    }

	ret	8
$LN2@GetAbsolut:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR _nX$[esp]

; 83   : 		{
; 84   :          return GetAbsolutePointerPel <0> (nX, nY);
; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2
	push	esi
	push	edi

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, DWORD PTR _nY$[esp+8]

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edx

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, edi
	jne	SHORT $LN4@GetAbsolut
	and	esi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	add	esi, esi
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN15@GetAbsolut
$LN4@GetAbsolut:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	shl	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN15@GetAbsolut:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	or	esi, eax
	mov	eax, DWORD PTR [ebx]
	shl	edx, cl
	mov	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 93   :       }
; 94   :    }

	ret	8
?GetAbsolutePointer@MVPlane@@QBEPBEHH@Z ENDP		; MVPlane::GetAbsolutePointer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ?GetPointer@MVPlane@@QBEPBEHH@Z
_TEXT	SEGMENT
_nX$ = 8						; size = 4
_nY$ = 12						; size = 4
?GetPointer@MVPlane@@QBEPBEHH@Z PROC			; MVPlane::GetPointer, COMDAT
; _this$ = ecx

; 103  :    {

	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	edi, DWORD PTR [ebx+32]
	mov	esi, DWORD PTR [ebx+28]
	add	edi, DWORD PTR _nY$[esp+8]
	add	esi, DWORD PTR _nX$[esp+8]

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ebx+56]

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN4@GetPointer

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx+12]
	imul	eax, edi
	shl	esi, cl
	mov	ecx, DWORD PTR [ebx]
	pop	edi
	add	eax, esi
	add	eax, DWORD PTR [ecx]
	pop	esi
	pop	ebx

; 105  :    }

	ret	8
$LN4@GetPointer:

; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edx, edi

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, esi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN6@GetPointer

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edx, 1

; 68   :       nX >>= NPELL2;

	sar	esi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	edi, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN15@GetPointer
$LN6@GetPointer:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edx, 3

; 68   :       nX >>= NPELL2;

	sar	esi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	edi, 2
$LN15@GetPointer:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	edi, DWORD PTR [ebx+12]
	or	edx, eax
	mov	eax, DWORD PTR [ebx]
	shl	esi, cl
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 105  :    }

	ret	8
?GetPointer@MVPlane@@QBEPBEHH@Z ENDP			; MVPlane::GetPointer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ?GetPitch@MVPlane@@QBEHXZ
_TEXT	SEGMENT
?GetPitch@MVPlane@@QBEHXZ PROC				; MVPlane::GetPitch, COMDAT
; _this$ = ecx

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?GetPitch@MVPlane@@QBEHXZ ENDP				; MVPlane::GetPitch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z
_TEXT	SEGMENT
_archlist$ = -80					; size = 20
$T2 = -60						; size = 16
$T3 = -60						; size = 16
$T4 = -60						; size = 16
$T5 = -60						; size = 16
$T6 = -60						; size = 16
$T7 = -60						; size = 16
$T8 = -60						; size = 16
$T9 = -60						; size = 16
$T10 = -60						; size = 16
$T11 = -60						; size = 16
$T12 = -60						; size = 16
$T13 = -60						; size = 16
$T14 = -60						; size = 16
$T15 = -60						; size = 16
$T16 = -60						; size = 16
$T17 = -60						; size = 16
$T18 = -60						; size = 16
$T19 = -60						; size = 16
$T20 = -60						; size = 16
$T21 = -60						; size = 16
$T22 = -60						; size = 16
$T23 = -60						; size = 16
$T24 = -60						; size = 16
$T25 = -60						; size = 16
$T26 = -60						; size = 16
$T27 = -60						; size = 16
$T28 = -60						; size = 16
$T29 = -60						; size = 16
$T30 = -60						; size = 16
$T31 = -60						; size = 16
$T32 = -60						; size = 16
$T33 = -60						; size = 16
$T34 = -60						; size = 16
$T35 = -60						; size = 16
$T36 = -60						; size = 16
$T37 = -60						; size = 16
$T38 = -60						; size = 16
$T39 = -60						; size = 16
$T40 = -60						; size = 16
$T41 = -60						; size = 16
$T42 = -60						; size = 16
$T43 = -60						; size = 16
$T44 = -60						; size = 16
$T45 = -60						; size = 16
$T46 = -60						; size = 16
$T47 = -60						; size = 16
$T48 = -60						; size = 16
$T49 = -60						; size = 16
$T50 = -60						; size = 16
$T51 = -60						; size = 16
$T52 = -60						; size = 16
$T53 = -60						; size = 16
$T54 = -60						; size = 16
$T55 = -60						; size = 16
$T56 = -60						; size = 16
_func_degrain$ = -44					; size = 8
_this$1$ = -36						; size = 4
$T57 = -32						; size = 8
$T58 = -32						; size = 8
$T59 = -32						; size = 8
$T60 = -32						; size = 8
$T61 = -32						; size = 8
$T62 = -32						; size = 8
$T63 = -32						; size = 8
$T64 = -32						; size = 8
$T65 = -32						; size = 8
$T66 = -32						; size = 8
$T67 = -32						; size = 8
$T68 = -32						; size = 8
$T69 = -32						; size = 8
$T70 = -32						; size = 8
$T71 = -32						; size = 8
$T72 = -32						; size = 8
$T73 = -32						; size = 8
$T74 = -32						; size = 8
$T75 = -32						; size = 8
$T76 = -32						; size = 8
$T77 = -32						; size = 8
$T78 = -32						; size = 8
$T79 = -32						; size = 8
$T80 = -32						; size = 8
$T81 = -32						; size = 8
$T82 = -32						; size = 8
$T83 = -32						; size = 8
$T84 = -32						; size = 8
$T85 = -32						; size = 8
$T86 = -32						; size = 8
$T87 = -32						; size = 8
$T88 = -32						; size = 8
$T89 = -32						; size = 8
$T90 = -32						; size = 8
$T91 = -32						; size = 8
$T92 = -32						; size = 8
$T93 = -32						; size = 8
$T94 = -32						; size = 8
$T95 = -32						; size = 8
$T96 = -32						; size = 8
$T97 = -32						; size = 8
$T98 = -32						; size = 8
$T99 = -32						; size = 8
$T100 = -32						; size = 8
$T101 = -32						; size = 8
$T102 = -32						; size = 8
$T103 = -32						; size = 8
$T104 = -32						; size = 8
$T105 = -32						; size = 8
$T106 = -28						; size = 4
$T107 = -28						; size = 4
$T108 = -28						; size = 4
$T109 = -28						; size = 4
$T110 = -24						; size = 4
$T111 = -24						; size = 4
$T112 = -24						; size = 4
$T113 = -24						; size = 4
$T114 = -20						; size = 4
$T115 = -20						; size = 4
$T116 = -20						; size = 4
$T117 = -20						; size = 4
$T118 = -16						; size = 4
$T119 = -16						; size = 4
$T120 = -16						; size = 4
$T121 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_BlockX$ = 8						; size = 4
_BlockY$ = 12						; size = 4
__pixelsize$dead$ = 16					; size = 4
_current_arch_try$122 = 20				; size = 4
_arch$ = 20						; size = 4
?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z PROC ; MDegrainN::get_denoiseN_function, COMDAT
; _this$ = ecx

; 284  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR _func_degrain$[ebp], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 284  : {

	mov	DWORD PTR _this$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR _func_degrain$[ebp+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR _func_degrain$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T56[ebp]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 288  :   std::map<std::tuple<int, int, int, arch_t>, DenoiseNFunction*> func_degrain;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	push	eax
	lea	eax, DWORD PTR $T105[ebp]
	push	eax
	movups	XMMWORD PTR $T56[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 292  :   func_degrain[make_tuple(32, 32, 1, NO_SIMD)] = DegrainN_C<uint8_t, 32, 32>;

	mov	eax, DWORD PTR $T105[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 292  :   func_degrain[make_tuple(32, 32, 1, NO_SIMD)] = DegrainN_C<uint8_t, 32, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,32,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T55[ebp]
	push	eax
	lea	eax, DWORD PTR $T104[ebp]
	push	eax
	movups	XMMWORD PTR $T55[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 293  :   func_degrain[make_tuple(32, 16, 1, NO_SIMD)] = DegrainN_C<uint8_t, 32, 16>;

	mov	eax, DWORD PTR $T104[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 293  :   func_degrain[make_tuple(32, 16, 1, NO_SIMD)] = DegrainN_C<uint8_t, 32, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,32,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T54[ebp]
	push	eax
	lea	eax, DWORD PTR $T103[ebp]
	push	eax
	movups	XMMWORD PTR $T54[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 294  :   func_degrain[make_tuple(32, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 32, 8>;

	mov	eax, DWORD PTR $T103[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 294  :   func_degrain[make_tuple(32, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 32, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,32,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T53[ebp]
	push	eax
	lea	eax, DWORD PTR $T102[ebp]
	push	eax
	movups	XMMWORD PTR $T53[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 295  :   func_degrain[make_tuple(16, 32, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 32>;

	mov	eax, DWORD PTR $T102[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 295  :   func_degrain[make_tuple(16, 32, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T52[ebp]
	push	eax
	lea	eax, DWORD PTR $T101[ebp]
	push	eax
	movups	XMMWORD PTR $T52[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 296  :   func_degrain[make_tuple(16, 16, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 16>;

	mov	eax, DWORD PTR $T101[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 296  :   func_degrain[make_tuple(16, 16, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T51[ebp]
	push	eax
	lea	eax, DWORD PTR $T100[ebp]
	push	eax
	movups	XMMWORD PTR $T51[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 297  :   func_degrain[make_tuple(16, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 8>;

	mov	eax, DWORD PTR $T100[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 297  :   func_degrain[make_tuple(16, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T50[ebp]
	push	eax
	lea	eax, DWORD PTR $T99[ebp]
	push	eax
	movups	XMMWORD PTR $T50[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 298  :   func_degrain[make_tuple(16, 4, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 4>;

	mov	eax, DWORD PTR $T99[ebp]
	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,4>
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T49[ebp]
	push	eax
	lea	eax, DWORD PTR $T98[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movups	XMMWORD PTR $T49[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 299  :   func_degrain[make_tuple(16, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 2>;

	mov	eax, DWORD PTR $T98[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 299  :   func_degrain[make_tuple(16, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 16, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,16,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T48[ebp]
	push	eax
	lea	eax, DWORD PTR $T97[ebp]
	push	eax
	movups	XMMWORD PTR $T48[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 300  :   func_degrain[make_tuple(8, 16, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 16>;

	mov	eax, DWORD PTR $T97[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 300  :   func_degrain[make_tuple(8, 16, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T47[ebp]
	push	eax
	lea	eax, DWORD PTR $T96[ebp]
	push	eax
	movups	XMMWORD PTR $T47[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 301  :   func_degrain[make_tuple(8, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 8>;

	mov	eax, DWORD PTR $T96[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 301  :   func_degrain[make_tuple(8, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T46[ebp]
	push	eax
	lea	eax, DWORD PTR $T95[ebp]
	push	eax
	movups	XMMWORD PTR $T46[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 302  :   func_degrain[make_tuple(8, 4, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 4>;

	mov	eax, DWORD PTR $T95[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 302  :   func_degrain[make_tuple(8, 4, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T45[ebp]
	push	eax
	lea	eax, DWORD PTR $T94[ebp]
	push	eax
	movups	XMMWORD PTR $T45[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 303  :   func_degrain[make_tuple(8, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 2>;

	mov	eax, DWORD PTR $T94[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 303  :   func_degrain[make_tuple(8, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T44[ebp]
	push	eax
	lea	eax, DWORD PTR $T93[ebp]
	push	eax
	movups	XMMWORD PTR $T44[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 304  :   func_degrain[make_tuple(8, 1, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 1>;

	mov	eax, DWORD PTR $T93[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 304  :   func_degrain[make_tuple(8, 1, 1, NO_SIMD)] = DegrainN_C<uint8_t, 8, 1>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,8,1>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T43[ebp]
	push	eax
	lea	eax, DWORD PTR $T92[ebp]
	push	eax
	movups	XMMWORD PTR $T43[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 305  :   func_degrain[make_tuple(4, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 4, 8>;

	mov	eax, DWORD PTR $T92[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000040000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 305  :   func_degrain[make_tuple(4, 8, 1, NO_SIMD)] = DegrainN_C<uint8_t, 4, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,4,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T42[ebp]
	push	eax
	lea	eax, DWORD PTR $T91[ebp]
	push	eax
	movups	XMMWORD PTR $T42[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 306  :   func_degrain[make_tuple(4, 4, 1, NO_SIMD)] = DegrainN_C<uint8_t, 4, 4>;

	mov	eax, DWORD PTR $T91[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000020000000100000000
	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,4,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T41[ebp]
	push	eax
	lea	eax, DWORD PTR $T90[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movups	XMMWORD PTR $T41[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 307  :   func_degrain[make_tuple(4, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 4, 2>;

	mov	eax, DWORD PTR $T90[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000040000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 307  :   func_degrain[make_tuple(4, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 4, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,4,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T40[ebp]
	push	eax
	lea	eax, DWORD PTR $T89[ebp]
	push	eax
	movups	XMMWORD PTR $T40[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 308  :   func_degrain[make_tuple(2, 4, 1, NO_SIMD)] = DegrainN_C<uint8_t, 2, 4>;

	mov	eax, DWORD PTR $T89[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000020000000100000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 308  :   func_degrain[make_tuple(2, 4, 1, NO_SIMD)] = DegrainN_C<uint8_t, 2, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,2,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T39[ebp]
	push	eax
	lea	eax, DWORD PTR $T88[ebp]
	push	eax
	movups	XMMWORD PTR $T39[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 309  :   func_degrain[make_tuple(2, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 2, 2>;

	mov	eax, DWORD PTR $T88[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 309  :   func_degrain[make_tuple(2, 2, 1, NO_SIMD)] = DegrainN_C<uint8_t, 2, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@E$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned char,2,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T38[ebp]
	push	eax
	lea	eax, DWORD PTR $T87[ebp]
	push	eax
	movups	XMMWORD PTR $T38[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 311  :   func_degrain[make_tuple(32, 32, 2, NO_SIMD)] = DegrainN_C<uint16_t, 32, 32>;

	mov	eax, DWORD PTR $T87[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 311  :   func_degrain[make_tuple(32, 32, 2, NO_SIMD)] = DegrainN_C<uint16_t, 32, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,32,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T37[ebp]
	push	eax
	lea	eax, DWORD PTR $T86[ebp]
	push	eax
	movups	XMMWORD PTR $T37[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 312  :   func_degrain[make_tuple(32, 16, 2, NO_SIMD)] = DegrainN_C<uint16_t, 32, 16>;

	mov	eax, DWORD PTR $T86[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 312  :   func_degrain[make_tuple(32, 16, 2, NO_SIMD)] = DegrainN_C<uint16_t, 32, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,32,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T36[ebp]
	push	eax
	lea	eax, DWORD PTR $T85[ebp]
	push	eax
	movups	XMMWORD PTR $T36[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 313  :   func_degrain[make_tuple(32, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 32, 8>;

	mov	eax, DWORD PTR $T85[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 313  :   func_degrain[make_tuple(32, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 32, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,32,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T35[ebp]
	push	eax
	lea	eax, DWORD PTR $T84[ebp]
	push	eax
	movups	XMMWORD PTR $T35[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 314  :   func_degrain[make_tuple(16, 32, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 32>;

	mov	eax, DWORD PTR $T84[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 314  :   func_degrain[make_tuple(16, 32, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T34[ebp]
	push	eax
	lea	eax, DWORD PTR $T83[ebp]
	push	eax
	movups	XMMWORD PTR $T34[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 315  :   func_degrain[make_tuple(16, 16, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 16>;

	mov	eax, DWORD PTR $T83[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,16>
	movups	XMMWORD PTR $T33[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T33[ebp]
	push	eax
	lea	eax, DWORD PTR $T82[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 316  :   func_degrain[make_tuple(16, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 8>;

	mov	eax, DWORD PTR $T82[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 316  :   func_degrain[make_tuple(16, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	lea	eax, DWORD PTR $T81[ebp]
	push	eax
	movups	XMMWORD PTR $T32[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 317  :   func_degrain[make_tuple(16, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 4>;

	mov	eax, DWORD PTR $T81[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 317  :   func_degrain[make_tuple(16, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T31[ebp]
	push	eax
	lea	eax, DWORD PTR $T80[ebp]
	push	eax
	movups	XMMWORD PTR $T31[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 318  :   func_degrain[make_tuple(16, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 2>;

	mov	eax, DWORD PTR $T80[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 318  :   func_degrain[make_tuple(16, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 16, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,16,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T30[ebp]
	push	eax
	lea	eax, DWORD PTR $T79[ebp]
	push	eax
	movups	XMMWORD PTR $T30[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 319  :   func_degrain[make_tuple(8, 16, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 16>;

	mov	eax, DWORD PTR $T79[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 319  :   func_degrain[make_tuple(8, 16, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	lea	eax, DWORD PTR $T78[ebp]
	push	eax
	movups	XMMWORD PTR $T29[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 320  :   func_degrain[make_tuple(8, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 8>;

	mov	eax, DWORD PTR $T78[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 320  :   func_degrain[make_tuple(8, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T28[ebp]
	push	eax
	lea	eax, DWORD PTR $T77[ebp]
	push	eax
	movups	XMMWORD PTR $T28[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 321  :   func_degrain[make_tuple(8, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 4>;

	mov	eax, DWORD PTR $T77[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 321  :   func_degrain[make_tuple(8, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	lea	eax, DWORD PTR $T76[ebp]
	push	eax
	movups	XMMWORD PTR $T27[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 322  :   func_degrain[make_tuple(8, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 2>;

	mov	eax, DWORD PTR $T76[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 322  :   func_degrain[make_tuple(8, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	lea	eax, DWORD PTR $T75[ebp]
	push	eax
	movups	XMMWORD PTR $T26[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 323  :   func_degrain[make_tuple(8, 1, 2, NO_SIMD)] = DegrainN_C<uint16_t, 8, 1>;

	mov	eax, DWORD PTR $T75[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,8,1>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T25[ebp]
	movups	XMMWORD PTR $T25[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR $T74[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 324  :   func_degrain[make_tuple(4, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 4, 8>;

	mov	eax, DWORD PTR $T74[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000040000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 324  :   func_degrain[make_tuple(4, 8, 2, NO_SIMD)] = DegrainN_C<uint16_t, 4, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,4,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T24[ebp]
	push	eax
	lea	eax, DWORD PTR $T73[ebp]
	push	eax
	movups	XMMWORD PTR $T24[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 325  :   func_degrain[make_tuple(4, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 4, 4>;

	mov	eax, DWORD PTR $T73[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000020000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 325  :   func_degrain[make_tuple(4, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 4, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,4,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T23[ebp]
	push	eax
	lea	eax, DWORD PTR $T72[ebp]
	push	eax
	movups	XMMWORD PTR $T23[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 326  :   func_degrain[make_tuple(4, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 4, 2>;

	mov	eax, DWORD PTR $T72[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000040000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 326  :   func_degrain[make_tuple(4, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 4, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,4,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T22[ebp]
	push	eax
	lea	eax, DWORD PTR $T71[ebp]
	push	eax
	movups	XMMWORD PTR $T22[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 327  :   func_degrain[make_tuple(2, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 2, 4>;

	mov	eax, DWORD PTR $T71[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000020000000200000000
; File c:\github\mvtools\sources\mdegrainn.cpp

; 327  :   func_degrain[make_tuple(2, 4, 2, NO_SIMD)] = DegrainN_C<uint16_t, 2, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,2,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	lea	eax, DWORD PTR $T70[ebp]
	push	eax
	movups	XMMWORD PTR $T21[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 328  :   func_degrain[make_tuple(2, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 2, 2>;

	mov	eax, DWORD PTR $T70[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 328  :   func_degrain[make_tuple(2, 2, 2, NO_SIMD)] = DegrainN_C<uint16_t, 2, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_C@G$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_C<unsigned short,2,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T20[ebp]
	push	eax
	lea	eax, DWORD PTR $T69[ebp]
	push	eax
	movups	XMMWORD PTR $T20[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 352  :   func_degrain[make_tuple(32, 32, 1, USE_SSE2)] = DegrainN_sse2<32, 32>;

	mov	eax, DWORD PTR $T69[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 352  :   func_degrain[make_tuple(32, 32, 1, USE_SSE2)] = DegrainN_sse2<32, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<32,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	lea	eax, DWORD PTR $T68[ebp]
	push	eax
	movups	XMMWORD PTR $T19[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 353  :   func_degrain[make_tuple(32, 16, 1, USE_SSE2)] = DegrainN_sse2<32, 16>;

	mov	eax, DWORD PTR $T68[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 353  :   func_degrain[make_tuple(32, 16, 1, USE_SSE2)] = DegrainN_sse2<32, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<32,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	lea	eax, DWORD PTR $T67[ebp]
	push	eax
	movups	XMMWORD PTR $T18[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 354  :   func_degrain[make_tuple(32, 8, 1, USE_SSE2)] = DegrainN_sse2<32, 8>;

	mov	eax, DWORD PTR $T67[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000100000002
	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<32,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T17[ebp]
	movups	XMMWORD PTR $T17[ebp], xmm0
	push	eax
	lea	eax, DWORD PTR $T66[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 355  :   func_degrain[make_tuple(16, 32, 1, USE_SSE2)] = DegrainN_sse2<16, 32>;

	mov	eax, DWORD PTR $T66[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 355  :   func_degrain[make_tuple(16, 32, 1, USE_SSE2)] = DegrainN_sse2<16, 32>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,32>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	lea	eax, DWORD PTR $T65[ebp]
	push	eax
	movups	XMMWORD PTR $T16[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 356  :   func_degrain[make_tuple(16, 16, 1, USE_SSE2)] = DegrainN_sse2<16, 16>;

	mov	eax, DWORD PTR $T65[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 356  :   func_degrain[make_tuple(16, 16, 1, USE_SSE2)] = DegrainN_sse2<16, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	lea	eax, DWORD PTR $T64[ebp]
	push	eax
	movups	XMMWORD PTR $T15[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 357  :   func_degrain[make_tuple(16, 8, 1, USE_SSE2)] = DegrainN_sse2<16, 8>;

	mov	eax, DWORD PTR $T64[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 357  :   func_degrain[make_tuple(16, 8, 1, USE_SSE2)] = DegrainN_sse2<16, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	lea	eax, DWORD PTR $T63[ebp]
	push	eax
	movups	XMMWORD PTR $T14[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 358  :   func_degrain[make_tuple(16, 4, 1, USE_SSE2)] = DegrainN_sse2<16, 4>;

	mov	eax, DWORD PTR $T63[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 358  :   func_degrain[make_tuple(16, 4, 1, USE_SSE2)] = DegrainN_sse2<16, 4>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	lea	eax, DWORD PTR $T62[ebp]
	push	eax
	movups	XMMWORD PTR $T13[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 359  :   func_degrain[make_tuple(16, 2, 1, USE_SSE2)] = DegrainN_sse2<16, 2>;

	mov	eax, DWORD PTR $T62[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 359  :   func_degrain[make_tuple(16, 2, 1, USE_SSE2)] = DegrainN_sse2<16, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<16,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	lea	eax, DWORD PTR $T61[ebp]
	push	eax
	movups	XMMWORD PTR $T12[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 360  :   func_degrain[make_tuple(8, 16, 1, USE_SSE2)] = DegrainN_sse2<8, 16>;

	mov	eax, DWORD PTR $T61[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 360  :   func_degrain[make_tuple(8, 16, 1, USE_SSE2)] = DegrainN_sse2<8, 16>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,16>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	lea	eax, DWORD PTR $T60[ebp]
	push	eax
	movups	XMMWORD PTR $T11[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 361  :   func_degrain[make_tuple(8, 8, 1, USE_SSE2)] = DegrainN_sse2<8, 8>;

	mov	eax, DWORD PTR $T60[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 361  :   func_degrain[make_tuple(8, 8, 1, USE_SSE2)] = DegrainN_sse2<8, 8>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,8>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	eax, DWORD PTR $T59[ebp]
	push	eax
	movups	XMMWORD PTR $T10[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 362  :   func_degrain[make_tuple(8, 4, 1, USE_SSE2)] = DegrainN_sse2<8, 4>;

	mov	eax, DWORD PTR $T59[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000100000002
	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,4>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	movups	XMMWORD PTR $T9[ebp], xmm0
	lea	eax, DWORD PTR $T58[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 363  :   func_degrain[make_tuple(8, 2, 1, USE_SSE2)] = DegrainN_sse2<8, 2>;

	mov	eax, DWORD PTR $T58[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000100000002
; File c:\github\mvtools\sources\mdegrainn.cpp

; 363  :   func_degrain[make_tuple(8, 2, 1, USE_SSE2)] = DegrainN_sse2<8, 2>;

	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,2>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	eax, DWORD PTR $T57[ebp]
	push	eax
	movups	XMMWORD PTR $T8[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\mdegrainn.cpp

; 364  :   func_degrain[make_tuple(8, 1, 1, USE_SSE2)] = DegrainN_sse2<8, 1>;

	mov	eax, DWORD PTR $T57[ebp]

; 365  :   func_degrain[make_tuple(4, 8, 1, USE_SSE2)] = DegrainN_sse2<4, 8>;

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000100000002
	mov	DWORD PTR [eax+32], OFFSET ??$DegrainN_sse2@$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<8,1>
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	movups	XMMWORD PTR $T7[ebp], xmm0
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]

; 366  :   func_degrain[make_tuple(4, 4, 1, USE_SSE2)] = DegrainN_sse2<4, 4>;

	lea	edx, DWORD PTR $T109[ebp]
	mov	DWORD PTR $T121[ebp], 2
	lea	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T117[ebp], 1
	mov	DWORD PTR $T113[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$DegrainN_sse2@$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<4,8>
	lea	eax, DWORD PTR $T121[ebp]
	push	eax
	lea	eax, DWORD PTR $T117[ebp]
	mov	DWORD PTR $T109[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T113[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]

; 367  :   func_degrain[make_tuple(4, 2, 1, USE_SSE2)] = DegrainN_sse2<4, 2>;

	lea	edx, DWORD PTR $T120[ebp]
	mov	DWORD PTR $T108[ebp], 2
	lea	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T112[ebp], 1
	mov	DWORD PTR $T116[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$DegrainN_sse2@$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<4,4>
	lea	eax, DWORD PTR $T108[ebp]
	push	eax
	lea	eax, DWORD PTR $T112[ebp]
	mov	DWORD PTR $T120[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T116[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]

; 368  :   func_degrain[make_tuple(2, 4, 1, USE_SSE2)] = DegrainN_sse2<2, 4>;

	lea	edx, DWORD PTR $T119[ebp]
	mov	DWORD PTR $T107[ebp], 2
	lea	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T111[ebp], 1
	mov	DWORD PTR $T115[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$DegrainN_sse2@$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<4,2>
	lea	eax, DWORD PTR $T107[ebp]
	push	eax
	lea	eax, DWORD PTR $T111[ebp]
	mov	DWORD PTR $T119[ebp], 2
	push	eax
	lea	eax, DWORD PTR $T115[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]

; 369  :   func_degrain[make_tuple(2, 2, 1, USE_SSE2)] = DegrainN_sse2<2, 2>;

	mov	DWORD PTR $T106[ebp], 2
	mov	DWORD PTR $T110[ebp], 1
	mov	DWORD PTR $T114[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$DegrainN_sse2@$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<2,4>
	lea	eax, DWORD PTR $T106[ebp]
	mov	DWORD PTR $T118[ebp], 2
	push	eax
	lea	eax, DWORD PTR $T110[ebp]
	push	eax
	lea	eax, DWORD PTR $T114[ebp]
	push	eax
	lea	edx, DWORD PTR $T118[ebp]
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000030000000500000006
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	lea	esi, DWORD PTR _archlist$[ebp]
	mov	ebx, DWORD PTR _arch$[ebp]
	movups	XMMWORD PTR _archlist$[ebp], xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 369  :   func_degrain[make_tuple(2, 2, 1, USE_SSE2)] = DegrainN_sse2<2, 2>;

	mov	DWORD PTR [eax], OFFSET ??$DegrainN_sse2@$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ; DegrainN_sse2<2,2>

; 370  : 
; 371  :   DenoiseNFunction* result = nullptr;
; 372  :   arch_t archlist[] = { USE_AVX2, USE_AVX, USE_SSE41, USE_SSE2, NO_SIMD };

	mov	DWORD PTR _archlist$[ebp+16], 0
	jmp	SHORT $LL2@get_denois
$LL4924@get_denois:
	mov	edi, DWORD PTR _this$1$[ebp]
$LL2@get_denois:

; 373  :   int index = 0;
; 374  :   while (result == nullptr) {
; 375  :     arch_t current_arch_try = archlist[index++];

	mov	eax, DWORD PTR [esi]
	lea	esi, DWORD PTR [esi+4]
	mov	DWORD PTR _current_arch_try$122[ebp], eax

; 376  :     if (current_arch_try > arch) continue;

	cmp	eax, ebx
	jg	SHORT $LL2@get_denois

; 377  :     result = func_degrain[make_tuple(BlockX, BlockY, pixelsize, current_arch_try)];

	lea	eax, DWORD PTR _current_arch_try$122[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+136]
	push	eax
	lea	eax, DWORD PTR _BlockY$[ebp]
	push	eax
	lea	edx, DWORD PTR _BlockX$[ebp]
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$make_tuple@AAHAAHAAHAAW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00AAW4arch_t@@@Z ; std::make_tuple<int &,int &,int &,enum arch_t &>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]
	mov	edi, DWORD PTR [eax]

; 378  :     if (result == nullptr && current_arch_try == NO_SIMD)

	test	edi, edi
	jne	SHORT $LN4921@get_denois
	cmp	DWORD PTR _current_arch_try$122[ebp], edi
	jne	SHORT $LL4924@get_denois
$LN4921@get_denois:

; 379  :       break;
; 380  :   }
; 381  : 
; 382  : #if 0
; 383  :   DenoiseNFunction* result = func_degrain[make_tuple(BlockX, BlockY, _pixelsize, arch)];
; 384  :   if(!result) // fallback to C
; 385  :     result = func_degrain[make_tuple(BlockX, BlockY, _pixelsize, NO_SIMD)];
; 386  : #endif
; 387  :   return result;

	lea	ecx, DWORD PTR _func_degrain$[ebp]
	call	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ

; 388  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z$0:
	lea	ecx, DWORD PTR _func_degrain$[ebp]
	jmp	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ
__ehhandler$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_denoiseN_function@MDegrainN@@AAEP6AXPAE0_NHPBEHQAPBEQAH4H@ZHHHW4arch_t@@@Z ENDP ; MDegrainN::get_denoiseN_function
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
	pop	ecx
	ret	0
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMDegrainN@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMDegrainN@@UAEPAXI@Z PROC				; MDegrainN::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MDegrainN@@UAE@XZ			; MDegrainN::~MDegrainN
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	3704					; 00000e78H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMDegrainN@@UAEPAXI@Z ENDP				; MDegrainN::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??1MDegrainN@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MDegrainN@@UAE@XZ PROC				; MDegrainN::~MDegrainN, COMDAT
; _this$ = ecx

; 625  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MDegrainN@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi], OFFSET ??_7MDegrainN@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+3688]
	test	ecx, ecx
	je	SHORT $LN7@MDegrainN

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+3696]
	sub	edx, ecx
	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+3688], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+3692], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+3696], 0
$LN7@MDegrainN:

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+276]
	test	ecx, ecx
	je	SHORT $LN104@MDegrainN

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+284]
	sub	edx, ecx
	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+276], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+280], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+284], 0
$LN104@MDegrainN:

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+260]
	test	ecx, ecx
	je	SHORT $LN201@MDegrainN

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+268]
	sub	edx, ecx
	sar	edx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+260], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+264], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+268], 0
$LN201@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 757  : 		delete _Myptr;

	mov	edi, DWORD PTR [esi+224]
	test	edi, edi
	je	SHORT $LN300@MDegrainN
; File c:\github\mvtools\sources\overlap.cpp

; 136  : 	delete [] Overlap9Windows;

	push	DWORD PTR [edi+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 137  : 	delete [] fWin1UVx;

	push	DWORD PTR [edi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 138  : 	delete [] fWin1UVxfirst;

	push	DWORD PTR [edi+28]
	call	??_V@YAXPAX@Z				; operator delete[]

; 139  : 	delete [] fWin1UVxlast;

	push	DWORD PTR [edi+32]
	call	??_V@YAXPAX@Z				; operator delete[]

; 140  : 	delete [] fWin1UVy;

	push	DWORD PTR [edi+36]
	call	??_V@YAXPAX@Z				; operator delete[]

; 141  : 	delete [] fWin1UVyfirst;

	push	DWORD PTR [edi+40]
	call	??_V@YAXPAX@Z				; operator delete[]

; 142  : 	delete [] fWin1UVylast;

	push	DWORD PTR [edi+44]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	48					; 00000030H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 36					; 00000024H
$LN300@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 757  : 		delete _Myptr;

	mov	edi, DWORD PTR [esi+220]
	test	edi, edi
	je	SHORT $LN312@MDegrainN
; File c:\github\mvtools\sources\overlap.cpp

; 136  : 	delete [] Overlap9Windows;

	push	DWORD PTR [edi+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 137  : 	delete [] fWin1UVx;

	push	DWORD PTR [edi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 138  : 	delete [] fWin1UVxfirst;

	push	DWORD PTR [edi+28]
	call	??_V@YAXPAX@Z				; operator delete[]

; 139  : 	delete [] fWin1UVxlast;

	push	DWORD PTR [edi+32]
	call	??_V@YAXPAX@Z				; operator delete[]

; 140  : 	delete [] fWin1UVy;

	push	DWORD PTR [edi+36]
	call	??_V@YAXPAX@Z				; operator delete[]

; 141  : 	delete [] fWin1UVyfirst;

	push	DWORD PTR [edi+40]
	call	??_V@YAXPAX@Z				; operator delete[]

; 142  : 	delete [] fWin1UVylast;

	push	DWORD PTR [edi+44]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	48					; 00000030H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 36					; 00000024H
$LN312@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 757  : 		delete _Myptr;

	mov	ebx, DWORD PTR [esi+216]
	mov	edi, DWORD PTR __imp___aligned_free
	test	ebx, ebx
	je	SHORT $LN324@MDegrainN
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN324@MDegrainN:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 757  : 		delete _Myptr;

	mov	ebx, DWORD PTR [esi+212]
	test	ebx, ebx
	je	SHORT $LN336@MDegrainN
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN336@MDegrainN:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN344@MDegrainN
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN344@MDegrainN
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 627  : }

	lea	ecx, DWORD PTR [esi+180]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
$LN344@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 627  : }

	lea	ecx, DWORD PTR [esi+152]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 976  : 		_Tidy();

	call	?_Tidy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Tidy
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN361@MDegrainN
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN361@MDegrainN
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN361@MDegrainN:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 627  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mdegrainn.cpp

; 627  : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MDegrainN@@UAE@XZ$102:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MDegrainN@@UAE@XZ$105:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MDegrainN@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MDegrainN@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MDegrainN@@UAE@XZ ENDP				; MDegrainN::~MDegrainN
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_pRef$ = -8276						; size = 3072
_nRefPitches$ = -5204					; size = 3072
_ref$ = -2132						; size = 1024
_slicer$2 = -1108					; size = 1056
$T3 = -52						; size = 4
_dstV$1$ = -48						; size = 4
_dstPitchY$1$ = -44					; size = 4
_mv$4 = -40						; size = 4
_nDstPitchYUY2$1$ = -36					; size = 4
_row_size$1$ = -32					; size = 4
_row_size$1$ = -32					; size = 4
_row_size$1$ = -32					; size = 4
_dstU$1$ = -32						; size = 4
_pDstYUY2$1$ = -28					; size = 4
_mv_clip$1$ = -28					; size = 4
_src$ = -24						; size = 4
$T5 = -20						; size = 8
$T6 = -20						; size = 8
$T7 = -20						; size = 8
$T8 = -20						; size = 8
_src_pitch$1$ = -16					; size = 4
_src_pitch$1$ = -16					; size = 4
_src_pitch$1$ = -16					; size = 4
_dstY$1$ = -16						; size = 4
_k2$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nDstPitchYUY2$ = 8					; size = 4
_pDstYUY2$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_dst_pitch$1$ = 16					; size = 4
_dst_pitch$1$ = 16					; size = 4
_width$1$ = 16						; size = 4
_width$1$ = 16						; size = 4
tv3385 = 16						; size = 4
tv3300 = 16						; size = 4
_k2$1$ = 16						; size = 4
_n$ = 16						; size = 4
_srcp$1$ = 20						; size = 4
_dstp$1$ = 20						; size = 4
_pitch$1$ = 20						; size = 4
_pitch$1$ = 20						; size = 4
_dst_pitch$1$ = 20					; size = 4
tv3306 = 20						; size = 4
tv3302 = 20						; size = 4
tv3297 = 20						; size = 4
_k2$1$ = 20						; size = 4
_env_ptr$ = 20						; size = 4
?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MDegrainN::GetFrame, COMDAT

; 632  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	push	eax
	mov	eax, 8264				; 00002048H
	mov	DWORD PTR fs:0, esp
	call	__chkstk
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T3[ebp], 0
	push	ebx
	push	esi

; 633  :   _covered_width = nBlkX * (nBlkSizeX - nOverlapX) + nOverlapX;

	mov	esi, DWORD PTR _this$[ebp]

; 643  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	xor	ebx, ebx
	mov	edx, DWORD PTR _n$[ebp]
	push	edi
	mov	eax, DWORD PTR [esi+76]
	sub	eax, DWORD PTR [esi+108]
	imul	eax, DWORD PTR [esi+64]
	add	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [esi+3680], eax
	mov	eax, DWORD PTR [esi+80]
	sub	eax, DWORD PTR [esi+112]
	imul	eax, DWORD PTR [esi+68]
	add	eax, DWORD PTR [esi+112]
	mov	DWORD PTR [esi+3684], eax
	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	test	eax, eax
	jle	$LN3@GetFrame
$LL4@GetFrame:

; 1003 :   const int k = (index < _trad)

	mov	eax, DWORD PTR [esi+164]
	cmp	ebx, eax
	jge	SHORT $LN72@GetFrame
	sub	eax, ebx
	lea	edi, DWORD PTR [eax*2-1]
	jmp	SHORT $LN73@GetFrame
$LN72@GetFrame:
	mov	edi, ebx
	sub	edi, eax
	add	edi, edi
$LN73@GetFrame:
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [esi+152]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [edi+edi*2]
	push	DWORD PTR _env_ptr$[ebp]
	push	edx
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [eax+ecx*8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 651  :     ::PVideoFrame mv = mv_clip.GetFrame(n, env_ptr);

	lea	ecx, DWORD PTR _mv$4[ebp]
	push	ecx
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	DWORD PTR _mv_clip$1$[ebp], eax
	push	eax
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 651  :     ::PVideoFrame mv = mv_clip.GetFrame(n, env_ptr);

	call	DWORD PTR [eax+4]

; 652  :     mv_clip.Update(mv, env_ptr);

	push	DWORD PTR _env_ptr$[ebp]
	mov	ecx, DWORD PTR _mv_clip$1$[ebp]
	lea	eax, DWORD PTR _mv$4[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	mov	eax, DWORD PTR _mv_clip$1$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	DWORD PTR [eax+220]
	push	DWORD PTR [eax+216]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	SHORT $LN91@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	eax, DWORD PTR _mv_clip$1$[ebp]
	mov	al, BYTE PTR [eax+68]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	SHORT $LN91@GetFrame
	mov	eax, 1
	jmp	SHORT $LN92@GetFrame
$LN91@GetFrame:
	xor	eax, eax
$LN92@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 653  :     _usable_flag_arr[k] = mv_clip.IsUsable();

	mov	BYTE PTR [edi+esi+292], al
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN99@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN99@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mv$4[ebp]
	call	eax
$LN99@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 643  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	edx, DWORD PTR _n$[ebp]
	inc	ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 643  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	cmp	ebx, eax
	jl	$LL4@GetFrame
$LN3@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 656  :   ::PVideoFrame src = child->GetFrame(n, env_ptr);

	mov	ebx, DWORD PTR _env_ptr$[ebp]
	push	ebx
	push	edx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _src$[ebp]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]

; 657  :   ::PVideoFrame dst = env_ptr->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR [ebx]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	push	edi
	push	ebx
	call	DWORD PTR [ecx+56]

; 992  :   return (dst);

	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR $T3[ebp], 1
	cmp	eax, 1610612740				; 60000004H
	jne	$LN17@GetFrame

; 658  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)
; 659  :   {
; 660  :     if (!_planar_flag)

	cmp	BYTE PTR [esi+185], 0
	jne	$LN19@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN108@GetFrame
	cmp	DWORD PTR [edx], 220			; 000000dcH
	jbe	SHORT $LN108@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+220]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	jmp	SHORT $LN109@GetFrame
$LN108@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN109@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edx, edx
	je	SHORT $LN114@GetFrame
	cmp	DWORD PTR [edx], 192			; 000000c0H
	jbe	SHORT $LN114@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+192]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
	jmp	SHORT $LN115@GetFrame
$LN114@GetFrame:
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], 0
$LN115@GetFrame:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+212]
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 664  :       _dst_ptr_arr[0] = _dst_planes->GetPtr();

	mov	DWORD PTR [esi+3620], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+212]
; File c:\github\mvtools\sources\yuy2planes.h

; 42   :    inline unsigned char *GetPtrU() const { return pSrcU; }

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 665  :       _dst_ptr_arr[1] = _dst_planes->GetPtrU();

	mov	DWORD PTR [esi+3624], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+212]
; File c:\github\mvtools\sources\yuy2planes.h

; 43   :    inline unsigned char *GetPtrV() const { return pSrcV; }

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 666  :       _dst_ptr_arr[2] = _dst_planes->GetPtrV();

	mov	DWORD PTR [esi+3628], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+212]
; File c:\github\mvtools\sources\yuy2planes.h

; 39   :    inline int GetPitch() const { return srcPitch; }

	mov	eax, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 667  :       _dst_pitch_arr[0] = _dst_planes->GetPitch();

	mov	DWORD PTR [esi+3644], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+212]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 668  :       _dst_pitch_arr[1] = _dst_planes->GetPitchUV();

	mov	DWORD PTR [esi+3648], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+212]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 669  :       _dst_pitch_arr[2] = _dst_planes->GetPitchUV();

	mov	DWORD PTR [esi+3652], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	edx, edx
	je	SHORT $LN168@GetFrame
	cmp	DWORD PTR [edx], 212			; 000000d4H
	jbe	SHORT $LN168@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+212]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ebx, eax
	jmp	SHORT $LN169@GetFrame
$LN168@GetFrame:
	xor	ebx, ebx
$LN169@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edx, edx
	je	SHORT $LN174@GetFrame
	cmp	DWORD PTR [edx], 192			; 000000c0H
	jbe	SHORT $LN174@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+192]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN175@GetFrame
$LN174@GetFrame:
	xor	ecx, ecx
$LN175@GetFrame:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+216]
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+3632], eax
	mov	DWORD PTR _dstY$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+216]
; File c:\github\mvtools\sources\yuy2planes.h

; 42   :    inline unsigned char *GetPtrU() const { return pSrcU; }

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+3636], eax
	mov	DWORD PTR _dstU$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+216]
; File c:\github\mvtools\sources\yuy2planes.h

; 43   :    inline unsigned char *GetPtrV() const { return pSrcV; }

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+3640], eax
	mov	DWORD PTR _dstV$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+216]
; File c:\github\mvtools\sources\yuy2planes.h

; 39   :    inline int GetPitch() const { return srcPitch; }

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+3656], eax
	mov	DWORD PTR _dstPitchY$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+216]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi+3660], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	eax, DWORD PTR [esi+216]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 678  :       _src_pitch_arr[2] = _src_planes->GetPitchUV();

	mov	DWORD PTR [esi+3664], eax
; File c:\github\mvtools\sources\yuy2planes.cpp

; 139  :   nWidth <<= 2; // real target width

	mov	edi, DWORD PTR [esi+92]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 680  :       YUY2ToPlanes(

	mov	al, BYTE PTR [esi+184]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 139  :   nWidth <<= 2; // real target width

	shl	edi, 2

; 140  :   if (sse2 && IsPtrAligned(pSrcYUY2, 16)) {

	test	al, al
	je	SHORT $LN225@GetFrame
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	bl, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 140  :   if (sse2 && IsPtrAligned(pSrcYUY2, 16)) {

	jne	SHORT $LN225@GetFrame

; 141  :     convert_yuy2_to_yv16_sse2(pSrcYUY2, (unsigned char *)dstY, (unsigned char *)dstU, (unsigned char *)dstV, nSrcPitchYUY2, dstPitchY, dstPitchUV, nWidth, nHeight);

	mov	eax, DWORD PTR [esi+96]
	push	eax
	push	edi
	push	edx
	push	DWORD PTR _dstPitchY$1$[ebp]
	mov	edx, DWORD PTR _dstY$1$[ebp]
	push	ecx
	push	DWORD PTR _dstV$1$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _dstU$1$[ebp]
	call	?convert_yuy2_to_yv16_sse2@@YAXPBEPAE11IIIII@Z ; convert_yuy2_to_yv16_sse2
	add	esp, 28					; 0000001cH

; 142  :   }
; 143  :   else

	jmp	$LN18@GetFrame
$LN225@GetFrame:

; 144  :   {
; 145  :     convert_yuy2_to_yv16_c(pSrcYUY2, (unsigned char *)dstY, (unsigned char *)dstU, (unsigned char *)dstV, nSrcPitchYUY2, dstPitchY, dstPitchUV, nWidth, nHeight);

	mov	eax, DWORD PTR [esi+96]
	push	eax
	push	edi
	push	edx
	push	DWORD PTR _dstPitchY$1$[ebp]
	mov	edx, DWORD PTR _dstY$1$[ebp]
	push	ecx
	push	DWORD PTR _dstV$1$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _dstU$1$[ebp]
	call	?convert_yuy2_to_yv16_c@@YAXPBEPAE11IIIII@Z ; convert_yuy2_to_yv16_c
	add	esp, 28					; 0000001cH
; File c:\github\mvtools\sources\mdegrainn.cpp

; 687  :     else

	jmp	$LN18@GetFrame
$LN19@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edi, edi
	je	SHORT $LN234@GetFrame
	cmp	DWORD PTR [edi], 220			; 000000dcH
	jbe	SHORT $LN234@GetFrame
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR [edi+220]
	push	0
	mov	ecx, DWORD PTR [ebx]
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN235@GetFrame
$LN234@GetFrame:
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	xor	ecx, ecx
$LN235@GetFrame:
	mov	DWORD PTR [esi+3620], ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 690  :       _dst_ptr_arr[1] = _dst_ptr_arr[0] + nWidth;

	add	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [esi+3624], ecx

; 691  :       _dst_ptr_arr[2] = _dst_ptr_arr[1] + nWidth / 2; //yuy2 xratio

	mov	eax, DWORD PTR [esi+92]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [esi+3628], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edi, edi
	je	SHORT $LN240@GetFrame
	cmp	DWORD PTR [edi], 192			; 000000c0H
	jbe	SHORT $LN240@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edi+192]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN241@GetFrame
$LN240@GetFrame:
	xor	eax, eax
$LN241@GetFrame:
	mov	DWORD PTR [esi+3644], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 693  :       _dst_pitch_arr[1] = _dst_pitch_arr[0];

	mov	DWORD PTR [esi+3648], eax

; 694  :       _dst_pitch_arr[2] = _dst_pitch_arr[0];

	mov	DWORD PTR [esi+3652], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	edi, edi
	je	SHORT $LN246@GetFrame
	cmp	DWORD PTR [edi], 212			; 000000d4H
	jbe	SHORT $LN246@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edi+212]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN247@GetFrame
$LN246@GetFrame:
	xor	eax, eax
$LN247@GetFrame:
	mov	DWORD PTR [esi+3632], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 696  :       _src_ptr_arr[1] = _src_ptr_arr[0] + nWidth;

	mov	ecx, DWORD PTR [esi+92]
	add	ecx, eax
	mov	DWORD PTR [esi+3636], ecx

; 697  :       _src_ptr_arr[2] = _src_ptr_arr[1] + nWidth / 2;

	mov	eax, DWORD PTR [esi+92]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [esi+3640], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edi, edi
	je	SHORT $LN252@GetFrame
	cmp	DWORD PTR [edi], 192			; 000000c0H
	jbe	SHORT $LN252@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edi+192]
	push	0
	call	eax
	jmp	SHORT $LN253@GetFrame
$LN252@GetFrame:
	xor	eax, eax
$LN253@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 703  :   else

	mov	edi, DWORD PTR _pDstYUY2$[ebp]
	mov	ebx, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR [esi+3656], eax
	mov	DWORD PTR [esi+3660], eax
	mov	DWORD PTR [esi+3664], eax
	mov	DWORD PTR _pDstYUY2$1$[ebp], edi
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], ebx
	jmp	$LN18@GetFrame
$LN17@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN258@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN258@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+220]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN259@GetFrame
$LN258@GetFrame:
	xor	ecx, ecx
$LN259@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 705  :     _dst_ptr_arr[0] = YWPLAN(dst);

	mov	DWORD PTR [esi+3620], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN264@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN264@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+220]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN265@GetFrame
$LN264@GetFrame:
	xor	ecx, ecx
$LN265@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 706  :     _dst_ptr_arr[1] = UWPLAN(dst);

	mov	DWORD PTR [esi+3624], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN270@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN270@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+220]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN271@GetFrame
$LN270@GetFrame:
	xor	ecx, ecx
$LN271@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 707  :     _dst_ptr_arr[2] = VWPLAN(dst);

	mov	DWORD PTR [esi+3628], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN276@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN276@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN277@GetFrame
$LN276@GetFrame:
	xor	ecx, ecx
$LN277@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 708  :     _dst_pitch_arr[0] = YPITCH(dst);

	mov	DWORD PTR [esi+3644], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN282@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN282@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN283@GetFrame
$LN282@GetFrame:
	xor	ecx, ecx
$LN283@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 709  :     _dst_pitch_arr[1] = UPITCH(dst);

	mov	DWORD PTR [esi+3648], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN288@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN288@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN289@GetFrame
$LN288@GetFrame:
	xor	ecx, ecx
$LN289@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 710  :     _dst_pitch_arr[2] = VPITCH(dst);

	mov	DWORD PTR [esi+3652], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN294@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN294@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN295@GetFrame
$LN294@GetFrame:
	xor	ecx, ecx
$LN295@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 711  :     _src_ptr_arr[0] = YRPLAN(src);

	mov	DWORD PTR [esi+3632], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN300@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN300@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN301@GetFrame
$LN300@GetFrame:
	xor	ecx, ecx
$LN301@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 712  :     _src_ptr_arr[1] = URPLAN(src);

	mov	DWORD PTR [esi+3636], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN306@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN306@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN307@GetFrame
$LN306@GetFrame:
	xor	ecx, ecx
$LN307@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 713  :     _src_ptr_arr[2] = VRPLAN(src);

	mov	DWORD PTR [esi+3640], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN312@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN312@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN313@GetFrame
$LN312@GetFrame:
	xor	ecx, ecx
$LN313@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 714  :     _src_pitch_arr[0] = YPITCH(src);

	mov	DWORD PTR [esi+3656], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN318@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN318@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN319@GetFrame
$LN318@GetFrame:
	xor	ecx, ecx
$LN319@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 715  :     _src_pitch_arr[1] = UPITCH(src);

	mov	DWORD PTR [esi+3660], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN324@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN324@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	jmp	SHORT $LN325@GetFrame
$LN324@GetFrame:
	xor	eax, eax
$LN325@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 716  :     _src_pitch_arr[2] = VPITCH(src);

	mov	DWORD PTR [esi+3664], eax
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN18@GetFrame:

; 717  :   }
; 718  : 
; 719  :   _lsb_offset_arr[0] = _dst_pitch_arr[0] * nHeight;

	mov	edx, DWORD PTR [esi+96]
	imul	edx, DWORD PTR [esi+3644]
	mov	DWORD PTR [esi+3668], edx

; 720  :   _lsb_offset_arr[1] = _dst_pitch_arr[1] * (nHeight >> _yratiouv_log);

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+204]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+3648]
	mov	DWORD PTR [esi+3672], eax

; 721  :   _lsb_offset_arr[2] = _dst_pitch_arr[2] * (nHeight >> _yratiouv_log);

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+204]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+3652]
	mov	DWORD PTR [esi+3676], eax

; 722  : 
; 723  :   if (_lsb_flag)

	cmp	BYTE PTR [esi+186], 0
	je	SHORT $LN22@GetFrame

; 724  :   {
; 725  :     memset(_dst_ptr_arr[0] + _lsb_offset_arr[0], 0, _lsb_offset_arr[0]);

	mov	eax, DWORD PTR [esi+3620]
	push	edx
	add	eax, edx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 726  :     if (!_planar_flag)

	cmp	BYTE PTR [esi+185], 0
	jne	SHORT $LN22@GetFrame

; 727  :     {
; 728  :       memset(_dst_ptr_arr[1] + _lsb_offset_arr[1], 0, _lsb_offset_arr[1]);

	mov	ecx, DWORD PTR [esi+3672]
	mov	eax, DWORD PTR [esi+3624]
	push	ecx
	add	eax, ecx
	push	0
	push	eax
	call	_memset

; 729  :       memset(_dst_ptr_arr[2] + _lsb_offset_arr[2], 0, _lsb_offset_arr[2]);

	mov	ecx, DWORD PTR [esi+3676]
	mov	eax, DWORD PTR [esi+3628]
	push	ecx
	add	eax, ecx
	push	0
	push	eax
	call	_memset
	add	esp, 24					; 00000018H
$LN22@GetFrame:

; 730  :     }
; 731  :   }
; 732  : 
; 733  :   ::PVideoFrame ref[MAX_TEMP_RAD * 2];

	push	OFFSET ??1PVideoFrame@@QAE@XZ		; PVideoFrame::~PVideoFrame
	push	OFFSET ??0PVideoFrame@@QAE@XZ		; PVideoFrame::PVideoFrame
	push	256					; 00000100H
	push	4
	lea	eax, DWORD PTR _ref$[ebp]
	push	eax
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 734  : 
; 735  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	xor	edi, edi
	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	test	eax, eax
	jle	SHORT $LN6@GetFrame
	lea	ebx, DWORD PTR [esi+180]
$LL7@GetFrame:

; 1003 :   const int k = (index < _trad)

	mov	eax, DWORD PTR [esi+164]
	cmp	edi, eax
	jge	SHORT $LN328@GetFrame
	sub	eax, edi
	lea	edx, DWORD PTR [eax*2-1]
	jmp	SHORT $LN329@GetFrame
$LN328@GetFrame:
	mov	edx, edi
	sub	edx, eax
	add	edx, edx
$LN329@GetFrame:
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [esi+152]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [edx+edx*2]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 740  :     mv_clip.use_ref_frame(ref[k], _usable_flag_arr[k], _super, n, env_ptr);

	push	DWORD PTR _env_ptr$[ebp]
	push	DWORD PTR _n$[ebp]
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	ecx, DWORD PTR [eax+ecx*8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 740  :     mv_clip.use_ref_frame(ref[k], _usable_flag_arr[k], _super, n, env_ptr);

	lea	eax, DWORD PTR [esi+292]
	add	eax, edx
	push	ebx
	push	eax
	lea	eax, DWORD PTR _ref$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	push	eax
	call	?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z ; MVClip::use_ref_frame
	mov	eax, DWORD PTR [esi+164]
	inc	edi
	add	eax, eax
	cmp	edi, eax
	jl	SHORT $LL7@GetFrame
$LN6@GetFrame:

; 741  :   }
; 742  : 
; 743  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [esi+116]

; 744  :   {
; 745  :     for (int k2 = 0; k2 < _trad * 2; ++k2)

	xor	ecx, ecx
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	mov	eax, DWORD PTR [esi+164]
	jne	$LN23@GetFrame
	add	eax, eax
	mov	DWORD PTR _k2$1$[ebp], ecx
	test	eax, eax
	jle	$LN12@GetFrame
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LL10@GetFrame:

; 1003 :   const int k = (index < _trad)

	mov	eax, DWORD PTR [esi+164]
	cmp	ecx, eax
	jge	SHORT $LN345@GetFrame
	sub	eax, ecx
	lea	ebx, DWORD PTR [eax*2-1]
	jmp	SHORT $LN346@GetFrame
$LN345@GetFrame:
	mov	ebx, ecx
	sub	ebx, eax
	add	ebx, ebx
$LN346@GetFrame:

; 746  :     {
; 747  :       const int k = reorder_ref(k2);
; 748  :       if (_usable_flag_arr[k])

	cmp	BYTE PTR [ebx+esi+292], 0
	je	$LN8@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	lea	eax, DWORD PTR _ref$[ebp]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR tv3302[ebp], eax

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	edi, edi
	je	SHORT $LN351@GetFrame
	cmp	DWORD PTR [edi], 212			; 000000d4H
	jbe	SHORT $LN351@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+212]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN717@GetFrame
$LN351@GetFrame:
	xor	eax, eax
$LN717@GetFrame:
	mov	DWORD PTR tv3385[ebp], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 750  :         pRef[k][0] = ref[k]->GetReadPtr();

	lea	ebx, DWORD PTR [ebx+ebx*2]
	mov	DWORD PTR _pRef$[ebp+ebx*4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	eax, DWORD PTR tv3302[ebp]

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	edi, edi
	je	SHORT $LN357@GetFrame
	cmp	DWORD PTR [edi], 196			; 000000c4H
	jbe	SHORT $LN357@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+196]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN358@GetFrame
$LN357@GetFrame:
	xor	eax, eax
$LN358@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 751  :         pRef[k][1] = pRef[k][0] + ref[k]->GetRowSize() / 2;

	mov	eax, eax
	test	eax, eax
	jns	SHORT $LN722@GetFrame
	add	eax, 1
$LN722@GetFrame:
	sar	eax, 1
	add	eax, DWORD PTR tv3385[ebp]
	mov	DWORD PTR tv3300[ebp], eax
	mov	DWORD PTR _pRef$[ebp+ebx*4+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	eax, DWORD PTR tv3302[ebp]

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	edi, edi
	je	SHORT $LN363@GetFrame
	cmp	DWORD PTR [edi], 196			; 000000c4H
	jbe	SHORT $LN363@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+196]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN364@GetFrame
$LN363@GetFrame:
	xor	eax, eax
$LN364@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 752  :         pRef[k][2] = pRef[k][1] + ref[k]->GetRowSize() / 4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR tv3300[ebp]
	mov	DWORD PTR _pRef$[ebp+ebx*4+8], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	eax, DWORD PTR tv3302[ebp]

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edi, edi
	je	SHORT $LN369@GetFrame
	cmp	DWORD PTR [edi], 192			; 000000c0H
	jbe	SHORT $LN369@GetFrame
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+192]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN370@GetFrame
$LN369@GetFrame:
	xor	eax, eax
$LN370@GetFrame:
	mov	ecx, DWORD PTR _k2$1$[ebp]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 753  :         nRefPitches[k][0] = ref[k]->GetPitch();

	mov	DWORD PTR _nRefPitches$[ebp+ebx*4], eax

; 754  :         nRefPitches[k][1] = nRefPitches[k][0];

	mov	DWORD PTR _nRefPitches$[ebp+ebx*4+4], eax

; 755  :         nRefPitches[k][2] = nRefPitches[k][0];

	mov	DWORD PTR _nRefPitches$[ebp+ebx*4+8], eax
$LN8@GetFrame:

; 744  :   {
; 745  :     for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	eax, DWORD PTR [esi+164]
	inc	ecx
	add	eax, eax
	mov	DWORD PTR _k2$1$[ebp], ecx
	cmp	ecx, eax
	jl	$LL10@GetFrame

; 756  :       }
; 757  :     }
; 758  :   }
; 759  :   else

	jmp	$LN12@GetFrame
$LN23@GetFrame:

; 760  :   {
; 761  :     for (int k2 = 0; k2 < _trad * 2; ++k2)

	add	eax, eax
	mov	DWORD PTR _k2$1$[ebp], ecx
	test	eax, eax
	jle	$LN12@GetFrame
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	npad	8
$LL13@GetFrame:

; 1003 :   const int k = (index < _trad)

	mov	eax, DWORD PTR [esi+164]
	cmp	ecx, eax
	jge	SHORT $LN373@GetFrame
	sub	eax, ecx
	lea	edi, DWORD PTR [eax*2-1]
	jmp	SHORT $LN374@GetFrame
$LN373@GetFrame:
	mov	edi, ecx
	sub	edi, eax
	add	edi, edi
$LN374@GetFrame:

; 762  :     {
; 763  :       const int k = reorder_ref(k2);
; 764  :       if (_usable_flag_arr[k])

	cmp	BYTE PTR [edi+esi+292], 0
	je	$LN11@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	lea	ebx, DWORD PTR _ref$[ebp]
	lea	ebx, DWORD PTR [ebx+edi*4]

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	edx, edx
	je	SHORT $LN379@GetFrame
	cmp	DWORD PTR [edx], 212			; 000000d4H
	jbe	SHORT $LN379@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+212]
	push	1
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN380@GetFrame
$LN379@GetFrame:
	xor	eax, eax
$LN380@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 766  :         pRef[k][0] = YRPLAN(ref[k]);

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR _pRef$[ebp+edi*4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	edx, edx
	je	SHORT $LN385@GetFrame
	cmp	DWORD PTR [edx], 212			; 000000d4H
	jbe	SHORT $LN385@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+212]
	push	2
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN386@GetFrame
$LN385@GetFrame:
	xor	eax, eax
$LN386@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 767  :         pRef[k][1] = URPLAN(ref[k]);

	mov	DWORD PTR _pRef$[ebp+edi*4+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	edx, edx
	je	SHORT $LN391@GetFrame
	cmp	DWORD PTR [edx], 212			; 000000d4H
	jbe	SHORT $LN391@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+212]
	push	4
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN392@GetFrame
$LN391@GetFrame:
	xor	eax, eax
$LN392@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 768  :         pRef[k][2] = VRPLAN(ref[k]);

	mov	DWORD PTR _pRef$[ebp+edi*4+8], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edx, edx
	je	SHORT $LN397@GetFrame
	cmp	DWORD PTR [edx], 192			; 000000c0H
	jbe	SHORT $LN397@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+192]
	push	1
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN398@GetFrame
$LN397@GetFrame:
	xor	eax, eax
$LN398@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 769  :         nRefPitches[k][0] = YPITCH(ref[k]);

	mov	DWORD PTR _nRefPitches$[ebp+edi*4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edx, edx
	je	SHORT $LN403@GetFrame
	cmp	DWORD PTR [edx], 192			; 000000c0H
	jbe	SHORT $LN403@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+192]
	push	2
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN404@GetFrame
$LN403@GetFrame:
	xor	eax, eax
$LN404@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 770  :         nRefPitches[k][1] = UPITCH(ref[k]);

	mov	DWORD PTR _nRefPitches$[ebp+edi*4+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edx, edx
	je	SHORT $LN409@GetFrame
	cmp	DWORD PTR [edx], 192			; 000000c0H
	jbe	SHORT $LN409@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+192]
	push	4
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN410@GetFrame
$LN409@GetFrame:
	xor	eax, eax
$LN410@GetFrame:
	mov	ecx, DWORD PTR _k2$1$[ebp]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 771  :         nRefPitches[k][2] = VPITCH(ref[k]);

	mov	DWORD PTR _nRefPitches$[ebp+edi*4+8], eax
$LN11@GetFrame:

; 760  :   {
; 761  :     for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	eax, DWORD PTR [esi+164]
	inc	ecx
	add	eax, eax
	mov	DWORD PTR _k2$1$[ebp], ecx
	cmp	ecx, eax
	jl	$LL13@GetFrame
$LN12@GetFrame:

; 772  :       }
; 773  :     }
; 774  :   }
; 775  : 
; 776  :   memset(_planes_ptr, 0, _trad * 2 * sizeof(_planes_ptr[0]));

	mov	eax, DWORD PTR [esi+164]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3
	push	eax
	lea	eax, DWORD PTR [esi+548]
	push	0
	push	eax
	call	_memset

; 777  : 
; 778  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	eax, DWORD PTR [esi+164]
	xor	ecx, ecx
	add	eax, eax
	mov	DWORD PTR _k2$1$[ebp], ecx
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	$LN15@GetFrame
$LL16@GetFrame:

; 1003 :   const int k = (index < _trad)

	mov	eax, DWORD PTR [esi+164]
	cmp	ecx, eax
	jge	SHORT $LN413@GetFrame
	sub	eax, ecx
	lea	edi, DWORD PTR [eax*2-1]
	jmp	SHORT $LN414@GetFrame
$LN413@GetFrame:
	mov	edi, ecx
	sub	edi, eax
	add	edi, edi
$LN414@GetFrame:
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [esi+152]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [edi+edi*2]
; File c:\github\mvtools\sources\sharedptr.hpp

; 181  : 	return (*_obj_ptr);

	mov	ebx, DWORD PTR [eax+ecx*8+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 782  :     gof.Update(

	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 2
	mov	ecx, ebx
	mov	DWORD PTR tv3297[ebp], eax
	push	DWORD PTR _nRefPitches$[ebp+eax+8]
	push	DWORD PTR _pRef$[ebp+eax+8]
	push	DWORD PTR _nRefPitches$[ebp+eax+4]
	push	DWORD PTR _pRef$[ebp+eax+4]
	push	DWORD PTR _nRefPitches$[ebp+eax]
	push	DWORD PTR _pRef$[ebp+eax]
	push	DWORD PTR [esi+168]
	call	?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z ; MVGroupOfFrames::Update

; 783  :       _yuvplanes,
; 784  :       const_cast <BYTE *> (pRef[k][0]), nRefPitches[k][0],
; 785  :       const_cast <BYTE *> (pRef[k][1]), nRefPitches[k][1],
; 786  :       const_cast <BYTE *> (pRef[k][2]), nRefPitches[k][2]
; 787  :     );
; 788  :     if (_yuvplanes & YPLANE)

	test	BYTE PTR [esi+168], 1
	je	SHORT $LN715@GetFrame
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ebx], 0
	jg	SHORT $LN429@GetFrame
; File c:\github\mvtools\sources\mdegrainn.cpp

; 790  :       _planes_ptr[k][0] = gof.GetFrame(0)->GetPlane(YPLANE);

	mov	edx, DWORD PTR tv3297[ebp]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	xor	eax, eax
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 790  :       _planes_ptr[k][0] = gof.GetFrame(0)->GetPlane(YPLANE);

	mov	DWORD PTR [edx+esi+548], eax
	jmp	SHORT $LN27@GetFrame
$LN429@GetFrame:
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ebx+4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 790  :       _planes_ptr[k][0] = gof.GetFrame(0)->GetPlane(YPLANE);

	mov	edx, DWORD PTR tv3297[ebp]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 790  :       _planes_ptr[k][0] = gof.GetFrame(0)->GetPlane(YPLANE);

	mov	DWORD PTR [edx+esi+548], eax
	jmp	SHORT $LN27@GetFrame
$LN715@GetFrame:
	mov	edx, DWORD PTR tv3297[ebp]
$LN27@GetFrame:

; 791  :     }
; 792  :     if (_yuvplanes & UPLANE)

	test	BYTE PTR [esi+168], 2
	je	SHORT $LN28@GetFrame
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ebx], 0
	jg	SHORT $LN438@GetFrame
	xor	ecx, ecx
	jmp	SHORT $LN437@GetFrame
$LN438@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [eax]
$LN437@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	ecx, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 794  :       _planes_ptr[k][1] = gof.GetFrame(0)->GetPlane(UPLANE);

	lea	eax, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+eax*4+552], ecx
$LN28@GetFrame:

; 795  :     }
; 796  :     if (_yuvplanes & VPLANE)

	test	BYTE PTR [esi+168], 4
	je	SHORT $LN14@GetFrame
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ebx], 0
	jg	SHORT $LN447@GetFrame
	xor	eax, eax
	jmp	SHORT $LN446@GetFrame
$LN447@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax]
$LN446@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 798  :       _planes_ptr[k][2] = gof.GetFrame(0)->GetPlane(VPLANE);

	mov	DWORD PTR [edx+esi+556], eax
$LN14@GetFrame:

; 777  : 
; 778  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	ecx, DWORD PTR _k2$1$[ebp]
	mov	eax, DWORD PTR [esi+164]
	inc	ecx
	add	eax, eax
	mov	DWORD PTR _k2$1$[ebp], ecx
	cmp	ecx, eax
	jl	$LL16@GetFrame
$LN15@GetFrame:

; 799  :     }
; 800  :   }
; 801  : 
; 802  :   PROFILE_START(MOTION_PROFILE_COMPENSATION);
; 803  : 
; 804  :   //-------------------------------------------------------------------------
; 805  :   // LUMA plane Y
; 806  : 
; 807  :   if ((_yuvplanes & YPLANE) == 0)

	test	BYTE PTR [esi+168], 1
	jne	$LN30@GetFrame

; 808  :   {
; 809  :     BitBlt(

	mov	ecx, DWORD PTR [esi+192]
	imul	ecx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [esi+3644]
	mov	edi, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [esi+3656]
	mov	ebx, DWORD PTR [esi+3632]
	mov	DWORD PTR _dst_pitch$1$[ebp], eax
	mov	eax, DWORD PTR [esi+3620]
	mov	DWORD PTR _row_size$1$[ebp], ecx
	mov	DWORD PTR _src_pitch$1$[ebp], edx
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edi, edi
	je	$LN653@GetFrame
	test	ecx, ecx
	je	$LN653@GetFrame

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	edi, 1
	je	SHORT $LN463@GetFrame
	cmp	DWORD PTR _dst_pitch$1$[ebp], edx
	jne	SHORT $LN461@GetFrame
	cmp	edx, ecx
	je	SHORT $LN463@GetFrame
$LN461@GetFrame:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	test	edi, edi
	jle	$LN653@GetFrame
	mov	esi, eax
$LL458@GetFrame:

; 94   :       memcpy(dstp, srcp, row_size);

	push	ecx
	push	ebx
	push	esi
	call	_memcpy

; 95   :       dstp += dst_pitch;

	add	esi, DWORD PTR _dst_pitch$1$[ebp]
	dec	edi

; 96   :       srcp += src_pitch;

	add	ebx, DWORD PTR _src_pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _row_size$1$[ebp]
	test	edi, edi
	jg	SHORT $LL458@GetFrame
; File c:\github\mvtools\sources\mdegrainn.cpp

; 643  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	esi, DWORD PTR _this$[ebp]
	jmp	$LN653@GetFrame
$LN463@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 91   :     memcpy(dstp, srcp, row_size*height); // Fizick: fixed bug

	imul	ecx, edi
	push	ecx
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\mdegrainn.cpp

; 815  :   else

	jmp	$LN653@GetFrame
$LN30@GetFrame:

; 817  :     Slicer slicer(_mt_flag);

	mov	bl, BYTE PTR [esi+187]
; File c:\github\mvtools\sources\mtslicer.hpp

; 70   : {

	mov	DWORD PTR _slicer$2[ebp], OFFSET ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR _slicer$2[ebp+8], eax

; 66   : ,	_proc_ptr (0)

	mov	DWORD PTR $T8[ebp], 0
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR _slicer$2[ebp+16], eax
	mov	DWORD PTR $T8[ebp+4], 0
	mov	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR _slicer$2[ebp+20], eax

; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR _slicer$2[ebp+28]
	push	1024					; 00000400H
	push	0
	push	eax
	mov	DWORD PTR _slicer$2[ebp+24], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 69   : ,	_mt_flag (mt_flag)

	mov	BYTE PTR _slicer$2[ebp+1052], bl
; File c:\github\mvtools\sources\mdegrainn.cpp

; 817  :     Slicer slicer(_mt_flag);

	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 818  : 
; 819  :     if (nOverlapX == 0 && nOverlapY == 0)

	cmp	DWORD PTR [esi+108], 0
	jne	SHORT $LN32@GetFrame
	cmp	DWORD PTR [esi+112], 0
	jne	SHORT $LN32@GetFrame

; 820  :     {
; 821  :       slicer.start(

	push	1
	push	0
	push	OFFSET ?process_luma_normal_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_luma_normal_slice
	push	esi
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MDegrainN,MDegrainN,64>::start
; File c:\github\mvtools\sources\mtslicer.hpp

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer$2[ebp+1052], 0
	je	SHORT $LN468@GetFrame

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$2[ebp+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer$2[ebp+8]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$2[ebp+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer$2[ebp+8]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN468@GetFrame:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR $T7[ebp], 0
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR _slicer$2[ebp+16], eax
	mov	DWORD PTR $T7[ebp+4], 0
	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR _slicer$2[ebp+20], eax

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer$2[ebp+24], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 830  :     else

	jmp	$LN646@GetFrame
$LN32@GetFrame:
	mov	eax, DWORD PTR [esi+260]
	cmp	eax, DWORD PTR [esi+264]

; 831  :     {
; 832  :       unsigned short *pDstShort = (_dst_short.empty()) ? 0 : &_dst_short[0];

	jne	SHORT $LN58@GetFrame
	xor	ebx, ebx
	jmp	SHORT $LN59@GetFrame
$LN58@GetFrame:
	mov	ebx, DWORD PTR [esi+260]
$LN59@GetFrame:
	mov	eax, DWORD PTR [esi+276]
	cmp	eax, DWORD PTR [esi+280]

; 833  :       int *pDstInt = (_dst_int.empty()) ? 0 : &_dst_int[0];

	jne	SHORT $LN60@GetFrame
	xor	edi, edi
	jmp	SHORT $LN61@GetFrame
$LN60@GetFrame:
	mov	edi, DWORD PTR [esi+276]
$LN61@GetFrame:

; 834  : 
; 835  :       if (_lsb_flag || pixelsize_super>1)

	cmp	BYTE PTR [esi+186], 0
	jne	SHORT $LN36@GetFrame
	cmp	DWORD PTR [esi+192], 1
	jg	SHORT $LN36@GetFrame

; 838  :           reinterpret_cast <unsigned char *> (pDstInt), 0,
; 839  :           _covered_width * sizeof(int), _covered_height, 0, 0, _dst_int_pitch * sizeof(int)
; 840  :         );
; 841  :       }
; 842  :       else
; 843  :       {
; 844  :         MemZoneSet(

	mov	eax, DWORD PTR [esi+272]
	mov	edi, DWORD PTR [esi+3684]
	add	eax, eax
	mov	DWORD PTR _pitch$1$[ebp], eax
	mov	eax, DWORD PTR [esi+3680]
	add	eax, eax
	mov	DWORD PTR _width$1$[ebp], eax
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	edi, edi
	jle	SHORT $LN540@GetFrame
	mov	esi, DWORD PTR _pitch$1$[ebp]
	npad	5
$LL546@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	eax
	push	0
	push	ebx
	call	_memset
	mov	eax, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	ebx, esi
	sub	edi, 1
	jne	SHORT $LL546@GetFrame
; File c:\github\mvtools\sources\mdegrainn.cpp

; 643  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	jmp	SHORT $LN718@GetFrame
$LN36@GetFrame:

; 836  :       {
; 837  :         MemZoneSet(

	mov	eax, DWORD PTR [esi+288]
	mov	ebx, DWORD PTR [esi+3684]
	shl	eax, 2
	mov	DWORD PTR _pitch$1$[ebp], eax
	mov	eax, DWORD PTR [esi+3680]
	shl	eax, 2
	mov	DWORD PTR _width$1$[ebp], eax
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	ebx, ebx
	jle	SHORT $LN540@GetFrame
	mov	esi, DWORD PTR _pitch$1$[ebp]
	npad	3
$LL541@GetFrame:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	eax
	push	0
	push	edi
	call	_memset
	mov	eax, DWORD PTR _width$1$[ebp]
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	edi, esi
	sub	ebx, 1
	jne	SHORT $LL541@GetFrame
$LN718@GetFrame:
	mov	esi, DWORD PTR _this$[ebp]
$LN540@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 850  :       if (nOverlapY > 0)

	cmp	DWORD PTR [esi+112], 0
	jle	SHORT $LN37@GetFrame
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+3692]
	sub	eax, DWORD PTR [esi+3688]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 852  :         memset(

	and	eax, -4					; fffffffcH
	push	eax
	push	0
	push	DWORD PTR [esi+3688]
	call	_memset
	add	esp, 12					; 0000000cH
$LN37@GetFrame:

; 853  :           &_boundary_cnt_arr[0],
; 854  :           0,
; 855  :           _boundary_cnt_arr.size() * sizeof(_boundary_cnt_arr[0])
; 856  :         );
; 857  :       }
; 858  : 
; 859  :       slicer.start(

	push	2
	push	0
	push	OFFSET ?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_luma_overlap_slice
	push	esi
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MDegrainN,MDegrainN,64>::start
; File c:\github\mvtools\sources\mtslicer.hpp

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer$2[ebp+1052], 0
	je	SHORT $LN581@GetFrame

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$2[ebp+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer$2[ebp+8]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$2[ebp+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer$2[ebp+8]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN581@GetFrame:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR $T6[ebp], 0
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _slicer$2[ebp+16], eax
	mov	DWORD PTR $T6[ebp+4], 0
	mov	eax, DWORD PTR $T6[ebp+4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 867  :       if (_lsb_flag)

	cmp	BYTE PTR [esi+186], 0
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR _slicer$2[ebp+20], eax

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer$2[ebp+24], 0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 867  :       if (_lsb_flag)

	je	SHORT $LN38@GetFrame

; 868  :       {
; 869  :         Short2BytesLsb(

	push	DWORD PTR [esi+3684]
	mov	edx, DWORD PTR [esi+3668]
	push	DWORD PTR [esi+3680]
	mov	ecx, DWORD PTR [esi+3620]
	add	edx, ecx
	push	DWORD PTR [esi+288]
	push	DWORD PTR [esi+276]
	push	DWORD PTR [esi+3644]
	call	?Short2BytesLsb@@YAXPAE0HPAHHHH@Z	; Short2BytesLsb
	add	esp, 20					; 00000014H
	jmp	$LN44@GetFrame
$LN38@GetFrame:

; 870  :           _dst_ptr_arr[0],
; 871  :           _dst_ptr_arr[0] + _lsb_offset_arr[0],
; 872  :           _dst_pitch_arr[0],
; 873  :           &_dst_int[0], _dst_int_pitch,
; 874  :           _covered_width, _covered_height
; 875  :         );
; 876  :       }
; 877  :       else if(pixelsize_super == 1)

	mov	eax, DWORD PTR [esi+192]
	cmp	eax, 1
	jne	SHORT $LN40@GetFrame

; 878  :       {
; 879  :         Short2Bytes(

	push	DWORD PTR [esi+3684]
	mov	edx, DWORD PTR [esi+3644]
	push	DWORD PTR [esi+3680]
	mov	ecx, DWORD PTR [esi+3620]
	push	DWORD PTR [esi+272]
	push	DWORD PTR [esi+260]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes
	jmp	SHORT $LN719@GetFrame
$LN40@GetFrame:

; 880  :           _dst_ptr_arr[0], _dst_pitch_arr[0],
; 881  :           &_dst_short[0], _dst_short_pitch,
; 882  :           _covered_width, _covered_height
; 883  :         );
; 884  :       }
; 885  :       else if (pixelsize_super == 2)

	cmp	eax, 2
	jne	SHORT $LN42@GetFrame

; 886  :       {
; 887  :         Short2Bytes_Int32toWord16(

	push	DWORD PTR [esi+196]
	mov	edx, DWORD PTR [esi+3644]
	push	DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+3620]
	push	DWORD PTR [esi+3680]
	push	DWORD PTR [esi+288]
	push	DWORD PTR [esi+276]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16
	add	esp, 20					; 00000014H
	jmp	SHORT $LN44@GetFrame
$LN42@GetFrame:

; 888  :           (uint16_t *)_dst_ptr_arr[0], _dst_pitch_arr[0],
; 889  :           &_dst_int[0], _dst_int_pitch,
; 890  :           _covered_width, _covered_height,
; 891  :           bits_per_pixel_super
; 892  :         );
; 893  :       }
; 894  :       else if (pixelsize_super == 4)

	cmp	eax, 4
	jne	SHORT $LN44@GetFrame

; 895  :       {
; 896  :         Short2Bytes_FloatInInt32ArrayToFloat(

	push	DWORD PTR [esi+3684]
	mov	edx, DWORD PTR [esi+3644]
	push	DWORD PTR [esi+3680]
	push	ecx
	push	DWORD PTR [esi+276]
	mov	ecx, DWORD PTR [esi+3620]
	call	?Short2Bytes_FloatInInt32ArrayToFloat@@YAXPAMHPAHHHH@Z ; Short2Bytes_FloatInInt32ArrayToFloat
$LN719@GetFrame:
	add	esp, 16					; 00000010H
$LN44@GetFrame:

; 897  :           (float *)_dst_ptr_arr[0], _dst_pitch_arr[0],
; 898  :           &_dst_int[0], _dst_int_pitch,
; 899  :           _covered_width, _covered_height
; 900  :         );
; 901  :       }
; 902  :       if (_covered_width < nWidth)

	mov	ebx, DWORD PTR [esi+3680]
	mov	ecx, DWORD PTR [esi+92]
	cmp	ebx, ecx
	jge	$LN636@GetFrame

; 903  :       {
; 904  :         BitBlt(

	mov	eax, DWORD PTR [esi+192]
	sub	ecx, ebx
	mov	edi, DWORD PTR [esi+3684]
	mov	edx, DWORD PTR [esi+3656]
	imul	ebx, eax
	imul	ecx, eax
	mov	eax, DWORD PTR [esi+3644]
	mov	DWORD PTR _dst_pitch$1$[ebp], eax
	mov	eax, DWORD PTR [esi+3620]
	mov	DWORD PTR tv3306[ebp], ebx
	mov	ebx, DWORD PTR [esi+3632]
	add	ebx, DWORD PTR tv3306[ebp]
	add	eax, DWORD PTR tv3306[ebp]
	mov	DWORD PTR _row_size$1$[ebp], ecx
	mov	DWORD PTR _src_pitch$1$[ebp], edx
	mov	DWORD PTR _dstp$1$[ebp], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edi, edi
	je	SHORT $LN636@GetFrame
	test	ecx, ecx
	je	SHORT $LN636@GetFrame

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	edi, 1
	je	SHORT $LN639@GetFrame
	cmp	DWORD PTR _dst_pitch$1$[ebp], edx
	jne	SHORT $LN637@GetFrame
	cmp	edx, ecx
	je	SHORT $LN639@GetFrame
$LN637@GetFrame:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	test	edi, edi
	jle	SHORT $LN636@GetFrame
	mov	esi, DWORD PTR _dstp$1$[ebp]
	npad	6
$LL634@GetFrame:

; 94   :       memcpy(dstp, srcp, row_size);

	push	ecx
	push	ebx
	push	esi
	call	_memcpy

; 95   :       dstp += dst_pitch;

	add	esi, DWORD PTR _dst_pitch$1$[ebp]
	dec	edi

; 96   :       srcp += src_pitch;

	add	ebx, DWORD PTR _src_pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _row_size$1$[ebp]
	test	edi, edi
	jg	SHORT $LL634@GetFrame
; File c:\github\mvtools\sources\mdegrainn.cpp

; 643  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	esi, DWORD PTR _this$[ebp]
	jmp	SHORT $LN636@GetFrame
$LN639@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 91   :     memcpy(dstp, srcp, row_size*height); // Fizick: fixed bug

	imul	ecx, edi
	push	ecx
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN636@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 910  :       if (_covered_height < nHeight) // bottom noncovered region

	mov	ebx, DWORD PTR [esi+3684]
	mov	edi, DWORD PTR [esi+96]
	cmp	ebx, edi
	jge	$LN646@GetFrame

; 912  :         BitBlt(

	mov	edx, DWORD PTR [esi+3656]
	mov	eax, ebx
	mov	ecx, DWORD PTR [esi+192]
	sub	edi, ebx
	imul	ecx, DWORD PTR [esi+92]
	imul	eax, edx
	mov	DWORD PTR _src_pitch$1$[ebp], edx
	mov	DWORD PTR _row_size$1$[ebp], ecx
	add	eax, DWORD PTR [esi+3632]
	mov	DWORD PTR _srcp$1$[ebp], eax
	mov	eax, DWORD PTR [esi+3644]
	imul	ebx, eax
	mov	DWORD PTR _dst_pitch$1$[ebp], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	eax, DWORD PTR _srcp$1$[ebp]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 912  :         BitBlt(

	add	ebx, DWORD PTR [esi+3620]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edi, edi
	je	SHORT $LN646@GetFrame
	test	ecx, ecx
	je	SHORT $LN646@GetFrame

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	edi, 1
	je	SHORT $LN649@GetFrame
	cmp	DWORD PTR _dst_pitch$1$[ebp], edx
	jne	SHORT $LN647@GetFrame
	cmp	edx, ecx
	je	SHORT $LN649@GetFrame
$LN647@GetFrame:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	test	edi, edi
	jle	SHORT $LN646@GetFrame
	mov	esi, DWORD PTR _srcp$1$[ebp]
$LL644@GetFrame:

; 94   :       memcpy(dstp, srcp, row_size);

	push	ecx
	push	esi
	push	ebx
	call	_memcpy

; 95   :       dstp += dst_pitch;

	add	ebx, DWORD PTR _dst_pitch$1$[ebp]
	dec	edi

; 96   :       srcp += src_pitch;

	add	esi, DWORD PTR _src_pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _row_size$1$[ebp]
	test	edi, edi
	jg	SHORT $LL644@GetFrame
; File c:\github\mvtools\sources\mdegrainn.cpp

; 643  :   for (int k2 = 0; k2 < _trad * 2; ++k2)

	mov	esi, DWORD PTR _this$[ebp]
	jmp	SHORT $LN646@GetFrame
$LN649@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 91   :     memcpy(dstp, srcp, row_size*height); // Fizick: fixed bug

	imul	ecx, edi
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN646@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 920  :     if (pixelsize_super <= 2)

	mov	edi, DWORD PTR [esi+192]
	cmp	edi, 2
	jg	SHORT $LN55@GetFrame

; 921  :     {
; 922  :       if (_nlimit < (1 << bits_per_pixel_super) - 1)

	mov	ecx, DWORD PTR [esi+196]
	mov	eax, 1
	mov	edx, DWORD PTR [esi+172]
	shl	eax, cl
	dec	eax
	cmp	edx, eax
	jge	SHORT $LN55@GetFrame

; 923  :       {
; 924  :         if (_isse_flag)

	cmp	BYTE PTR [esi+184], 0

; 927  :             LimitChanges_sse2_new<uint8_t>(

	mov	ecx, DWORD PTR [esi+3620]
	push	edx
	push	DWORD PTR [esi+96]
	mov	edx, DWORD PTR [esi+3644]
	push	DWORD PTR [esi+92]
	push	DWORD PTR [esi+3656]
	push	DWORD PTR [esi+3632]
	je	SHORT $LN50@GetFrame

; 925  :         {
; 926  :           if (pixelsize_super == 1)

	cmp	edi, 1
	jne	SHORT $LN52@GetFrame

; 927  :             LimitChanges_sse2_new<uint8_t>(

	call	??$LimitChanges_sse2_new@E@@YAXPAEHPBEHHHH@Z ; LimitChanges_sse2_new<unsigned char>

; 928  :               _dst_ptr_arr[0], _dst_pitch_arr[0],
; 929  :               _src_ptr_arr[0], _src_pitch_arr[0],
; 930  :               nWidth, nHeight,
; 931  :               _nlimit
; 932  :               );
; 933  :           else // pixelsize_super == 2

	jmp	SHORT $LN720@GetFrame
$LN52@GetFrame:

; 934  :             LimitChanges_sse2_new<uint16_t>(

	call	??$LimitChanges_sse2_new@G@@YAXPAEHPBEHHHH@Z ; LimitChanges_sse2_new<unsigned short>

; 935  :               _dst_ptr_arr[0], _dst_pitch_arr[0],
; 936  :               _src_ptr_arr[0], _src_pitch_arr[0],
; 937  :               nWidth, nHeight,
; 938  :               _nlimit
; 939  :               );
; 940  :         }
; 941  :         else

	jmp	SHORT $LN720@GetFrame
$LN50@GetFrame:

; 942  :         {
; 943  :           if (pixelsize_super == 1)

	cmp	edi, 1
	jne	SHORT $LN54@GetFrame

; 944  :             LimitChanges_c<uint8_t>(

	call	??$LimitChanges_c@E@@YAXPAEHPBEHHHH@Z	; LimitChanges_c<unsigned char>

; 945  :               _dst_ptr_arr[0], _dst_pitch_arr[0],
; 946  :               _src_ptr_arr[0], _src_pitch_arr[0],
; 947  :               nWidth, nHeight, _nlimit
; 948  :               );
; 949  :           else

	jmp	SHORT $LN720@GetFrame
$LN54@GetFrame:

; 950  :             LimitChanges_c<uint16_t>(

	call	??$LimitChanges_c@G@@YAXPAEHPBEHHHH@Z	; LimitChanges_c<unsigned short>
$LN720@GetFrame:
	add	esp, 20					; 00000014H
$LN55@GetFrame:
; File c:\github\mvtools\sources\mtslicer.hpp

; 86   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR _slicer$2[ebp+24], 0
	mov	DWORD PTR _slicer$2[ebp], OFFSET ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@
	je	SHORT $LN652@GetFrame

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer$2[ebp+1052], 0
	je	SHORT $LN656@GetFrame

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$2[ebp+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer$2[ebp+8]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer$2[ebp+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer$2[ebp+8]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN656@GetFrame:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR $T5[ebp], 0
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _slicer$2[ebp+16], eax
	mov	DWORD PTR $T5[ebp+4], 0
	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR _slicer$2[ebp+20], eax

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer$2[ebp+24], 0
$LN652@GetFrame:

; 91   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 4
$LN653@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 973  :   process_chroma <1>(UPLANE & _nsupermodeyuv);

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, esi
	and	eax, 2
	push	eax
	call	??$process_chroma@$00@MDegrainN@@AAEXH@Z ; MDegrainN::process_chroma<1>

; 974  :   process_chroma <2>(VPLANE & _nsupermodeyuv);

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, esi
	and	eax, 4
	push	eax
	call	??$process_chroma@$01@MDegrainN@@AAEXH@Z ; MDegrainN::process_chroma<2>

; 975  : 
; 976  :   //-------------------------------------------------------------------------
; 977  : 
; 978  : #ifndef _M_X64 
; 979  :   _mm_empty(); // (we may use double-float somewhere) Fizick

	emms

; 980  : #endif
; 981  : 
; 982  :   PROFILE_STOP(MOTION_PROFILE_COMPENSATION);
; 983  : 
; 984  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !_planar_flag)

	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN664@GetFrame
	cmp	BYTE PTR [esi+185], 0
	jne	SHORT $LN664@GetFrame

; 985  :   {
; 986  :     YUY2FromPlanes(

	mov	edi, DWORD PTR [esi+188]
	mov	al, BYTE PTR [esi+184]
	imul	edi, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [esi+3648]
	mov	ebx, DWORD PTR [esi+3628]
	mov	ecx, DWORD PTR [esi+3620]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	test	al, al
	je	SHORT $LN663@GetFrame
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	cl, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	jne	SHORT $LN663@GetFrame

; 155  :     //U and V don't have to be aligned since we user movq to read from those
; 156  :     convert_yv16_to_yuy2_sse2(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	mov	eax, DWORD PTR [esi+3644]
	push	edi
	push	DWORD PTR [esi+92]
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+3624]
	push	eax
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	ebx
	call	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_sse2

; 157  :   }
; 158  :   else

	jmp	SHORT $LN721@GetFrame
$LN663@GetFrame:

; 159  :   {
; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	mov	eax, DWORD PTR [esi+3644]
	push	edi
	push	DWORD PTR [esi+92]
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+3624]
	push	eax
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	ebx
	call	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_c
$LN721@GetFrame:
	add	esp, 28					; 0000001cH
$LN664@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 992  :   return (dst);

	push	OFFSET ??1PVideoFrame@@QAE@XZ		; PVideoFrame::~PVideoFrame
	push	256					; 00000100H
	push	4
	lea	eax, DWORD PTR _ref$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	pop	esi
	pop	ebx
	test	edx, edx
	je	SHORT $LN713@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN713@GetFrame
	mov	edx, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	edx
$LN713@GetFrame:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 992  :   return (dst);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 993  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _mv$4[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	mov	eax, DWORD PTR $T3[ebp]
	and	eax, 1
	je	$LN67@GetFrame
	and	DWORD PTR $T3[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN67@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	push	OFFSET ??1PVideoFrame@@QAE@XZ		; PVideoFrame::~PVideoFrame
	push	256					; 00000100H
	push	4
	lea	eax, DWORD PTR _ref$[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR _slicer$2[ebp]
	jmp	??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ ; MTSlicer<MDegrainN,MDegrainN,64>::~MTSlicer<MDegrainN,MDegrainN,64>
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$81:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$82:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MDegrainN@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MDegrainN::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?reorder_ref@MDegrainN@@ABEHH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?reorder_ref@MDegrainN@@ABEHH@Z PROC			; MDegrainN::reorder_ref, COMDAT
; _this$ = ecx

; 1000 :   assert(index >= 0);
; 1001 :   assert(index < _trad * 2);
; 1002 : 
; 1003 :   const int k = (index < _trad)

	mov	ecx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _index$[esp-4]
	cmp	eax, ecx
	jge	SHORT $LN3@reorder_re
	sub	ecx, eax
	lea	eax, DWORD PTR [ecx*2-1]

; 1004 :     ? (_trad - index) * 2 - 1
; 1005 :     : (index - _trad) * 2;
; 1006 : 
; 1007 :   return (k);
; 1008 : }

	ret	4
$LN3@reorder_re:

; 1000 :   assert(index >= 0);
; 1001 :   assert(index < _trad * 2);
; 1002 : 
; 1003 :   const int k = (index < _trad)

	sub	eax, ecx
	add	eax, eax

; 1004 :     ? (_trad - index) * 2 - 1
; 1005 :     : (index - _trad) * 2;
; 1006 : 
; 1007 :   return (k);
; 1008 : }

	ret	4
?reorder_ref@MDegrainN@@ABEHH@Z ENDP			; MDegrainN::reorder_ref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?process_luma_normal_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_pSrcCur$1$ = -3160					; size = 4
_dst_pitch$1$ = -3156					; size = 4
_dst_pitch$1$ = -3156					; size = 4
_k$1$ = -3156						; size = 4
_pDstCur$1$ = -3152					; size = 4
tv1064 = -3148						; size = 4
_src_pitch$1$ = -3144					; size = 4
$T1 = -3144						; size = 4
_src_pitch$1$ = -3140					; size = 4
tv993 = -3140						; size = 4
_row_size$1$ = -3140					; size = 4
_dstp$1$ = -3136					; size = 4
_dstp$1$ = -3136					; size = 4
tv1136 = -3136						; size = 4
_this$1$ = -3132					; size = 4
_by$1$ = -3128						; size = 4
tv1066 = -3124						; size = 4
_xx$1$ = -3120						; size = 4
_bx$1$ = -3116						; size = 4
_row_size$1$ = -3112					; size = 4
_i$1$ = -3112						; size = 4
_rowsize$1$ = -3108					; size = 4
$T2 = -3104						; size = 12
$T3 = -3092						; size = 12
_weight_arr$4 = -3080					; size = 1028
_pitch_arr$5 = -2048					; size = 1024
_ref_data_ptr_arr$6 = -1024				; size = 1024
_td$ = 8						; size = 4
?process_luma_normal_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z PROC ; MDegrainN::process_luma_normal_slice, COMDAT
; _this$ = ecx

; 1189 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 3164				; 00000c5cH
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 1190 :   assert(&td != 0);
; 1191 : 
; 1192 :   const int rowsize = nBlkSizeY;
; 1193 :   BYTE *pDstCur = _dst_ptr_arr[0] + td._y_beg * rowsize * _dst_pitch_arr[0]; // P.F. why *rowsize? (*nBlkSizeY)

	mov	edi, DWORD PTR _td$[ebp]
	mov	ecx, DWORD PTR [ebx+3644]

; 1194 :   const BYTE *pSrcCur = _src_ptr_arr[0] + td._y_beg * rowsize * _src_pitch_arr[0]; // P.F. why *rowsize? (*nBlkSizeY)

	mov	esi, DWORD PTR [ebx+3656]
	mov	eax, DWORD PTR [ebx+80]
	mov	edx, DWORD PTR [edi+8]
	imul	ecx, edx
	imul	esi, edx
	mov	DWORD PTR _this$1$[esp+3176], ebx
	mov	DWORD PTR _rowsize$1$[esp+3176], eax
	mov	DWORD PTR _by$1$[esp+3176], edx
	imul	ecx, eax
	imul	esi, eax
	add	ecx, DWORD PTR [ebx+3620]
	add	esi, DWORD PTR [ebx+3632]
	mov	DWORD PTR _pDstCur$1$[esp+3176], ecx
	mov	DWORD PTR _pSrcCur$1$[esp+3176], esi

; 1195 : 
; 1196 :   for (int by = td._y_beg; by < td._y_end; ++by)

	cmp	edx, DWORD PTR [edi+12]
	jge	$LN3@process_lu

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	movss	xmm3, DWORD PTR __real@43800000
$LL4@process_lu:

; 1199 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	edi, DWORD PTR [ebx+64]
	xor	eax, eax
	mov	DWORD PTR _xx$1$[esp+3176], 0
	mov	DWORD PTR _bx$1$[esp+3176], eax
	test	edi, edi
	jle	$LN6@process_lu
	npad	4
$LL7@process_lu:

; 1200 :     {
; 1201 :       int i = by * nBlkX + bx;

	imul	edi, edx

; 1206 :       for (int k = 0; k < _trad * 2; ++k)

	xor	ecx, ecx
	mov	DWORD PTR _k$1$[esp+3176], ecx
	add	edi, eax
	mov	eax, DWORD PTR [ebx+164]
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+3176], edi
	mov	DWORD PTR $T1[esp+3176], eax
	test	eax, eax
	jle	$LN9@process_lu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [ebx+152]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1208 :         use_block_y(

	lea	edx, DWORD PTR [ebx+548]
	mov	esi, DWORD PTR $T1[esp+3176]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	DWORD PTR tv1136[esp+3176], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1208 :         use_block_y(

	xor	eax, eax
	mov	DWORD PTR tv1066[esp+3176], eax
	mov	DWORD PTR tv1064[esp+3176], edx
	npad	15
$LL10@process_lu:

; 1611 :   if (usable_flag)

	cmp	BYTE PTR [ebx+ecx+292], 0

; 1208 :         use_block_y(

	mov	edx, DWORD PTR [edx]

; 1611 :   if (usable_flag)

	je	$LN26@process_lu
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	ecx, DWORD PTR [ebx+152]
	mov	eax, DWORD PTR [ecx+eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	ecx, DWORD PTR [edi+edi*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1615 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	eax, DWORD PTR [ebx+104]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv993[esp+3176], esi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1615 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [esi+ecx*4+4]
	mov	edi, DWORD PTR [esi+ecx*4]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [esi+ecx*4+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1615 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	imul	ebx, eax
	imul	edi, eax
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[esp+3176], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T2[esp+3176], xmm0
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+32]
	add	edi, DWORD PTR [edx+28]
	add	ebx, DWORD PTR $T2[esp+3180]
	add	edi, DWORD PTR $T3[esp+3176]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN48@process_lu

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebx
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN51@process_lu
$LN48@process_lu:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN50@process_lu

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	esi, esi
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 1
	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN117@process_lu
$LN50@process_lu:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	esi, 2
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 2
	sar	ebx, 2
$LN117@process_lu:
	mov	edi, DWORD PTR tv1064[esp+3176]
	mov	ecx, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR tv1064[esp+3176]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	add	edi, edx
	mov	edx, DWORD PTR [eax]
	imul	ebx, DWORD PTR [edx+12]
	add	edi, ebx
$LN51@process_lu:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1616 :     p = plane_ptr->GetPointer(blx, bly);

	mov	ecx, DWORD PTR _k$1$[esp+3176]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	mov	ebx, DWORD PTR _this$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1616 :     p = plane_ptr->GetPointer(blx, bly);

	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+3176], edi

; 1617 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edi, DWORD PTR _i$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	edx, DWORD PTR tv1066[esp+3176]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+3176], eax
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv993[esp+3176]
	lea	esi, DWORD PTR [edi+edi*4]
	mov	esi, DWORD PTR [eax+esi*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR tv1136[esp+3176]
	mov	edx, DWORD PTR [eax+edx+16]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	edx, esi
	jg	SHORT $LN64@process_lu
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	esi, DWORD PTR $T1[esp+3176]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	eax, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax

; 1621 :   else

	jmp	$LN8@process_lu
$LN64@process_lu:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [ebx+140], 8
	jg	SHORT $LN65@process_lu

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	edx, edx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	esi, esi

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, edx
	sub	eax, esi

; 921  :     const int den = thSAD2 + blockSAD2;

	add	esi, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN68@process_lu
	shl	eax, 8
	cdq
	idiv	esi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	esi, DWORD PTR $T1[esp+3176]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax
	jmp	SHORT $LN8@process_lu
$LN68@process_lu:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	esi, 8
	cdq
	idiv	esi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	esi, DWORD PTR $T1[esp+3176]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax
	jmp	SHORT $LN8@process_lu
$LN65@process_lu:
	movd	xmm2, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
	movd	xmm1, esi

; 935  :                                                         // smart compiler makes x*x, VS2015 calls __libm_sse2_pow_precise, way too slow
; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	esi, DWORD PTR $T1[esp+3176]
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	mulss	xmm2, xmm2

; 935  :                                                         // smart compiler makes x*x, VS2015 calls __libm_sse2_pow_precise, way too slow
; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, xmm3
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax

; 1621 :   else

	jmp	SHORT $LN8@process_lu
$LN26@process_lu:

; 1208 :         use_block_y(

	mov	eax, DWORD PTR [ebx+192]
	imul	eax, DWORD PTR _xx$1$[esp+3176]

; 1625 :     wref = 0;

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], 0
	add	eax, DWORD PTR _pSrcCur$1$[esp+3176]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+3176], eax
	mov	eax, DWORD PTR [ebx+3656]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+3176], eax
$LN8@process_lu:

; 1206 :       for (int k = 0; k < _trad * 2; ++k)

	mov	edx, DWORD PTR tv1064[esp+3176]
	inc	ecx
	mov	eax, DWORD PTR tv1066[esp+3176]
	add	edx, 12					; 0000000cH
	add	eax, 24					; 00000018H
	mov	DWORD PTR _k$1$[esp+3176], ecx
	mov	DWORD PTR tv1064[esp+3176], edx
	mov	DWORD PTR tv1066[esp+3176], eax
	cmp	ecx, esi
	jl	$LL10@process_lu
	mov	esi, DWORD PTR _pSrcCur$1$[esp+3176]
$LN9@process_lu:

; 1209 :           ref_data_ptr_arr[k],
; 1210 :           pitch_arr[k],
; 1211 :           weight_arr[k + 1],
; 1212 :           _usable_flag_arr[k],
; 1213 :           _mv_clip_arr[k],
; 1214 :           i,
; 1215 :           _planes_ptr[k][0],
; 1216 :           pSrcCur,
; 1217 :           xx * pixelsize_super,
; 1218 :           _src_pitch_arr[0]
; 1219 :         );
; 1220 :       }
; 1221 : 
; 1222 :       norm_weights(weight_arr, _trad);

	mov	edx, DWORD PTR [ebx+164]
	lea	ecx, DWORD PTR _weight_arr$4[esp+3176]
	call	?norm_weights@MDegrainN@@CAXQAHH@Z	; MDegrainN::norm_weights

; 1223 : 
; 1224 :       // luma
; 1225 :       _degrainluma_ptr(

	push	DWORD PTR [ebx+164]
	mov	ecx, DWORD PTR [ebx+192]
	lea	eax, DWORD PTR _weight_arr$4[esp+3180]
	mov	edi, DWORD PTR _xx$1$[esp+3180]
	mov	edx, DWORD PTR _pDstCur$1$[esp+3180]
	push	eax
	imul	ecx, edi
	lea	eax, DWORD PTR _pitch_arr$5[esp+3184]
	push	eax
	lea	eax, DWORD PTR _ref_data_ptr_arr$6[esp+3188]
	push	eax
	push	DWORD PTR [ebx+3656]
	lea	eax, DWORD PTR [ecx+esi]
	push	eax
	push	DWORD PTR [ebx+3644]
	movzx	eax, BYTE PTR [ebx+186]
	push	eax
	lea	eax, DWORD PTR [ecx+edx]
	add	eax, DWORD PTR [ebx+3668]
	push	eax
	lea	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	eax, DWORD PTR [ebx+252]
	call	eax

; 1226 :         pDstCur + xx*pixelsize_super, pDstCur + _lsb_offset_arr[0] + xx*pixelsize_super, _lsb_flag, _dst_pitch_arr[0],
; 1227 :         pSrcCur + xx*pixelsize_super, _src_pitch_arr[0],
; 1228 :         ref_data_ptr_arr, pitch_arr, weight_arr, _trad
; 1229 :       );
; 1230 : 
; 1231 :       xx += (nBlkSizeX); // xx: indexing offset
; 1232 : 
; 1233 :       if (bx == nBlkX - 1 && _covered_width < nWidth) // right non-covered region

	mov	eax, DWORD PTR [ebx+64]
	add	esp, 40					; 00000028H
	add	edi, DWORD PTR [ebx+76]
	dec	eax
	mov	DWORD PTR _xx$1$[esp+3176], edi
	cmp	DWORD PTR _bx$1$[esp+3176], eax
	jne	$LN5@process_lu
	mov	edi, DWORD PTR [ebx+3680]
	mov	ecx, DWORD PTR [ebx+92]
	cmp	edi, ecx
	jge	$LN5@process_lu

; 1236 :         BitBlt(

	mov	eax, DWORD PTR [ebx+192]
	sub	ecx, edi
	mov	edx, DWORD PTR [ebx+3656]
	mov	esi, DWORD PTR [ebx+80]
	imul	ecx, eax
	imul	eax, edi
	mov	edi, DWORD PTR _pSrcCur$1$[esp+3176]
	mov	DWORD PTR _src_pitch$1$[esp+3176], edx
	mov	edx, DWORD PTR [ebx+3644]
	mov	DWORD PTR _dst_pitch$1$[esp+3176], edx
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	edx, DWORD PTR _src_pitch$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1236 :         BitBlt(

	add	edi, eax
	add	eax, DWORD PTR _pDstCur$1$[esp+3176]
	mov	DWORD PTR _row_size$1$[esp+3176], ecx
	mov	DWORD PTR _dstp$1$[esp+3176], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	esi, esi
	je	SHORT $LN116@process_lu
	test	ecx, ecx
	je	SHORT $LN116@process_lu

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	esi, 1
	je	SHORT $LN78@process_lu
	cmp	DWORD PTR _dst_pitch$1$[esp+3176], edx
	jne	SHORT $LN76@process_lu
	cmp	edx, ecx
	je	SHORT $LN78@process_lu
$LN76@process_lu:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	test	esi, esi
	jle	SHORT $LN116@process_lu
	mov	ebx, DWORD PTR _dstp$1$[esp+3176]
	npad	3
$LL73@process_lu:

; 94   :       memcpy(dstp, srcp, row_size);

	push	ecx
	push	edi
	push	ebx
	call	_memcpy

; 95   :       dstp += dst_pitch;

	add	ebx, DWORD PTR _dst_pitch$1$[esp+3188]
	dec	esi

; 96   :       srcp += src_pitch;

	add	edi, DWORD PTR _src_pitch$1$[esp+3188]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _row_size$1$[esp+3176]
	test	esi, esi
	jg	SHORT $LL73@process_lu
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1206 :       for (int k = 0; k < _trad * 2; ++k)

	mov	ebx, DWORD PTR _this$1$[esp+3176]
	jmp	SHORT $LN116@process_lu
$LN78@process_lu:
; File c:\github\mvtools\sources\copycode.cpp

; 91   :     memcpy(dstp, srcp, row_size*height); // Fizick: fixed bug

	imul	esi, ecx
	push	esi
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN116@process_lu:
	mov	esi, DWORD PTR _pSrcCur$1$[esp+3176]
$LN5@process_lu:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1199 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	eax, DWORD PTR _bx$1$[esp+3176]
	mov	edi, DWORD PTR [ebx+64]
	inc	eax
	movss	xmm3, DWORD PTR __real@43800000
	mov	edx, DWORD PTR _by$1$[esp+3176]
	mov	DWORD PTR _bx$1$[esp+3176], eax
	cmp	eax, edi
	jl	$LL7@process_lu
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
$LN6@process_lu:

; 1237 :           pDstCur + _covered_width * pixelsize_super, _dst_pitch_arr[0],
; 1238 :           pSrcCur + _covered_width * pixelsize_super, _src_pitch_arr[0],
; 1239 :           (nWidth - _covered_width) * pixelsize_super, nBlkSizeY, _isse_flag);
; 1240 :       }
; 1241 :     }	// for bx
; 1242 : 
; 1243 :     pDstCur += rowsize * _dst_pitch_arr[0];

	mov	edx, DWORD PTR [ebx+3644]
	mov	eax, edx
	imul	eax, DWORD PTR _rowsize$1$[esp+3176]
	mov	DWORD PTR _dst_pitch$1$[esp+3176], edx
	add	ecx, eax
	mov	DWORD PTR _pDstCur$1$[esp+3176], ecx

; 1244 :     pSrcCur += rowsize * _src_pitch_arr[0];

	mov	ecx, DWORD PTR [ebx+3656]
	mov	eax, ecx
	imul	eax, DWORD PTR _rowsize$1$[esp+3176]
	mov	DWORD PTR _src_pitch$1$[esp+3176], ecx
	add	esi, eax

; 1245 : 
; 1246 :     if (by == nBlkY - 1 && _covered_height < nHeight) // bottom uncovered region

	mov	eax, DWORD PTR [ebx+68]
	dec	eax
	mov	DWORD PTR _pSrcCur$1$[esp+3176], esi
	cmp	DWORD PTR _by$1$[esp+3176], eax
	jne	SHORT $LN2@process_lu
	mov	eax, DWORD PTR [ebx+3684]
	mov	esi, DWORD PTR [ebx+96]
	cmp	eax, esi
	jge	SHORT $LN113@process_lu

; 1249 :       BitBlt(

	mov	edx, DWORD PTR _pDstCur$1$[esp+3176]
	sub	esi, eax
	mov	eax, DWORD PTR [ebx+92]
	imul	eax, DWORD PTR [ebx+192]
	mov	edi, DWORD PTR _pSrcCur$1$[esp+3176]
	mov	DWORD PTR _dstp$1$[esp+3176], edx
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	edx, DWORD PTR _dst_pitch$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1249 :       BitBlt(

	mov	DWORD PTR _row_size$1$[esp+3176], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	esi, esi
	je	SHORT $LN113@process_lu
	test	eax, eax
	je	SHORT $LN113@process_lu

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	esi, 1
	je	SHORT $LN88@process_lu
	cmp	edx, ecx
	jne	SHORT $LN86@process_lu
	cmp	ecx, eax
	je	SHORT $LN88@process_lu
$LN86@process_lu:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	test	esi, esi
	jle	SHORT $LN113@process_lu
	mov	ebx, DWORD PTR _dstp$1$[esp+3176]
	npad	6
$LL83@process_lu:

; 94   :       memcpy(dstp, srcp, row_size);

	push	eax
	push	edi
	push	ebx
	call	_memcpy

; 95   :       dstp += dst_pitch;

	add	ebx, DWORD PTR _dst_pitch$1$[esp+3188]
	dec	esi

; 96   :       srcp += src_pitch;

	add	edi, DWORD PTR _src_pitch$1$[esp+3188]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _row_size$1$[esp+3176]
	test	esi, esi
	jg	SHORT $LL83@process_lu
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1206 :       for (int k = 0; k < _trad * 2; ++k)

	mov	ebx, DWORD PTR _this$1$[esp+3176]
$LN113@process_lu:
	mov	esi, DWORD PTR _pSrcCur$1$[esp+3176]
$LN2@process_lu:

; 1195 : 
; 1196 :   for (int by = td._y_beg; by < td._y_end; ++by)

	mov	edx, DWORD PTR _by$1$[esp+3176]
	mov	eax, DWORD PTR _td$[ebp]
	inc	edx
	movss	xmm3, DWORD PTR __real@43800000
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
	mov	DWORD PTR _by$1$[esp+3176], edx
	cmp	edx, DWORD PTR [eax+12]
	jl	$LL4@process_lu
$LN3@process_lu:

; 1256 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN88@process_lu:
; File c:\github\mvtools\sources\copycode.cpp

; 91   :     memcpy(dstp, srcp, row_size*height); // Fizick: fixed bug

	imul	eax, esi
	mov	esi, DWORD PTR _pSrcCur$1$[esp+3176]
	push	eax
	push	esi
	push	DWORD PTR _pDstCur$1$[esp+3184]
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@process_lu
?process_luma_normal_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ENDP ; MDegrainN::process_luma_normal_slice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_inc_ftor$2 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_td$ = 8						; size = 4
?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z PROC ; MDegrainN::process_luma_overlap_slice, COMDAT
; _this$ = ecx

; 1261 : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi

; 1262 :   assert(&td != 0);
; 1263 : 
; 1264 :   if (nOverlapY == 0
; 1265 :     || (td._y_beg == 0 && td._y_end == nBlkY))

	mov	esi, DWORD PTR _td$[ebp]
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [edi+112], 0
	je	$LN4@process_lu
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	jne	SHORT $LN2@process_lu
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [edi+68]
	je	$LN4@process_lu
$LN2@process_lu:

; 1268 :   }
; 1269 : 
; 1270 :   else
; 1271 :   {
; 1272 :     assert(td._y_end - td._y_beg >= 2);
; 1273 : 
; 1274 :     process_luma_overlap_slice(td._y_beg, td._y_end - 1);

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	push	eax
	push	ecx
	mov	ecx, edi
	call	?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z ; MDegrainN::process_luma_overlap_slice
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _inc_ftor$2[ebp], OFFSET ??_7?$AioAdd@H@conc@@6B@

; 38   : :	_operand (operand)

	mov	DWORD PTR _inc_ftor$2[ebp+4], 1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1276 :     const conc::AioAdd <int>	inc_ftor(+1);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+3688]
	push	ebx
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	2
$LL28@process_lu:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL28@process_lu
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1282 :     if (td._y_beg > 0 && cnt_top == 2)

	mov	esi, DWORD PTR _td$[ebp]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jle	SHORT $LN5@process_lu
	cmp	ebx, 2
	jne	SHORT $LN5@process_lu

; 1283 :     {
; 1284 :       process_luma_overlap_slice(td._y_beg - 1, td._y_beg);

	push	eax
	dec	eax
	mov	ecx, edi
	push	eax
	call	?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z ; MDegrainN::process_luma_overlap_slice
$LN5@process_lu:

; 1285 :     }
; 1286 : 
; 1287 :     int cnt_bot = 2;
; 1288 :     if (td._y_end < nBlkY)

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, DWORD PTR [edi+68]
	jge	SHORT $LN77@process_lu
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [edi+3688]
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	5
$LL56@process_lu:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL56@process_lu
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1295 :     if (cnt_bot == 2)

	mov	esi, DWORD PTR _td$[ebp]
	cmp	ebx, 2
	jne	SHORT $LN79@process_lu
$LN77@process_lu:

; 1296 :     {
; 1297 :       process_luma_overlap_slice(td._y_end - 1, td._y_end);

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, edi
	push	eax
	dec	eax
	push	eax
	call	?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z ; MDegrainN::process_luma_overlap_slice
$LN79@process_lu:
	pop	ebx
	pop	edi
	pop	esi

; 1298 :     }
; 1299 :   }
; 1300 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@process_lu:

; 1266 :   {
; 1267 :     process_luma_overlap_slice(td._y_beg, td._y_end);

	push	DWORD PTR [esi+12]
	mov	ecx, edi
	push	DWORD PTR [esi+8]
	call	?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z ; MDegrainN::process_luma_overlap_slice

; 1298 :     }
; 1299 :   }
; 1300 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z$0:
	lea	ecx, DWORD PTR _inc_ftor$2[ebp]
	jmp	??1?$AioAdd@H@conc@@UAE@XZ		; conc::AioAdd<int>::~AioAdd<int>
__ehhandler$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?process_luma_overlap_slice@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ENDP ; MDegrainN::process_luma_overlap_slice
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mdegrainn.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mdegrainn.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z
_TEXT	SEGMENT
tv1128 = -5224						; size = 4
_i$1$ = -5220						; size = 4
_pDstInt$1$ = -5216					; size = 4
_tmpPitch$1$ = -5212					; size = 4
_pDstShort$1$ = -5208					; size = 4
_this$1$ = -5204					; size = 4
tv1130 = -5200						; size = 4
_winOver$1$ = -5196					; size = 4
_bx$1$ = -5192						; size = 4
_pSrcCur$1$ = -5188					; size = 4
_k$1$ = -5184						; size = 4
_xx$1$ = -5180						; size = 4
_wby$1$ = -5176						; size = 4
tv1046 = -5172						; size = 4
$T1 = -5168						; size = 4
_rowsize$1$ = -5164					; size = 4
$T2 = -5160						; size = 12
$T3 = -5148						; size = 12
_weight_arr$4 = -5136					; size = 1028
_tmp_block$ = -4104					; size = 2052
_pitch_arr$5 = -2048					; size = 1024
_ref_data_ptr_arr$6 = -1024				; size = 1024
_y_beg$ = 8						; size = 4
_y_end$ = 12						; size = 4
?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z PROC	; MDegrainN::process_luma_overlap_slice, COMDAT
; _this$ = ecx

; 1305 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, 5228				; 0000146cH
	call	__chkstk

; 1309 :   const BYTE *   pSrcCur = _src_ptr_arr[0] + y_beg * rowsize * _src_pitch_arr[0];

	mov	edx, DWORD PTR _y_beg$[ebp]
; File c:\github\mvtools\sources\mdegrainn.h

; 78   :     TmpBlock() : _lsb_ptr(&_d[AREA]) {}

	lea	eax, DWORD PTR _tmp_block$[esp+6252]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1305 : {

	push	ebx
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\mdegrainn.h

; 78   :     TmpBlock() : _lsb_ptr(&_d[AREA]) {}

	mov	DWORD PTR _tmp_block$[esp+7284], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1305 : {

	push	edi
	mov	DWORD PTR _this$1$[esp+5240], esi

; 1306 :   TmpBlock       tmp_block;
; 1307 : 
; 1308 :   const int      rowsize = nBlkSizeY - nOverlapY;

	mov	edi, DWORD PTR [esi+80]
	sub	edi, DWORD PTR [esi+112]

; 1309 :   const BYTE *   pSrcCur = _src_ptr_arr[0] + y_beg * rowsize * _src_pitch_arr[0];

	mov	ebx, DWORD PTR [esi+3656]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+260]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1309 :   const BYTE *   pSrcCur = _src_ptr_arr[0] + y_beg * rowsize * _src_pitch_arr[0];

	imul	ebx, edi
	mov	DWORD PTR _rowsize$1$[esp+5240], edi
	imul	ebx, edx
	add	ebx, DWORD PTR [esi+3632]
	mov	DWORD PTR _pSrcCur$1$[esp+5240], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	cmp	eax, DWORD PTR [esi+264]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1311 :   unsigned short * pDstShort = (_dst_short.empty()) ? 0 : &_dst_short[0] + y_beg * rowsize * _dst_short_pitch;

	jne	SHORT $LN17@process_lu
	mov	DWORD PTR _pDstShort$1$[esp+5240], 0
	jmp	SHORT $LN18@process_lu
$LN17@process_lu:
	mov	ecx, DWORD PTR [esi+272]
	imul	ecx, edi
	imul	ecx, edx
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _pDstShort$1$[esp+5240], eax
$LN18@process_lu:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+276]
	cmp	eax, DWORD PTR [esi+280]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1312 :   int *pDstInt = (_dst_int.empty()) ? 0 : &_dst_int[0] + y_beg * rowsize * _dst_int_pitch;

	jne	SHORT $LN19@process_lu
	mov	DWORD PTR _pDstInt$1$[esp+5240], 0
	jmp	SHORT $LN20@process_lu
$LN19@process_lu:
	mov	ecx, DWORD PTR [esi+288]
	imul	ecx, edi
	imul	ecx, edx
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pDstInt$1$[esp+5240], eax
$LN20@process_lu:

; 1313 :   const int tmpPitch = nBlkSizeX;

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR _tmpPitch$1$[esp+5240], eax

; 1314 :   assert(tmpPitch <= TmpBlock::MAX_SIZE);
; 1315 : 
; 1316 :   for (int by = y_beg; by < y_end; ++by)

	cmp	edx, DWORD PTR _y_end$[ebp]
	jge	$LN3@process_lu

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	movss	xmm3, DWORD PTR __real@43800000
$LL4@process_lu:

; 1317 :   {
; 1318 :     int wby = ((by + nBlkY - 3) / (nBlkY - 2)) * 3;

	mov	ecx, DWORD PTR [esi+68]
	lea	eax, DWORD PTR [edx-3]
	add	eax, ecx

; 1319 :     int xx = 0; // logical offset. Mul by 2 for pixelsize_super==2. Don't mul for indexing int* array

	xor	edi, edi
	add	ecx, -2					; fffffffeH
	cdq
	idiv	ecx

; 1320 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR _xx$1$[esp+5240], edi
	mov	DWORD PTR _i$1$[esp+5240], ecx
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _wby$1$[esp+5240], eax
	xor	eax, eax
	mov	DWORD PTR _bx$1$[esp+5240], eax
	test	ecx, ecx
	jle	$LN166@process_lu
	npad	8
$LL7@process_lu:

; 1324 :       short *winOver = _overwins->GetWindow(wby + wbx);

	add	eax, -3					; fffffffdH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	esi, DWORD PTR [esi+220]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1324 :       short *winOver = _overwins->GetWindow(wby + wbx);

	add	eax, ecx

; 1331 :       for (int k = 0; k < _trad * 2; ++k)

	xor	ebx, ebx
	cdq
	add	ecx, -2					; fffffffeH
	idiv	ecx
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	ecx, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1324 :       short *winOver = _overwins->GetWindow(wby + wbx);

	add	eax, DWORD PTR _wby$1$[esp+5240]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	imul	eax, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1326 :       int i = by * nBlkX + bx;

	mov	edx, DWORD PTR _i$1$[esp+5240]

; 1331 :       for (int k = 0; k < _trad * 2; ++k)

	mov	esi, DWORD PTR _this$1$[esp+5240]
	imul	edx, DWORD PTR _y_beg$[ebp]
	mov	DWORD PTR _k$1$[esp+5240], ebx
	add	edx, DWORD PTR _bx$1$[esp+5240]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	lea	eax, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _winOver$1$[esp+5240], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1331 :       for (int k = 0; k < _trad * 2; ++k)

	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+5240], edx
	mov	DWORD PTR $T1[esp+5240], eax
	test	eax, eax
	jle	$LN9@process_lu

; 1332 :       {
; 1333 :         use_block_y(

	xor	eax, eax
	lea	ecx, DWORD PTR [esi+548]
	mov	DWORD PTR tv1130[esp+5240], eax
	mov	DWORD PTR tv1128[esp+5240], ecx
	npad	15
$LL10@process_lu:

; 1611 :   if (usable_flag)

	cmp	BYTE PTR [esi+ebx+292], 0

; 1332 :       {
; 1333 :         use_block_y(

	mov	ecx, DWORD PTR [ecx]

; 1611 :   if (usable_flag)

	je	$LN107@process_lu
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	edi, DWORD PTR [esi+152]
	mov	eax, DWORD PTR [edi+eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	edi, DWORD PTR [edx+edx*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ecx+56]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv1046[esp+5240], edx
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [edx+edi*4+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1615 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [edx+edi*4+4]
	mov	edi, DWORD PTR [edx+edi*4]
	imul	ebx, DWORD PTR [esi+104]
	imul	edi, DWORD PTR [esi+104]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[esp+5240], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T2[esp+5240], xmm0
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [ecx+32]
	add	edi, DWORD PTR [ecx+28]
	add	ebx, DWORD PTR $T2[esp+5244]
	add	edi, DWORD PTR $T3[esp+5240]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN129@process_lu

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR tv1128[esp+5240]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, ebx
	add	edi, eax
	mov	eax, DWORD PTR [ecx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN132@process_lu
$LN129@process_lu:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 68   :       nX >>= NPELL2;

	mov	edx, edi
	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN131@process_lu

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	add	esi, esi
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN167@process_lu
$LN131@process_lu:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	shl	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN167@process_lu:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	esi, eax

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	edi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR tv1128[esp+5240]
	add	edi, edx
	mov	esi, DWORD PTR _this$1$[esp+5240]
	mov	ecx, DWORD PTR [eax]
	imul	ebx, DWORD PTR [ecx+12]
	add	edi, ebx
$LN132@process_lu:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1616 :     p = plane_ptr->GetPointer(blx, bly);

	mov	ebx, DWORD PTR _k$1$[esp+5240]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ebx*4+5240], edi

; 1617 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR [ecx+12]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	ecx, DWORD PTR _i$1$[esp+5240]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1617 :     np = plane_ptr->GetPitch();

	mov	DWORD PTR _pitch_arr$5[esp+ebx*4+5240], eax
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv1046[esp+5240]
	lea	edx, DWORD PTR [ecx+ecx*4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	ecx, DWORD PTR tv1130[esp+5240]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edx, DWORD PTR [eax+edx*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR [eax+ecx+16]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	ecx, edx
	jg	SHORT $LN145@process_lu
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	edi, DWORD PTR _xx$1$[esp+5240]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	eax, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	edx, DWORD PTR _i$1$[esp+5240]
	mov	DWORD PTR _weight_arr$4[esp+ebx*4+5244], eax
	jmp	$LN8@process_lu
$LN145@process_lu:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [esi+140], 8
	jg	SHORT $LN146@process_lu

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	ecx, ecx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edx, edx

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, ecx
	sub	eax, edx

; 921  :     const int den = thSAD2 + blockSAD2;

	add	ecx, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN149@process_lu
	shl	eax, 8
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	edi, DWORD PTR _xx$1$[esp+5240]
	mov	edx, DWORD PTR _i$1$[esp+5240]
	mov	DWORD PTR _weight_arr$4[esp+ebx*4+5244], eax
	jmp	SHORT $LN8@process_lu
$LN149@process_lu:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	ecx, 8
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	edi, DWORD PTR _xx$1$[esp+5240]
	mov	edx, DWORD PTR _i$1$[esp+5240]
	mov	DWORD PTR _weight_arr$4[esp+ebx*4+5244], eax
	jmp	SHORT $LN8@process_lu
$LN146@process_lu:
	movd	xmm2, ecx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	edi, DWORD PTR _xx$1$[esp+5240]
	movd	xmm1, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1621 :   else

	mov	edx, DWORD PTR _i$1$[esp+5240]
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	mulss	xmm2, xmm2

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, xmm3
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ebx*4+5244], eax

; 1621 :   else

	jmp	SHORT $LN8@process_lu
$LN107@process_lu:

; 1332 :       {
; 1333 :         use_block_y(

	mov	eax, DWORD PTR [esi+192]
	imul	eax, edi

; 1625 :     wref = 0;

	mov	DWORD PTR _weight_arr$4[esp+ebx*4+5244], 0
	add	eax, DWORD PTR _pSrcCur$1$[esp+5240]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ebx*4+5240], eax
	mov	eax, DWORD PTR [esi+3656]
	mov	DWORD PTR _pitch_arr$5[esp+ebx*4+5240], eax
$LN8@process_lu:

; 1331 :       for (int k = 0; k < _trad * 2; ++k)

	mov	ecx, DWORD PTR tv1128[esp+5240]
	inc	ebx
	mov	eax, DWORD PTR tv1130[esp+5240]
	add	ecx, 12					; 0000000cH
	add	eax, 24					; 00000018H
	mov	DWORD PTR _k$1$[esp+5240], ebx
	mov	DWORD PTR tv1128[esp+5240], ecx
	mov	DWORD PTR tv1130[esp+5240], eax
	cmp	ebx, DWORD PTR $T1[esp+5240]
	jl	$LL10@process_lu
$LN9@process_lu:

; 1334 :           ref_data_ptr_arr[k],
; 1335 :           pitch_arr[k],
; 1336 :           weight_arr[k + 1],
; 1337 :           _usable_flag_arr[k],
; 1338 :           _mv_clip_arr[k],
; 1339 :           i,
; 1340 :           _planes_ptr[k][0],
; 1341 :           pSrcCur,
; 1342 :           xx*pixelsize_super,
; 1343 :           _src_pitch_arr[0]
; 1344 :         );
; 1345 :       }
; 1346 : 
; 1347 :       norm_weights(weight_arr, _trad);

	mov	ebx, DWORD PTR [esi+164]
	lea	ecx, DWORD PTR _weight_arr$4[esp+5240]
	mov	edx, ebx
	call	?norm_weights@MDegrainN@@CAXQAHH@Z	; MDegrainN::norm_weights

; 1348 : 
; 1349 :       // luma
; 1350 :       _degrainluma_ptr(

	mov	ecx, DWORD PTR [esi+192]
	lea	eax, DWORD PTR _weight_arr$4[esp+5240]
	push	ebx
	mov	ebx, DWORD PTR _pSrcCur$1$[esp+5244]
	push	eax
	lea	eax, DWORD PTR _pitch_arr$5[esp+5248]
	push	eax
	lea	eax, DWORD PTR _ref_data_ptr_arr$6[esp+5252]
	push	eax
	push	DWORD PTR [esi+3656]
	mov	eax, ecx
	imul	ecx, DWORD PTR _tmpPitch$1$[esp+5260]
	imul	eax, edi
	add	eax, ebx
	push	eax
	movzx	eax, BYTE PTR [esi+186]
	push	ecx
	push	eax
	push	DWORD PTR _tmp_block$[esp+7320]
	lea	eax, DWORD PTR _tmp_block$[esp+5276]
	push	eax
	mov	eax, DWORD PTR [esi+252]
	call	eax
	add	esp, 40					; 00000028H

; 1351 :         &tmp_block._d[0], tmp_block._lsb_ptr, _lsb_flag, tmpPitch*pixelsize_super,
; 1352 :         pSrcCur + xx*pixelsize_super, _src_pitch_arr[0],
; 1353 :         ref_data_ptr_arr, pitch_arr, weight_arr, _trad
; 1354 :       );
; 1355 :       if (_lsb_flag)

	cmp	BYTE PTR [esi+186], 0
	je	SHORT $LN11@process_lu

; 1356 :       {
; 1357 :         _oversluma_lsb_ptr(

	push	DWORD PTR [esi+76]
	lea	eax, DWORD PTR _tmp_block$[esp+5244]
	push	DWORD PTR _winOver$1$[esp+5244]
	push	DWORD PTR _tmpPitch$1$[esp+5248]
	push	DWORD PTR _tmp_block$[esp+7300]
	push	eax
	mov	eax, DWORD PTR _pDstInt$1$[esp+5260]
	push	DWORD PTR [esi+288]
	lea	eax, DWORD PTR [eax+edi*4]
	push	eax
	mov	eax, DWORD PTR [esi+244]
	call	eax
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN15@process_lu
$LN11@process_lu:

; 1358 :           pDstInt + xx, _dst_int_pitch,
; 1359 :           &tmp_block._d[0], tmp_block._lsb_ptr, tmpPitch,
; 1360 :           winOver, nBlkSizeX
; 1361 :         );
; 1362 :       }
; 1363 :       else if (pixelsize_super == 1)

	mov	eax, DWORD PTR [esi+192]
	cmp	eax, 1
	jne	SHORT $LN13@process_lu

; 1364 :       {
; 1365 :         _oversluma_ptr(

	push	DWORD PTR [esi+76]
	lea	eax, DWORD PTR _tmp_block$[esp+5244]
	push	DWORD PTR _winOver$1$[esp+5244]
	push	DWORD PTR _tmpPitch$1$[esp+5248]
	push	eax
	mov	eax, DWORD PTR _pDstShort$1$[esp+5256]
	push	DWORD PTR [esi+272]
	lea	eax, DWORD PTR [eax+edi*2]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	jmp	SHORT $LN168@process_lu
$LN13@process_lu:

; 1366 :           pDstShort + xx, _dst_short_pitch,
; 1367 :           &tmp_block._d[0], tmpPitch,
; 1368 :           winOver, nBlkSizeX
; 1369 :         );
; 1370 :       }
; 1371 :       else if (pixelsize_super == 2) {

	cmp	eax, 2
	jne	SHORT $LN15@process_lu

; 1372 :         _oversluma16_ptr((uint16_t *)(pDstInt + xx), _dst_int_pitch, &tmp_block._d[0], tmpPitch*pixelsize_super, winOver, nBlkSizeX);

	push	DWORD PTR [esi+76]
	mov	eax, DWORD PTR _tmpPitch$1$[esp+5244]
	push	DWORD PTR _winOver$1$[esp+5244]
	add	eax, eax
	push	eax
	lea	eax, DWORD PTR _tmp_block$[esp+5252]
	push	eax
	mov	eax, DWORD PTR _pDstInt$1$[esp+5256]
	push	DWORD PTR [esi+288]
	lea	eax, DWORD PTR [eax+edi*4]
	push	eax
	mov	eax, DWORD PTR [esi+236]
$LN168@process_lu:
	call	eax
	add	esp, 24					; 00000018H
$LN15@process_lu:

; 1373 :       }
; 1374 : 
; 1375 :       xx += nBlkSizeX - nOverlapX;

	mov	eax, DWORD PTR [esi+76]
	sub	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+64]
	add	edi, eax
	mov	eax, DWORD PTR _bx$1$[esp+5240]
	movss	xmm3, DWORD PTR __real@43800000
	inc	eax
	mov	DWORD PTR _xx$1$[esp+5240], edi
	mov	DWORD PTR _bx$1$[esp+5240], eax
	mov	DWORD PTR _i$1$[esp+5240], ecx
	cmp	eax, ecx
	jl	$LL7@process_lu
$LN166@process_lu:

; 1376 :     } // for bx
; 1377 : 
; 1378 :     pSrcCur += rowsize * _src_pitch_arr[0]; // byte pointer

	mov	edx, DWORD PTR _rowsize$1$[esp+5240]
	mov	eax, DWORD PTR [esi+3656]

; 1379 :     pDstShort += rowsize * _dst_short_pitch; // short pointer

	mov	ecx, DWORD PTR _pDstShort$1$[esp+5240]
	imul	eax, edx
	add	ebx, eax
	mov	eax, DWORD PTR [esi+272]
	imul	eax, edx
	mov	DWORD PTR _pSrcCur$1$[esp+5240], ebx
	lea	ecx, DWORD PTR [ecx+eax*2]

; 1380 :     pDstInt += rowsize * _dst_int_pitch; // int pointer

	mov	eax, DWORD PTR [esi+288]
	imul	eax, edx
	mov	edx, DWORD PTR _y_beg$[ebp]
	mov	DWORD PTR _pDstShort$1$[esp+5240], ecx
	inc	edx
	mov	ecx, DWORD PTR _pDstInt$1$[esp+5240]
	mov	DWORD PTR _y_beg$[ebp], edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pDstInt$1$[esp+5240], ecx
	cmp	edx, DWORD PTR _y_end$[ebp]
	jl	$LL4@process_lu
$LN3@process_lu:

; 1381 :   } // for by
; 1382 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?process_luma_overlap_slice@MDegrainN@@AAEXHH@Z ENDP	; MDegrainN::process_luma_overlap_slice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?use_block_y@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
$T1 = -24						; size = 12
$T2 = -12						; size = 12
_p$ = 8							; size = 4
_np$ = 12						; size = 4
_wref$ = 16						; size = 4
tv364 = 20						; size = 4
_usable_flag$ = 20					; size = 1
_c_info$ = 24						; size = 4
tv365 = 28						; size = 4
_i$ = 28						; size = 4
_plane_ptr$ = 32					; size = 4
_src_ptr$ = 36						; size = 4
_xx$ = 40						; size = 4
_src_pitch$ = 44					; size = 4
?use_block_y@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z PROC ; MDegrainN::use_block_y, COMDAT
; _this$ = ecx

; 1610 : {

	sub	esp, 28					; 0000001cH

; 1611 :   if (usable_flag)

	cmp	BYTE PTR _usable_flag$[esp+24], 0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[esp+32], esi
	je	$LN2@use_block_
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR _c_info$[esp+28]
	push	ebx
	push	ebp
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	ebp, DWORD PTR _plane_ptr$[esp+36]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
	push	edi
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _i$[esp+40]
	mov	edx, DWORD PTR [edx+52]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	DWORD PTR tv365[esp+40], edx
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ebp+56]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv364[esp+40], ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1615 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [edx+ecx*4+4]
	mov	edi, DWORD PTR [edx+ecx*4]
	imul	ebx, DWORD PTR [esi+104]
	imul	edi, DWORD PTR [esi+104]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [edx+ecx*4+8]
; File c:\github\mvtools\sources\mvplane.h

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T2[esp+44], xmm0
	movq	xmm0, xmm0
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [ebp+32]
	add	edi, DWORD PTR [ebp+28]
	add	edi, DWORD PTR $T2[esp+44]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T1[esp+44], xmm0
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR $T1[esp+48]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN24@use_block_

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebp+12]
	imul	eax, ebx
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [ebp]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN27@use_block_
$LN24@use_block_:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 68   :       nX >>= NPELL2;

	mov	edx, edi
	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN26@use_block_

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	add	esi, esi
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN46@use_block_
$LN26@use_block_:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	shl	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN46@use_block_:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	or	esi, eax
	mov	eax, DWORD PTR [ebp]
	shl	edx, cl
	mov	edi, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR _this$1$[esp+44]
	add	edi, edx
	add	edi, ebx
$LN27@use_block_:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1616 :     p = plane_ptr->GetPointer(blx, bly);

	mov	eax, DWORD PTR _p$[esp+40]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edx, DWORD PTR tv364[esp+40]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1616 :     p = plane_ptr->GetPointer(blx, bly);

	mov	DWORD PTR [eax], edi

; 1617 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR _np$[esp+40]
	mov	ecx, DWORD PTR [ebp+12]
	pop	edi
	pop	ebp
	mov	DWORD PTR [eax], ecx
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv365[esp+32]
	pop	ebx
	mov	edx, DWORD PTR [eax+edx*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _c_info$[esp+28]
	mov	ecx, DWORD PTR [eax+16]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	ecx, edx
	jg	SHORT $LN40@use_block_
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+28]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	ecx, ecx
	pop	esi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	DWORD PTR [eax], ecx

; 1626 :   }
; 1627 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN40@use_block_:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [esi+140], 8
	jg	SHORT $LN41@use_block_

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	ecx, ecx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edx, edx

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, ecx
	sub	eax, edx

; 921  :     const int den = thSAD2 + blockSAD2;

	add	ecx, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN44@use_block_
	shl	eax, 8
	cdq
	idiv	ecx
	pop	esi
	mov	ecx, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+24]
	mov	DWORD PTR [eax], ecx

; 1626 :   }
; 1627 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN44@use_block_:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	ecx, 8
	cdq
	idiv	ecx
	pop	esi
	mov	ecx, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+24]
	mov	DWORD PTR [eax], ecx

; 1626 :   }
; 1627 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN41@use_block_:
	movd	xmm2, ecx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+28]
	pop	esi
	movd	xmm1, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, DWORD PTR __real@43800000
	divss	xmm0, xmm1
	cvttss2si ecx, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1619 :     wref = DegrainWeight(c_info._thsad, block_sad, bits_per_pixel);

	mov	DWORD PTR [eax], ecx

; 1626 :   }
; 1627 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN2@use_block_:

; 1620 :   }
; 1621 :   else
; 1622 :   {
; 1623 :     p = src_ptr + xx;

	mov	eax, DWORD PTR _p$[esp+28]
	mov	ecx, DWORD PTR _xx$[esp+28]
	add	ecx, DWORD PTR _src_ptr$[esp+28]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 1624 :     np = src_pitch;

	mov	eax, DWORD PTR _np$[esp+24]
	mov	ecx, DWORD PTR _src_pitch$[esp+24]
	mov	DWORD PTR [eax], ecx

; 1625 :     wref = 0;

	mov	eax, DWORD PTR _wref$[esp+24]
	mov	DWORD PTR [eax], 0

; 1626 :   }
; 1627 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
?use_block_y@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z ENDP ; MDegrainN::use_block_y
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?use_block_uv@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
$T1 = -24						; size = 12
$T2 = -12						; size = 12
_p$ = 8							; size = 4
_np$ = 12						; size = 4
_wref$ = 16						; size = 4
tv366 = 20						; size = 4
_usable_flag$ = 20					; size = 1
_c_info$ = 24						; size = 4
tv367 = 28						; size = 4
_i$ = 28						; size = 4
_plane_ptr$ = 32					; size = 4
_src_ptr$ = 36						; size = 4
_xx$ = 40						; size = 4
_src_pitch$ = 44					; size = 4
?use_block_uv@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z PROC ; MDegrainN::use_block_uv, COMDAT
; _this$ = ecx

; 1635 : {

	sub	esp, 28					; 0000001cH

; 1636 :   if (usable_flag)

	cmp	BYTE PTR _usable_flag$[esp+24], 0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[esp+32], esi
	je	$LN2@use_block_
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR _c_info$[esp+28]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+204]
	push	ebx
	push	ebp
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	ebp, DWORD PTR _plane_ptr$[esp+36]
	push	edi
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _i$[esp+40]
	mov	edx, DWORD PTR [edx+52]
	lea	edi, DWORD PTR [eax+eax*4]
	mov	DWORD PTR tv367[esp+40], edx
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ebp+56]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv366[esp+40], edi
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [edx+edi*4+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [edx+edi*4+4]
	imul	ebx, DWORD PTR [esi+104]
	mov	edi, DWORD PTR [edx+edi*4]
	imul	edi, DWORD PTR [esi+104]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T2[esp+44], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T1[esp+44], xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	add	ebx, DWORD PTR $T1[esp+48]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	sar	ebx, cl
	add	edi, DWORD PTR $T2[esp+44]
	mov	ecx, DWORD PTR [esi+200]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [ebp+32]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [ebp+28]

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebp+52]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN24@use_block_

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebp+12]
	imul	eax, ebx
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [ebp]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN27@use_block_
$LN24@use_block_:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 68   :       nX >>= NPELL2;

	mov	edx, edi
	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN26@use_block_

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	add	esi, esi
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN46@use_block_
$LN26@use_block_:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	shl	esi, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ebx, 2
$LN46@use_block_:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	imul	ebx, DWORD PTR [ebp+12]
	or	esi, eax
	mov	eax, DWORD PTR [ebp]
	shl	edx, cl
	mov	edi, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR _this$1$[esp+44]
	add	edi, edx
	add	edi, ebx
$LN27@use_block_:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	eax, DWORD PTR _p$[esp+40]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edx, DWORD PTR tv366[esp+40]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	DWORD PTR [eax], edi

; 1642 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR _np$[esp+40]
	mov	ecx, DWORD PTR [ebp+12]
	pop	edi
	pop	ebp
	mov	DWORD PTR [eax], ecx
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv367[esp+32]
	pop	ebx
	mov	edx, DWORD PTR [eax+edx*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _c_info$[esp+28]
	mov	ecx, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	ecx, edx
	jg	SHORT $LN40@use_block_
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+28]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	ecx, ecx
	pop	esi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR [eax], ecx

; 1651 :   }
; 1652 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN40@use_block_:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [esi+140], 8
	jg	SHORT $LN41@use_block_

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	ecx, ecx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edx, edx

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, ecx
	sub	eax, edx

; 921  :     const int den = thSAD2 + blockSAD2;

	add	ecx, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN44@use_block_
	shl	eax, 8
	cdq
	idiv	ecx
	pop	esi
	mov	ecx, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+24]
	mov	DWORD PTR [eax], ecx

; 1651 :   }
; 1652 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN44@use_block_:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	ecx, 8
	cdq
	idiv	ecx
	pop	esi
	mov	ecx, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+24]
	mov	DWORD PTR [eax], ecx

; 1651 :   }
; 1652 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN41@use_block_:
	movd	xmm2, ecx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR _wref$[esp+28]
	pop	esi
	movd	xmm1, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, DWORD PTR __real@43800000
	divss	xmm0, xmm1
	cvttss2si ecx, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR [eax], ecx

; 1651 :   }
; 1652 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
$LN2@use_block_:

; 1645 :   }
; 1646 :   else
; 1647 :   {
; 1648 :     p = src_ptr + xx; // done: kill  >> _xratiouv_log from here and put it in the caller like in MDegrainX

	mov	eax, DWORD PTR _p$[esp+28]
	mov	ecx, DWORD PTR _xx$[esp+28]
	add	ecx, DWORD PTR _src_ptr$[esp+28]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 1649 :     np = src_pitch;

	mov	eax, DWORD PTR _np$[esp+24]
	mov	ecx, DWORD PTR _src_pitch$[esp+24]
	mov	DWORD PTR [eax], ecx

; 1650 :     wref = 0;

	mov	eax, DWORD PTR _wref$[esp+24]
	mov	DWORD PTR [eax], 0

; 1651 :   }
; 1652 : }

	add	esp, 28					; 0000001cH
	ret	40					; 00000028H
?use_block_uv@MDegrainN@@AAEXAAPBEAAH1_NABVMvClipInfo@1@HPBVMVPlane@@PBEHH@Z ENDP ; MDegrainN::use_block_uv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ?norm_weights@MDegrainN@@CAXQAHH@Z
_TEXT	SEGMENT
_k$1$ = -20						; size = 4
$T1 = -16						; size = 4
tv637 = -12						; size = 4
$T2 = -8						; size = 4
_nbr_frames$1$ = -4					; size = 4
?norm_weights@MDegrainN@@CAXQAHH@Z PROC			; MDegrainN::norm_weights, COMDAT
; _wref_arr$ = ecx
; _trad$ = edx

; 1657 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi

; 1658 :   const int nbr_frames = trad * 2 + 1;

	lea	eax, DWORD PTR [edx+edx]
	mov	esi, ecx
	lea	ebp, DWORD PTR [eax+1]
	mov	DWORD PTR tv637[esp+32], eax

; 1659 : 
; 1660 :   wref_arr[0] = 256;
; 1661 :   int wsum = 1;
; 1662 :   for (int k = 0; k < nbr_frames; ++k)

	xor	eax, eax
	mov	DWORD PTR _nbr_frames$1$[esp+32], ebp
	mov	ebx, 1
	mov	DWORD PTR [esi], 256			; 00000100H
	push	edi
	test	ebp, ebp
	jle	SHORT $LN14@norm_weigh
	cmp	ebp, 8
	jb	SHORT $LN14@norm_weigh
	mov	ecx, ebp
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN33@norm_weigh
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN33@norm_weigh:
	mov	edx, ebp
	xorps	xmm2, xmm2
	sub	edx, ecx
	movaps	xmm1, xmm2
	npad	10
$LL4@norm_weigh:
	movups	xmm0, XMMWORD PTR [esi+eax*4]
	paddd	xmm2, xmm0
	movups	xmm0, XMMWORD PTR [esi+eax*4+16]
	add	eax, 8
	paddd	xmm1, xmm0
	cmp	eax, edx
	jl	SHORT $LL4@norm_weigh
	paddd	xmm1, xmm2
	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	ebx, xmm1
	inc	ebx
$LN14@norm_weigh:
	xor	edx, edx
	xor	edi, edi
	cmp	eax, ebp
	jge	SHORT $LN21@norm_weigh
	mov	ecx, ebp
	sub	ecx, eax
	cmp	ecx, 2
	jl	SHORT $LC22@norm_weigh
	mov	ecx, DWORD PTR tv637[esp+36]
	npad	2
$LL24@norm_weigh:

; 1663 :   {
; 1664 :     wsum += wref_arr[k];

	add	edx, DWORD PTR [esi+eax*4]
	add	edi, DWORD PTR [esi+eax*4+4]
	add	eax, 2
	cmp	eax, ecx
	jl	SHORT $LL24@norm_weigh
$LC22@norm_weigh:

; 1659 : 
; 1660 :   wref_arr[0] = 256;
; 1661 :   int wsum = 1;
; 1662 :   for (int k = 0; k < nbr_frames; ++k)

	cmp	eax, ebp
	jge	SHORT $LN23@norm_weigh

; 1663 :   {
; 1664 :     wsum += wref_arr[k];

	add	ebx, DWORD PTR [esi+eax*4]
$LN23@norm_weigh:
	lea	eax, DWORD PTR [edi+edx]
	add	ebx, eax
$LN21@norm_weigh:

; 1665 :   }
; 1666 : 
; 1667 :   // normalize weights to 256
; 1668 :   int wsrc = 256;
; 1669 :   for (int k = 1; k < nbr_frames; ++k)

	mov	eax, 1
	mov	DWORD PTR $T2[esp+36], 0
	mov	DWORD PTR $T1[esp+36], 0
	mov	ecx, 256				; 00000100H
	mov	DWORD PTR _k$1$[esp+36], eax
	cmp	ebp, eax
	jle	SHORT $LN32@norm_weigh
	mov	edi, DWORD PTR tv637[esp+36]
	cmp	edi, 2
	jl	SHORT $LC26@norm_weigh
	mov	ecx, eax
	xor	ebp, ebp
	npad	7
$LL28@norm_weigh:

; 1670 :   {
; 1671 :     const int norm = wref_arr[k] * 256 / wsum;

	mov	eax, DWORD PTR [esi+ecx*4]
	shl	eax, 8
	cdq
	idiv	ebx

; 1672 :     wref_arr[k] = norm;

	mov	DWORD PTR [esi+ecx*4], eax

; 1673 :     wsrc -= norm;

	sub	ebp, eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
	shl	eax, 8
	cdq
	idiv	ebx
	sub	DWORD PTR $T1[esp+36], eax
	mov	DWORD PTR [esi+ecx*4+4], eax
	add	ecx, 2
	cmp	ecx, edi
	jl	SHORT $LL28@norm_weigh
	mov	DWORD PTR _k$1$[esp+36], ecx
	mov	ecx, 256				; 00000100H
	mov	eax, DWORD PTR _k$1$[esp+36]
	mov	DWORD PTR $T2[esp+36], ebp
	mov	ebp, DWORD PTR _nbr_frames$1$[esp+36]
$LC26@norm_weigh:

; 1665 :   }
; 1666 : 
; 1667 :   // normalize weights to 256
; 1668 :   int wsrc = 256;
; 1669 :   for (int k = 1; k < nbr_frames; ++k)

	cmp	eax, ebp
	jge	SHORT $LN27@norm_weigh

; 1670 :   {
; 1671 :     const int norm = wref_arr[k] * 256 / wsum;

	mov	eax, DWORD PTR [esi+eax*4]
	shl	eax, 8
	cdq
	idiv	ebx

; 1672 :     wref_arr[k] = norm;

	mov	ecx, DWORD PTR _k$1$[esp+36]
	mov	DWORD PTR [esi+ecx*4], eax

; 1673 :     wsrc -= norm;

	mov	ecx, 256				; 00000100H
	sub	ecx, eax
$LN27@norm_weigh:
	mov	eax, DWORD PTR $T2[esp+36]
	add	eax, DWORD PTR $T1[esp+36]
	add	ecx, eax
$LN32@norm_weigh:
	pop	edi

; 1674 :   }
; 1675 :   wref_arr[0] = wsrc;

	mov	DWORD PTR [esi], ecx
	pop	esi
	pop	ebp
	pop	ebx

; 1676 : }

	add	esp, 20					; 00000014H
	ret	0
?norm_weights@MDegrainN@@CAXQAHH@Z ENDP			; MDegrainN::norm_weights
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.h
;	COMDAT ??1?$AioAdd@H@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AioAdd@H@conc@@UAE@XZ PROC				; conc::AioAdd<int>::~AioAdd<int>, COMDAT
; _this$ = ecx

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AioAdd@H@conc@@6B@
	ret	0
??1?$AioAdd@H@conc@@UAE@XZ ENDP				; conc::AioAdd<int>::~AioAdd<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1092 : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Keyval$ = 8						; size = 4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[], COMDAT
; _this$ = ecx

; 177  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 8

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp+4]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >

; 178  : 		return (try_emplace(_STD move(_Keyval)).first->second);

	mov	eax, DWORD PTR $T1[esp+8]
	add	eax, 32					; 00000020H

; 179  : 		}

	add	esp, 8
	ret	4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAEAAP6AXPAE0_NHPBEHQAPBEQAH4H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >, COMDAT
; _this$ = ecx

; 100  : 		{	// construct empty map from defaults

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 101  : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	0
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEAAV?$AtomicInt@H@conc@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEAAV?$AtomicInt@H@conc@@I@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1243 : 		}

	ret	4
??A?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEAAV?$AtomicInt@H@conc@@I@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1181 : 		}

	ret	0
?size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	esi

; 1134 : 		if (_Newsize < size())

	mov	esi, DWORD PTR __Newsize$[esp]
	push	edi
	mov	edi, ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]
	mov	edx, eax
	sub	edx, DWORD PTR [edi]
	sar	edx, 2

; 1134 : 		if (_Newsize < size())

	cmp	edx, esi
	jbe	SHORT $LN192@resize

; 1535 : 		this->_Mylast() = _Ptr;

	sub	esi, edx
	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi

; 1147 : 			}
; 1148 : 		}

	ret	4
$LN192@resize:

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	mov	eax, esi
	sub	eax, edx
	push	eax
	call	?_Reserve@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+4]

; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),

	mov	edx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, ecx
	sub	eax, DWORD PTR [edi]
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),

	sub	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	call	??$_Uninitialized_default_fill_n1@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, DWORD PTR [edi]
	sar	eax, 2

; 1141 : 				this->_Getal());
; 1142 : 			_CATCH_ALL
; 1143 : 			_Tidy();
; 1144 : 			_RERAISE;
; 1145 : 			_CATCH_END
; 1146 : 			this->_Mylast() += _Newsize - size();

	sub	esi, eax
	shl	esi, 2
	add	DWORD PTR [edi+4], esi
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	pop	edi
	pop	esi
	ret	4
?resize@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::~vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::~vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1243 : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ PROC	; std::vector<int,std::allocator<int> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

	ret	0
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::vector<int,std::allocator<int> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	esi

; 1134 : 		if (_Newsize < size())

	mov	esi, DWORD PTR __Newsize$[esp]
	push	edi
	mov	edi, ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]
	mov	edx, eax
	sub	edx, DWORD PTR [edi]
	sar	edx, 2

; 1134 : 		if (_Newsize < size())

	cmp	edx, esi
	jbe	SHORT $LN194@resize

; 1535 : 		this->_Mylast() = _Ptr;

	sub	esi, edx
	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi

; 1147 : 			}
; 1148 : 		}

	ret	4
$LN194@resize:

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	mov	eax, esi
	sub	eax, edx
	push	eax
	call	?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, edx
	sub	ecx, DWORD PTR [edi]
	sar	ecx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	sub	eax, ecx
	shl	eax, 2
	push	eax
	push	0
	push	edx
	call	_memset
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, DWORD PTR [edi]
	sar	eax, 2

; 1139 : 			_TRY_BEGIN
; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1141 : 				this->_Getal());
; 1142 : 			_CATCH_ALL
; 1143 : 			_Tidy();
; 1144 : 			_RERAISE;
; 1145 : 			_CATCH_END
; 1146 : 			this->_Mylast() += _Newsize - size();

	sub	esi, eax
	shl	esi, 2
	add	DWORD PTR [edi+4], esi
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	pop	edi
	pop	esi
	ret	4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z
_TEXT	SEGMENT
__Pos$dead$ = 8						; size = 4
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [ecx]

; 1243 : 		}

	ret	4
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::empty, COMDAT
; _this$ = ecx

; 1189 : 		{	// test if sequence is empty

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1190 : 		return (this->_Myfirst() == this->_Mylast());
; 1191 : 		}

	ret	0
?empty@?$vector@GV?$allocator@G@std@@@std@@QBE_NXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	esi

; 1134 : 		if (_Newsize < size())

	mov	esi, DWORD PTR __Newsize$[esp]
	push	edi
	mov	edi, ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]
	mov	edx, eax
	sub	edx, DWORD PTR [edi]
	sar	edx, 1

; 1134 : 		if (_Newsize < size())

	cmp	edx, esi
	jbe	SHORT $LN194@resize

; 1535 : 		this->_Mylast() = _Ptr;

	sub	esi, edx
	lea	eax, DWORD PTR [eax+esi*2]
	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi

; 1147 : 			}
; 1148 : 		}

	ret	4
$LN194@resize:

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	mov	eax, esi
	sub	eax, edx
	push	eax
	call	?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, edx
	sub	ecx, DWORD PTR [edi]
	sar	ecx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	sub	eax, ecx
	add	eax, eax
	push	eax
	push	0
	push	edx
	call	_memset
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, DWORD PTR [edi]
	sar	eax, 1

; 1139 : 			_TRY_BEGIN
; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1141 : 				this->_Getal());
; 1142 : 			_CATCH_ALL
; 1143 : 			_Tidy();
; 1144 : 			_RERAISE;
; 1145 : 			_CATCH_END
; 1146 : 			this->_Mylast() += _Newsize - size();

	sub	esi, eax
	add	esi, esi
	add	DWORD PTR [edi+4], esi
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	pop	edi
	pop	esi
	ret	4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??C?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ
_TEXT	SEGMENT
??C?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ PROC ; std::auto_ptr<OverlapWindows>::operator->, COMDAT
; _this$ = ecx

; 772  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 773  : 		if (_Myptr == 0)
; 774  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 775  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 776  : 
; 777  : 		return (get());

	mov	eax, DWORD PTR [ecx]

; 778  : 		}

	ret	0
??C?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ ENDP ; std::auto_ptr<OverlapWindows>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\overlap.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??1?$auto_ptr@VOverlapWindows@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VOverlapWindows@@@std@@QAE@XZ PROC	; std::auto_ptr<OverlapWindows>::~auto_ptr<OverlapWindows>, COMDAT
; _this$ = ecx

; 756  : 		{	// destroy the object

	push	esi

; 757  : 		delete _Myptr;

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN6@auto_ptr
; File c:\github\mvtools\sources\overlap.cpp

; 136  : 	delete [] Overlap9Windows;

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 137  : 	delete [] fWin1UVx;

	push	DWORD PTR [esi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 138  : 	delete [] fWin1UVxfirst;

	push	DWORD PTR [esi+28]
	call	??_V@YAXPAX@Z				; operator delete[]

; 139  : 	delete [] fWin1UVxlast;

	push	DWORD PTR [esi+32]
	call	??_V@YAXPAX@Z				; operator delete[]

; 140  : 	delete [] fWin1UVy;

	push	DWORD PTR [esi+36]
	call	??_V@YAXPAX@Z				; operator delete[]

; 141  : 	delete [] fWin1UVyfirst;

	push	DWORD PTR [esi+40]
	call	??_V@YAXPAX@Z				; operator delete[]

; 142  : 	delete [] fWin1UVylast;

	push	DWORD PTR [esi+44]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	48					; 00000030H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 36					; 00000024H
$LN6@auto_ptr:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 758  : 		}

	ret	0
??1?$auto_ptr@VOverlapWindows@@@std@@QAE@XZ ENDP	; std::auto_ptr<OverlapWindows>::~auto_ptr<OverlapWindows>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??4?$auto_ptr@VOverlapWindows@@@std@@QAEAAV01@U?$auto_ptr_ref@VOverlapWindows@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$auto_ptr@VOverlapWindows@@@std@@QAEAAV01@U?$auto_ptr_ref@VOverlapWindows@@@1@@Z PROC ; std::auto_ptr<OverlapWindows>::operator=, COMDAT
; _this$ = ecx

; 748  : 		{	// assign compatible _Right._Ref (assume pointer)

	push	esi
	mov	esi, ecx
	push	edi

; 749  : 		_Ty *_Ptr = _Right._Ref;

	mov	edi, DWORD PTR __Right$[esp+4]

; 750  : 		_Right._Ref = 0;	// release old

	mov	DWORD PTR __Right$[esp+4], 0

; 794  : 		if (_Ptr != _Myptr)

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	je	SHORT $LN9@operator

; 795  : 			delete _Myptr;

	test	ecx, ecx
	je	SHORT $LN9@operator
	push	ecx
	call	??_GOverlapWindows@@QAEPAXI@Z
$LN9@operator:

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [esi], edi

; 751  : 		reset(_Ptr);	// set new
; 752  : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 753  : 		}

	ret	4
??4?$auto_ptr@VOverlapWindows@@@std@@QAEAAV01@U?$auto_ptr_ref@VOverlapWindows@@@1@@Z ENDP ; std::auto_ptr<OverlapWindows>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z PROC ; std::auto_ptr<OverlapWindows>::auto_ptr<OverlapWindows>, COMDAT
; _this$ = ecx

; 697  : 		: _Myptr(_Ptr)

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax

; 699  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z ENDP ; std::auto_ptr<OverlapWindows>::auto_ptr<OverlapWindows>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??C?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ
_TEXT	SEGMENT
??C?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ PROC ; std::auto_ptr<YUY2Planes>::operator->, COMDAT
; _this$ = ecx

; 772  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 773  : 		if (_Myptr == 0)
; 774  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 775  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 776  : 
; 777  : 		return (get());

	mov	eax, DWORD PTR [ecx]

; 778  : 		}

	ret	0
??C?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ ENDP ; std::auto_ptr<YUY2Planes>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??1?$auto_ptr@VYUY2Planes@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VYUY2Planes@@@std@@QAE@XZ PROC		; std::auto_ptr<YUY2Planes>::~auto_ptr<YUY2Planes>, COMDAT
; _this$ = ecx

; 756  : 		{	// destroy the object

	push	edi

; 757  : 		delete _Myptr;

	mov	edi, DWORD PTR [ecx]
	test	edi, edi
	je	SHORT $LN6@auto_ptr
	push	esi
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [edi]
	mov	esi, DWORD PTR __imp___aligned_free
	call	esi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [edi+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [edi+8]
	call	esi
	push	28					; 0000001cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
	pop	esi
$LN6@auto_ptr:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 758  : 		}

	ret	0
??1?$auto_ptr@VYUY2Planes@@@std@@QAE@XZ ENDP		; std::auto_ptr<YUY2Planes>::~auto_ptr<YUY2Planes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??4?$auto_ptr@VYUY2Planes@@@std@@QAEAAV01@U?$auto_ptr_ref@VYUY2Planes@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$auto_ptr@VYUY2Planes@@@std@@QAEAAV01@U?$auto_ptr_ref@VYUY2Planes@@@1@@Z PROC ; std::auto_ptr<YUY2Planes>::operator=, COMDAT
; _this$ = ecx

; 748  : 		{	// assign compatible _Right._Ref (assume pointer)

	push	ebx
	push	ebp

; 749  : 		_Ty *_Ptr = _Right._Ref;

	mov	ebp, DWORD PTR __Right$[esp+4]
	push	edi
	mov	edi, ecx

; 750  : 		_Right._Ref = 0;	// release old

	mov	DWORD PTR __Right$[esp+8], 0

; 794  : 		if (_Ptr != _Myptr)

	mov	ebx, DWORD PTR [edi]
	cmp	ebp, ebx
	je	SHORT $LN16@operator

; 795  : 			delete _Myptr;

	test	ebx, ebx
	je	SHORT $LN16@operator
	push	esi
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	mov	esi, DWORD PTR __imp___aligned_free
	call	esi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	esi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
	pop	esi
$LN16@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi], ebp

; 751  : 		reset(_Ptr);	// set new
; 752  : 		return (*this);

	mov	eax, edi
	pop	edi
	pop	ebp
	pop	ebx

; 753  : 		}

	ret	4
??4?$auto_ptr@VYUY2Planes@@@std@@QAEAAV01@U?$auto_ptr_ref@VYUY2Planes@@@1@@Z ENDP ; std::auto_ptr<YUY2Planes>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z PROC ; std::auto_ptr<YUY2Planes>::auto_ptr<YUY2Planes>, COMDAT
; _this$ = ecx

; 697  : 		: _Myptr(_Ptr)

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax

; 699  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z ENDP ; std::auto_ptr<YUY2Planes>::auto_ptr<YUY2Planes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEAAVMvClipInfo@MDegrainN@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEAAVMvClipInfo@MDegrainN@@I@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*8]

; 1243 : 		}

	ret	4
??A?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEAAVMvClipInfo@MDegrainN@@I@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	ebx

; 1134 : 		if (_Newsize < size())

	mov	ebx, DWORD PTR __Newsize$[esp]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	push	ebp

; 1133 : 		{	// determine new length, padding as needed

	mov	ebp, ecx
	push	esi
	push	edi

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR [ebp+4]
	mov	edx, edi
	sub	edx, DWORD PTR [ebp]
	imul	edx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1134 : 		if (_Newsize < size())

	cmp	ecx, ebx
	jbe	SHORT $LN223@resize

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	sub	ebx, ecx
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	ebx, DWORD PTR [edi+eax*8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	esi, ebx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	ebx, edi
	je	SHORT $LN85@resize
$LL86@resize:
	mov	ecx, esi
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL86@resize
$LN85@resize:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [ebp+4], ebx
	pop	ebp
	pop	ebx

; 1147 : 			}
; 1148 : 		}

	ret	4
$LN223@resize:

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	mov	eax, ebx
	sub	eax, ecx
	mov	ecx, ebp
	push	eax
	call	?_Reserve@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reserve
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebp+4]
	sub	ecx, DWORD PTR [ebp]
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	ecx, DWORD PTR [ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1139 : 			_TRY_BEGIN
; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),

	mov	edx, ebx
	sub	edx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	call	??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1141 : 				this->_Getal());
; 1142 : 			_CATCH_ALL
; 1143 : 			_Tidy();
; 1144 : 			_RERAISE;
; 1145 : 			_CATCH_END
; 1146 : 			this->_Mylast() += _Newsize - size();

	sub	ebx, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 3
	add	DWORD PTR [ebp+4], eax
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
?resize@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::~vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; _this$ = ecx

; 976  : 		_Tidy();

	jmp	?_Tidy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXXZ ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Tidy
??1?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::~vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.h
;	COMDAT ??_G?$AioAdd@H@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AioAdd@H@conc@@UAEPAXI@Z PROC			; conc::AioAdd<int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AioAdd@H@conc@@6B@
	je	SHORT $LN7@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AioAdd@H@conc@@UAEPAXI@Z ENDP			; conc::AioAdd<int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\overlap.cpp
;	COMDAT ??_GOverlapWindows@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GOverlapWindows@@QAEPAXI@Z PROC			; OverlapWindows::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 136  : 	delete [] Overlap9Windows;

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 137  : 	delete [] fWin1UVx;

	push	DWORD PTR [esi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 138  : 	delete [] fWin1UVxfirst;

	push	DWORD PTR [esi+28]
	call	??_V@YAXPAX@Z				; operator delete[]

; 139  : 	delete [] fWin1UVxlast;

	push	DWORD PTR [esi+32]
	call	??_V@YAXPAX@Z				; operator delete[]

; 140  : 	delete [] fWin1UVy;

	push	DWORD PTR [esi+36]
	call	??_V@YAXPAX@Z				; operator delete[]

; 141  : 	delete [] fWin1UVyfirst;

	push	DWORD PTR [esi+40]
	call	??_V@YAXPAX@Z				; operator delete[]

; 142  : 	delete [] fWin1UVylast;

	push	DWORD PTR [esi+44]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	48					; 00000030H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 36					; 00000024H
	mov	eax, esi
	pop	esi
	ret	4
??_GOverlapWindows@@QAEPAXI@Z ENDP			; OverlapWindows::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ??_GYUY2Planes@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GYUY2Planes@@QAEPAXI@Z PROC				; YUY2Planes::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi

; 37   :   _aligned_free(pSrc);

	mov	esi, DWORD PTR __imp___aligned_free
	push	edi
	mov	edi, ecx
	push	DWORD PTR [edi]
	call	esi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [edi+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [edi+8]
	call	esi
	push	28					; 0000001cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??_GYUY2Planes@@QAEPAXI@Z ENDP				; YUY2Planes::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator->, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 407  : 		return (pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 727  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase

; 2169 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1005 : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXXZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXXZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	esi
	mov	esi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR __Count$[esp]
	push	edi

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, ecx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	edx, DWORD PTR [esi]
	push	ebx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ebx, 1073741823				; 3fffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, ebx
	sub	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN136@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, DWORD PTR [esi]

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edi, 2
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, edi
	shr	eax, 1
	sub	ebx, eax
	add	eax, edi
	cmp	ebx, edi
	cmovae	ecx, eax
	cmp	ecx, edx
	cmovae	edx, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, esi
	push	edx
	call	?_Reallocate@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reallocate
	pop	ebx
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	ret	4
$LN135@Reserve:
?_Reserve@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	eax, DWORD PTR __Count$[esp-4]
	neg	eax
	shl	eax, 2

; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;

	add	DWORD PTR [ecx+4], eax

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	esi
	mov	esi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR __Count$[esp]
	push	edi

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, ecx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	edx, DWORD PTR [esi]
	push	ebx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ebx, 1073741823				; 3fffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, ebx
	sub	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN136@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, DWORD PTR [esi]

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edi, 2
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, edi
	shr	eax, 1
	sub	ebx, eax
	add	eax, edi
	cmp	ebx, edi
	cmovae	ecx, eax
	cmp	ecx, edx
	cmovae	edx, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, esi
	push	edx
	call	?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int> >::_Reallocate
	pop	ebx
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	ret	4
$LN135@Reserve:
?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	eax, DWORD PTR __Count$[esp-4]
	neg	eax
	shl	eax, 2

; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;

	add	DWORD PTR [ecx+4], eax

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1181 : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	esi
	mov	esi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR __Count$[esp]
	push	edi

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 1

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, ecx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	edx, DWORD PTR [esi]
	push	ebx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ebx, 2147483647				; 7fffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, ebx
	sub	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN136@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, DWORD PTR [esi]

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edi, 1
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, edi
	shr	eax, 1
	sub	ebx, eax
	add	eax, edi
	cmp	ebx, edi
	cmovae	ecx, eax
	cmp	ecx, edx
	cmovae	edx, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, esi
	push	edx
	call	?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reallocate
	pop	ebx
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	ret	4
$LN135@Reserve:
?_Reserve@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	eax, DWORD PTR __Count$[esp-4]
	neg	eax
	add	eax, eax

; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;

	add	DWORD PTR [ecx+4], eax

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 1

; 1181 : 		}

	ret	0
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?reset@?$auto_ptr@VOverlapWindows@@@std@@QAEXPAVOverlapWindows@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?reset@?$auto_ptr@VOverlapWindows@@@std@@QAEXPAVOverlapWindows@@@Z PROC ; std::auto_ptr<OverlapWindows>::reset, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy designated object and store new pointer

	push	esi
	mov	esi, ecx
	push	edi

; 794  : 		if (_Ptr != _Myptr)

	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	je	SHORT $LN7@reset

; 795  : 			delete _Myptr;

	test	ecx, ecx
	je	SHORT $LN7@reset
	push	ecx
	call	??_GOverlapWindows@@QAEPAXI@Z
$LN7@reset:

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 797  : 		}

	ret	4
?reset@?$auto_ptr@VOverlapWindows@@@std@@QAEXPAVOverlapWindows@@@Z ENDP ; std::auto_ptr<OverlapWindows>::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?get@?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ PROC ; std::auto_ptr<OverlapWindows>::get, COMDAT
; _this$ = ecx

; 782  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 783  : 		}

	ret	0
?get@?$auto_ptr@VOverlapWindows@@@std@@QBEPAVOverlapWindows@@XZ ENDP ; std::auto_ptr<OverlapWindows>::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?reset@?$auto_ptr@VYUY2Planes@@@std@@QAEXPAVYUY2Planes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?reset@?$auto_ptr@VYUY2Planes@@@std@@QAEXPAVYUY2Planes@@@Z PROC ; std::auto_ptr<YUY2Planes>::reset, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy designated object and store new pointer

	push	ebx
	mov	ebx, ecx
	push	ebp

; 794  : 		if (_Ptr != _Myptr)

	mov	ebp, DWORD PTR __Ptr$[esp+4]
	push	edi
	mov	edi, DWORD PTR [ebx]
	cmp	ebp, edi
	je	SHORT $LN14@reset

; 795  : 			delete _Myptr;

	test	edi, edi
	je	SHORT $LN14@reset
	push	esi
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [edi]
	mov	esi, DWORD PTR __imp___aligned_free
	call	esi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [edi+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [edi+8]
	call	esi
	push	28					; 0000001cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
	pop	esi
$LN14@reset:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [ebx], ebp
	pop	ebp
	pop	ebx

; 797  : 		}

	ret	4
?reset@?$auto_ptr@VYUY2Planes@@@std@@QAEXPAVYUY2Planes@@@Z ENDP ; std::auto_ptr<YUY2Planes>::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?get@?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ PROC ; std::auto_ptr<YUY2Planes>::get, COMDAT
; _this$ = ecx

; 782  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 783  : 		}

	ret	0
?get@?$auto_ptr@VYUY2Planes@@@std@@QBEPAVYUY2Planes@@XZ ENDP ; std::auto_ptr<YUY2Planes>::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXXZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	push	edi
	mov	edi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN43@Tidy
$LL44@Tidy:
	mov	ecx, esi
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL44@Tidy
$LN43@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [ebx]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 2
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [ebx], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [ebx+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [ebx+8], 0
	pop	edi
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	pop	esi
	pop	ebx
	ret	0
?_Tidy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXXZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebx
	mov	ebx, ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, 715827883				; 2aaaaaabH
	push	ebp
	push	esi
	push	edi
	mov	ebp, DWORD PTR [ebx+8]
	mov	edx, ebp
	mov	esi, DWORD PTR [ebx+4]
	sub	edx, esi

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	edi, DWORD PTR __Count$[esp+12]

; 1048 : 		return (this->_Myend() - this->_Mylast());

	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, edi
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	esi, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	esi

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, 178956970				; 0aaaaaaaH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN135@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	ebp, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebp

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edi, ecx
	xor	ecx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 178956970				; 0aaaaaaaH
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	add	eax, esi
	cmp	edx, esi
	cmovae	ecx, eax
	cmp	ecx, edi
	cmovae	edi, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, ebx
	push	edi
	call	?_Reallocate@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN134@Reserve:
?_Reserve@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	eax, DWORD PTR __Count$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi
	lea	eax, DWORD PTR [eax+eax*2]
	mov	edi, DWORD PTR [ebp+4]
	mov	ebx, edi
	shl	eax, 3
	sub	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	esi, ebx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	ebx, edi
	je	SHORT $LN61@Pop_back_n
	npad	3
$LL34@Pop_back_n:
	mov	ecx, esi
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL34@Pop_back_n
$LN61@Pop_back_n:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [ebp+4], ebx
	pop	ebp
	pop	ebx

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1181 : 		}

	ret	0
?size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> *>::pointer_to, COMDAT
; __Val$ = ecx

; 280  : 		return (_STD addressof(_Val));

	mov	eax, ecx

; 281  : 		}

	ret	0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Freeheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 846  : 		}

	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

	push	esi
	mov	esi, ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 705  : 		_Construct();
; 706  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

	push	ecx

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp]

; 1445 : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	esi, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	edx, esi

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 1446 : 			{	// erase all
; 1447 : 			clear();

	call	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::clear

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN176@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 279  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN133@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN178@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN188@erase
	npad	7
$LL144@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL144@erase

; 65   : 		else

	jmp	SHORT $LN188@erase
$LN178@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN188@erase
$LL128@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN188@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[esp+8], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL128@erase
$LN188@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[esp+8], edx
$LN133@erase:

; 1453 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T1[esp+16]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp+8]
	cmp	eax, DWORD PTR __Last$[esp+8]

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

	mov	eax, ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::end, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1122 : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::begin, COMDAT
; _this$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1112 : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z PROC ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAPAV?$AtomicInt@H@conc@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEXXZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEXXZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ecx
	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	ebp, DWORD PTR __Count$[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z ; std::allocator<conc::AtomicInt<int> >::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, ecx
	sar	ebx, 2

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	eax, DWORD PTR [edi+ebp*4]
	mov	DWORD PTR [esi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [esi], edi

; 1623 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
?_Reallocate@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXI@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEII@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 1073741823				; 3fffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	esi, DWORD PTR [ecx]
	sar	esi, 2

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IBEII@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXPAV?$AtomicInt@H@conc@@0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXPAV?$AtomicInt@H@conc@@0@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEXPAV?$AtomicInt@H@conc@@0@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	ebp, DWORD PTR __Count$[esp+4]
	push	esi
	push	edi
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR [edi+4]
	sub	edx, esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	esi
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, ecx
	sar	esi, 2

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	eax, DWORD PTR [ebx+ebp*4]
	mov	DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [edi], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1623 : 		}

	ret	4
?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z PROC ; std::vector<int,std::allocator<int> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 1073741823				; 3fffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	esi, DWORD PTR [ecx]
	sar	esi, 2

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned short> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	2
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEXPAGI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned short> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	ebp, DWORD PTR __Count$[esp+4]
	push	esi
	push	edi
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@G@std@@QAEPAGI@Z	; std::allocator<unsigned short>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR [edi+4]
	sub	edx, esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	esi
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, ecx
	sar	esi, 1

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	eax, DWORD PTR [ebx+ebp*2]
	mov	DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ebx+esi*2]
	mov	DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [edi], ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1623 : 		}

	ret	4
?_Reallocate@?$vector@GV?$allocator@G@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 2147483647				; 7fffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	esi, DWORD PTR [ecx]
	sar	esi, 1

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@GV?$allocator@G@std@@@std@@IBEII@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 2147483647				; 7fffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 1

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	24					; 00000018H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MDegrainN@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEXXZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEXXZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$1$ = -8						; size = 4
$T1 = -8						; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Count$[esp+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z ; std::allocator<MDegrainN::MvClipInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	ebp, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+28]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	push	ebp
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR [ebx+4]
	mov	eax, 715827883				; 2aaaaaabH
	mov	esi, DWORD PTR [ebx]
	mov	ecx, edi
	sub	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx
	sar	edx, 2
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	DWORD PTR __Size$1$[esp+24], ecx

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	esi, esi
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN130@Reallocate
$LL131@Reallocate:
	mov	ecx, esi
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL131@Reallocate
$LN130@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [ebx]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 2
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	mov	ecx, DWORD PTR __Size$1$[esp+28]
	add	esp, 4
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[esp+20]

; 1621 : 		this->_Mylast() = _Ptr + _Size;
; 1622 : 		this->_Myfirst() = _Ptr;
; 1623 : 		}

	pop	edi
	pop	esi
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax*8]
	add	eax, ebp
	mov	DWORD PTR [ebx+8], eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax*8]
	add	eax, ebp
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx], ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
?_Reallocate@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEII@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	push	esi
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 178956970				; 0aaaaaaaH
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IBEII@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXPAVMvClipInfo@MDegrainN@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXPAVMvClipInfo@MDegrainN@@0@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 1100 : 	for (; _First != _Last; ++_First)

	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN13@Destroy
	npad	2
$LL14@Destroy:
	mov	ecx, esi
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL14@Destroy
$LN13@Destroy:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1582 : 		}

	ret	8
?_Destroy@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEXPAVMvClipInfo@MDegrainN@@0@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 1186 : 		}

	ret	0
?max_size@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx+4]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 385  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 279  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], edx

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator++

; 280  : 		++*this;
; 281  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 282  : 		}

	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));
; 250  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 911  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

	push	esi
	mov	esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 722  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 684  : 		}

	ret	0
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 679  : 		}

	ret	0
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Left, COMDAT
; __Pnode$ = ecx

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, ecx

; 674  : 		}

	ret	0
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2078 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+4]

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	esi, ebx

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN23@clear
	npad	6
$LL24@clear:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL24@clear
$LN23@clear:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1477 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1473 : 		_Root() = this->_Myhead();
; 1474 : 		_Lmost() = this->_Myhead();
; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1477 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1195 = -12						; size = 4
tv1197 = -8						; size = 4
tv1196 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 123  : 		return (_Ptr);

	mov	ebp, DWORD PTR __Where$[esp+16]

; 1259 : 		{	// erase element at _Where

	mov	ebx, ecx
	push	esi
	push	edi

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[esp+24]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator++

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [ebp]

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1270 : 		++_Where;	// save successor iterator for return
; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN691@erase
$LN5@erase:
	mov	eax, DWORD PTR [ebp+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, ecx

; 1281 : 		else

	jmp	SHORT $LN691@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[esp+24]

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

	cmp	edx, ebp
	jne	$LN9@erase
$LN691@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1297 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [ebx]

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [edx], ebp
	jne	SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	ecx, esi
	jmp	SHORT $LN166@erase
$LN42@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, edi

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
	npad	3
$LL165@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx], ecx
$LN16@erase:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR [ebx]

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [edx+8], ebp
	jne	$LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	ecx, esi
	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN44@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, edi

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
	npad	1
$LL217@erase:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [ecx+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ebp+8]
	jne	SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1320 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebp+4]

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 50   : 	_Left = _STD move(_Right);

	mov	al, BYTE PTR [ebp+12]
	mov	cl, BYTE PTR [edx+12]
	mov	BYTE PTR [edx+12], al

; 51   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ebp+12], cl
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ebp+12], 1
	jne	$LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	4
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	edx, esi
	mov	DWORD PTR tv1195[esp+28], edx
	mov	DWORD PTR tv1197[esp+28], esi
	mov	DWORD PTR tv1196[esp+28], esi
	jne	$LN3@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, esi
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN694@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN3@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR tv1195[esp+28]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN694@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1197[esp+28]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1196[esp+28]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebp
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[esp+24]

; 1436 : 		if (0 < this->_Mysize())

	test	eax, eax
	je	SHORT $LN693@erase

; 1437 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN693@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,
; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

	add	esp, 12					; 0000000cH
	ret	8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rrotate
	jmp	SHORT $LN3@erase
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z PROC ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z ; std::allocator<conc::AtomicInt<int> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABQAV?$AtomicInt@H@conc@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1044 : 		}

	ret	0
?capacity@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QBEIXZ ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z PROC ; std::allocator<conc::AtomicInt<int> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@I@Z ENDP ; std::allocator<conc::AtomicInt<int> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1044 : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned short> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 2147483647				; 7fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned short> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@G@std@@QAEPAGI@Z	; std::allocator<unsigned short>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAEPAGI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned short> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 1

; 1044 : 		}

	ret	0
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXPAGI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@G@std@@QAEXPAGI@Z PROC		; std::allocator<unsigned short>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	2
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@G@std@@QAEXPAGI@Z ENDP		; std::allocator<unsigned short>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 178956970				; 0aaaaaaaH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z ; std::allocator<MDegrainN::MvClipInfo>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MDegrainN@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1044 : 		}

	ret	0
?capacity@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QBEIXZ ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z PROC ; std::allocator<MDegrainN::MvClipInfo>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	24					; 00000018H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@I@Z ENDP ; std::allocator<MDegrainN::MvClipInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

	mov	eax, esi
	pop	esi

; 275  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 604  : 		}

	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 599  : 		}

	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 594  : 		}

	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Left, COMDAT
; __Pnode$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, ecx

; 589  : 		}

	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 941  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN61@Buyheadnod
	mov	DWORD PTR [eax], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 832  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
$LL4@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 699  : 		}

	ret	0
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
	npad	7
$LL4@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 694  : 		}

	ret	0
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 689  : 		}

	ret	0
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 669  : 		}

	ret	0
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 664  : 		}

	ret	0
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN3@Rrotate:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Root, COMDAT
; _this$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2107 : 		return (this->_Parent(this->_Myhead()));
; 2108 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2102 : 		return (this->_Right(this->_Myhead()));
; 2103 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN3@Lrotate:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	mov	ebx, ecx
	mov	esi, edi

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN3@Erase
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL4@Erase
$LN3@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 2038 : 			this->_Getal().destroy(
; 2039 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2040 : 
; 2041 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2042 : 			}
; 2043 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAIABV?$allocator@V?$AtomicInt@H@conc@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAIABV?$allocator@V?$AtomicInt@H@conc@@@2@@Z PROC ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAIABV?$allocator@V?$AtomicInt@H@conc@@@2@@Z ENDP ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z PROC ; std::allocator<conc::AtomicInt<int> >::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEPAV?$AtomicInt@H@conc@@I@Z ENDP ; std::allocator<conc::AtomicInt<int> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::allocator_traits<std::allocator<int> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned short> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 2147483647				; 7fffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@G@std@@QAEPAGI@Z PROC		; std::allocator<unsigned short>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@G@std@@QAEPAGI@Z ENDP		; std::allocator<unsigned short>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MDegrainN@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MDegrainN@@@2@@Z PROC ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MDegrainN@@@2@@Z ENDP ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z PROC ; std::allocator<MDegrainN::MvClipInfo>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 3

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEPAVMvClipInfo@MDegrainN@@I@Z ENDP ; std::allocator<MDegrainN::MvClipInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

	mov	eax, ecx

; 618  : 		}

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
	npad	7
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 584  : 		}

	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 579  : 		}

	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$AtomicInt@H@conc@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$AtomicInt@H@conc@@@std@@QBEIXZ PROC ; std::allocator<conc::AtomicInt<int> >::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$AtomicInt@H@conc@@@std@@QBEIXZ ENDP ; std::allocator<conc::AtomicInt<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@G@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@G@std@@QBEIXZ PROC		; std::allocator<unsigned short>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 2147483647				; 7fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@G@std@@QBEIXZ ENDP		; std::allocator<unsigned short>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VMvClipInfo@MDegrainN@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VMvClipInfo@MDegrainN@@@std@@QBEIXZ PROC ; std::allocator<MDegrainN::MvClipInfo>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 178956970				; 0aaaaaaaH

; 750  : 		}

	ret	0
?max_size@?$allocator@VMvClipInfo@MDegrainN@@@std@@QBEIXZ ENDP ; std::allocator<MDegrainN::MvClipInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	ret	4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0?$SharedPtr@VMVClip@@@@QAE@PAVMVClip@@@Z
_TEXT	SEGMENT
??0?$SharedPtr@VMVClip@@@@QAE@PAVMVClip@@@Z PROC	; SharedPtr<MVClip>::SharedPtr<MVClip>, COMDAT
; _this$ = ecx

; 47   : {

	push	esi

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	push	4
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [esi+4], eax

; 48   : 	// Nothing
; 49   : }

	mov	eax, esi
	pop	esi
	ret	0
??0?$SharedPtr@VMVClip@@@@QAE@PAVMVClip@@@Z ENDP	; SharedPtr<MVClip>::SharedPtr<MVClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??1?$SharedPtr@VMVClip@@@@QAE@XZ
_TEXT	SEGMENT
??1?$SharedPtr@VMVClip@@@@QAE@XZ PROC			; SharedPtr<MVClip>::~SharedPtr<MVClip>, COMDAT
; _this$ = ecx

; 67   : {

	push	esi
	mov	esi, ecx

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN5@SharedPtr

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@SharedPtr

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@SharedPtr
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN7@SharedPtr:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN5@SharedPtr:
	pop	esi

; 68   : 	assert (is_valid ());
; 69   : 
; 70   : 	destroy_complete ();
; 71   : }

	ret	0
??1?$SharedPtr@VMVClip@@@@QAE@XZ ENDP			; SharedPtr<MVClip>::~SharedPtr<MVClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??4?$SharedPtr@VMVClip@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??4?$SharedPtr@VMVClip@@@@QAEAAV0@ABV0@@Z PROC		; SharedPtr<MVClip>::operator=, COMDAT
; _this$ = ecx

; 77   : {

	push	esi
	push	edi

; 78   : 	assert (is_valid ());
; 79   : 	assert (is_consistent (other));
; 80   : 
; 81   : 	if (other._obj_ptr != _obj_ptr)

	mov	edi, DWORD PTR _other$[esp+4]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [edi], eax
	je	SHORT $LN14@operator

; 284  : 	if (_obj_ptr != 0)

	test	eax, eax
	je	SHORT $LN6@operator

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN6@operator

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN8@operator
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN8@operator:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN6@operator:

; 82   : 	{
; 83   : 		destroy_complete ();
; 84   : 		_obj_ptr = other._obj_ptr;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 85   : 		_count_ptr = other._count_ptr;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN14@operator

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN14@operator:
	pop	edi

; 86   : 		add_ref ();
; 87   : 	}
; 88   : 	assert (is_consistent (other));
; 89   : 
; 90   : 	return (*this);

	mov	eax, esi
	pop	esi

; 91   : }

	ret	4
??4?$SharedPtr@VMVClip@@@@QAEAAV0@ABV0@@Z ENDP		; SharedPtr<MVClip>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??C?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ
_TEXT	SEGMENT
??C?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ PROC		; SharedPtr<MVClip>::operator->, COMDAT
; _this$ = ecx

; 169  : 	assert (_obj_ptr != 0);
; 170  : 	
; 171  : 	return (_obj_ptr);

	mov	eax, DWORD PTR [ecx]

; 172  : }

	ret	0
??C?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ ENDP		; SharedPtr<MVClip>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??D?$SharedPtr@VMVClip@@@@QBEAAVMVClip@@XZ
_TEXT	SEGMENT
??D?$SharedPtr@VMVClip@@@@QBEAAVMVClip@@XZ PROC		; SharedPtr<MVClip>::operator*, COMDAT
; _this$ = ecx

; 179  : 	assert (_obj_ptr != 0);
; 180  : 	
; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [ecx]

; 182  : }

	ret	0
??D?$SharedPtr@VMVClip@@@@QBEAAVMVClip@@XZ ENDP		; SharedPtr<MVClip>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@PAVMVGroupOfFrames@@@Z
_TEXT	SEGMENT
??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@PAVMVGroupOfFrames@@@Z PROC ; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>, COMDAT
; _this$ = ecx

; 47   : {

	push	esi

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	push	4
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [eax], 1
	mov	DWORD PTR [esi+4], eax

; 48   : 	// Nothing
; 49   : }

	mov	eax, esi
	pop	esi
	ret	0
??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@PAVMVGroupOfFrames@@@Z ENDP ; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??1?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ
_TEXT	SEGMENT
??1?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ PROC		; SharedPtr<MVGroupOfFrames>::~SharedPtr<MVGroupOfFrames>, COMDAT
; _this$ = ecx

; 67   : {

	push	esi
	mov	esi, ecx

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN5@SharedPtr

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@SharedPtr
	push	edi

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN10@SharedPtr
	mov	ecx, edi
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@SharedPtr:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
	pop	edi
$LN5@SharedPtr:
	pop	esi

; 68   : 	assert (is_valid ());
; 69   : 
; 70   : 	destroy_complete ();
; 71   : }

	ret	0
??1?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ ENDP		; SharedPtr<MVGroupOfFrames>::~SharedPtr<MVGroupOfFrames>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??4?$SharedPtr@VMVGroupOfFrames@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??4?$SharedPtr@VMVGroupOfFrames@@@@QAEAAV0@ABV0@@Z PROC	; SharedPtr<MVGroupOfFrames>::operator=, COMDAT
; _this$ = ecx

; 77   : {

	push	esi
	push	edi

; 78   : 	assert (is_valid ());
; 79   : 	assert (is_consistent (other));
; 80   : 
; 81   : 	if (other._obj_ptr != _obj_ptr)

	mov	edi, DWORD PTR _other$[esp+4]
	mov	esi, ecx
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN8@operator

; 82   : 	{
; 83   : 		destroy_complete ();

	call	?destroy_complete@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ ; SharedPtr<MVGroupOfFrames>::destroy_complete

; 84   : 		_obj_ptr = other._obj_ptr;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 85   : 		_count_ptr = other._count_ptr;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN8@operator

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN8@operator:
	pop	edi

; 86   : 		add_ref ();
; 87   : 	}
; 88   : 	assert (is_consistent (other));
; 89   : 
; 90   : 	return (*this);

	mov	eax, esi
	pop	esi

; 91   : }

	ret	4
??4?$SharedPtr@VMVGroupOfFrames@@@@QAEAAV0@ABV0@@Z ENDP	; SharedPtr<MVGroupOfFrames>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??D?$SharedPtr@VMVGroupOfFrames@@@@QBEAAVMVGroupOfFrames@@XZ
_TEXT	SEGMENT
??D?$SharedPtr@VMVGroupOfFrames@@@@QBEAAVMVGroupOfFrames@@XZ PROC ; SharedPtr<MVGroupOfFrames>::operator*, COMDAT
; _this$ = ecx

; 179  : 	assert (_obj_ptr != 0);
; 180  : 	
; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [ecx]

; 182  : }

	ret	0
??D?$SharedPtr@VMVGroupOfFrames@@@@QBEAAVMVGroupOfFrames@@XZ ENDP ; SharedPtr<MVGroupOfFrames>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??0?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAE@_N@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_mt_flag$ = 8						; size = 1
??0?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAE@_N@Z PROC	; MTSlicer<MDegrainN,MDegrainN,64>::MTSlicer<MDegrainN,MDegrainN,64>, COMDAT
; _this$ = ecx

; 70   : {

	sub	esp, 8
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR [esi+8], eax

; 66   : ,	_proc_ptr (0)

	mov	DWORD PTR $T1[esp+12], 0
	mov	eax, DWORD PTR $T1[esp+12]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR $T1[esp+16], 0
	mov	eax, DWORD PTR $T1[esp+16]
	mov	DWORD PTR [esi+20], eax

; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR [esi+28]
	push	1024					; 00000400H
	push	0
	push	eax
	mov	DWORD PTR [esi+24], 0
	call	_memset

; 69   : ,	_mt_flag (mt_flag)

	mov	al, BYTE PTR _mt_flag$[esp+20]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [esi+1052], al

; 71   : 	// Nothing
; 72   : }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	4
??0?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAE@_N@Z ENDP	; MTSlicer<MDegrainN,MDegrainN,64>::MTSlicer<MDegrainN,MDegrainN,64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ PROC		; MTSlicer<MDegrainN,MDegrainN,64>::~MTSlicer<MDegrainN,MDegrainN,64>, COMDAT
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx], OFFSET ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@
	je	SHORT $LN2@MTSlicer

; 88   : 	{
; 89   : 		wait ();

	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait
$LN2@MTSlicer:

; 90   : 	}
; 91   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ ENDP		; MTSlicer<MDegrainN,MDegrainN,64>::~MTSlicer<MDegrainN,MDegrainN,64>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_nbr_threads$4 = -20					; size = 4
_task_data$5 = -16					; size = 16
_height$ = 8						; size = 4
_glob_data$ = 12					; size = 4
_proc_ptr$ = 16						; size = 8
_y_beg$1$ = 24						; size = 4
_min_slice_h$ = 24					; size = 4
?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z PROC ; MTSlicer<MDegrainN,MDegrainN,64>::start, COMDAT
; _this$ = ecx

; 145  : 	assert (height > 0);
; 146  : 	assert (&glob_data != 0);
; 147  : 	assert (proc_ptr != 0);
; 148  : 	assert (min_slice_h > 0);
; 149  : 
; 150  : 	_proc_ptr = proc_ptr;

	mov	edx, DWORD PTR _proc_ptr$[esp-4]
	sub	esp, 32					; 00000020H
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _proc_ptr$[esp+40]

; 151  : 
; 152  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1052], 0
	mov	DWORD PTR [esi+16], edx
	mov	DWORD PTR [esi+20], edi
	je	$LN8@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	mov	eax, DWORD PTR [esi+8]
	push	ebx
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 132  : 	return (_avstp_get_nbr_threads_ptr ());

	mov	eax, DWORD PTR [eax+16]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	ecx, DWORD PTR _height$[esp+40]
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, 64					; 00000040H
; File c:\github\mvtools\sources\mtslicer.hpp

; 155  : 		nbr_threads = std::min (nbr_threads, int (MAXT));

	mov	DWORD PTR $T1[esp+44], 64		; 00000040H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR $T3[esp+44], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovg	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	eax, ecx
	cdq
	idiv	DWORD PTR _min_slice_h$[esp+40]

; 158  : 
; 159  : 		int				y_beg = 0;

	mov	DWORD PTR _y_beg$1$[esp+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, edi
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	DWORD PTR $T2[esp+44], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	edi, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmp	edi, eax
	cmovl	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR _nbr_threads$4[esp+44], edi

; 160  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN3@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	push	ebp
	mov	ebx, ecx
	mov	ebp, edi
	lea	ecx, DWORD PTR [esi+36]
	npad	3
$LL4@start:

; 161  : 		{
; 162  : 			const int		y_end = (t_cnt + 1) * height / nbr_threads;

	mov	eax, ebx

; 163  : 			TaskData &		task_data = _task_data_arr [t_cnt];
; 164  : 			task_data._glob_data_ptr = &glob_data;
; 165  : 			task_data._slicer_ptr    = this;

	mov	DWORD PTR [ecx-4], esi
	cdq
	lea	ecx, DWORD PTR [ecx+16]
	idiv	edi
	mov	edx, DWORD PTR _glob_data$[esp+44]
	add	ebx, DWORD PTR _height$[esp+44]
	mov	DWORD PTR [ecx-24], edx

; 166  : 			task_data._y_beg         = y_beg;

	mov	edx, DWORD PTR _y_beg$1$[esp+44]
	mov	DWORD PTR [ecx-16], edx

; 167  : 			task_data._y_end         = y_end;

	mov	DWORD PTR [ecx-12], eax

; 168  : 			y_beg = y_end;

	mov	DWORD PTR _y_beg$1$[esp+44], eax
	sub	ebp, 1
	jne	SHORT $LL4@start
	pop	ebp
$LN3@start:

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 118  : 	return (_avstp_create_dispatcher_ptr ());

	mov	eax, DWORD PTR [eax+8]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	DWORD PTR [esi+24], eax

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN40@start

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	lea	ebx, DWORD PTR [esi+28]
	npad	4
$LL7@start:

; 175  : 		{
; 176  : 			_avstp.enqueue_task (

	mov	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 139  : 	return (_avstp_enqueue_task_ptr (td_ptr, task_ptr, user_data_ptr));

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	push	OFFSET ?redirect_task@?$MTSlicer@VMDegrainN@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<MDegrainN,MDegrainN,64>::redirect_task
	push	eax
	mov	eax, DWORD PTR [ecx+20]
	call	eax
	add	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\mtslicer.hpp

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	add	ebx, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL7@start
$LN40@start:
	pop	ebx
	pop	edi
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 32					; 00000020H
	ret	20					; 00000014H
$LN8@start:

; 177  : 				_dispatcher_ptr,
; 178  : 				&redirect_task,
; 179  : 				&_task_data_arr [t_cnt]
; 180  : 			);
; 181  : 		}
; 182  : 	}
; 183  : 
; 184  : 	// Multi-threading disabled
; 185  : 	else
; 186  : 	{
; 187  : 		TaskData			task_data;
; 188  : 		task_data._glob_data_ptr = &glob_data;
; 189  : 		task_data._slicer_ptr    = this;
; 190  : 		task_data._y_beg         = 0;
; 191  : 		task_data._y_end         = height;

	mov	eax, DWORD PTR _height$[esp+36]
	mov	ecx, DWORD PTR _glob_data$[esp+36]
	mov	DWORD PTR _task_data$5[esp+52], eax

; 192  : 
; 193  : 		T *				this_ptr =
; 194  : 			MTSlicer_Access <T, GD>::access (&glob_data);
; 195  : 		((*this_ptr).*(proc_ptr)) (task_data);

	lea	eax, DWORD PTR _task_data$5[esp+40]
	mov	DWORD PTR _task_data$5[esp+40], ecx
	add	ecx, edi
	push	eax
	mov	DWORD PTR _task_data$5[esp+48], esi
	mov	DWORD PTR _task_data$5[esp+52], 0
	call	edx
	pop	edi
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 32					; 00000020H
	ret	20					; 00000014H
?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ENDP ; MTSlicer<MDegrainN,MDegrainN,64>::start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ PROC	; MTSlicer<MDegrainN,MDegrainN,64>::wait, COMDAT
; _this$ = ecx

; 214  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 215  : 	assert (_proc_ptr != 0);
; 216  : 
; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1052], 0
	je	SHORT $LN2@wait

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	edx, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+8]
	push	edx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+8]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN2@wait:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR $T1[esp+12], 0
	mov	eax, DWORD PTR $T1[esp+12]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR $T1[esp+16], 0
	mov	eax, DWORD PTR $T1[esp+16]
	mov	DWORD PTR [esi+20], eax

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+24], 0
	pop	esi

; 227  : }

	add	esp, 8
	ret	0
?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ENDP	; MTSlicer<MDegrainN,MDegrainN,64>::wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$?BVYUY2Planes@@@?$auto_ptr@VYUY2Planes@@@std@@QAE?AU?$auto_ptr_ref@VYUY2Planes@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVYUY2Planes@@@?$auto_ptr@VYUY2Planes@@@std@@QAE?AU?$auto_ptr_ref@VYUY2Planes@@@1@XZ PROC ; std::auto_ptr<YUY2Planes>::operator<YUY2Planes> std::auto_ptr_ref<YUY2Planes>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]

; 722  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 723  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);
; 724  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 682  : 		: _Ref(_Right)

	mov	DWORD PTR [eax], edx

; 725  : 		return (_Ans);
; 726  : 		}

	ret	4
??$?BVYUY2Planes@@@?$auto_ptr@VYUY2Planes@@@std@@QAE?AU?$auto_ptr_ref@VYUY2Planes@@@1@XZ ENDP ; std::auto_ptr<YUY2Planes>::operator<YUY2Planes> std::auto_ptr_ref<YUY2Planes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$?BVOverlapWindows@@@?$auto_ptr@VOverlapWindows@@@std@@QAE?AU?$auto_ptr_ref@VOverlapWindows@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVOverlapWindows@@@?$auto_ptr@VOverlapWindows@@@std@@QAE?AU?$auto_ptr_ref@VOverlapWindows@@@1@XZ PROC ; std::auto_ptr<OverlapWindows>::operator<OverlapWindows> std::auto_ptr_ref<OverlapWindows>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]

; 722  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 723  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);
; 724  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 682  : 		: _Ref(_Right)

	mov	DWORD PTR [eax], edx

; 725  : 		return (_Ans);
; 726  : 		}

	ret	4
??$?BVOverlapWindows@@@?$auto_ptr@VOverlapWindows@@@std@@QAE?AU?$auto_ptr_ref@VOverlapWindows@@@1@XZ ENDP ; std::auto_ptr<OverlapWindows>::operator<OverlapWindows> std::auto_ptr_ref<OverlapWindows>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ??$GetAbsolutePointerPel@$00@MVPlane@@QBEPBEHH@Z
_TEXT	SEGMENT
_nX$ = 8						; size = 4
_nY$ = 12						; size = 4
??$GetAbsolutePointerPel@$00@MVPlane@@QBEPBEHH@Z PROC	; MVPlane::GetAbsolutePointerPel<1>, COMDAT
; _this$ = ecx

; 64   : 		enum {	MASK = (1 << NPELL2) - 1	};
; 65   : 
; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR _nX$[esp-4]
	mov	eax, edx
	push	ebx
	push	esi
	push	edi

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR _nY$[esp+8]
	mov	ebx, ecx
	mov	esi, edi
	sar	edx, 1
	and	esi, 1
	sar	edi, 1
	and	eax, 1
	add	esi, esi
	imul	edi, DWORD PTR [ebx+12]
	or	esi, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	shl	edx, cl
	mov	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 72   :    }

	ret	8
??$GetAbsolutePointerPel@$00@MVPlane@@QBEPBEHH@Z ENDP	; MVPlane::GetAbsolutePointerPel<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.h
;	COMDAT ??$GetAbsolutePointerPel@$01@MVPlane@@QBEPBEHH@Z
_TEXT	SEGMENT
_nX$ = 8						; size = 4
_nY$ = 12						; size = 4
??$GetAbsolutePointerPel@$01@MVPlane@@QBEPBEHH@Z PROC	; MVPlane::GetAbsolutePointerPel<2>, COMDAT
; _this$ = ecx

; 64   : 		enum {	MASK = (1 << NPELL2) - 1	};
; 65   : 
; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR _nX$[esp-4]
	mov	eax, edx
	push	ebx
	push	esi
	push	edi

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	edi, DWORD PTR _nY$[esp+8]
	mov	ebx, ecx
	mov	esi, edi
	sar	edx, 2
	and	esi, 3
	sar	edi, 2
	and	eax, 3
	shl	esi, 2
	imul	edi, DWORD PTR [ebx+12]
	or	esi, eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+52]
	shl	edx, cl
	mov	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 72   :    }

	ret	8
??$GetAbsolutePointerPel@$01@MVPlane@@QBEPBEHH@Z ENDP	; MVPlane::GetAbsolutePointerPel<2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1302 = -16						; size = 4
tv1298 = -16						; size = 4
tv1314 = -12						; size = 4
tv1307 = -8						; size = 4
tv1309 = -4						; size = 4
tv1308 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,32,32>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1302[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1309[esp+36], ebx
	mov	DWORD PTR tv1307[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1314[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1314[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1307[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1309[esp+36]
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1302[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1298[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1308[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1308[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1298[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,32,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1303 = -16						; size = 4
tv1299 = -16						; size = 4
tv1315 = -12						; size = 4
tv1308 = -8						; size = 4
tv1310 = -4						; size = 4
tv1309 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,32,16>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1303[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1310[esp+36], ebx
	mov	DWORD PTR tv1308[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1315[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1315[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1308[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1310[esp+36]
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1303[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1299[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1309[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1309[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1299[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,32,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1303 = -16						; size = 4
tv1299 = -16						; size = 4
tv1315 = -12						; size = 4
tv1308 = -8						; size = 4
tv1310 = -4						; size = 4
tv1309 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,32,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1303[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1310[esp+36], ebx
	mov	DWORD PTR tv1308[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1315[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1315[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1308[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1310[esp+36]
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1303[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1299[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1309[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1309[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1299[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,32,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1303 = -16						; size = 4
tv1299 = -16						; size = 4
tv1315 = -12						; size = 4
tv1308 = -8						; size = 4
tv1310 = -4						; size = 4
tv1309 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,16,32>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1303[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1310[esp+36], ebx
	mov	DWORD PTR tv1308[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1315[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1315[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1308[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1310[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1303[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1299[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1309[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1309[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1299[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,16,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1302 = -16						; size = 4
tv1298 = -16						; size = 4
tv1314 = -12						; size = 4
tv1307 = -8						; size = 4
tv1309 = -4						; size = 4
tv1308 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,16,16>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1302[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1309[esp+36], ebx
	mov	DWORD PTR tv1307[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1314[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1314[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1307[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1309[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1302[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1298[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1308[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1308[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1298[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,16,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1303 = -16						; size = 4
tv1299 = -16						; size = 4
tv1315 = -12						; size = 4
tv1308 = -8						; size = 4
tv1310 = -4						; size = 4
tv1309 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,16,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1303[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1310[esp+36], ebx
	mov	DWORD PTR tv1308[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1315[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1315[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1308[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1310[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1303[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1299[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1309[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1309[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1299[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,16,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1303 = -16						; size = 4
tv1299 = -16						; size = 4
tv1315 = -12						; size = 4
tv1308 = -8						; size = 4
tv1310 = -4						; size = 4
tv1309 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,16,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1303[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1310[esp+36], ebx
	mov	DWORD PTR tv1308[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1315[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1315[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1308[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1310[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1303[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1299[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1309[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1309[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1299[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,16,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1303 = -16						; size = 4
tv1299 = -16						; size = 4
tv1315 = -12						; size = 4
tv1308 = -8						; size = 4
tv1310 = -4						; size = 4
tv1309 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,16,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1303[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1310[esp+36], ebx
	mov	DWORD PTR tv1308[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1315[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1315[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1308[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1310[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1303[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1299[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1309[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1309[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1299[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,16,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1326 = -16						; size = 4
tv1322 = -16						; size = 4
tv1339 = -12						; size = 4
tv1332 = -8						; size = 4
tv1334 = -4						; size = 4
tv1333 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned char,8,16>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1326[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1334[esp+36], ebx
	mov	DWORD PTR tv1332[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1339[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1339[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1332[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1334[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1326[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1322[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1333[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1333[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1322[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned char,8,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1325 = -16						; size = 4
tv1321 = -16						; size = 4
tv1338 = -12						; size = 4
tv1331 = -8						; size = 4
tv1333 = -4						; size = 4
tv1332 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,8,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1325[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1333[esp+36], ebx
	mov	DWORD PTR tv1331[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1338[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1338[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1331[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1333[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1325[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1321[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1332[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1332[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1321[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,8,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1326 = -16						; size = 4
tv1322 = -16						; size = 4
tv1339 = -12						; size = 4
tv1332 = -8						; size = 4
tv1334 = -4						; size = 4
tv1333 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,8,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1326[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1334[esp+36], ebx
	mov	DWORD PTR tv1332[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1339[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1339[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1332[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1334[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1326[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1322[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1333[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1333[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1322[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,8,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1326 = -16						; size = 4
tv1322 = -16						; size = 4
tv1339 = -12						; size = 4
tv1332 = -8						; size = 4
tv1334 = -4						; size = 4
tv1333 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,8,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1326[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1334[esp+36], ebx
	mov	DWORD PTR tv1332[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1339[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1339[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1332[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1334[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1326[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1322[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1333[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1333[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1322[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,8,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
tv1320 = -8						; size = 4
tv1315 = -4						; size = 4
tv1314 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
tv1317 = 16						; size = 4
tv1316 = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,8,1>, COMDAT

; 31   : {

	sub	esp, 8

; 32   :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[esp+4], 0
	push	ebx
	push	ebp

; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)
; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebp, DWORD PTR _trad$[esp+12]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	eax, DWORD PTR _pSrc$[esp+20]
	xor	esi, esi
	mov	ecx, DWORD PTR _pDst$[esp+20]
	sub	eax, ecx
	sub	DWORD PTR _pDstLsb$[esp+20], ecx
	mov	DWORD PTR tv1315[esp+24], eax
	npad	6
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	add	ecx, esi

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1320[esp+24], ecx
	movzx	ebx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _Wall$[esp+20]
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	lea	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _pRef$[esp+20]
	sub	eax, DWORD PTR _Wall$[esp+20]
	mov	DWORD PTR tv1317[esp+20], eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [eax+edx]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+20]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	mov	eax, DWORD PTR tv1317[esp+20]
	add	ebx, ecx
	cmp	edi, ebp
	jl	SHORT $LL10@DegrainN_C
	mov	ecx, DWORD PTR tv1320[esp+24]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR _pDstLsb$[esp+20]
	mov	BYTE PTR [eax+ecx], bl
	mov	eax, DWORD PTR tv1315[esp+24]
	mov	ecx, DWORD PTR _pDst$[esp+20]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;
; 51   :       pDstLsb += nDstPitch;
; 52   :       pSrc += nSrcPitch;
; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	test	ebp, ebp
	jle	$LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+20]
	mov	edi, DWORD PTR _Pitch$[esp+20]
	mov	esi, edi
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	7
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [edi+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 8
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)
; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _pSrc$[esp+20]
	xor	ebx, ebx
	mov	eax, DWORD PTR _pDst$[esp+20]
	sub	ecx, eax
	mov	edx, DWORD PTR _Wall$[esp+20]
	mov	DWORD PTR tv1314[esp+24], ecx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	add	eax, ebx

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [ecx+eax]
	imul	eax, DWORD PTR [edx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ecx, DWORD PTR _pRef$[esp+20]
	lea	esi, DWORD PTR [edx+4]
	sub	ecx, edx
	mov	DWORD PTR tv1316[esp+20], ecx
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ecx]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+20]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	mov	ecx, DWORD PTR tv1316[esp+20]
	add	eax, edx
	cmp	edi, ebp
	jl	SHORT $LL22@DegrainN_C
	mov	edx, DWORD PTR _Wall$[esp+20]
	mov	ecx, DWORD PTR tv1314[esp+24]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	mov	esi, DWORD PTR _pDst$[esp+20]
	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	mov	eax, esi
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;
; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+20]
	mov	edi, DWORD PTR _Pitch$[esp+20]
	mov	esi, edi
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	7
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [edi+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
$LN14@DegrainN_C:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 8
	ret	0
??$DegrainN_C@E$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,8,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1326 = -16						; size = 4
tv1322 = -16						; size = 4
tv1339 = -12						; size = 4
tv1332 = -8						; size = 4
tv1334 = -4						; size = 4
tv1333 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,4,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1326[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1334[esp+36], ebx
	mov	DWORD PTR tv1332[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1339[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1339[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1332[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1334[esp+36]
	cmp	esi, 4
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1326[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1322[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1333[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1333[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 4
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1322[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,4,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1325 = -16						; size = 4
tv1321 = -16						; size = 4
tv1338 = -12						; size = 4
tv1331 = -8						; size = 4
tv1333 = -4						; size = 4
tv1332 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,4,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1325[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1333[esp+36], ebx
	mov	DWORD PTR tv1331[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1338[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1338[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1331[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1333[esp+36]
	cmp	esi, 4
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1325[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1321[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1332[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1332[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 4
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1321[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,4,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1326 = -16						; size = 4
tv1322 = -16						; size = 4
tv1339 = -12						; size = 4
tv1332 = -8						; size = 4
tv1334 = -4						; size = 4
tv1333 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,4,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1326[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1334[esp+36], ebx
	mov	DWORD PTR tv1332[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1339[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1339[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1332[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1334[esp+36]
	cmp	esi, 4
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1326[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1322[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1333[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1333[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 4
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1322[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,4,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1326 = -16						; size = 4
tv1322 = -16						; size = 4
tv1339 = -12						; size = 4
tv1332 = -8						; size = 4
tv1334 = -4						; size = 4
tv1333 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,2,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1326[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1334[esp+36], ebx
	mov	DWORD PTR tv1332[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1339[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1339[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1332[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1334[esp+36]
	cmp	esi, 2
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1326[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1322[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1333[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1333[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 2
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1322[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,2,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@E$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1325 = -16						; size = 4
tv1321 = -16						; size = 4
tv1338 = -12						; size = 4
tv1331 = -8						; size = 4
tv1333 = -4						; size = 4
tv1332 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@E$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned char,2,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1325[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1333[esp+36], ebx
	mov	DWORD PTR tv1331[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1338[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1338[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1331[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1333[esp+36]
	cmp	esi, 2
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1325[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1321[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1332[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1332[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, 2
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	3
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1321[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@E$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned char,2,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1357 = -16						; size = 4
tv1351 = -16						; size = 4
tv1368 = -12						; size = 4
tv1362 = -8						; size = 4
tv1364 = -4						; size = 4
tv1363 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,32,32>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1357[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1364[esp+36], ebx
	mov	DWORD PTR tv1362[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1368[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1368[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1362[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1364[esp+36]
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1357[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1351[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1363[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1363[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 64					; 00000040H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1351[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,32,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1358 = -16						; size = 4
tv1352 = -16						; size = 4
tv1369 = -12						; size = 4
tv1363 = -8						; size = 4
tv1365 = -4						; size = 4
tv1364 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,32,16>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1358[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1365[esp+36], ebx
	mov	DWORD PTR tv1363[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1369[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1369[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1363[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1365[esp+36]
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1358[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1352[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1364[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1364[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 64					; 00000040H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1352[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,32,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1358 = -16						; size = 4
tv1352 = -16						; size = 4
tv1369 = -12						; size = 4
tv1363 = -8						; size = 4
tv1365 = -4						; size = 4
tv1364 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,32,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1358[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1365[esp+36], ebx
	mov	DWORD PTR tv1363[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1369[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1369[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1363[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1365[esp+36]
	cmp	esi, 32					; 00000020H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1358[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1352[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1364[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1364[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 64					; 00000040H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1352[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,32,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1358 = -16						; size = 4
tv1352 = -16						; size = 4
tv1369 = -12						; size = 4
tv1363 = -8						; size = 4
tv1365 = -4						; size = 4
tv1364 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,16,32>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1358[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1365[esp+36], ebx
	mov	DWORD PTR tv1363[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1369[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1369[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1363[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1365[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1358[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1352[esp+36], 32		; 00000020H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1364[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1364[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1352[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,16,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1357 = -16						; size = 4
tv1351 = -16						; size = 4
tv1368 = -12						; size = 4
tv1362 = -8						; size = 4
tv1364 = -4						; size = 4
tv1363 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,16,16>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1357[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1364[esp+36], ebx
	mov	DWORD PTR tv1362[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1368[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1368[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1362[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1364[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1357[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1351[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1363[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1363[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1351[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,16,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1358 = -16						; size = 4
tv1352 = -16						; size = 4
tv1369 = -12						; size = 4
tv1363 = -8						; size = 4
tv1365 = -4						; size = 4
tv1364 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,16,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1358[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1365[esp+36], ebx
	mov	DWORD PTR tv1363[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1369[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1369[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1363[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1365[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1358[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1352[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1364[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1364[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1352[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,16,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1358 = -16						; size = 4
tv1352 = -16						; size = 4
tv1369 = -12						; size = 4
tv1363 = -8						; size = 4
tv1365 = -4						; size = 4
tv1364 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,16,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1358[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1365[esp+36], ebx
	mov	DWORD PTR tv1363[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1369[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1369[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1363[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1365[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1358[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1352[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1364[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1364[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1352[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,16,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1358 = -16						; size = 4
tv1352 = -16						; size = 4
tv1369 = -12						; size = 4
tv1363 = -8						; size = 4
tv1365 = -4						; size = 4
tv1364 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,16,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1358[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1365[esp+36], ebx
	mov	DWORD PTR tv1363[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1369[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1369[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1363[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1365[esp+36]
	cmp	esi, 16					; 00000010H
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1358[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1352[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1364[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1364[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 32					; 00000020H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1352[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,16,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1383 = -16						; size = 4
tv1376 = -16						; size = 4
tv1394 = -12						; size = 4
tv1388 = -8						; size = 4
tv1390 = -4						; size = 4
tv1389 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_C<unsigned short,8,16>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1383[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1390[esp+36], ebx
	mov	DWORD PTR tv1388[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1394[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1394[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1388[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1390[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1383[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1376[esp+36], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1389[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1389[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1376[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_C<unsigned short,8,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1382 = -16						; size = 4
tv1375 = -16						; size = 4
tv1393 = -12						; size = 4
tv1387 = -8						; size = 4
tv1389 = -4						; size = 4
tv1388 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,8,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1382[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1389[esp+36], ebx
	mov	DWORD PTR tv1387[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1393[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1393[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1387[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1389[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1382[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1375[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1388[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1388[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1375[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,8,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1383 = -16						; size = 4
tv1376 = -16						; size = 4
tv1394 = -12						; size = 4
tv1388 = -8						; size = 4
tv1390 = -4						; size = 4
tv1389 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,8,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1383[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1390[esp+36], ebx
	mov	DWORD PTR tv1388[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1394[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1394[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1388[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1390[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1383[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1376[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1389[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1389[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1376[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,8,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1383 = -16						; size = 4
tv1376 = -16						; size = 4
tv1394 = -12						; size = 4
tv1388 = -8						; size = 4
tv1390 = -4						; size = 4
tv1389 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,8,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1383[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1390[esp+36], ebx
	mov	DWORD PTR tv1388[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1394[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1394[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1388[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1390[esp+36]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1383[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1376[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1389[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1389[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1376[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,8,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
tv1374 = -8						; size = 4
tv1370 = -4						; size = 4
tv1369 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
tv1372 = 16						; size = 4
tv1371 = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,8,1>, COMDAT

; 31   : {

	sub	esp, 8

; 32   :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[esp+4], 0
	push	ebx
	push	ebp

; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)
; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebp, DWORD PTR _trad$[esp+12]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	eax, DWORD PTR _pSrc$[esp+20]
	xor	esi, esi
	mov	ecx, DWORD PTR _pDst$[esp+20]
	sub	eax, ecx
	sub	DWORD PTR _pDstLsb$[esp+20], ecx
	mov	DWORD PTR tv1370[esp+24], eax
	npad	6
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	add	ecx, esi

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1374[esp+24], ecx
	movzx	ebx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _Wall$[esp+20]
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	lea	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _pRef$[esp+20]
	sub	eax, DWORD PTR _Wall$[esp+20]
	mov	DWORD PTR tv1372[esp+20], eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [eax+edx]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+20]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	mov	eax, DWORD PTR tv1372[esp+20]
	add	ebx, ecx
	cmp	edi, ebp
	jl	SHORT $LL10@DegrainN_C
	mov	ecx, DWORD PTR tv1374[esp+24]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR _pDstLsb$[esp+20]
	mov	BYTE PTR [eax+ecx], bl
	mov	eax, DWORD PTR tv1370[esp+24]
	mov	ecx, DWORD PTR _pDst$[esp+20]
	cmp	esi, 8
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;
; 51   :       pDstLsb += nDstPitch;
; 52   :       pSrc += nSrcPitch;
; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	test	ebp, ebp
	jle	$LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+20]
	mov	edi, DWORD PTR _Pitch$[esp+20]
	mov	esi, edi
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	7
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [edi+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 8
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)
; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _pSrc$[esp+20]
	xor	ebx, ebx
	mov	eax, DWORD PTR _pDst$[esp+20]
	sub	ecx, eax
	mov	edx, DWORD PTR _Wall$[esp+20]
	mov	DWORD PTR tv1369[esp+24], ecx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	add	eax, ebx

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [ecx+eax]
	imul	eax, DWORD PTR [edx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ecx, DWORD PTR _pRef$[esp+20]
	lea	esi, DWORD PTR [edx+4]
	sub	ecx, edx
	mov	DWORD PTR tv1371[esp+20], ecx
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ecx]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+20]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	mov	ecx, DWORD PTR tv1371[esp+20]
	add	eax, edx
	cmp	edi, ebp
	jl	SHORT $LL22@DegrainN_C
	mov	edx, DWORD PTR _Wall$[esp+20]
	mov	ecx, DWORD PTR tv1369[esp+24]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	mov	esi, DWORD PTR _pDst$[esp+20]
	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	mov	eax, esi
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;
; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+20]
	mov	edi, DWORD PTR _Pitch$[esp+20]
	mov	esi, edi
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	4
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [edi+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
$LN14@DegrainN_C:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 8
	ret	0
??$DegrainN_C@G$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,8,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1383 = -16						; size = 4
tv1376 = -16						; size = 4
tv1394 = -12						; size = 4
tv1388 = -8						; size = 4
tv1390 = -4						; size = 4
tv1389 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,4,8>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1383[esp+36], 8
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1390[esp+36], ebx
	mov	DWORD PTR tv1388[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1394[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1394[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1388[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1390[esp+36]
	cmp	esi, 4
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1383[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1376[esp+36], 8
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1389[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1389[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1376[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,4,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1382 = -16						; size = 4
tv1375 = -16						; size = 4
tv1393 = -12						; size = 4
tv1387 = -8						; size = 4
tv1389 = -4						; size = 4
tv1388 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,4,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1382[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1389[esp+36], ebx
	mov	DWORD PTR tv1387[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1393[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1393[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1387[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1389[esp+36]
	cmp	esi, 4
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1382[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1375[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1388[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1388[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1375[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,4,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1383 = -16						; size = 4
tv1376 = -16						; size = 4
tv1394 = -12						; size = 4
tv1388 = -8						; size = 4
tv1390 = -4						; size = 4
tv1389 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,4,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1383[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1390[esp+36], ebx
	mov	DWORD PTR tv1388[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1394[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1394[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1388[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1390[esp+36]
	cmp	esi, 4
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1383[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1376[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1389[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1389[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 8
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1376[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,4,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1383 = -16						; size = 4
tv1376 = -16						; size = 4
tv1394 = -12						; size = 4
tv1388 = -8						; size = 4
tv1390 = -4						; size = 4
tv1389 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,2,4>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1383[esp+36], 4
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1390[esp+36], ebx
	mov	DWORD PTR tv1388[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1394[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1394[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1388[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1390[esp+36]
	cmp	esi, 2
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1383[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1376[esp+36], 4
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1389[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1389[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 4
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1376[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,2,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_C@G$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -20						; size = 4
_pSrc$2$ = -20						; size = 4
tv1382 = -16						; size = 4
tv1375 = -16						; size = 4
tv1393 = -12						; size = 4
tv1387 = -8						; size = 4
tv1389 = -4						; size = 4
tv1388 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_pDst$2$ = 16						; size = 4
_pSrc$1$ = 16						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_C@G$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC	; DegrainN_C<unsigned short,2,2>, COMDAT

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pSrc$[esp-4]
	sub	esp, 20					; 00000014H
	cmp	BYTE PTR _lsb_flag$[esp+16], 0
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _trad$[esp+24]
	push	esi
	push	edi
	je	$LN26@DegrainN_C
	mov	edx, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1382[esp+36], 2
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	mov	DWORD PTR _pDst$1$[esp+36], edx
	npad	2
$LL4@DegrainN_C:

; 36   :     {
; 37   :       for (int x = 0; x < blockWidth; ++x)

	mov	ebx, eax
	xor	esi, esi
	mov	eax, DWORD PTR _pDstLsb$[esp+32]
	sub	ebx, edx
	sub	eax, edx
	mov	DWORD PTR tv1389[esp+36], ebx
	mov	DWORD PTR tv1387[esp+36], eax
$LL7@DegrainN_C:

; 38   :       {
; 39   :         int				val = pSrc[x] * Wall[0];

	mov	eax, DWORD PTR _Wall$[esp+32]
	lea	ecx, DWORD PTR [esi+edx]
	movzx	ebx, BYTE PTR [ebx+ecx]

; 40   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	mov	DWORD PTR tv1393[esp+36], ecx
	imul	ebx, DWORD PTR [eax]
	test	ebp, ebp
	jle	SHORT $LN9@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	edx, DWORD PTR [eax+4]
	sub	ebp, eax
$LL10@DegrainN_C:

; 41   :         {
; 42   :           val += pRef[k * 2][x] * Wall[k * 2 + 1]

	mov	eax, DWORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+8]
	movzx	ecx, BYTE PTR [eax+esi]
	mov	eax, DWORD PTR _pRef$[esp+32]
	imul	ecx, DWORD PTR [edx-4]
	mov	eax, DWORD PTR [eax+edi*8]
	inc	edi
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, DWORD PTR [edx-8]
	add	ebx, eax
	add	ebx, ecx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL10@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR tv1393[esp+36]
	mov	edx, DWORD PTR _pDst$1$[esp+36]
$LN9@DegrainN_C:

; 43   :             + pRef[k * 2 + 1][x] * Wall[k * 2 + 2];
; 44   :         }
; 45   : 
; 46   :         pDst[x] = val >> 8;

	mov	eax, ebx
	inc	esi
	sar	eax, 8
	mov	BYTE PTR [ecx], al

; 47   :         pDstLsb[x] = val & 255;

	mov	eax, DWORD PTR tv1387[esp+36]
	mov	BYTE PTR [eax+ecx], bl
	mov	ebx, DWORD PTR tv1389[esp+36]
	cmp	esi, 2
	jl	SHORT $LL7@DegrainN_C

; 48   :       }
; 49   : 
; 50   :       pDst += nDstPitch;

	mov	eax, DWORD PTR _nDstPitch$[esp+32]
	add	edx, eax

; 51   :       pDstLsb += nDstPitch;

	add	DWORD PTR _pDstLsb$[esp+32], eax

; 52   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$1$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+36], edx

; 53   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], eax
	test	ebp, ebp
	jle	SHORT $LN2@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL13@DegrainN_C:

; 54   :       {
; 55   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 56   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL13@DegrainN_C
	mov	eax, DWORD PTR _pSrc$1$[esp+32]
$LN2@DegrainN_C:

; 32   :   if (lsb_flag)
; 33   :   {
; 34   :     // 8 bit base only
; 35   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1382[esp+36], 1
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	jne	$LL4@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
$LN26@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	mov	esi, DWORD PTR _pDst$[esp+32]
	mov	DWORD PTR tv1375[esp+36], 2
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	mov	DWORD PTR _pDst$2$[esp+32], esi
$LL16@DegrainN_C:

; 65   :     {
; 66   :       for (int x = 0; x < blockWidth; ++x)

	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, eax
	xor	ebx, ebx
	sub	edx, esi
	mov	DWORD PTR tv1388[esp+36], edx
$LL19@DegrainN_C:

; 67   :       {
; 68   :         int val = reinterpret_cast<const pixel_t *>(pSrc)[x] * Wall[0] + 128;

	lea	eax, DWORD PTR [ebx+esi]

; 69   :         for (int k = 0; k < trad; ++k)

	xor	edi, edi
	movzx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR [ecx]
	sub	eax, -128				; ffffff80H
	test	ebp, ebp
	jle	SHORT $LN21@DegrainN_C
	mov	ebp, DWORD PTR _pRef$[esp+32]
	lea	esi, DWORD PTR [ecx+4]
	sub	ebp, ecx
	npad	2
$LL22@DegrainN_C:

; 70   :         {
; 71   :           val += reinterpret_cast<const pixel_t *>(pRef[k * 2])[x] * Wall[k * 2 + 1]

	mov	ecx, DWORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+8]
	movzx	edx, WORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	imul	edx, DWORD PTR [esi-4]
	mov	ecx, DWORD PTR [ecx+edi*8]
	inc	edi
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, DWORD PTR [esi-8]
	add	eax, ecx
	add	eax, edx
	cmp	edi, DWORD PTR _trad$[esp+32]
	jl	SHORT $LL22@DegrainN_C
	mov	ebp, DWORD PTR _trad$[esp+32]
	mov	ecx, DWORD PTR _Wall$[esp+32]
	mov	edx, DWORD PTR tv1388[esp+36]
	mov	esi, DWORD PTR _pDst$2$[esp+32]
$LN21@DegrainN_C:

; 72   :             + reinterpret_cast<const pixel_t *>(pRef[k * 2 + 1])[x] * Wall[k * 2 + 2];
; 73   :         }
; 74   :         reinterpret_cast<pixel_t *>(pDst)[x] = val >> 8;

	sar	eax, 8
	mov	WORD PTR [ebx+esi], ax
	add	ebx, 2
	cmp	ebx, 4
	jl	SHORT $LL19@DegrainN_C

; 75   :       }
; 76   : 
; 77   :       pDst += nDstPitch;
; 78   :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+36]

; 79   :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[esp+32]
	add	eax, DWORD PTR _nSrcPitch$[esp+32]
	mov	DWORD PTR _pDst$2$[esp+32], esi
	mov	DWORD PTR _pSrc$2$[esp+36], eax
	test	ebp, ebp
	jle	SHORT $LN14@DegrainN_C
	mov	eax, DWORD PTR _pRef$[esp+32]
	mov	ebx, DWORD PTR _Pitch$[esp+32]
	mov	esi, ebx
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
$LL25@DegrainN_C:

; 80   :       {
; 81   :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [ebx+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 82   :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, ebp
	jl	SHORT $LL25@DegrainN_C
	mov	esi, DWORD PTR _pDst$2$[esp+32]
	mov	eax, DWORD PTR _pSrc$2$[esp+36]
$LN14@DegrainN_C:

; 57   :       }
; 58   :     }
; 59   :   }
; 60   : 
; 61   :   else
; 62   :   {
; 63   :     // Wall: 8 bit. rounding: 128
; 64   :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1375[esp+36], 1
	jne	$LL16@DegrainN_C
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 83   :       }
; 84   :     }
; 85   :   }
; 86   : }

	add	esp, 20					; 00000014H
	ret	0
??$DegrainN_C@G$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP	; DegrainN_C<unsigned short,2,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1478 = -20						; size = 4
tv1452 = -20						; size = 4
tv1464 = -16						; size = 4
tv1461 = -16						; size = 4
tv1471 = -12						; size = 4
tv1426 = -8						; size = 4
tv1470 = -4						; size = 4
tv1469 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<32,32>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1464[esp+40], 32		; 00000020H
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1471[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1469[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1471[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1426[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1478[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1478[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1426[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1469[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1464[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1452[esp+40], 32		; 00000020H
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1470[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1461[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1461[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1470[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 32					; 00000020H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1452[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0CA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<32,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1479 = -20						; size = 4
tv1453 = -20						; size = 4
tv1465 = -16						; size = 4
tv1462 = -16						; size = 4
tv1472 = -12						; size = 4
tv1427 = -8						; size = 4
tv1471 = -4						; size = 4
tv1470 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<32,16>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1465[esp+40], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1472[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1470[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1472[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1427[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1479[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1479[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1427[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1470[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1465[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1453[esp+40], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1471[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1462[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1462[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1471[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 32					; 00000020H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1453[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0CA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<32,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1479 = -20						; size = 4
tv1453 = -20						; size = 4
tv1465 = -16						; size = 4
tv1462 = -16						; size = 4
tv1472 = -12						; size = 4
tv1427 = -8						; size = 4
tv1471 = -4						; size = 4
tv1470 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<32,8>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1465[esp+40], 8
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1472[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1470[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1472[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1427[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1479[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1479[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1427[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1470[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1465[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1453[esp+40], 8
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1471[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1462[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1462[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1471[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 32					; 00000020H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1453[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0CA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<32,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1479 = -20						; size = 4
tv1453 = -20						; size = 4
tv1465 = -16						; size = 4
tv1462 = -16						; size = 4
tv1472 = -12						; size = 4
tv1427 = -8						; size = 4
tv1471 = -4						; size = 4
tv1470 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<16,32>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1465[esp+40], 32		; 00000020H
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1472[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1470[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1472[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1427[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1479[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1479[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1427[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1470[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 16					; 00000010H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1465[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1453[esp+40], 32		; 00000020H
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1471[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1462[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1462[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1471[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 16					; 00000010H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1453[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0BA@$0CA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<16,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1478 = -20						; size = 4
tv1452 = -20						; size = 4
tv1464 = -16						; size = 4
tv1461 = -16						; size = 4
tv1471 = -12						; size = 4
tv1426 = -8						; size = 4
tv1470 = -4						; size = 4
tv1469 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<16,16>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1464[esp+40], 16		; 00000010H
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1471[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1469[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1471[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1426[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1478[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1478[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1426[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1469[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 16					; 00000010H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1464[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1452[esp+40], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1470[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1461[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1461[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1470[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 16					; 00000010H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1452[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0BA@$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<16,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1479 = -20						; size = 4
tv1453 = -20						; size = 4
tv1465 = -16						; size = 4
tv1462 = -16						; size = 4
tv1472 = -12						; size = 4
tv1427 = -8						; size = 4
tv1471 = -4						; size = 4
tv1470 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<16,8>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1465[esp+40], 8
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1472[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1470[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1472[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1427[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1479[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1479[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1427[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1470[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 16					; 00000010H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1465[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1453[esp+40], 8
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1471[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1462[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1462[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1471[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 16					; 00000010H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1453[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0BA@$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<16,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1479 = -20						; size = 4
tv1453 = -20						; size = 4
tv1465 = -16						; size = 4
tv1462 = -16						; size = 4
tv1472 = -12						; size = 4
tv1427 = -8						; size = 4
tv1471 = -4						; size = 4
tv1470 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<16,4>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1465[esp+40], 4
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1472[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1470[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1472[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1427[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1479[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1479[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1427[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1470[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 16					; 00000010H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1465[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1453[esp+40], 4
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1471[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1462[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1462[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1471[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 16					; 00000010H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1453[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0BA@$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<16,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -28						; size = 4
_pSrc$2$ = -28						; size = 4
_pDst$2$ = -24						; size = 4
_pSrc$1$ = -24						; size = 4
tv1479 = -20						; size = 4
tv1453 = -20						; size = 4
tv1465 = -16						; size = 4
tv1462 = -16						; size = 4
tv1472 = -12						; size = 4
tv1427 = -8						; size = 4
tv1471 = -4						; size = 4
tv1470 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<16,2>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	esi, DWORD PTR _pDst$[ebp]
	push	edi
	je	$LN26@DegrainN_s
	mov	edi, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1465[esp+40], 2
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	mov	DWORD PTR _pDst$1$[esp+40], esi
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	sub	edi, esi
	xor	ecx, ecx
	mov	DWORD PTR tv1472[esp+40], edi
	mov	edi, DWORD PTR _Wall$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1470[esp+40], eax
	npad	7
$LL7@DegrainN_s:

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR tv1472[esp+40]
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1427[esp+40], edx
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	test	eax, eax
	jle	SHORT $LN9@DegrainN_s

; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	edx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	edx, 4
	mov	DWORD PTR tv1479[esp+40], eax

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	1
$LL10@DegrainN_s:
	sub	DWORD PTR tv1479[esp+40], 1
	lea	edx, DWORD PTR [edx+8]

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [edi+edx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [edx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+ecx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL10@DegrainN_s
	mov	edx, DWORD PTR tv1427[esp+40]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	esi, DWORD PTR _pDst$1$[esp+40]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(
; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	mov	eax, DWORD PTR tv1470[esp+40]
	movaps	xmm0, xmm1
	psrlw	xmm0, 8
	pand	xmm1, xmm4
	packuswb xmm1, xmm3
	add	ecx, 8
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx], xmm0
	movq	QWORD PTR [eax+edx], xmm1
	mov	eax, DWORD PTR _trad$[ebp]
	cmp	ecx, 16					; 00000010H
	jl	$LL7@DegrainN_s

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;

	mov	edi, DWORD PTR _pSrc$1$[esp+40]

; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	mov	ecx, DWORD PTR _nDstPitch$[ebp]
	add	esi, ecx
	add	edi, DWORD PTR _nSrcPitch$[ebp]
	add	DWORD PTR _pDstLsb$[ebp], ecx
	mov	DWORD PTR _pDst$1$[esp+40], esi
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	test	eax, eax
	jle	SHORT $LN2@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	esi, DWORD PTR _Pitch$[ebp]
	mov	edi, DWORD PTR _trad$[ebp]
	sub	esi, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	2
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR _Pitch$[ebp]
	lea	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+edx*8]
	inc	edx
	add	DWORD PTR [ecx-12], eax

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	esi, DWORD PTR _pDst$1$[esp+40]
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1465[esp+40], 1
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1453[esp+40], 2
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _pDst$2$[esp+40], esi
	npad	5
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)

	mov	edi, DWORD PTR _Wall$[ebp]
	xor	edx, edx
	sub	ecx, esi
	mov	DWORD PTR tv1471[esp+40], ecx
	npad	5
$LL19@DegrainN_s:

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	lea	eax, DWORD PTR [edx+esi]
	movq	xmm1, QWORD PTR [ecx+eax]
	movsx	eax, WORD PTR [edi]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	mov	eax, DWORD PTR _trad$[ebp]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4
	test	eax, eax
	jle	SHORT $LN21@DegrainN_s

; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	ecx, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edi+8]
	add	ecx, 4
	mov	DWORD PTR tv1462[esp+40], eax

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edi, DWORD PTR _pRef$[ebp]
	npad	5
$LL22@DegrainN_s:
	sub	DWORD PTR tv1462[esp+40], 1
	lea	ecx, DWORD PTR [ecx+8]

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-12]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [edi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax+edx]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	jne	SHORT $LL22@DegrainN_s
	mov	eax, DWORD PTR _trad$[ebp]
	mov	edi, DWORD PTR _Wall$[ebp]
	mov	ecx, DWORD PTR tv1471[esp+40]
	mov	esi, DWORD PTR _pDst$2$[esp+40]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [edx+esi], xmm1
	add	edx, 8
	cmp	edx, 16					; 00000010H
	jl	$LL19@DegrainN_s

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	ecx, DWORD PTR _pSrc$2$[esp+40]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	esi, DWORD PTR _nDstPitch$[ebp]
	add	ecx, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pDst$2$[esp+40], esi
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	test	eax, eax
	jle	SHORT $LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	edi, DWORD PTR _Pitch$[ebp]
	mov	esi, DWORD PTR _trad$[ebp]
	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+4]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR _Pitch$[ebp]
	lea	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ecx+edx*8]
	inc	edx
	add	DWORD PTR [eax-12], ecx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [edi+eax-8]
	add	DWORD PTR [eax-8], ecx
	cmp	edx, esi
	jl	SHORT $LL25@DegrainN_s
	mov	esi, DWORD PTR _pDst$2$[esp+40]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1453[esp+40], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$0BA@$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<16,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1454 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1474 = -8						; size = 4
tv1448 = -8						; size = 4
tv1455 = -4						; size = 4
tv1451 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<8,16>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 16					; 00000010H
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1455[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1454[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1474[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1455[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1454[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1448[esp+24], 16		; 00000010H
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1451[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1448[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$07$0BA@@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<8,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1453 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1473 = -8						; size = 4
tv1447 = -8						; size = 4
tv1454 = -4						; size = 4
tv1450 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<8,8>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 8
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1454[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1453[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1473[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1453[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1454[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1453[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1453[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1447[esp+24], 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1450[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1447[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$07$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<8,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1454 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1474 = -8						; size = 4
tv1448 = -8						; size = 4
tv1455 = -4						; size = 4
tv1451 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<8,4>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 4
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1455[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1454[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1474[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1455[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1454[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1448[esp+24], 4
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1451[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1448[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$07$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<8,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1454 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1474 = -8						; size = 4
tv1448 = -8						; size = 4
tv1455 = -4						; size = 4
tv1451 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<8,2>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 2
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1455[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1454[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1474[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1455[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1454[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1448[esp+24], 2
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1451[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1448[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$07$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<8,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
tv1436 = -4						; size = 4
tv1425 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<8,1>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)
; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);
; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)
; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pSrc$[ebp]
	sub	esp, 8
	cmp	BYTE PTR _lsb_flag$[ebp], 0
	xorps	xmm3, xmm3
	mov	edx, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	push	esi
	movsx	eax, WORD PTR [edx]
	punpcklbw xmm1, xmm3
	push	edi

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	mov	edi, DWORD PTR _trad$[ebp]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	je	$LN26@DegrainN_s
	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)
; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);
; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)
; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edx+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	edx, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	4
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDst$[ebp]
	movaps	xmm0, xmm1

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movq	QWORD PTR [eax], xmm1
	test	edi, edi
	jle	$LN14@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);
; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)
; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	paddw	xmm1, XMMWORD PTR __xmm@00800080008000800080008000800080

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);
; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)
; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	esi, DWORD PTR [edx+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	edx, eax
	lea	ecx, DWORD PTR [eax+4]
	npad	6
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	esi, DWORD PTR [esi+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDst$[ebp]

; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;
; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	psrlw	xmm1, 8
	packuswb xmm1, xmm3
	movq	QWORD PTR [eax], xmm1
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
	npad	5
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
$LN14@DegrainN_s:

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$07$00@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<8,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1454 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1474 = -8						; size = 4
tv1448 = -8						; size = 4
tv1455 = -4						; size = 4
tv1451 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<4,8>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 8
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1455[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1454[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1474[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1455[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1454[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1448[esp+24], 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1451[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1448[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$03$07@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<4,8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1453 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1473 = -8						; size = 4
tv1447 = -8						; size = 4
tv1454 = -4						; size = 4
tv1450 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<4,4>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 4
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1454[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1453[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1473[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1453[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1454[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1453[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1453[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1447[esp+24], 4
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1450[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1447[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$03$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<4,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1454 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1474 = -8						; size = 4
tv1448 = -8						; size = 4
tv1455 = -4						; size = 4
tv1451 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<4,2>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 2
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1455[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1454[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1474[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1455[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1454[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1448[esp+24], 2
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1451[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1448[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$03$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<4,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1454 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1474 = -8						; size = 4
tv1448 = -8						; size = 4
tv1455 = -4						; size = 4
tv1451 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<2,4>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 4
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1455[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1454[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1474[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1455[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1454[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1454[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1448[esp+24], 4
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1451[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1448[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$01$03@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<2,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$DegrainN_sse2@$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z
_TEXT	SEGMENT
_pDst$1$ = -16						; size = 4
_pSrc$1$ = -16						; size = 4
tv1453 = -12						; size = 4
_pSrc$2$ = -12						; size = 4
tv1473 = -8						; size = 4
tv1447 = -8						; size = 4
tv1454 = -4						; size = 4
tv1450 = -4						; size = 4
_pDst$ = 8						; size = 4
_pDstLsb$ = 12						; size = 4
_lsb_flag$ = 16						; size = 1
_nDstPitch$ = 20					; size = 4
_pSrc$ = 24						; size = 4
_nSrcPitch$ = 28					; size = 4
_pRef$ = 32						; size = 4
_Pitch$ = 36						; size = 4
_Wall$ = 40						; size = 4
_trad$ = 44						; size = 4
??$DegrainN_sse2@$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z PROC ; DegrainN_sse2<2,2>, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	xorps	xmm3, xmm3

; 194  :   const __m128i	z = _mm_setzero_si128();
; 195  : 
; 196  :   if (lsb_flag)

	cmp	BYTE PTR _lsb_flag$[ebp], 0
	push	esi
	push	edi

; 197  :   {
; 198  :     const __m128i	m = _mm_set1_epi16(255);

	mov	edi, DWORD PTR _trad$[ebp]
	je	$LN26@DegrainN_s

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	mov	eax, DWORD PTR _pDst$[ebp]
	mov	ecx, 2
	sub	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
	mov	DWORD PTR tv1454[esp+24], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv1453[esp+24], ecx
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	npad	4
$LL4@DegrainN_s:

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN9@DegrainN_s

; 201  :     {
; 202  :       for (int x = 0; x < blockWidth; x += 8)
; 203  :       {
; 204  :         __m128i			val = _mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 205  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 206  :           _mm_set1_epi16(Wall[0])
; 207  :         );
; 208  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1473[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL10@DegrainN_s:

; 209  :         {
; 210  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 211  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 212  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 213  :           );
; 214  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 215  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 216  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 217  :           );
; 218  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 219  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL10@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR tv1453[esp+24]
$LN9@DegrainN_s:

; 220  :         }
; 221  :         _mm_storel_epi64(

	mov	eax, DWORD PTR _pDstLsb$[ebp]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1454[esp+24]

; 222  :           (__m128i*)(pDst + x),
; 223  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 224  :         );
; 225  :         _mm_storel_epi64(

	pand	xmm1, xmm4
	psrlw	xmm0, 8
	packuswb xmm1, xmm3
	packuswb xmm0, xmm3
	movq	QWORD PTR [edx+eax], xmm0

; 226  :           (__m128i*)(pDstLsb + x),
; 227  :           _mm_packus_epi16(_mm_and_si128(val, m), z)
; 228  :         );
; 229  :       }
; 230  :       pDst += nDstPitch;
; 231  :       pDstLsb += nDstPitch;
; 232  :       pSrc += nSrcPitch;
; 233  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	movq	QWORD PTR [eax], xmm1
	add	eax, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDstLsb$[ebp], eax
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	mov	DWORD PTR _pSrc$1$[esp+24], eax
	test	edi, edi
	jle	SHORT $LN2@DegrainN_s
	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _Pitch$[ebp]
	add	ecx, 4
	mov	esi, eax
	sub	esi, DWORD PTR _pRef$[ebp]
$LL13@DegrainN_s:

; 234  :       {
; 235  :         pRef[k * 2] += Pitch[k * 2];

	mov	eax, DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [ecx+8]
	add	DWORD PTR [ecx-12], eax
	inc	edx

; 236  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	eax, DWORD PTR [esi+ecx-8]
	add	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL13@DegrainN_s
	mov	eax, DWORD PTR _pSrc$1$[esp+24]
	mov	ecx, DWORD PTR tv1453[esp+24]
$LN2@DegrainN_s:

; 199  : 
; 200  :     for (int h = 0; h < blockHeight; ++h)

	sub	ecx, 1
	mov	DWORD PTR tv1453[esp+24], ecx
	jne	$LL4@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@DegrainN_s:

; 237  :       }
; 238  :     }
; 239  :   }
; 240  : 
; 241  :   else
; 242  :   {
; 243  :     const __m128i	o = _mm_set1_epi16(128);

	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	ecx, DWORD PTR _pDst$[ebp]
	movaps	xmm4, XMMWORD PTR __xmm@00800080008000800080008000800080
	mov	DWORD PTR tv1447[esp+24], 2
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	npad	10
$LL16@DegrainN_s:

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	esi, DWORD PTR _Wall$[ebp]
	movq	xmm1, QWORD PTR [eax]
	punpcklbw xmm1, xmm3
	movsx	eax, WORD PTR [esi]
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0
	paddw	xmm1, xmm4

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	test	edi, edi
	jle	SHORT $LN21@DegrainN_s

; 246  :     {
; 247  :       for (int x = 0; x < blockWidth; x += 8)
; 248  :       {
; 249  :         __m128i			val = _mm_add_epi16(_mm_mullo_epi16(

	mov	eax, DWORD PTR _pRef$[ebp]
	lea	edx, DWORD PTR [esi+8]

; 250  :           _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc + x)), z),
; 251  :           _mm_set1_epi16(Wall[0])
; 252  :         ), o);
; 253  :         for (int k = 0; k < trad; ++k)

	sub	esi, eax
	mov	DWORD PTR tv1450[esp+24], edi
	lea	ecx, DWORD PTR [eax+4]
$LL22@DegrainN_s:

; 254  :         {
; 255  :           const __m128i	s1 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-4]
	lea	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edx+8]
	movq	xmm2, QWORD PTR [eax]
	movsx	eax, WORD PTR [esi+ecx-8]
	punpcklbw xmm2, xmm3
	movd	xmm0, eax

; 256  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2] + x)), z),
; 257  :             _mm_set1_epi16(Wall[k * 2 + 1])
; 258  :           );
; 259  :           const __m128i	s2 = _mm_mullo_epi16(

	mov	eax, DWORD PTR [ecx-8]
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm2, xmm0

; 260  :             _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef[k * 2 + 1] + x)), z),
; 261  :             _mm_set1_epi16(Wall[k * 2 + 2])
; 262  :           );
; 263  :           val = _mm_add_epi16(val, s1);

	paddw	xmm2, xmm1
	movq	xmm1, QWORD PTR [eax]
	movsx	eax, WORD PTR [edx-8]
	punpcklbw xmm1, xmm3
	movd	xmm0, eax
	punpcklwd xmm0, xmm0
	pshufd	xmm0, xmm0, 0
	pmullw	xmm1, xmm0

; 264  :           val = _mm_add_epi16(val, s2);

	paddw	xmm1, xmm2
	sub	edi, 1
	jne	SHORT $LL22@DegrainN_s
	mov	edi, DWORD PTR _trad$[ebp]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN21@DegrainN_s:

; 265  :         }
; 266  :         _mm_storel_epi64(
; 267  :           (__m128i*)(pDst + x),
; 268  :           _mm_packus_epi16(_mm_srli_epi16(val, 8), z)
; 269  :         );
; 270  :       }
; 271  : 
; 272  :       pDst += nDstPitch;
; 273  :       pSrc += nSrcPitch;

	mov	eax, DWORD PTR _pSrc$2$[esp+24]

; 274  :       for (int k = 0; k < trad; ++k)

	xor	edx, edx
	add	eax, DWORD PTR _nSrcPitch$[ebp]
	psrlw	xmm1, 8
	mov	DWORD PTR _pSrc$2$[esp+24], eax
	packuswb xmm1, xmm3
	movq	QWORD PTR [ecx], xmm1
	add	ecx, DWORD PTR _nDstPitch$[ebp]
	mov	DWORD PTR _pDst$1$[esp+24], ecx
	test	edi, edi
	jle	SHORT $LN14@DegrainN_s
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	ecx, DWORD PTR _Pitch$[ebp]
	add	eax, 4
	mov	esi, ecx
	sub	esi, DWORD PTR _pRef$[ebp]
$LL25@DegrainN_s:

; 275  :       {
; 276  :         pRef[k * 2] += Pitch[k * 2];

	mov	ecx, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+8]
	add	DWORD PTR [eax-12], ecx
	inc	edx

; 277  :         pRef[k * 2 + 1] += Pitch[k * 2 + 1];

	mov	ecx, DWORD PTR [esi+eax-8]
	add	DWORD PTR [eax-8], ecx
	mov	ecx, DWORD PTR _Pitch$[ebp]
	cmp	edx, edi
	jl	SHORT $LL25@DegrainN_s
	mov	eax, DWORD PTR _pSrc$2$[esp+24]
	mov	ecx, DWORD PTR _pDst$1$[esp+24]
$LN14@DegrainN_s:

; 244  : 
; 245  :     for (int h = 0; h < blockHeight; ++h)

	sub	DWORD PTR tv1447[esp+24], 1
	jne	$LL16@DegrainN_s

; 278  :       }
; 279  :     }
; 280  :   }
; 281  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$DegrainN_sse2@$01$01@@YAXPAE0_NHPBEHQAPBEQAH4H@Z ENDP ; DegrainN_sse2<2,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma@$00@MDegrainN@@AAEXH@Z
_TEXT	SEGMENT
_slicer$2 = -1076					; size = 1056
_this$1$ = -20						; size = 4
_pitch$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_row_size$1$ = 8					; size = 4
_plane_mask$ = 8					; size = 4
??$process_chroma@$00@MDegrainN@@AAEXH@Z PROC		; MDegrainN::process_chroma<1>, COMDAT
; _this$ = ecx

; 1014 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$process_chroma@$00@MDegrainN@@AAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1064				; 00000428H

; 1015 :   if ((_yuvplanes & plane_mask) == 0)

	mov	eax, DWORD PTR _plane_mask$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi
	test	DWORD PTR [esi+168], eax
	jne	SHORT $LN2@process_ch

; 1017 :     BitBlt(

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+204]
	sar	eax, cl
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	eax, eax
	je	$LN216@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1017 :     BitBlt(

	mov	ecx, DWORD PTR [esi+200]
	mov	edx, DWORD PTR [esi+3648]
	push	eax
	mov	eax, DWORD PTR [esi+92]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+192]
	mov	ecx, DWORD PTR [esi+3624]
	push	eax
	push	DWORD PTR [esi+3660]
	push	DWORD PTR [esi+3636]
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
	pop	esi

; 1184 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@process_ch:

; 1018 :       _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1019 :       _src_ptr_arr[P], _src_pitch_arr[P],
; 1020 :       pixelsize_super * (nWidth >> _xratiouv_log), nHeight >> _yratiouv_log, _isse_flag
; 1021 :     );
; 1022 :   }
; 1023 : 
; 1024 :   else
; 1025 :   {
; 1026 :     Slicer slicer(_mt_flag);

	movzx	eax, BYTE PTR [esi+187]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	push	edi
	push	eax
	call	??0?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAE@_N@Z ; MTSlicer<MDegrainN,MDegrainN,64>::MTSlicer<MDegrainN,MDegrainN,64>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1027 : 
; 1028 :     if (nOverlapX == 0 && nOverlapY == 0)

	cmp	DWORD PTR [esi+108], 0
	jne	SHORT $LN4@process_ch
	cmp	DWORD PTR [esi+112], 0
	jne	SHORT $LN4@process_ch

; 1029 :     {
; 1030 :       slicer.start(

	push	1
	push	0
	push	OFFSET ??$process_chroma_normal_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_normal_slice<1>
	push	esi
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MDegrainN,MDegrainN,64>::start

; 1031 :         nBlkY,
; 1032 :         *this,
; 1033 :         &MDegrainN::process_chroma_normal_slice <P>
; 1034 :       );
; 1035 :       slicer.wait();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait

; 1036 :     }
; 1037 : 
; 1038 :     // Overlap
; 1039 :     else

	jmp	$LN208@process_ch
$LN4@process_ch:
	mov	eax, DWORD PTR [esi+260]
	push	ebx
	cmp	eax, DWORD PTR [esi+264]

; 1040 :     {
; 1041 :       unsigned short * pDstShort = (_dst_short.empty()) ? 0 : &_dst_short[0];

	jne	SHORT $LN29@process_ch
	xor	ebx, ebx
	jmp	SHORT $LN30@process_ch
$LN29@process_ch:
	mov	ebx, eax
$LN30@process_ch:
	mov	eax, DWORD PTR [esi+276]
	cmp	eax, DWORD PTR [esi+280]

; 1042 :       int * pDstInt = (_dst_int.empty()) ? 0 : &_dst_int[0];

	jne	SHORT $LN31@process_ch
	xor	edi, edi
	jmp	SHORT $LN32@process_ch
$LN31@process_ch:
	mov	edi, eax
$LN32@process_ch:

; 1043 : 
; 1044 :       if (_lsb_flag || pixelsize_super > 1)

	cmp	BYTE PTR [esi+186], 0
	jne	SHORT $LN8@process_ch
	cmp	DWORD PTR [esi+192], 1
	jg	SHORT $LN8@process_ch

; 1047 :           reinterpret_cast <unsigned char *> (pDstInt), 0,
; 1048 :           (_covered_width * sizeof(int)) >> _xratiouv_log, _covered_height >> _yratiouv_log,
; 1049 :           0, 0, _dst_int_pitch * sizeof(int)
; 1050 :         );
; 1051 :       }
; 1052 :       else
; 1053 :       {  
; 1054 :         MemZoneSet(

	mov	eax, DWORD PTR [esi+272]
	xor	dl, dl
	mov	ecx, DWORD PTR [esi+204]
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR [esi+3684]
	sub	esp, 8
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	add	eax, eax
	shr	eax, cl
	mov	ecx, ebx
	push	eax
	call	_MemZoneSet
	add	esp, 20					; 00000014H
	jmp	SHORT $LN112@process_ch
$LN8@process_ch:

; 1045 :       {
; 1046 :         MemZoneSet(

	mov	eax, DWORD PTR [esi+288]
	mov	ebx, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	shl	eax, 2
	mov	DWORD PTR _pitch$1$[ebp], eax
	mov	eax, DWORD PTR [esi+3680]
	sar	ebx, cl
	mov	ecx, DWORD PTR [esi+200]
	shl	eax, 2
	shr	eax, cl
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	ebx, ebx
	jle	SHORT $LN112@process_ch
	mov	esi, eax
	npad	4
$LL113@process_ch:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	esi
	push	0
	push	edi
	call	_memset

; 108  : 		ptr += pitch;

	add	edi, DWORD PTR _pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL113@process_ch
	mov	esi, DWORD PTR _this$1$[ebp]
$LN112@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1061 :       if (nOverlapY > 0)

	cmp	DWORD PTR [esi+112], 0
	jle	SHORT $LN9@process_ch
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+3692]
	sub	eax, DWORD PTR [esi+3688]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1063 :         memset(

	and	eax, -4					; fffffffcH
	push	eax
	push	0
	push	DWORD PTR [esi+3688]
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@process_ch:

; 1064 :           &_boundary_cnt_arr[0],
; 1065 :           0,
; 1066 :           _boundary_cnt_arr.size() * sizeof(_boundary_cnt_arr[0])
; 1067 :         );
; 1068 :       }
; 1069 : 
; 1070 :       slicer.start(

	push	2
	push	0
	push	OFFSET ??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_overlap_slice<1>
	push	esi
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MDegrainN,MDegrainN,64>::start

; 1071 :         nBlkY,
; 1072 :         *this,
; 1073 :         &MDegrainN::process_chroma_overlap_slice <P>,
; 1074 :         2
; 1075 :       );
; 1076 :       slicer.wait();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait

; 1077 :       
; 1078 :       if (_lsb_flag)

	cmp	BYTE PTR [esi+186], 0
	je	SHORT $LN10@process_ch

; 1079 :       {
; 1080 :         Short2BytesLsb(

	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edi, DWORD PTR [esi+3624]
	mov	edx, DWORD PTR [esi+3672]
	sar	eax, cl
	add	edx, edi
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	mov	ecx, edi
	push	eax
	push	DWORD PTR [esi+288]
	push	DWORD PTR [esi+276]
	push	DWORD PTR [esi+3648]
	call	?Short2BytesLsb@@YAXPAE0HPAHHHH@Z	; Short2BytesLsb
	add	esp, 20					; 00000014H
	jmp	$LN16@process_ch
$LN10@process_ch:

; 1081 :           _dst_ptr_arr[P],
; 1082 :           _dst_ptr_arr[P] + _lsb_offset_arr[P], // 8 bit only
; 1083 :           _dst_pitch_arr[P],
; 1084 :           &_dst_int[0], _dst_int_pitch,
; 1085 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log
; 1086 :         );
; 1087 :       }
; 1088 :       else if (pixelsize_super == 1)

	mov	eax, DWORD PTR [esi+192]
	cmp	eax, 1
	jne	SHORT $LN12@process_ch

; 1089 :       {
; 1090 :         Short2Bytes(

	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+3648]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+3624]
	push	eax
	push	DWORD PTR [esi+272]
	push	DWORD PTR [esi+260]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes
	jmp	$LN225@process_ch
$LN12@process_ch:

; 1091 :           _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1092 :           &_dst_short[0], _dst_short_pitch,
; 1093 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log
; 1094 :         );
; 1095 :       }
; 1096 :       else if (pixelsize_super == 2)

	cmp	eax, 2
	jne	SHORT $LN14@process_ch

; 1097 :       {
; 1098 :         Short2Bytes_Int32toWord16(

	push	DWORD PTR [esi+196]
	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+3648]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+3624]
	push	eax
	push	DWORD PTR [esi+288]
	push	DWORD PTR [esi+276]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16
	add	esp, 20					; 00000014H
	jmp	SHORT $LN16@process_ch
$LN14@process_ch:

; 1099 :           (uint16_t *)_dst_ptr_arr[P], _dst_pitch_arr[P],
; 1100 :           &_dst_int[0], _dst_int_pitch,
; 1101 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log,
; 1102 :           bits_per_pixel_super
; 1103 :         );
; 1104 :       }
; 1105 :       else if (pixelsize_super == 4)

	cmp	eax, 4
	jne	SHORT $LN16@process_ch

; 1106 :       {
; 1107 :         Short2Bytes_FloatInInt32ArrayToFloat(

	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+3648]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	push	eax
	push	ecx
	push	DWORD PTR [esi+276]
	mov	ecx, DWORD PTR [esi+3624]
	call	?Short2Bytes_FloatInInt32ArrayToFloat@@YAXPAMHPAHHHH@Z ; Short2Bytes_FloatInInt32ArrayToFloat
$LN225@process_ch:
	add	esp, 16					; 00000010H
$LN16@process_ch:

; 1108 :           (float *)_dst_ptr_arr[P], _dst_pitch_arr[P],
; 1109 :           &_dst_int[0], _dst_int_pitch,
; 1110 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log
; 1111 :         );
; 1112 :       }
; 1113 : 
; 1114 :       if (_covered_width < nWidth)

	mov	edx, DWORD PTR [esi+3680]
	mov	edi, DWORD PTR [esi+92]
	cmp	edx, edi
	jge	SHORT $LN196@process_ch

; 1115 :       {
; 1116 :         BitBlt(

	mov	ebx, DWORD PTR [esi+3684]
	sub	edi, edx
	mov	ecx, DWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+192]
	sar	ebx, cl
	mov	ecx, DWORD PTR [esi+200]
	sar	edx, cl
	imul	edx, eax
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+3624]
	imul	edi, eax
	mov	eax, DWORD PTR [esi+3636]
	add	eax, edx
	add	ecx, edx
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	ebx, ebx
	je	SHORT $LN196@process_ch
	mov	edx, DWORD PTR [esi+3648]
	push	ebx
	push	edi
	push	DWORD PTR [esi+3660]
	push	eax
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN196@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1123 :       if (_covered_height < nHeight) // bottom noncovered region

	mov	edi, DWORD PTR [esi+3684]
	mov	edx, DWORD PTR [esi+96]
	cmp	edi, edx
	jge	SHORT $LN224@process_ch

; 1124 :       {
; 1125 :         BitBlt(

	mov	eax, DWORD PTR [esi+204]
	sub	edx, edi
	mov	ebx, DWORD PTR [esi+92]
	mov	ecx, eax
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+200]
	sar	ebx, cl
	mov	ecx, eax
	imul	ebx, DWORD PTR [esi+192]
	mov	DWORD PTR _row_size$1$[ebp], ebx
	mov	ebx, edi
	imul	ebx, DWORD PTR [esi+3660]
	imul	edi, DWORD PTR [esi+3648]
	sar	ebx, cl
	add	ebx, DWORD PTR [esi+3636]
	sar	edi, cl
	add	edi, DWORD PTR [esi+3624]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edx, edx
	je	SHORT $LN224@process_ch
	push	edx
	push	DWORD PTR _row_size$1$[ebp]
	mov	edx, DWORD PTR [esi+3648]
	mov	ecx, edi
	push	DWORD PTR [esi+3660]
	push	ebx
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN224@process_ch:
	pop	ebx
$LN208@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1134 :     if (pixelsize_super <= 2) {

	mov	edi, DWORD PTR [esi+192]
	cmp	edi, 2
	jg	SHORT $LN27@process_ch

; 1135 :       if (_nlimitc < (1 << bits_per_pixel_super) - 1)

	mov	ecx, DWORD PTR [esi+196]
	mov	eax, 1
	mov	edx, DWORD PTR [esi+176]
	shl	eax, cl
	dec	eax
	cmp	edx, eax
	jge	SHORT $LN27@process_ch

; 1140 :             LimitChanges_sse2_new<uint8_t>(

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+204]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	edx
	mov	edx, DWORD PTR [esi+3648]
	push	eax
	mov	eax, DWORD PTR [esi+92]
	sar	eax, cl
	cmp	BYTE PTR [esi+184], 0
	mov	ecx, DWORD PTR [esi+3624]
	push	eax
	push	DWORD PTR [esi+3660]
	push	DWORD PTR [esi+3636]
	je	SHORT $LN22@process_ch

; 1136 :       {
; 1137 :         if (_isse_flag)
; 1138 :         {
; 1139 :           if (pixelsize_super == 1)

	cmp	edi, 1
	jne	SHORT $LN24@process_ch

; 1140 :             LimitChanges_sse2_new<uint8_t>(

	call	??$LimitChanges_sse2_new@E@@YAXPAEHPBEHHHH@Z ; LimitChanges_sse2_new<unsigned char>

; 1141 :               _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1142 :               _src_ptr_arr[P], _src_pitch_arr[P],
; 1143 :               nWidth >> _xratiouv_log, nHeight >> _yratiouv_log,
; 1144 :               _nlimitc
; 1145 :             );
; 1146 :           else // pixelsize_super == 2

	jmp	SHORT $LN226@process_ch
$LN24@process_ch:

; 1147 :             LimitChanges_sse2_new<uint16_t>(

	call	??$LimitChanges_sse2_new@G@@YAXPAEHPBEHHHH@Z ; LimitChanges_sse2_new<unsigned short>

; 1148 :               _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1149 :               _src_ptr_arr[P], _src_pitch_arr[P],
; 1150 :               nWidth >> _xratiouv_log, nHeight >> _yratiouv_log,
; 1151 :               _nlimitc
; 1152 :               );
; 1153 :         }
; 1154 :         else

	jmp	SHORT $LN226@process_ch
$LN22@process_ch:

; 1155 :         {
; 1156 :           if (pixelsize_super == 1)

	cmp	edi, 1
	jne	SHORT $LN26@process_ch

; 1157 :             LimitChanges_c<uint8_t>(

	call	??$LimitChanges_c@E@@YAXPAEHPBEHHHH@Z	; LimitChanges_c<unsigned char>

; 1158 :               _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1159 :               _src_ptr_arr[P], _src_pitch_arr[P],
; 1160 :               nWidth >> _xratiouv_log, nHeight >> _yratiouv_log,
; 1161 :               _nlimitc
; 1162 :               );
; 1163 :           else

	jmp	SHORT $LN226@process_ch
$LN26@process_ch:

; 1164 :             LimitChanges_c<uint16_t>(

	call	??$LimitChanges_c@G@@YAXPAEHPBEHHHH@Z	; LimitChanges_c<unsigned short>
$LN226@process_ch:
	add	esp, 20					; 00000014H
$LN27@process_ch:
; File c:\github\mvtools\sources\mtslicer.hpp

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR _slicer$2[ebp+24], 0
	mov	DWORD PTR _slicer$2[ebp], OFFSET ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@
	pop	edi
	je	SHORT $LN216@process_ch

; 88   : 	{
; 89   : 		wait ();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait
$LN216@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1184 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$process_chroma@$00@MDegrainN@@AAEXH@Z$0:
	lea	ecx, DWORD PTR _slicer$2[ebp]
	jmp	??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ ; MTSlicer<MDegrainN,MDegrainN,64>::~MTSlicer<MDegrainN,MDegrainN,64>
__unwindfunclet$??$process_chroma@$00@MDegrainN@@AAEXH@Z$43:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$process_chroma@$00@MDegrainN@@AAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$??$process_chroma@$00@MDegrainN@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$process_chroma@$00@MDegrainN@@AAEXH@Z ENDP		; MDegrainN::process_chroma<1>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma@$01@MDegrainN@@AAEXH@Z
_TEXT	SEGMENT
_slicer$2 = -1076					; size = 1056
_this$1$ = -20						; size = 4
_pitch$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_row_size$1$ = 8					; size = 4
_plane_mask$ = 8					; size = 4
??$process_chroma@$01@MDegrainN@@AAEXH@Z PROC		; MDegrainN::process_chroma<2>, COMDAT
; _this$ = ecx

; 1014 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$process_chroma@$01@MDegrainN@@AAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1064				; 00000428H

; 1015 :   if ((_yuvplanes & plane_mask) == 0)

	mov	eax, DWORD PTR _plane_mask$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi
	test	DWORD PTR [esi+168], eax
	jne	SHORT $LN2@process_ch

; 1017 :     BitBlt(

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+204]
	sar	eax, cl
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	eax, eax
	je	$LN216@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1017 :     BitBlt(

	mov	ecx, DWORD PTR [esi+200]
	mov	edx, DWORD PTR [esi+3652]
	push	eax
	mov	eax, DWORD PTR [esi+92]
	sar	eax, cl
	imul	eax, DWORD PTR [esi+192]
	mov	ecx, DWORD PTR [esi+3628]
	push	eax
	push	DWORD PTR [esi+3664]
	push	DWORD PTR [esi+3640]
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
	pop	esi

; 1184 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@process_ch:

; 1018 :       _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1019 :       _src_ptr_arr[P], _src_pitch_arr[P],
; 1020 :       pixelsize_super * (nWidth >> _xratiouv_log), nHeight >> _yratiouv_log, _isse_flag
; 1021 :     );
; 1022 :   }
; 1023 : 
; 1024 :   else
; 1025 :   {
; 1026 :     Slicer slicer(_mt_flag);

	movzx	eax, BYTE PTR [esi+187]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	push	edi
	push	eax
	call	??0?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAE@_N@Z ; MTSlicer<MDegrainN,MDegrainN,64>::MTSlicer<MDegrainN,MDegrainN,64>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1027 : 
; 1028 :     if (nOverlapX == 0 && nOverlapY == 0)

	cmp	DWORD PTR [esi+108], 0
	jne	SHORT $LN4@process_ch
	cmp	DWORD PTR [esi+112], 0
	jne	SHORT $LN4@process_ch

; 1029 :     {
; 1030 :       slicer.start(

	push	1
	push	0
	push	OFFSET ??$process_chroma_normal_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_normal_slice<2>
	push	esi
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MDegrainN,MDegrainN,64>::start

; 1031 :         nBlkY,
; 1032 :         *this,
; 1033 :         &MDegrainN::process_chroma_normal_slice <P>
; 1034 :       );
; 1035 :       slicer.wait();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait

; 1036 :     }
; 1037 : 
; 1038 :     // Overlap
; 1039 :     else

	jmp	$LN208@process_ch
$LN4@process_ch:
	mov	eax, DWORD PTR [esi+260]
	push	ebx
	cmp	eax, DWORD PTR [esi+264]

; 1040 :     {
; 1041 :       unsigned short * pDstShort = (_dst_short.empty()) ? 0 : &_dst_short[0];

	jne	SHORT $LN29@process_ch
	xor	ebx, ebx
	jmp	SHORT $LN30@process_ch
$LN29@process_ch:
	mov	ebx, eax
$LN30@process_ch:
	mov	eax, DWORD PTR [esi+276]
	cmp	eax, DWORD PTR [esi+280]

; 1042 :       int * pDstInt = (_dst_int.empty()) ? 0 : &_dst_int[0];

	jne	SHORT $LN31@process_ch
	xor	edi, edi
	jmp	SHORT $LN32@process_ch
$LN31@process_ch:
	mov	edi, eax
$LN32@process_ch:

; 1043 : 
; 1044 :       if (_lsb_flag || pixelsize_super > 1)

	cmp	BYTE PTR [esi+186], 0
	jne	SHORT $LN8@process_ch
	cmp	DWORD PTR [esi+192], 1
	jg	SHORT $LN8@process_ch

; 1047 :           reinterpret_cast <unsigned char *> (pDstInt), 0,
; 1048 :           (_covered_width * sizeof(int)) >> _xratiouv_log, _covered_height >> _yratiouv_log,
; 1049 :           0, 0, _dst_int_pitch * sizeof(int)
; 1050 :         );
; 1051 :       }
; 1052 :       else
; 1053 :       {  
; 1054 :         MemZoneSet(

	mov	eax, DWORD PTR [esi+272]
	xor	dl, dl
	mov	ecx, DWORD PTR [esi+204]
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR [esi+3684]
	sub	esp, 8
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	add	eax, eax
	shr	eax, cl
	mov	ecx, ebx
	push	eax
	call	_MemZoneSet
	add	esp, 20					; 00000014H
	jmp	SHORT $LN112@process_ch
$LN8@process_ch:

; 1045 :       {
; 1046 :         MemZoneSet(

	mov	eax, DWORD PTR [esi+288]
	mov	ebx, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	shl	eax, 2
	mov	DWORD PTR _pitch$1$[ebp], eax
	mov	eax, DWORD PTR [esi+3680]
	sar	ebx, cl
	mov	ecx, DWORD PTR [esi+200]
	shl	eax, 2
	shr	eax, cl
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	ebx, ebx
	jle	SHORT $LN112@process_ch
	mov	esi, eax
	npad	4
$LL113@process_ch:

; 106  : 	{
; 107  : 		memset(ptr, value, width);

	push	esi
	push	0
	push	edi
	call	_memset

; 108  : 		ptr += pitch;

	add	edi, DWORD PTR _pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL113@process_ch
	mov	esi, DWORD PTR _this$1$[ebp]
$LN112@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1061 :       if (nOverlapY > 0)

	cmp	DWORD PTR [esi+112], 0
	jle	SHORT $LN9@process_ch
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+3692]
	sub	eax, DWORD PTR [esi+3688]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1063 :         memset(

	and	eax, -4					; fffffffcH
	push	eax
	push	0
	push	DWORD PTR [esi+3688]
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@process_ch:

; 1064 :           &_boundary_cnt_arr[0],
; 1065 :           0,
; 1066 :           _boundary_cnt_arr.size() * sizeof(_boundary_cnt_arr[0])
; 1067 :         );
; 1068 :       }
; 1069 : 
; 1070 :       slicer.start(

	push	2
	push	0
	push	OFFSET ??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ; MDegrainN::process_chroma_overlap_slice<2>
	push	esi
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXHAAVMDegrainN@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MDegrainN,MDegrainN,64>::start

; 1071 :         nBlkY,
; 1072 :         *this,
; 1073 :         &MDegrainN::process_chroma_overlap_slice <P>,
; 1074 :         2
; 1075 :       );
; 1076 :       slicer.wait();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait

; 1077 :       
; 1078 :       if (_lsb_flag)

	cmp	BYTE PTR [esi+186], 0
	je	SHORT $LN10@process_ch

; 1079 :       {
; 1080 :         Short2BytesLsb(

	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edi, DWORD PTR [esi+3628]
	mov	edx, DWORD PTR [esi+3676]
	sar	eax, cl
	add	edx, edi
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	mov	ecx, edi
	push	eax
	push	DWORD PTR [esi+288]
	push	DWORD PTR [esi+276]
	push	DWORD PTR [esi+3652]
	call	?Short2BytesLsb@@YAXPAE0HPAHHHH@Z	; Short2BytesLsb
	add	esp, 20					; 00000014H
	jmp	$LN16@process_ch
$LN10@process_ch:

; 1081 :           _dst_ptr_arr[P],
; 1082 :           _dst_ptr_arr[P] + _lsb_offset_arr[P], // 8 bit only
; 1083 :           _dst_pitch_arr[P],
; 1084 :           &_dst_int[0], _dst_int_pitch,
; 1085 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log
; 1086 :         );
; 1087 :       }
; 1088 :       else if (pixelsize_super == 1)

	mov	eax, DWORD PTR [esi+192]
	cmp	eax, 1
	jne	SHORT $LN12@process_ch

; 1089 :       {
; 1090 :         Short2Bytes(

	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+3652]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+3628]
	push	eax
	push	DWORD PTR [esi+272]
	push	DWORD PTR [esi+260]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes
	jmp	$LN225@process_ch
$LN12@process_ch:

; 1091 :           _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1092 :           &_dst_short[0], _dst_short_pitch,
; 1093 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log
; 1094 :         );
; 1095 :       }
; 1096 :       else if (pixelsize_super == 2)

	cmp	eax, 2
	jne	SHORT $LN14@process_ch

; 1097 :       {
; 1098 :         Short2Bytes_Int32toWord16(

	push	DWORD PTR [esi+196]
	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+3652]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+3628]
	push	eax
	push	DWORD PTR [esi+288]
	push	DWORD PTR [esi+276]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16
	add	esp, 20					; 00000014H
	jmp	SHORT $LN16@process_ch
$LN14@process_ch:

; 1099 :           (uint16_t *)_dst_ptr_arr[P], _dst_pitch_arr[P],
; 1100 :           &_dst_int[0], _dst_int_pitch,
; 1101 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log,
; 1102 :           bits_per_pixel_super
; 1103 :         );
; 1104 :       }
; 1105 :       else if (pixelsize_super == 4)

	cmp	eax, 4
	jne	SHORT $LN16@process_ch

; 1106 :       {
; 1107 :         Short2Bytes_FloatInInt32ArrayToFloat(

	mov	eax, DWORD PTR [esi+3684]
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+3652]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	eax
	mov	eax, DWORD PTR [esi+3680]
	sar	eax, cl
	push	eax
	push	ecx
	push	DWORD PTR [esi+276]
	mov	ecx, DWORD PTR [esi+3628]
	call	?Short2Bytes_FloatInInt32ArrayToFloat@@YAXPAMHPAHHHH@Z ; Short2Bytes_FloatInInt32ArrayToFloat
$LN225@process_ch:
	add	esp, 16					; 00000010H
$LN16@process_ch:

; 1108 :           (float *)_dst_ptr_arr[P], _dst_pitch_arr[P],
; 1109 :           &_dst_int[0], _dst_int_pitch,
; 1110 :           _covered_width >> _xratiouv_log, _covered_height >> _yratiouv_log
; 1111 :         );
; 1112 :       }
; 1113 : 
; 1114 :       if (_covered_width < nWidth)

	mov	edx, DWORD PTR [esi+3680]
	mov	edi, DWORD PTR [esi+92]
	cmp	edx, edi
	jge	SHORT $LN196@process_ch

; 1115 :       {
; 1116 :         BitBlt(

	mov	ebx, DWORD PTR [esi+3684]
	sub	edi, edx
	mov	ecx, DWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+192]
	sar	ebx, cl
	mov	ecx, DWORD PTR [esi+200]
	sar	edx, cl
	imul	edx, eax
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+3628]
	imul	edi, eax
	mov	eax, DWORD PTR [esi+3640]
	add	eax, edx
	add	ecx, edx
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	ebx, ebx
	je	SHORT $LN196@process_ch
	mov	edx, DWORD PTR [esi+3652]
	push	ebx
	push	edi
	push	DWORD PTR [esi+3664]
	push	eax
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN196@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1123 :       if (_covered_height < nHeight) // bottom noncovered region

	mov	edi, DWORD PTR [esi+3684]
	mov	edx, DWORD PTR [esi+96]
	cmp	edi, edx
	jge	SHORT $LN224@process_ch

; 1124 :       {
; 1125 :         BitBlt(

	mov	eax, DWORD PTR [esi+204]
	sub	edx, edi
	mov	ebx, DWORD PTR [esi+92]
	mov	ecx, eax
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+200]
	sar	ebx, cl
	mov	ecx, eax
	imul	ebx, DWORD PTR [esi+192]
	mov	DWORD PTR _row_size$1$[ebp], ebx
	mov	ebx, edi
	imul	ebx, DWORD PTR [esi+3664]
	imul	edi, DWORD PTR [esi+3652]
	sar	ebx, cl
	add	ebx, DWORD PTR [esi+3640]
	sar	edi, cl
	add	edi, DWORD PTR [esi+3628]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edx, edx
	je	SHORT $LN224@process_ch
	push	edx
	push	DWORD PTR _row_size$1$[ebp]
	mov	edx, DWORD PTR [esi+3652]
	mov	ecx, edi
	push	DWORD PTR [esi+3664]
	push	ebx
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN224@process_ch:
	pop	ebx
$LN208@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1134 :     if (pixelsize_super <= 2) {

	mov	edi, DWORD PTR [esi+192]
	cmp	edi, 2
	jg	SHORT $LN27@process_ch

; 1135 :       if (_nlimitc < (1 << bits_per_pixel_super) - 1)

	mov	ecx, DWORD PTR [esi+196]
	mov	eax, 1
	mov	edx, DWORD PTR [esi+176]
	shl	eax, cl
	dec	eax
	cmp	edx, eax
	jge	SHORT $LN27@process_ch

; 1140 :             LimitChanges_sse2_new<uint8_t>(

	mov	eax, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [esi+204]
	sar	eax, cl
	mov	ecx, DWORD PTR [esi+200]
	push	edx
	mov	edx, DWORD PTR [esi+3652]
	push	eax
	mov	eax, DWORD PTR [esi+92]
	sar	eax, cl
	cmp	BYTE PTR [esi+184], 0
	mov	ecx, DWORD PTR [esi+3628]
	push	eax
	push	DWORD PTR [esi+3664]
	push	DWORD PTR [esi+3640]
	je	SHORT $LN22@process_ch

; 1136 :       {
; 1137 :         if (_isse_flag)
; 1138 :         {
; 1139 :           if (pixelsize_super == 1)

	cmp	edi, 1
	jne	SHORT $LN24@process_ch

; 1140 :             LimitChanges_sse2_new<uint8_t>(

	call	??$LimitChanges_sse2_new@E@@YAXPAEHPBEHHHH@Z ; LimitChanges_sse2_new<unsigned char>

; 1141 :               _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1142 :               _src_ptr_arr[P], _src_pitch_arr[P],
; 1143 :               nWidth >> _xratiouv_log, nHeight >> _yratiouv_log,
; 1144 :               _nlimitc
; 1145 :             );
; 1146 :           else // pixelsize_super == 2

	jmp	SHORT $LN226@process_ch
$LN24@process_ch:

; 1147 :             LimitChanges_sse2_new<uint16_t>(

	call	??$LimitChanges_sse2_new@G@@YAXPAEHPBEHHHH@Z ; LimitChanges_sse2_new<unsigned short>

; 1148 :               _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1149 :               _src_ptr_arr[P], _src_pitch_arr[P],
; 1150 :               nWidth >> _xratiouv_log, nHeight >> _yratiouv_log,
; 1151 :               _nlimitc
; 1152 :               );
; 1153 :         }
; 1154 :         else

	jmp	SHORT $LN226@process_ch
$LN22@process_ch:

; 1155 :         {
; 1156 :           if (pixelsize_super == 1)

	cmp	edi, 1
	jne	SHORT $LN26@process_ch

; 1157 :             LimitChanges_c<uint8_t>(

	call	??$LimitChanges_c@E@@YAXPAEHPBEHHHH@Z	; LimitChanges_c<unsigned char>

; 1158 :               _dst_ptr_arr[P], _dst_pitch_arr[P],
; 1159 :               _src_ptr_arr[P], _src_pitch_arr[P],
; 1160 :               nWidth >> _xratiouv_log, nHeight >> _yratiouv_log,
; 1161 :               _nlimitc
; 1162 :               );
; 1163 :           else

	jmp	SHORT $LN226@process_ch
$LN26@process_ch:

; 1164 :             LimitChanges_c<uint16_t>(

	call	??$LimitChanges_c@G@@YAXPAEHPBEHHHH@Z	; LimitChanges_c<unsigned short>
$LN226@process_ch:
	add	esp, 20					; 00000014H
$LN27@process_ch:
; File c:\github\mvtools\sources\mtslicer.hpp

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR _slicer$2[ebp+24], 0
	mov	DWORD PTR _slicer$2[ebp], OFFSET ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@
	pop	edi
	je	SHORT $LN216@process_ch

; 88   : 	{
; 89   : 		wait ();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait
$LN216@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1184 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$process_chroma@$01@MDegrainN@@AAEXH@Z$0:
	lea	ecx, DWORD PTR _slicer$2[ebp]
	jmp	??1?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAE@XZ ; MTSlicer<MDegrainN,MDegrainN,64>::~MTSlicer<MDegrainN,MDegrainN,64>
__unwindfunclet$??$process_chroma@$01@MDegrainN@@AAEXH@Z$43:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$process_chroma@$01@MDegrainN@@AAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$??$process_chroma@$01@MDegrainN@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$process_chroma@$01@MDegrainN@@AAEXH@Z ENDP		; MDegrainN::process_chroma<2>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.hpp
;	COMDAT ??0?$AioAdd@H@conc@@QAE@H@Z
_TEXT	SEGMENT
_operand$ = 8						; size = 4
??0?$AioAdd@H@conc@@QAE@H@Z PROC			; conc::AioAdd<int>::AioAdd<int>, COMDAT
; _this$ = ecx

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR _operand$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 40   : 	// Nothing
; 41   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$AioAdd@H@conc@@6B@
	ret	4
??0?$AioAdd@H@conc@@QAE@H@Z ENDP			; conc::AioAdd<int>::AioAdd<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_new@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@@Z
_TEXT	SEGMENT
??$exec_new@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@@Z PROC ; conc::AtomicIntOp::exec_new<int,conc::AioAdd<int> const >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 68   : {

	push	ebx
	push	esi
	mov	ebx, edx
	mov	edx, ecx
	push	edi
$LL6@exec_new:

; 90   : 		val_cur = atom;

	mov	edi, DWORD PTR [edx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	mov	esi, DWORD PTR [ebx+4]
	add	esi, edi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, esi
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edi
	jne	SHORT $LL6@exec_new

; 69   : 	assert (&atom != 0);
; 70   : 	assert (&ftor != 0);
; 71   : 
; 72   : 	T					val_new;
; 73   : 	T					val_old;
; 74   : 	exec_both (atom, ftor, val_old, val_new);
; 75   : 
; 76   : 	return (val_new);

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 77   : }

	ret	0
??$exec_new@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAHAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@@Z ENDP ; conc::AtomicIntOp::exec_new<int,conc::AioAdd<int> const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::try_emplace<>, COMDAT
; _this$ = ecx

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp-4]
	push	DWORD PTR ___$ReturnUdt$[esp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 245  : 			_STD forward<_Mappedty>(_Mapval)...));
; 246  : 		}

	ret	8
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::try_emplace<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ecx

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Uninitialized_default_fill_n@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<int *,unsigned int,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,
; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	ret	0
??$_Uninitialized_default_fill_n@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<int *,unsigned int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<unsigned short *,unsigned int,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx+edx]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,
; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	ret	0
??$_Uninitialized_default_fill_n@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<unsigned short *,unsigned int,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ecx

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Uninitialized_default_fill_n@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >,std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@G@std@@@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned short> >,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z PROC ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAV?$AtomicInt@H@conc@@@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEPAV?$AtomicInt@H@conc@@PAV23@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$AtomicInt@H@conc@@@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEPAV?$AtomicInt@H@conc@@PAV23@00@Z PROC ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Umove<conc::AtomicInt<int> *>, COMDAT
; _this$dead$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Ptr$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
??$_Umove@PAV?$AtomicInt@H@conc@@@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@IAEPAV?$AtomicInt@H@conc@@PAV23@00@Z ENDP ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::_Umove<conc::AtomicInt<int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<conc::AtomicInt<int> >,conc::AtomicInt<int> *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<conc::AtomicInt<int> >,conc::AtomicInt<int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[esp-4]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Ptr$[esp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<int>,int *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<int>,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[esp-4]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Ptr$[esp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	ret	12					; 0000000cH
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short>,unsigned short *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short>,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAVMvClipInfo@MDegrainN@@@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEPAVMvClipInfo@MDegrainN@@PAV23@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVMvClipInfo@MDegrainN@@@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEPAVMvClipInfo@MDegrainN@@PAV23@00@Z PROC ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Umove<MDegrainN::MvClipInfo *>, COMDAT
; _this$dead$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Ptr$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
??$_Umove@PAVMvClipInfo@MDegrainN@@@?$vector@VMvClipInfo@MDegrainN@@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@IAEPAVMvClipInfo@MDegrainN@@PAV23@00@Z ENDP ; std::vector<MDegrainN::MvClipInfo,std::allocator<MDegrainN::MvClipInfo> >::_Umove<MDegrainN::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MDegrainN::MvClipInfo>,MDegrainN::MvClipInfo *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra
	npad	6
$LL6@Destroy_ra:
	mov	ecx, esi
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL6@Destroy_ra
$LN5@Destroy_ra:
	pop	edi
	pop	esi

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MDegrainN::MvClipInfo>,MDegrainN::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z PROC	; MTSlicer<MDegrainN,MDegrainN,64>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VMDegrainN@@V1@$0EA@@@6B@
	je	SHORT $LN5@scalar

; 88   : 	{
; 89   : 		wait ();

	call	?wait@?$MTSlicer@VMDegrainN@@V1@$0EA@@@QAEXXZ ; MTSlicer<MDegrainN,MDegrainN,64>::wait
$LN5@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	push	1056					; 00000420H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$MTSlicer@VMDegrainN@@V1@$0EA@@@UAEPAXI@Z ENDP	; MTSlicer<MDegrainN,MDegrainN,64>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?access@?$MTSlicer_Access@VMDegrainN@@V1@@@SAPAVMDegrainN@@PAV2@@Z
_TEXT	SEGMENT
?access@?$MTSlicer_Access@VMDegrainN@@V1@@@SAPAVMDegrainN@@PAV2@@Z PROC ; MTSlicer_Access<MDegrainN,MDegrainN>::access, COMDAT
; _ptr$ = ecx

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	eax, ecx
	ret	0
?access@?$MTSlicer_Access@VMDegrainN@@V1@@@SAPAVMDegrainN@@PAV2@@Z ENDP ; MTSlicer_Access<MDegrainN,MDegrainN>::access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >::_Vector_val<std::_Simple_types<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned short> >::_Wrap_alloc<std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned short> >::_Wrap_alloc<std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr_ref@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z PROC ; std::auto_ptr_ref<OverlapWindows>::auto_ptr_ref<OverlapWindows>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [ecx], eax

; 684  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr_ref@VOverlapWindows@@@std@@QAE@PAVOverlapWindows@@@Z ENDP ; std::auto_ptr_ref<OverlapWindows>::auto_ptr_ref<OverlapWindows>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr_ref@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z PROC ; std::auto_ptr_ref<YUY2Planes>::auto_ptr_ref<YUY2Planes>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [ecx], eax

; 684  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr_ref@VYUY2Planes@@@std@@QAE@PAVYUY2Planes@@@Z ENDP ; std::auto_ptr_ref<YUY2Planes>::auto_ptr_ref<YUY2Planes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >::_Vector_val<std::_Simple_types<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$AtomicInt@H@conc@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$AtomicInt@H@conc@@@std@@QAE@XZ PROC	; std::allocator<conc::AtomicInt<int> >::allocator<conc::AtomicInt<int> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@V?$AtomicInt@H@conc@@@std@@QAE@XZ ENDP	; std::allocator<conc::AtomicInt<int> >::allocator<conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@G@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@G@std@@QAE@XZ PROC			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@G@std@@QAE@XZ ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VMvClipInfo@MDegrainN@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VMvClipInfo@MDegrainN@@@std@@QAE@XZ PROC	; std::allocator<MDegrainN::MvClipInfo>::allocator<MDegrainN::MvClipInfo>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@VMvClipInfo@MDegrainN@@@std@@QAE@XZ ENDP	; std::allocator<MDegrainN::MvClipInfo>::allocator<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ?add_ref@?$SharedPtr@VMVClip@@@@AAEXXZ
_TEXT	SEGMENT
?add_ref@?$SharedPtr@VMVClip@@@@AAEXXZ PROC		; SharedPtr<MVClip>::add_ref, COMDAT
; _this$ = ecx

; 259  : 	if (_count_ptr != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@add_ref

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN2@add_ref:

; 262  : 	}
; 263  : }

	ret	0
?add_ref@?$SharedPtr@VMVClip@@@@AAEXXZ ENDP		; SharedPtr<MVClip>::add_ref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ?destroy_complete@?$SharedPtr@VMVClip@@@@AAEXXZ
_TEXT	SEGMENT
?destroy_complete@?$SharedPtr@VMVClip@@@@AAEXXZ PROC	; SharedPtr<MVClip>::destroy_complete, COMDAT
; _this$ = ecx

; 281  : {

	push	esi
	mov	esi, ecx

; 282  : 	assert (is_valid ());
; 283  : 
; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN3@destroy_co

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@destroy_co

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@destroy_co
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN5@destroy_co:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN3@destroy_co:
	pop	esi

; 295  : 		}
; 296  : 	}
; 297  : }

	ret	0
?destroy_complete@?$SharedPtr@VMVClip@@@@AAEXXZ ENDP	; SharedPtr<MVClip>::destroy_complete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ?add_ref@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ
_TEXT	SEGMENT
?add_ref@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ PROC	; SharedPtr<MVGroupOfFrames>::add_ref, COMDAT
; _this$ = ecx

; 259  : 	if (_count_ptr != 0)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@add_ref

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN2@add_ref:

; 262  : 	}
; 263  : }

	ret	0
?add_ref@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ ENDP	; SharedPtr<MVGroupOfFrames>::add_ref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ?destroy_complete@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ
_TEXT	SEGMENT
?destroy_complete@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ PROC ; SharedPtr<MVGroupOfFrames>::destroy_complete, COMDAT
; _this$ = ecx

; 281  : {

	push	esi
	mov	esi, ecx

; 282  : 	assert (is_valid ());
; 283  : 
; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN3@destroy_co

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@destroy_co

; 289  : 		{
; 290  : 			delete _obj_ptr;

	push	edi
	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN8@destroy_co
	mov	ecx, edi
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@destroy_co:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
	pop	edi
$LN3@destroy_co:
	pop	esi

; 295  : 		}
; 296  : 	}
; 297  : }

	ret	0
?destroy_complete@?$SharedPtr@VMVGroupOfFrames@@@@AAEXXZ ENDP ; SharedPtr<MVGroupOfFrames>::destroy_complete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?redirect_task@?$MTSlicer@VMDegrainN@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z
_TEXT	SEGMENT
_dispatcher_ptr$ = 8					; size = 4
_data_ptr$ = 12						; size = 4
?redirect_task@?$MTSlicer@VMDegrainN@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z PROC ; MTSlicer<MDegrainN,MDegrainN,64>::redirect_task, COMDAT

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	ecx, DWORD PTR _data_ptr$[esp-4]
	push	esi

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	push	ecx
	mov	eax, DWORD PTR [ecx+4]

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	edx, DWORD PTR [ecx]

; 268  : 	TaskData *		td_ptr   = reinterpret_cast <TaskData *> (data_ptr);
; 269  : 	assert (td_ptr != 0);
; 270  : 	assert (td_ptr->_glob_data_ptr != 0);
; 271  : 	assert (td_ptr->_slicer_ptr != 0);
; 272  : 
; 273  : 	T *				this_ptr =
; 274  : 		MTSlicer_Access <T, GD>::access (td_ptr->_glob_data_ptr);
; 275  : 	assert (this_ptr != 0);
; 276  : 
; 277  : 	ProcPtr			proc_ptr = td_ptr->_slicer_ptr->_proc_ptr;

	mov	esi, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	lea	ecx, DWORD PTR [eax+edx]
	call	esi
	pop	esi

; 281  : }

	ret	0
?redirect_task@?$MTSlicer@VMDegrainN@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ENDP ; MTSlicer<MDegrainN,MDegrainN,64>::redirect_task
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@VTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@VTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@J@Z PROC ; conc::Array<MTSlicer<MDegrainN,MDegrainN,64>::TaskData,64>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	shl	eax, 4
	add	eax, ecx

; 56   : }

	ret	4
??A?$Array@VTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@J@Z ENDP ; conc::Array<MTSlicer<MDegrainN,MDegrainN,64>::TaskData,64>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma_normal_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_pDstCur$1$ = -3164					; size = 4
_pSrcCur$1$ = -3160					; size = 4
_xx$1$ = -3156						; size = 4
_dstp$1$ = -3152					; size = 4
_dst_pitch$1$ = -3152					; size = 4
_k$1$ = -3152						; size = 4
_src_pitch$1$ = -3148					; size = 4
_y$1$ = -3148						; size = 4
tv1079 = -3148						; size = 4
_dst_pitch$1$ = -3144					; size = 4
_src_pitch$1$ = -3144					; size = 4
$T1 = -3144						; size = 4
tv1163 = -3140						; size = 4
_srcp$1$ = -3136					; size = 4
_dstp$1$ = -3136					; size = 4
_i$1$ = -3136						; size = 4
_this$1$ = -3132					; size = 4
_by$1$ = -3128						; size = 4
tv1165 = -3124						; size = 4
_bx$1$ = -3120						; size = 4
_effective_nDstPitch$1$ = -3116				; size = 4
_rowsize$1$ = -3112					; size = 4
_effective_nSrcPitch$1$ = -3108				; size = 4
$T2 = -3104						; size = 12
$T3 = -3092						; size = 12
_weight_arr$4 = -3080					; size = 1028
_pitch_arr$5 = -2048					; size = 1024
_ref_data_ptr_arr$6 = -1024				; size = 1024
_td$ = 8						; size = 4
??$process_chroma_normal_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z PROC ; MDegrainN::process_chroma_normal_slice<1>, COMDAT
; _this$ = ecx

; 1388 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 3164				; 00000c5cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$1$[esp+3176], esi

; 1389 :   assert(&td != 0);
; 1390 :   const int rowsize = nBlkSizeY >> _yratiouv_log; // bad name. it's height really

	mov	eax, DWORD PTR [esi+80]
	mov	ecx, DWORD PTR [esi+204]

; 1391 :   BYTE *pDstCur = _dst_ptr_arr[P] + td._y_beg * rowsize * _dst_pitch_arr[P];

	mov	edx, DWORD PTR [esi+3648]

; 1392 :   const BYTE *pSrcCur = _src_ptr_arr[P] + td._y_beg * rowsize * _src_pitch_arr[P];

	mov	edi, DWORD PTR [esi+3660]
	sar	eax, cl
	mov	ecx, DWORD PTR _td$[ebp]
	mov	DWORD PTR _effective_nDstPitch$1$[esp+3176], edx
	mov	DWORD PTR _rowsize$1$[esp+3176], eax
	mov	ebx, DWORD PTR [ecx+8]
	mov	ecx, ebx
	imul	ecx, edx
	mov	edx, edi

; 1393 : 
; 1394 :   int effective_nSrcPitch = (nBlkSizeY >> _yratiouv_log) * _src_pitch_arr[P]; // pitch is byte granularity

	imul	edi, eax
	imul	edx, ebx
	mov	DWORD PTR _by$1$[esp+3176], ebx
	imul	ecx, eax
	mov	DWORD PTR _effective_nSrcPitch$1$[esp+3176], edi

; 1395 :   int effective_nDstPitch = (nBlkSizeY >> _yratiouv_log) * _dst_pitch_arr[P]; // pitch is short granularity

	mov	edi, DWORD PTR _effective_nDstPitch$1$[esp+3176]
	imul	edx, eax
	imul	edi, eax

; 1397 :   for (int by = td._y_beg; by < td._y_end; ++by)

	mov	eax, DWORD PTR _td$[ebp]
	add	ecx, DWORD PTR [esi+3624]
	mov	DWORD PTR _pDstCur$1$[esp+3176], ecx
	add	edx, DWORD PTR [esi+3636]
	mov	DWORD PTR _pSrcCur$1$[esp+3176], edx
	mov	DWORD PTR _effective_nDstPitch$1$[esp+3176], edi
	cmp	ebx, DWORD PTR [eax+12]
	jge	$LN3@process_ch

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	movss	xmm3, DWORD PTR __real@43800000
$LL4@process_ch:

; 1398 :   {
; 1399 :     int xx = 0; // index
; 1400 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	ebx, DWORD PTR [esi+64]
	xor	edi, edi
	xor	eax, eax
	mov	DWORD PTR _xx$1$[esp+3176], edi
	mov	DWORD PTR _bx$1$[esp+3176], eax
	test	ebx, ebx
	jle	$LN6@process_ch
	npad	1
$LL7@process_ch:

; 1401 :     {
; 1402 :       int i = by * nBlkX + bx;

	imul	ebx, DWORD PTR _by$1$[esp+3176]

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	xor	ecx, ecx
	mov	DWORD PTR _k$1$[esp+3176], ecx
	add	ebx, eax
	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+3176], ebx
	mov	DWORD PTR $T1[esp+3176], eax
	test	eax, eax
	jle	$LN9@process_ch

; 1408 :       {
; 1409 :         use_block_uv(

	mov	edi, DWORD PTR $T1[esp+3176]
	lea	edx, DWORD PTR [esi+552]
	xor	eax, eax
	mov	DWORD PTR tv1163[esp+3176], edx
	mov	DWORD PTR tv1165[esp+3176], eax
	npad	7
$LL10@process_ch:

; 1636 :   if (usable_flag)

	cmp	BYTE PTR [esi+ecx+292], 0

; 1408 :       {
; 1409 :         use_block_uv(

	mov	edx, DWORD PTR [edx]

; 1636 :   if (usable_flag)

	je	$LN27@process_ch
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	ecx, DWORD PTR [esi+152]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	edi, DWORD PTR [ebx+ebx*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv1079[esp+3176], ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [ecx+edi*4+4]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+edi*4+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	imul	ebx, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+204]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[esp+3176], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T2[esp+3176], xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	add	ebx, DWORD PTR $T2[esp+3180]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	sar	ebx, cl
	mov	ecx, DWORD PTR tv1079[esp+3176]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1639 :     const int blx = block.GetX() * nPel + block.GetMV().x;

	mov	edi, DWORD PTR [ecx+edi*4]
	imul	edi, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+200]
	add	edi, DWORD PTR $T3[esp+3176]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [edx+28]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN49@process_ch

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebx
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN52@process_ch
$LN49@process_ch:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN51@process_ch

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	esi, esi
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 1
	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN119@process_ch
$LN51@process_ch:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	esi, 2
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 2
	sar	ebx, 2
$LN119@process_ch:
	mov	edi, DWORD PTR tv1163[esp+3176]
	mov	ecx, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR tv1163[esp+3176]
	mov	esi, DWORD PTR _this$1$[esp+3176]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	add	edi, edx
	mov	edx, DWORD PTR [eax]
	imul	ebx, DWORD PTR [edx+12]
	add	edi, ebx
$LN52@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR _k$1$[esp+3176]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	ebx, DWORD PTR _i$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+3176], edi

; 1642 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	lea	edi, DWORD PTR [ebx+ebx*4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	edx, DWORD PTR tv1165[esp+3176]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+3176], eax
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv1079[esp+3176]
	mov	edi, DWORD PTR [eax+edi*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR [esi+152]
	mov	edx, DWORD PTR [eax+edx+20]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	edx, edi
	jg	SHORT $LN65@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	eax, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax

; 1646 :   else

	jmp	$LN8@process_ch
$LN65@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [esi+140], 8
	jg	SHORT $LN66@process_ch

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	edx, edx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edi, edi

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, edx
	sub	eax, edi

; 921  :     const int den = thSAD2 + blockSAD2;

	add	edi, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN69@process_ch
	shl	eax, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax
	jmp	SHORT $LN8@process_ch
$LN69@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	edi, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax
	jmp	SHORT $LN8@process_ch
$LN66@process_ch:
	movd	xmm2, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
	movd	xmm1, edi

; 935  :                                                         // smart compiler makes x*x, VS2015 calls __libm_sse2_pow_precise, way too slow
; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	mulss	xmm2, xmm2

; 935  :                                                         // smart compiler makes x*x, VS2015 calls __libm_sse2_pow_precise, way too slow
; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, xmm3
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax

; 1646 :   else

	jmp	SHORT $LN8@process_ch
$LN27@process_ch:

; 1408 :       {
; 1409 :         use_block_uv(

	mov	eax, DWORD PTR [esi+192]
	imul	eax, DWORD PTR _xx$1$[esp+3176]

; 1650 :     wref = 0;

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], 0
	add	eax, DWORD PTR _pSrcCur$1$[esp+3176]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+3176], eax
	mov	eax, DWORD PTR [esi+3660]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+3176], eax
$LN8@process_ch:

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	mov	edx, DWORD PTR tv1163[esp+3176]
	inc	ecx
	mov	eax, DWORD PTR tv1165[esp+3176]
	add	edx, 12					; 0000000cH
	add	eax, 24					; 00000018H
	mov	DWORD PTR _k$1$[esp+3176], ecx
	mov	DWORD PTR tv1163[esp+3176], edx
	mov	DWORD PTR tv1165[esp+3176], eax
	cmp	ecx, edi
	jl	$LL10@process_ch
	mov	edi, DWORD PTR _xx$1$[esp+3176]
$LN9@process_ch:

; 1410 :           ref_data_ptr_arr[k],
; 1411 :           pitch_arr[k],
; 1412 :           weight_arr[k + 1],
; 1413 :           _usable_flag_arr[k],
; 1414 :           _mv_clip_arr[k],
; 1415 :           i,
; 1416 :           _planes_ptr[k][P],
; 1417 :           pSrcCur,
; 1418 :           xx*pixelsize_super, // the pointer increment inside knows that xx later here is incremented with nBlkSize and not nBlkSize>>_xRatioUV
; 1419 :               // todo: copy from MDegrainX. Here we shift, and incement with nBlkSize>>_xRatioUV
; 1420 :           _src_pitch_arr[P]
; 1421 :         ); // vs: extra nLogPel, plane, xSubUV, ySubUV, thSAD
; 1422 :       }
; 1423 : 
; 1424 :       norm_weights(weight_arr, _trad); // normaliseWeights<radius>(WSrc, WRefs);

	mov	ebx, DWORD PTR [esi+164]
	lea	ecx, DWORD PTR _weight_arr$4[esp+3176]
	mov	edx, ebx
	call	?norm_weights@MDegrainN@@CAXQAHH@Z	; MDegrainN::norm_weights

; 1425 : 
; 1426 : 
; 1427 :       // chroma
; 1428 :       _degrainchroma_ptr(

	mov	ecx, DWORD PTR [esi+192]
	lea	eax, DWORD PTR _weight_arr$4[esp+3176]
	mov	edx, DWORD PTR _pDstCur$1$[esp+3176]
	push	ebx
	push	eax
	imul	ecx, edi
	lea	eax, DWORD PTR _pitch_arr$5[esp+3184]
	push	eax
	lea	eax, DWORD PTR _ref_data_ptr_arr$6[esp+3188]
	push	eax
	push	DWORD PTR [esi+3660]
	mov	eax, DWORD PTR _pSrcCur$1$[esp+3196]
	add	eax, ecx
	push	eax
	push	DWORD PTR [esi+3648]
	movzx	eax, BYTE PTR [esi+186]
	push	eax
	mov	eax, DWORD PTR [esi+3672]
	add	eax, ecx
	add	eax, edx
	push	eax
	lea	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax

; 1429 :         pDstCur + xx * pixelsize_super,
; 1430 :         pDstCur + xx * pixelsize_super + _lsb_offset_arr[P], _lsb_flag, _dst_pitch_arr[P],
; 1431 :         pSrcCur + xx * pixelsize_super, _src_pitch_arr[P],
; 1432 :         ref_data_ptr_arr, pitch_arr, weight_arr, _trad
; 1433 :       );
; 1434 : 
; 1435 :       if (nLogxRatioUV != _xratiouv_log)

	mov	ecx, DWORD PTR [esi+128]
	add	esp, 40					; 00000028H
	mov	ebx, DWORD PTR [esi+200]
	cmp	ecx, ebx
	je	SHORT $LN11@process_ch

; 1436 :       //xx += nBlkSizeX; // blksize of Y plane, that's why there is xx >> xRatioUVlog above
; 1437 :       xx += (nBlkSizeX >> nLogxRatioUV); // xx: indexing offset

	mov	eax, DWORD PTR [esi+76]
	sar	eax, cl
	add	edi, eax
	mov	DWORD PTR _xx$1$[esp+3176], edi
$LN11@process_ch:

; 1438 : 
; 1439 :       if (bx == nBlkX - 1 && _covered_width < nWidth) // right non-covered region

	mov	eax, DWORD PTR [esi+64]
	dec	eax
	cmp	DWORD PTR _bx$1$[esp+3176], eax
	jne	$LN118@process_ch
	mov	edx, DWORD PTR [esi+3680]
	mov	edi, DWORD PTR [esi+92]
	cmp	edx, edi
	jge	$LN111@process_ch

; 1442 :         BitBlt(

	mov	eax, DWORD PTR [esi+192]
	sub	edi, edx
	mov	ecx, ebx
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+3660]
	mov	DWORD PTR _src_pitch$1$[esp+3176], ecx
	mov	ecx, ebx
	mov	ebx, DWORD PTR _pSrcCur$1$[esp+3176]
	sar	edx, cl
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
	imul	edx, eax
	imul	edi, eax
	mov	eax, DWORD PTR [esi+3648]
	mov	DWORD PTR _dst_pitch$1$[esp+3176], eax
	add	ebx, edx
	lea	eax, DWORD PTR [edx+ecx]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	edx, DWORD PTR _rowsize$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1442 :         BitBlt(

	mov	DWORD PTR _dstp$1$[esp+3176], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edx, edx
	je	$LN113@process_ch
	test	edi, edi
	je	$LN113@process_ch

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	edx, 1
	je	$LN79@process_ch
	mov	ecx, DWORD PTR _src_pitch$1$[esp+3176]
	cmp	DWORD PTR _dst_pitch$1$[esp+3176], ecx
	jne	SHORT $LN77@process_ch
	cmp	ecx, edi
	je	$LN79@process_ch
$LN77@process_ch:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	mov	DWORD PTR _y$1$[esp+3176], edx
	test	edx, edx
	jle	SHORT $LN111@process_ch
	mov	esi, DWORD PTR _dstp$1$[esp+3176]
	npad	1
$LL74@process_ch:

; 94   :       memcpy(dstp, srcp, row_size);

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	mov	eax, DWORD PTR _y$1$[esp+3188]
	add	esp, 12					; 0000000cH

; 95   :       dstp += dst_pitch;

	add	esi, DWORD PTR _dst_pitch$1$[esp+3176]
	dec	eax

; 96   :       srcp += src_pitch;

	add	ebx, DWORD PTR _src_pitch$1$[esp+3176]
	mov	DWORD PTR _y$1$[esp+3176], eax
	test	eax, eax
	jg	SHORT $LL74@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	mov	esi, DWORD PTR _this$1$[esp+3176]
$LN111@process_ch:
	mov	edi, DWORD PTR _xx$1$[esp+3176]
$LN118@process_ch:
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
$LN5@process_ch:

; 1398 :   {
; 1399 :     int xx = 0; // index
; 1400 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	eax, DWORD PTR _bx$1$[esp+3176]
	mov	ebx, DWORD PTR [esi+64]
	inc	eax
	movss	xmm3, DWORD PTR __real@43800000
	mov	DWORD PTR _bx$1$[esp+3176], eax
	cmp	eax, ebx
	jl	$LL7@process_ch
	mov	edx, DWORD PTR _pSrcCur$1$[esp+3176]
$LN6@process_ch:

; 1443 :           pDstCur + (_covered_width >> _xratiouv_log) * pixelsize_super, _dst_pitch_arr[P],
; 1444 :           pSrcCur + (_covered_width >> _xratiouv_log) * pixelsize_super, _src_pitch_arr[P],
; 1445 :           ((nWidth - _covered_width) >> _xratiouv_log) * pixelsize_super /* real row_size */, rowsize /* bad name. it's height = nBlkSizeY >> _yratiouv_log*/,
; 1446 :           _isse_flag
; 1447 :         );
; 1448 :       }
; 1449 :     } // for bx
; 1450 : 
; 1451 :     pDstCur += effective_nDstPitch;
; 1452 :     pSrcCur += effective_nSrcPitch;
; 1453 : 
; 1454 :     if (by == nBlkY - 1 && _covered_height < nHeight) // bottom uncovered region

	mov	eax, DWORD PTR [esi+68]
	add	ecx, DWORD PTR _effective_nDstPitch$1$[esp+3176]
	dec	eax
	add	edx, DWORD PTR _effective_nSrcPitch$1$[esp+3176]
	mov	DWORD PTR _pDstCur$1$[esp+3176], ecx
	mov	DWORD PTR _pSrcCur$1$[esp+3176], edx
	cmp	DWORD PTR _by$1$[esp+3176], eax
	jne	$LN2@process_ch
	mov	eax, DWORD PTR [esi+3684]
	mov	edi, DWORD PTR [esi+96]
	cmp	eax, edi
	jge	$LN2@process_ch

; 1455 :     {
; 1456 :       // chroma
; 1457 :       BitBlt(

	mov	ecx, DWORD PTR [esi+204]
	sub	edi, eax
	mov	ebx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR _pDstCur$1$[esp+3176]
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+200]
	sar	ebx, cl
	imul	ebx, DWORD PTR [esi+192]
	mov	ecx, DWORD PTR [esi+3660]
	mov	DWORD PTR _srcp$1$[esp+3176], edx
	mov	edx, DWORD PTR [esi+3648]
	mov	DWORD PTR _src_pitch$1$[esp+3176], ecx
	mov	DWORD PTR _dst_pitch$1$[esp+3176], edx
	mov	DWORD PTR _dstp$1$[esp+3176], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edi, edi
	je	SHORT $LN117@process_ch
	test	ebx, ebx
	je	SHORT $LN117@process_ch

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	edi, 1
	je	SHORT $LN89@process_ch
	cmp	edx, ecx
	jne	SHORT $LN87@process_ch
	cmp	ecx, ebx
	je	SHORT $LN89@process_ch
$LN87@process_ch:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	test	edi, edi
	jle	SHORT $LN117@process_ch
	mov	esi, DWORD PTR _srcp$1$[esp+3176]
$LL84@process_ch:

; 94   :       memcpy(dstp, srcp, row_size);

	push	ebx
	push	esi
	push	eax
	call	_memcpy

; 95   :       dstp += dst_pitch;

	mov	eax, DWORD PTR _dstp$1$[esp+3188]
	dec	edi
	add	eax, DWORD PTR _dst_pitch$1$[esp+3188]
	add	esp, 12					; 0000000cH

; 96   :       srcp += src_pitch;

	add	esi, DWORD PTR _src_pitch$1$[esp+3176]
	mov	DWORD PTR _dstp$1$[esp+3176], eax
	test	edi, edi
	jg	SHORT $LL84@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	mov	esi, DWORD PTR _this$1$[esp+3176]
	jmp	SHORT $LN117@process_ch
$LN79@process_ch:
; File c:\github\mvtools\sources\copycode.cpp

; 91   :     memcpy(dstp, srcp, row_size*height); // Fizick: fixed bug

	imul	edi, edx
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	$LN111@process_ch
$LN113@process_ch:
	mov	edi, DWORD PTR _xx$1$[esp+3176]
	jmp	$LN5@process_ch
$LN89@process_ch:
	imul	ebx, edi
	push	ebx
	push	DWORD PTR _pSrcCur$1$[esp+3180]
	push	DWORD PTR _pDstCur$1$[esp+3184]
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN117@process_ch:
	mov	edx, DWORD PTR _pSrcCur$1$[esp+3176]
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
$LN2@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1397 :   for (int by = td._y_beg; by < td._y_end; ++by)

	mov	eax, DWORD PTR _by$1$[esp+3176]
	mov	ebx, DWORD PTR _td$[ebp]
	inc	eax
	movss	xmm3, DWORD PTR __real@43800000
	mov	DWORD PTR _by$1$[esp+3176], eax
	cmp	eax, DWORD PTR [ebx+12]
	jl	$LL4@process_ch
$LN3@process_ch:

; 1458 :         pDstCur, _dst_pitch_arr[P],
; 1459 :         pSrcCur, _src_pitch_arr[P],
; 1460 :         (nWidth >> _xratiouv_log)*pixelsize_super, (nHeight - _covered_height) >> _yratiouv_log /* height */,
; 1461 :         _isse_flag
; 1462 :       );
; 1463 :     }
; 1464 :   } // for by
; 1465 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$process_chroma_normal_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ENDP ; MDegrainN::process_chroma_normal_slice<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_inc_ftor$2 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_td$ = 8						; size = 4
??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z PROC ; MDegrainN::process_chroma_overlap_slice<1>, COMDAT
; _this$ = ecx

; 1471 : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi

; 1472 :   assert(&td != 0);
; 1473 : 
; 1474 :   if (nOverlapY == 0
; 1475 :     || (td._y_beg == 0 && td._y_end == nBlkY))

	mov	esi, DWORD PTR _td$[ebp]
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [edi+112], 0
	je	$LN4@process_ch
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	jne	SHORT $LN2@process_ch
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [edi+68]
	je	$LN4@process_ch
$LN2@process_ch:

; 1478 :   }
; 1479 : 
; 1480 :   else
; 1481 :   {
; 1482 :     assert(td._y_end - td._y_beg >= 2);
; 1483 : 
; 1484 :     process_chroma_overlap_slice <P>(td._y_beg, td._y_end - 1);

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	push	eax
	push	ecx
	mov	ecx, edi
	call	??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<1>
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _inc_ftor$2[ebp], OFFSET ??_7?$AioAdd@H@conc@@6B@

; 38   : :	_operand (operand)

	mov	DWORD PTR _inc_ftor$2[ebp+4], 1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1486 :     const conc::AioAdd <int> inc_ftor(+1);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+3688]
	push	ebx
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	2
$LL28@process_ch:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL28@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1492 :     if (td._y_beg > 0 && cnt_top == 2)

	mov	esi, DWORD PTR _td$[ebp]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jle	SHORT $LN5@process_ch
	cmp	ebx, 2
	jne	SHORT $LN5@process_ch

; 1493 :     {
; 1494 :       process_chroma_overlap_slice <P>(td._y_beg - 1, td._y_beg);

	push	eax
	dec	eax
	mov	ecx, edi
	push	eax
	call	??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<1>
$LN5@process_ch:

; 1495 :     }
; 1496 : 
; 1497 :     int				cnt_bot = 2;
; 1498 :     if (td._y_end < nBlkY)

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, DWORD PTR [edi+68]
	jge	SHORT $LN77@process_ch
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [edi+3688]
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	5
$LL56@process_ch:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL56@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1505 :     if (cnt_bot == 2)

	mov	esi, DWORD PTR _td$[ebp]
	cmp	ebx, 2
	jne	SHORT $LN79@process_ch
$LN77@process_ch:

; 1506 :     {
; 1507 :       process_chroma_overlap_slice <P>(td._y_end - 1, td._y_end);

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, edi
	push	eax
	dec	eax
	push	eax
	call	??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<1>
$LN79@process_ch:
	pop	ebx
	pop	edi
	pop	esi

; 1508 :     }
; 1509 :   }
; 1510 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@process_ch:

; 1476 :   {
; 1477 :     process_chroma_overlap_slice <P>(td._y_beg, td._y_end);

	push	DWORD PTR [esi+12]
	mov	ecx, edi
	push	DWORD PTR [esi+8]
	call	??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<1>

; 1508 :     }
; 1509 :   }
; 1510 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z$0:
	lea	ecx, DWORD PTR _inc_ftor$2[ebp]
	jmp	??1?$AioAdd@H@conc@@UAE@XZ		; conc::AioAdd<int>::~AioAdd<int>
__ehhandler$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ENDP ; MDegrainN::process_chroma_overlap_slice<1>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma_normal_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_pDstCur$1$ = -3164					; size = 4
_pSrcCur$1$ = -3160					; size = 4
_xx$1$ = -3156						; size = 4
_dstp$1$ = -3152					; size = 4
_dst_pitch$1$ = -3152					; size = 4
_k$1$ = -3152						; size = 4
_src_pitch$1$ = -3148					; size = 4
_y$1$ = -3148						; size = 4
tv1076 = -3148						; size = 4
_dst_pitch$1$ = -3144					; size = 4
_src_pitch$1$ = -3144					; size = 4
$T1 = -3144						; size = 4
tv1160 = -3140						; size = 4
_srcp$1$ = -3136					; size = 4
_dstp$1$ = -3136					; size = 4
_i$1$ = -3136						; size = 4
_this$1$ = -3132					; size = 4
_by$1$ = -3128						; size = 4
tv1162 = -3124						; size = 4
_bx$1$ = -3120						; size = 4
_effective_nDstPitch$1$ = -3116				; size = 4
_rowsize$1$ = -3112					; size = 4
_effective_nSrcPitch$1$ = -3108				; size = 4
$T2 = -3104						; size = 12
$T3 = -3092						; size = 12
_weight_arr$4 = -3080					; size = 1028
_pitch_arr$5 = -2048					; size = 1024
_ref_data_ptr_arr$6 = -1024				; size = 1024
_td$ = 8						; size = 4
??$process_chroma_normal_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z PROC ; MDegrainN::process_chroma_normal_slice<2>, COMDAT
; _this$ = ecx

; 1388 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 3164				; 00000c5cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$1$[esp+3176], esi

; 1389 :   assert(&td != 0);
; 1390 :   const int rowsize = nBlkSizeY >> _yratiouv_log; // bad name. it's height really

	mov	eax, DWORD PTR [esi+80]
	mov	ecx, DWORD PTR [esi+204]

; 1391 :   BYTE *pDstCur = _dst_ptr_arr[P] + td._y_beg * rowsize * _dst_pitch_arr[P];

	mov	edx, DWORD PTR [esi+3652]

; 1392 :   const BYTE *pSrcCur = _src_ptr_arr[P] + td._y_beg * rowsize * _src_pitch_arr[P];

	mov	edi, DWORD PTR [esi+3664]
	sar	eax, cl
	mov	ecx, DWORD PTR _td$[ebp]
	mov	DWORD PTR _effective_nDstPitch$1$[esp+3176], edx
	mov	DWORD PTR _rowsize$1$[esp+3176], eax
	mov	ebx, DWORD PTR [ecx+8]
	mov	ecx, ebx
	imul	ecx, edx
	mov	edx, edi

; 1393 : 
; 1394 :   int effective_nSrcPitch = (nBlkSizeY >> _yratiouv_log) * _src_pitch_arr[P]; // pitch is byte granularity

	imul	edi, eax
	imul	edx, ebx
	mov	DWORD PTR _by$1$[esp+3176], ebx
	imul	ecx, eax
	mov	DWORD PTR _effective_nSrcPitch$1$[esp+3176], edi

; 1395 :   int effective_nDstPitch = (nBlkSizeY >> _yratiouv_log) * _dst_pitch_arr[P]; // pitch is short granularity

	mov	edi, DWORD PTR _effective_nDstPitch$1$[esp+3176]
	imul	edx, eax
	imul	edi, eax

; 1397 :   for (int by = td._y_beg; by < td._y_end; ++by)

	mov	eax, DWORD PTR _td$[ebp]
	add	ecx, DWORD PTR [esi+3628]
	mov	DWORD PTR _pDstCur$1$[esp+3176], ecx
	add	edx, DWORD PTR [esi+3640]
	mov	DWORD PTR _pSrcCur$1$[esp+3176], edx
	mov	DWORD PTR _effective_nDstPitch$1$[esp+3176], edi
	cmp	ebx, DWORD PTR [eax+12]
	jge	$LN3@process_ch

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	movss	xmm3, DWORD PTR __real@43800000
$LL4@process_ch:

; 1398 :   {
; 1399 :     int xx = 0; // index
; 1400 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	ebx, DWORD PTR [esi+64]
	xor	edi, edi
	xor	eax, eax
	mov	DWORD PTR _xx$1$[esp+3176], edi
	mov	DWORD PTR _bx$1$[esp+3176], eax
	test	ebx, ebx
	jle	$LN6@process_ch
	npad	1
$LL7@process_ch:

; 1401 :     {
; 1402 :       int i = by * nBlkX + bx;

	imul	ebx, DWORD PTR _by$1$[esp+3176]

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	xor	ecx, ecx
	mov	DWORD PTR _k$1$[esp+3176], ecx
	add	ebx, eax
	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+3176], ebx
	mov	DWORD PTR $T1[esp+3176], eax
	test	eax, eax
	jle	$LN9@process_ch

; 1408 :       {
; 1409 :         use_block_uv(

	mov	edi, DWORD PTR $T1[esp+3176]
	lea	edx, DWORD PTR [esi+556]
	xor	eax, eax
	mov	DWORD PTR tv1160[esp+3176], edx
	mov	DWORD PTR tv1162[esp+3176], eax
	npad	7
$LL10@process_ch:

; 1636 :   if (usable_flag)

	cmp	BYTE PTR [esi+ecx+292], 0

; 1408 :       {
; 1409 :         use_block_uv(

	mov	edx, DWORD PTR [edx]

; 1636 :   if (usable_flag)

	je	$LN27@process_ch
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	ecx, DWORD PTR [esi+152]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	edi, DWORD PTR [ebx+ebx*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv1076[esp+3176], ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [ecx+edi*4+4]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+edi*4+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	imul	ebx, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+204]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[esp+3176], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T2[esp+3176], xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	add	ebx, DWORD PTR $T2[esp+3180]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	sar	ebx, cl
	mov	ecx, DWORD PTR tv1076[esp+3176]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1639 :     const int blx = block.GetX() * nPel + block.GetMV().x;

	mov	edi, DWORD PTR [ecx+edi*4]
	imul	edi, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+200]
	add	edi, DWORD PTR $T3[esp+3176]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [edx+28]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN49@process_ch

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebx
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN52@process_ch
$LN49@process_ch:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN51@process_ch

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	esi, esi
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 1
	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN119@process_ch
$LN51@process_ch:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	esi, 2
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 2
	sar	ebx, 2
$LN119@process_ch:
	mov	edi, DWORD PTR tv1160[esp+3176]
	mov	ecx, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR tv1160[esp+3176]
	mov	esi, DWORD PTR _this$1$[esp+3176]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	add	edi, edx
	mov	edx, DWORD PTR [eax]
	imul	ebx, DWORD PTR [edx+12]
	add	edi, ebx
$LN52@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR _k$1$[esp+3176]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	ebx, DWORD PTR _i$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+3176], edi

; 1642 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	lea	edi, DWORD PTR [ebx+ebx*4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	edx, DWORD PTR tv1162[esp+3176]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+3176], eax
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv1076[esp+3176]
	mov	edi, DWORD PTR [eax+edi*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR [esi+152]
	mov	edx, DWORD PTR [eax+edx+20]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	edx, edi
	jg	SHORT $LN65@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	eax, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax

; 1646 :   else

	jmp	$LN8@process_ch
$LN65@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [esi+140], 8
	jg	SHORT $LN66@process_ch

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	edx, edx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edi, edi

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, edx
	sub	eax, edi

; 921  :     const int den = thSAD2 + blockSAD2;

	add	edi, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN69@process_ch
	shl	eax, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax
	jmp	SHORT $LN8@process_ch
$LN69@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	edi, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax
	jmp	SHORT $LN8@process_ch
$LN66@process_ch:
	movd	xmm2, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
	movd	xmm1, edi

; 935  :                                                         // smart compiler makes x*x, VS2015 calls __libm_sse2_pow_precise, way too slow
; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR $T1[esp+3176]
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	mulss	xmm2, xmm2

; 935  :                                                         // smart compiler makes x*x, VS2015 calls __libm_sse2_pow_precise, way too slow
; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, xmm3
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], eax

; 1646 :   else

	jmp	SHORT $LN8@process_ch
$LN27@process_ch:

; 1408 :       {
; 1409 :         use_block_uv(

	mov	eax, DWORD PTR [esi+192]
	imul	eax, DWORD PTR _xx$1$[esp+3176]

; 1650 :     wref = 0;

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+3180], 0
	add	eax, DWORD PTR _pSrcCur$1$[esp+3176]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+3176], eax
	mov	eax, DWORD PTR [esi+3664]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+3176], eax
$LN8@process_ch:

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	mov	edx, DWORD PTR tv1160[esp+3176]
	inc	ecx
	mov	eax, DWORD PTR tv1162[esp+3176]
	add	edx, 12					; 0000000cH
	add	eax, 24					; 00000018H
	mov	DWORD PTR _k$1$[esp+3176], ecx
	mov	DWORD PTR tv1160[esp+3176], edx
	mov	DWORD PTR tv1162[esp+3176], eax
	cmp	ecx, edi
	jl	$LL10@process_ch
	mov	edi, DWORD PTR _xx$1$[esp+3176]
$LN9@process_ch:

; 1410 :           ref_data_ptr_arr[k],
; 1411 :           pitch_arr[k],
; 1412 :           weight_arr[k + 1],
; 1413 :           _usable_flag_arr[k],
; 1414 :           _mv_clip_arr[k],
; 1415 :           i,
; 1416 :           _planes_ptr[k][P],
; 1417 :           pSrcCur,
; 1418 :           xx*pixelsize_super, // the pointer increment inside knows that xx later here is incremented with nBlkSize and not nBlkSize>>_xRatioUV
; 1419 :               // todo: copy from MDegrainX. Here we shift, and incement with nBlkSize>>_xRatioUV
; 1420 :           _src_pitch_arr[P]
; 1421 :         ); // vs: extra nLogPel, plane, xSubUV, ySubUV, thSAD
; 1422 :       }
; 1423 : 
; 1424 :       norm_weights(weight_arr, _trad); // normaliseWeights<radius>(WSrc, WRefs);

	mov	ebx, DWORD PTR [esi+164]
	lea	ecx, DWORD PTR _weight_arr$4[esp+3176]
	mov	edx, ebx
	call	?norm_weights@MDegrainN@@CAXQAHH@Z	; MDegrainN::norm_weights

; 1425 : 
; 1426 : 
; 1427 :       // chroma
; 1428 :       _degrainchroma_ptr(

	mov	ecx, DWORD PTR [esi+192]
	lea	eax, DWORD PTR _weight_arr$4[esp+3176]
	mov	edx, DWORD PTR _pDstCur$1$[esp+3176]
	push	ebx
	push	eax
	imul	ecx, edi
	lea	eax, DWORD PTR _pitch_arr$5[esp+3184]
	push	eax
	lea	eax, DWORD PTR _ref_data_ptr_arr$6[esp+3188]
	push	eax
	push	DWORD PTR [esi+3664]
	mov	eax, DWORD PTR _pSrcCur$1$[esp+3196]
	add	eax, ecx
	push	eax
	push	DWORD PTR [esi+3652]
	movzx	eax, BYTE PTR [esi+186]
	push	eax
	mov	eax, DWORD PTR [esi+3676]
	add	eax, ecx
	add	eax, edx
	push	eax
	lea	eax, DWORD PTR [ecx+edx]
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax

; 1429 :         pDstCur + xx * pixelsize_super,
; 1430 :         pDstCur + xx * pixelsize_super + _lsb_offset_arr[P], _lsb_flag, _dst_pitch_arr[P],
; 1431 :         pSrcCur + xx * pixelsize_super, _src_pitch_arr[P],
; 1432 :         ref_data_ptr_arr, pitch_arr, weight_arr, _trad
; 1433 :       );
; 1434 : 
; 1435 :       if (nLogxRatioUV != _xratiouv_log)

	mov	ecx, DWORD PTR [esi+128]
	add	esp, 40					; 00000028H
	mov	ebx, DWORD PTR [esi+200]
	cmp	ecx, ebx
	je	SHORT $LN11@process_ch

; 1436 :       //xx += nBlkSizeX; // blksize of Y plane, that's why there is xx >> xRatioUVlog above
; 1437 :       xx += (nBlkSizeX >> nLogxRatioUV); // xx: indexing offset

	mov	eax, DWORD PTR [esi+76]
	sar	eax, cl
	add	edi, eax
	mov	DWORD PTR _xx$1$[esp+3176], edi
$LN11@process_ch:

; 1438 : 
; 1439 :       if (bx == nBlkX - 1 && _covered_width < nWidth) // right non-covered region

	mov	eax, DWORD PTR [esi+64]
	dec	eax
	cmp	DWORD PTR _bx$1$[esp+3176], eax
	jne	$LN118@process_ch
	mov	edx, DWORD PTR [esi+3680]
	mov	edi, DWORD PTR [esi+92]
	cmp	edx, edi
	jge	$LN111@process_ch

; 1442 :         BitBlt(

	mov	eax, DWORD PTR [esi+192]
	sub	edi, edx
	mov	ecx, ebx
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+3664]
	mov	DWORD PTR _src_pitch$1$[esp+3176], ecx
	mov	ecx, ebx
	mov	ebx, DWORD PTR _pSrcCur$1$[esp+3176]
	sar	edx, cl
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
	imul	edx, eax
	imul	edi, eax
	mov	eax, DWORD PTR [esi+3652]
	mov	DWORD PTR _dst_pitch$1$[esp+3176], eax
	add	ebx, edx
	lea	eax, DWORD PTR [edx+ecx]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	edx, DWORD PTR _rowsize$1$[esp+3176]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1442 :         BitBlt(

	mov	DWORD PTR _dstp$1$[esp+3176], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edx, edx
	je	$LN113@process_ch
	test	edi, edi
	je	$LN113@process_ch

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	edx, 1
	je	$LN79@process_ch
	mov	ecx, DWORD PTR _src_pitch$1$[esp+3176]
	cmp	DWORD PTR _dst_pitch$1$[esp+3176], ecx
	jne	SHORT $LN77@process_ch
	cmp	ecx, edi
	je	$LN79@process_ch
$LN77@process_ch:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	mov	DWORD PTR _y$1$[esp+3176], edx
	test	edx, edx
	jle	SHORT $LN111@process_ch
	mov	esi, DWORD PTR _dstp$1$[esp+3176]
	npad	1
$LL74@process_ch:

; 94   :       memcpy(dstp, srcp, row_size);

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	mov	eax, DWORD PTR _y$1$[esp+3188]
	add	esp, 12					; 0000000cH

; 95   :       dstp += dst_pitch;

	add	esi, DWORD PTR _dst_pitch$1$[esp+3176]
	dec	eax

; 96   :       srcp += src_pitch;

	add	ebx, DWORD PTR _src_pitch$1$[esp+3176]
	mov	DWORD PTR _y$1$[esp+3176], eax
	test	eax, eax
	jg	SHORT $LL74@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	mov	esi, DWORD PTR _this$1$[esp+3176]
$LN111@process_ch:
	mov	edi, DWORD PTR _xx$1$[esp+3176]
$LN118@process_ch:
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
$LN5@process_ch:

; 1398 :   {
; 1399 :     int xx = 0; // index
; 1400 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	eax, DWORD PTR _bx$1$[esp+3176]
	mov	ebx, DWORD PTR [esi+64]
	inc	eax
	movss	xmm3, DWORD PTR __real@43800000
	mov	DWORD PTR _bx$1$[esp+3176], eax
	cmp	eax, ebx
	jl	$LL7@process_ch
	mov	edx, DWORD PTR _pSrcCur$1$[esp+3176]
$LN6@process_ch:

; 1443 :           pDstCur + (_covered_width >> _xratiouv_log) * pixelsize_super, _dst_pitch_arr[P],
; 1444 :           pSrcCur + (_covered_width >> _xratiouv_log) * pixelsize_super, _src_pitch_arr[P],
; 1445 :           ((nWidth - _covered_width) >> _xratiouv_log) * pixelsize_super /* real row_size */, rowsize /* bad name. it's height = nBlkSizeY >> _yratiouv_log*/,
; 1446 :           _isse_flag
; 1447 :         );
; 1448 :       }
; 1449 :     } // for bx
; 1450 : 
; 1451 :     pDstCur += effective_nDstPitch;
; 1452 :     pSrcCur += effective_nSrcPitch;
; 1453 : 
; 1454 :     if (by == nBlkY - 1 && _covered_height < nHeight) // bottom uncovered region

	mov	eax, DWORD PTR [esi+68]
	add	ecx, DWORD PTR _effective_nDstPitch$1$[esp+3176]
	dec	eax
	add	edx, DWORD PTR _effective_nSrcPitch$1$[esp+3176]
	mov	DWORD PTR _pDstCur$1$[esp+3176], ecx
	mov	DWORD PTR _pSrcCur$1$[esp+3176], edx
	cmp	DWORD PTR _by$1$[esp+3176], eax
	jne	$LN2@process_ch
	mov	eax, DWORD PTR [esi+3684]
	mov	edi, DWORD PTR [esi+96]
	cmp	eax, edi
	jge	$LN2@process_ch

; 1455 :     {
; 1456 :       // chroma
; 1457 :       BitBlt(

	mov	ecx, DWORD PTR [esi+204]
	sub	edi, eax
	mov	ebx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR _pDstCur$1$[esp+3176]
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+200]
	sar	ebx, cl
	imul	ebx, DWORD PTR [esi+192]
	mov	ecx, DWORD PTR [esi+3664]
	mov	DWORD PTR _srcp$1$[esp+3176], edx
	mov	edx, DWORD PTR [esi+3652]
	mov	DWORD PTR _src_pitch$1$[esp+3176], ecx
	mov	DWORD PTR _dst_pitch$1$[esp+3176], edx
	mov	DWORD PTR _dstp$1$[esp+3176], eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edi, edi
	je	SHORT $LN117@process_ch
	test	ebx, ebx
	je	SHORT $LN117@process_ch

; 77   : #if 0
; 78   : #ifdef X86_32
; 79   :   if (isse) {
; 80   :     if (height == 1 || (src_pitch == dst_pitch && dst_pitch == row_size)) {
; 81   : //      memcpy_amd(dstp, srcp, row_size*height);
; 82   : 		memcpy(dstp, srcp, row_size*height); // P.F. no memcpy_amd here
; 83   : 	} else {
; 84   :       asm_BitBlt_ISSE(dstp,dst_pitch,srcp,src_pitch,row_size,height);
; 85   :     }
; 86   :     return;
; 87   :   }
; 88   : #endif
; 89   : #endif
; 90   :   if (height == 1 || (dst_pitch == src_pitch && src_pitch == row_size)) {

	cmp	edi, 1
	je	SHORT $LN89@process_ch
	cmp	edx, ecx
	jne	SHORT $LN87@process_ch
	cmp	ecx, ebx
	je	SHORT $LN89@process_ch
$LN87@process_ch:

; 92   :   } else {
; 93   :     for (int y=height; y>0; --y) {

	test	edi, edi
	jle	SHORT $LN117@process_ch
	mov	esi, DWORD PTR _srcp$1$[esp+3176]
$LL84@process_ch:

; 94   :       memcpy(dstp, srcp, row_size);

	push	ebx
	push	esi
	push	eax
	call	_memcpy

; 95   :       dstp += dst_pitch;

	mov	eax, DWORD PTR _dstp$1$[esp+3188]
	dec	edi
	add	eax, DWORD PTR _dst_pitch$1$[esp+3188]
	add	esp, 12					; 0000000cH

; 96   :       srcp += src_pitch;

	add	esi, DWORD PTR _src_pitch$1$[esp+3176]
	mov	DWORD PTR _dstp$1$[esp+3176], eax
	test	edi, edi
	jg	SHORT $LL84@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1407 :       for (int k = 0; k < _trad * 2; ++k)

	mov	esi, DWORD PTR _this$1$[esp+3176]
	jmp	SHORT $LN117@process_ch
$LN79@process_ch:
; File c:\github\mvtools\sources\copycode.cpp

; 91   :     memcpy(dstp, srcp, row_size*height); // Fizick: fixed bug

	imul	edi, edx
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	$LN111@process_ch
$LN113@process_ch:
	mov	edi, DWORD PTR _xx$1$[esp+3176]
	jmp	$LN5@process_ch
$LN89@process_ch:
	imul	ebx, edi
	push	ebx
	push	DWORD PTR _pSrcCur$1$[esp+3180]
	push	DWORD PTR _pDstCur$1$[esp+3184]
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN117@process_ch:
	mov	edx, DWORD PTR _pSrcCur$1$[esp+3176]
	mov	ecx, DWORD PTR _pDstCur$1$[esp+3176]
$LN2@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1397 :   for (int by = td._y_beg; by < td._y_end; ++by)

	mov	eax, DWORD PTR _by$1$[esp+3176]
	mov	ebx, DWORD PTR _td$[ebp]
	inc	eax
	movss	xmm3, DWORD PTR __real@43800000
	mov	DWORD PTR _by$1$[esp+3176], eax
	cmp	eax, DWORD PTR [ebx+12]
	jl	$LL4@process_ch
$LN3@process_ch:

; 1458 :         pDstCur, _dst_pitch_arr[P],
; 1459 :         pSrcCur, _src_pitch_arr[P],
; 1460 :         (nWidth >> _xratiouv_log)*pixelsize_super, (nHeight - _covered_height) >> _yratiouv_log /* height */,
; 1461 :         _isse_flag
; 1462 :       );
; 1463 :     }
; 1464 :   } // for by
; 1465 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$process_chroma_normal_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ENDP ; MDegrainN::process_chroma_normal_slice<2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_inc_ftor$2 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_td$ = 8						; size = 4
??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z PROC ; MDegrainN::process_chroma_overlap_slice<2>, COMDAT
; _this$ = ecx

; 1471 : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi

; 1472 :   assert(&td != 0);
; 1473 : 
; 1474 :   if (nOverlapY == 0
; 1475 :     || (td._y_beg == 0 && td._y_end == nBlkY))

	mov	esi, DWORD PTR _td$[ebp]
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [edi+112], 0
	je	$LN4@process_ch
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	jne	SHORT $LN2@process_ch
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [edi+68]
	je	$LN4@process_ch
$LN2@process_ch:

; 1478 :   }
; 1479 : 
; 1480 :   else
; 1481 :   {
; 1482 :     assert(td._y_end - td._y_beg >= 2);
; 1483 : 
; 1484 :     process_chroma_overlap_slice <P>(td._y_beg, td._y_end - 1);

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	push	eax
	push	ecx
	mov	ecx, edi
	call	??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<2>
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _inc_ftor$2[ebp], OFFSET ??_7?$AioAdd@H@conc@@6B@

; 38   : :	_operand (operand)

	mov	DWORD PTR _inc_ftor$2[ebp+4], 1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1486 :     const conc::AioAdd <int> inc_ftor(+1);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+3688]
	push	ebx
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	2
$LL28@process_ch:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL28@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1492 :     if (td._y_beg > 0 && cnt_top == 2)

	mov	esi, DWORD PTR _td$[ebp]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jle	SHORT $LN5@process_ch
	cmp	ebx, 2
	jne	SHORT $LN5@process_ch

; 1493 :     {
; 1494 :       process_chroma_overlap_slice <P>(td._y_beg - 1, td._y_beg);

	push	eax
	dec	eax
	mov	ecx, edi
	push	eax
	call	??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<2>
$LN5@process_ch:

; 1495 :     }
; 1496 : 
; 1497 :     int				cnt_bot = 2;
; 1498 :     if (td._y_end < nBlkY)

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, DWORD PTR [edi+68]
	jge	SHORT $LN77@process_ch
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [edi+3688]
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	5
$LL56@process_ch:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL56@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1505 :     if (cnt_bot == 2)

	mov	esi, DWORD PTR _td$[ebp]
	cmp	ebx, 2
	jne	SHORT $LN79@process_ch
$LN77@process_ch:

; 1506 :     {
; 1507 :       process_chroma_overlap_slice <P>(td._y_end - 1, td._y_end);

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, edi
	push	eax
	dec	eax
	push	eax
	call	??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<2>
$LN79@process_ch:
	pop	ebx
	pop	edi
	pop	esi

; 1508 :     }
; 1509 :   }
; 1510 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@process_ch:

; 1476 :   {
; 1477 :     process_chroma_overlap_slice <P>(td._y_beg, td._y_end);

	push	DWORD PTR [esi+12]
	mov	ecx, edi
	push	DWORD PTR [esi+8]
	call	??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z ; MDegrainN::process_chroma_overlap_slice<2>

; 1508 :     }
; 1509 :   }
; 1510 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z$0:
	lea	ecx, DWORD PTR _inc_ftor$2[ebp]
	jmp	??1?$AioAdd@H@conc@@UAE@XZ		; conc::AioAdd<int>::~AioAdd<int>
__ehhandler$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXAAVTaskData@?$MTSlicer@VMDegrainN@@V1@$0EA@@@@Z ENDP ; MDegrainN::process_chroma_overlap_slice<2>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_both@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@AAH2@Z
_TEXT	SEGMENT
_val_old$ = 8						; size = 4
_val_new$ = 12						; size = 4
??$exec_both@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@AAH2@Z PROC ; conc::AtomicIntOp::exec_both<int,conc::AioAdd<int> const >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 83   : {

	push	ebx
	mov	ebx, DWORD PTR _val_new$[esp]
	push	ebp
	mov	ebp, DWORD PTR _val_old$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	npad	2
$LL4@exec_both:

; 84   : 	assert (&atom != 0);
; 85   : 	assert (&ftor != 0);
; 86   : 
; 87   : 	T					val_cur;
; 88   : 	do
; 89   : 	{
; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	mov	ecx, DWORD PTR [edx+4]
	add	ecx, esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [ebx], ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [edi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 92   : 		val_old = atom.cas (val_new, val_cur);

	mov	DWORD PTR [ebp], eax

; 93   : 	}
; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL4@exec_both

; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$exec_both@H$$CBV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@ABV?$AioAdd@H@1@AAH2@Z ENDP ; conc::AtomicIntOp::exec_both<int,conc::AioAdd<int> const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 208  : 		{	// fail if _Keyval present, else emplace

	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	edi, DWORD PTR __Keyval$[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 208  : 		{	// fail if _Keyval present, else emplace

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	edi
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	esi, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 211  : 			|| _DEBUG_LT_PRED(_Mybase::_Getcomp(),

	je	SHORT $LN4@Try_emplac
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [esi+24]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LN4@Try_emplac
$LN177@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
$LN4@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	lea	eax, DWORD PTR $T2[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[esp+12], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, ebx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, ebx
	push	eax
	push	esi
	lea	eax, DWORD PTR $T1[esp+20]
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	ecx, DWORD PTR $T1[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	test	edx, edx
	je	SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN19@Uninitiali
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 54   : :	_val ()

	mov	DWORD PTR [ecx], 0
$LN19@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	ecx, 4
	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAV?$AtomicInt@H@conc@@IV?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAXPAV?$AtomicInt@H@conc@@IAAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<conc::AtomicInt<int> *,unsigned int,std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<int *,unsigned int,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 472  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAHIV?$allocator@H@std@@@std@@YAXPAHIAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<int *,unsigned int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<unsigned short *,unsigned int,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx+edx]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 472  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAGIV?$allocator@G@std@@@std@@YAXPAGIAAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<unsigned short *,unsigned int,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	test	edx, edx
	je	SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN19@Uninitiali
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [ecx+4], 0

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx+8], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [ecx+12], 0
$LN19@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	ecx, 24					; 00000018H
	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MDegrainN@@IV?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAXPAVMvClipInfo@MDegrainN@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<MDegrainN::MvClipInfo *,unsigned int,std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z PROC ; std::_Uninitialized_move<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<conc::AtomicInt<int> >,conc::AtomicInt<int> *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$AtomicInt@H@conc@@@std@@PAV?$AtomicInt@H@conc@@@std@@YAXPAV?$AtomicInt@H@conc@@0AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<conc::AtomicInt<int> >,conc::AtomicInt<int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 319  : 	}

	ret	0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<int>,int *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@H@std@@PAH@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<int>,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 319  : 	}

	ret	0
??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned short>,unsigned short *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@G@std@@PAG@std@@YAXPAG0AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned short>,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z PROC ; std::_Uninitialized_move<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<MDegrainN::MvClipInfo>,MDegrainN::MvClipInfo *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN3@Destroy_ra
	npad	6
$LL4@Destroy_ra:
	mov	ecx, esi
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	add	esi, 24					; 00000018H
	cmp	esi, edi
	jne	SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:
	pop	edi
	pop	esi

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@VMvClipInfo@MDegrainN@@@std@@PAVMvClipInfo@MDegrainN@@@std@@YAXPAVMvClipInfo@MDegrainN@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<MDegrainN::MvClipInfo>,MDegrainN::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVGroupOfFrames@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GMVGroupOfFrames@@QAEPAXI@Z PROC			; MVGroupOfFrames::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	pop	esi
	ret	4
??_GMVGroupOfFrames@@QAEPAXI@Z ENDP			; MVGroupOfFrames::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 570  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 901  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Key, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2179 : 		}

	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	DWORD PTR __Keyval$[esp-4]
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	eax, ecx

; 1539 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2173 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[esp-4]

; 2174 : 		}

	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??B?$AtomicInt@H@conc@@QBEHXZ
_TEXT	SEGMENT
??B?$AtomicInt@H@conc@@QBEHXZ PROC			; conc::AtomicInt<int>::operator int, COMDAT
; _this$ = ecx

; 93   : 	return (T (_val));

	mov	eax, DWORD PTR [ecx]

; 94   : }

	ret	0
??B?$AtomicInt@H@conc@@QBEHXZ ENDP			; conc::AtomicInt<int>::operator int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ?cas@?$AtomicInt@H@conc@@QAEHHH@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
_comp$ = 12						; size = 4
?cas@?$AtomicInt@H@conc@@QAEHHH@Z PROC			; conc::AtomicInt<int>::cas, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	edx, DWORD PTR _other$[esp-4]
	mov	eax, DWORD PTR _comp$[esp-4]
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 110  : }

	ret	8
?cas@?$AtomicInt@H@conc@@QAEHHH@Z ENDP			; conc::AtomicInt<int>::cas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.hpp
;	COMDAT ??R?$AioAdd@H@conc@@QBEHH@Z
_TEXT	SEGMENT
_old_val$ = 8						; size = 4
??R?$AioAdd@H@conc@@QBEHH@Z PROC			; conc::AioAdd<int>::operator(), COMDAT
; _this$ = ecx

; 48   : 	return (old_val + _operand);

	mov	eax, DWORD PTR [ecx+4]
	add	eax, DWORD PTR _old_val$[esp-4]

; 49   : }

	ret	4
??R?$AioAdd@H@conc@@QBEHH@Z ENDP			; conc::AioAdd<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@V?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z PROC ; std::_Unfancy<conc::AtomicInt<int> >, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@V?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z ENDP ; std::_Unfancy<conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@VMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z PROC ; std::_Unfancy<MDegrainN::MvClipInfo>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@VMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z ENDP ; std::_Unfancy<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mdegrainn.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mdegrainn.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z
_TEXT	SEGMENT
tv1245 = -5232						; size = 4
_pDstInt$1$ = -5228					; size = 4
_pSrcCur$1$ = -5224					; size = 4
_pDstShort$1$ = -5220					; size = 4
_this$1$ = -5216					; size = 4
tv1247 = -5212						; size = 4
_winOverUV$1$ = -5208					; size = 4
_bx$1$ = -5204						; size = 4
tv1154 = -5200						; size = 4
_i$1$ = -5196						; size = 4
_k$1$ = -5192						; size = 4
_xx$1$ = -5188						; size = 4
_wby$1$ = -5184						; size = 4
$T1 = -5180						; size = 4
_tmpPitch$1$ = -5176					; size = 4
_effective_nSrcPitch$1$ = -5172				; size = 4
tv1250 = -5168						; size = 4
tv1249 = -5164						; size = 4
$T2 = -5160						; size = 12
$T3 = -5148						; size = 12
_weight_arr$4 = -5136					; size = 1028
_tmp_block$ = -4104					; size = 2052
_pitch_arr$5 = -2048					; size = 1024
_ref_data_ptr_arr$6 = -1024				; size = 1024
_y_beg$ = 8						; size = 4
_y_end$ = 12						; size = 4
??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z PROC ; MDegrainN::process_chroma_overlap_slice<1>, COMDAT
; _this$ = ecx

; 1516 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, 5236				; 00001474H
	call	__chkstk
	push	ebx

; 1520 :   const BYTE *pSrcCur = _src_ptr_arr[P] + y_beg * rowsize * _src_pitch_arr[P];

	mov	ebx, DWORD PTR _y_beg$[ebp]
; File c:\github\mvtools\sources\mdegrainn.h

; 78   :     TmpBlock() : _lsb_ptr(&_d[AREA]) {}

	lea	eax, DWORD PTR _tmp_block$[esp+6264]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1516 : {

	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\mdegrainn.h

; 78   :     TmpBlock() : _lsb_ptr(&_d[AREA]) {}

	mov	DWORD PTR _tmp_block$[esp+7292], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1516 : {

	push	edi
	mov	DWORD PTR _this$1$[esp+5248], esi

; 1517 :   TmpBlock       tmp_block;
; 1518 : 
; 1519 :   const int rowsize = (nBlkSizeY - nOverlapY) >> _yratiouv_log; // bad name. it's height really

	mov	edx, DWORD PTR [esi+80]
	sub	edx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [esi+204]

; 1520 :   const BYTE *pSrcCur = _src_ptr_arr[P] + y_beg * rowsize * _src_pitch_arr[P];

	mov	edi, DWORD PTR [esi+3660]
	mov	eax, edi
	sar	edx, cl
	imul	eax, edx
	imul	eax, ebx
	add	eax, DWORD PTR [esi+3636]
	mov	DWORD PTR _pSrcCur$1$[esp+5248], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+260]
	cmp	eax, DWORD PTR [esi+264]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1522 :   unsigned short *pDstShort = (_dst_short.empty()) ? 0 : &_dst_short[0] + y_beg * rowsize * _dst_short_pitch;

	jne	SHORT $LN17@process_ch
	mov	DWORD PTR _pDstShort$1$[esp+5248], 0
	jmp	SHORT $LN18@process_ch
$LN17@process_ch:
	mov	ecx, DWORD PTR [esi+272]
	imul	ecx, edx
	imul	ecx, ebx
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _pDstShort$1$[esp+5248], eax
$LN18@process_ch:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+276]
	cmp	eax, DWORD PTR [esi+280]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1523 :   int *pDstInt = (_dst_int.empty()) ? 0 : &_dst_int[0] + y_beg * rowsize * _dst_int_pitch;

	jne	SHORT $LN19@process_ch
	mov	DWORD PTR _pDstInt$1$[esp+5248], 0
	jmp	SHORT $LN20@process_ch
$LN19@process_ch:
	mov	ecx, DWORD PTR [esi+288]
	imul	ecx, edx
	imul	ecx, ebx
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pDstInt$1$[esp+5248], eax
$LN20@process_ch:

; 1524 :   const int tmpPitch = nBlkSizeX;

	mov	eax, DWORD PTR [esi+76]

; 1525 :   assert(tmpPitch <= TmpBlock::MAX_SIZE);
; 1526 : 
; 1527 :   int effective_nSrcPitch = ((nBlkSizeY - nOverlapY) >> _yratiouv_log) * _src_pitch_arr[P]; // pitch is byte granularity
; 1528 :   int effective_dstShortPitch = ((nBlkSizeY - nOverlapY) >> _yratiouv_log) * _dst_short_pitch; // pitch is short granularity
; 1529 :   int effective_dstIntPitch = ((nBlkSizeY - nOverlapY) >> _yratiouv_log) * _dst_int_pitch; // pitch is int granularity

	mov	ecx, DWORD PTR [esi+288]
	imul	edi, edx
	mov	DWORD PTR _tmpPitch$1$[esp+5248], eax
	mov	eax, DWORD PTR [esi+272]
	imul	eax, edx
	imul	ecx, edx
	mov	DWORD PTR _effective_nSrcPitch$1$[esp+5248], edi

; 1530 : 
; 1531 :   for (int by = y_beg; by < y_end; ++by)

	cmp	ebx, DWORD PTR _y_end$[ebp]
	jge	$LN3@process_ch

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	movss	xmm3, DWORD PTR __real@43800000
	add	eax, eax
	mov	DWORD PTR tv1250[esp+5248], eax
	lea	eax, DWORD PTR [ecx*4]
	mov	DWORD PTR tv1249[esp+5248], eax
$LL4@process_ch:

; 1532 :   {
; 1533 :     int wby = ((by + nBlkY - 3) / (nBlkY - 2)) * 3;

	mov	ecx, DWORD PTR [esi+68]
	lea	eax, DWORD PTR [ebx-3]
	add	eax, ecx

; 1534 :     int xx = 0; // logical offset. Mul by 2 for pixelsize_super==2. Don't mul for indexing int* array
; 1535 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	edi, DWORD PTR [esi+64]
	cdq
	add	ecx, -2					; fffffffeH
	idiv	ecx
	xor	ebx, ebx
	mov	DWORD PTR _xx$1$[esp+5248], ebx
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _wby$1$[esp+5248], eax
	xor	eax, eax
	mov	DWORD PTR _bx$1$[esp+5248], eax
	test	edi, edi
	jle	$LN166@process_ch
$LL7@process_ch:

; 1539 :       short *winOverUV = _overwins_uv->GetWindow(wby + wbx);

	add	eax, -3					; fffffffdH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	esi, DWORD PTR [esi+224]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1539 :       short *winOverUV = _overwins_uv->GetWindow(wby + wbx);

	add	eax, edi
	lea	ecx, DWORD PTR [edi-2]
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	ecx, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1539 :       short *winOverUV = _overwins_uv->GetWindow(wby + wbx);

	add	eax, DWORD PTR _wby$1$[esp+5248]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	imul	eax, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1546 :       for (int k = 0; k < _trad * 2; ++k)

	mov	esi, DWORD PTR _this$1$[esp+5248]
	imul	edi, DWORD PTR _y_beg$[ebp]
	add	edi, DWORD PTR _bx$1$[esp+5248]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	lea	eax, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1541 :       int i = by * nBlkX + bx;

	mov	DWORD PTR _i$1$[esp+5248], edi
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	DWORD PTR _winOverUV$1$[esp+5248], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1546 :       for (int k = 0; k < _trad * 2; ++k)

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	mov	DWORD PTR _k$1$[esp+5248], ecx
	mov	DWORD PTR $T1[esp+5248], eax
	test	eax, eax
	jle	$LN9@process_ch

; 1547 :       {
; 1548 :         use_block_uv(

	xor	eax, eax
	lea	edx, DWORD PTR [esi+552]
	mov	DWORD PTR tv1247[esp+5248], eax
	mov	DWORD PTR tv1245[esp+5248], edx
	npad	15
$LL10@process_ch:

; 1636 :   if (usable_flag)

	cmp	BYTE PTR [esi+ecx+292], 0

; 1547 :       {
; 1548 :         use_block_uv(

	mov	edx, DWORD PTR [edx]

; 1636 :   if (usable_flag)

	je	$LN107@process_ch
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	ecx, DWORD PTR [esi+152]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	edi, DWORD PTR [edi+edi*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv1154[esp+5248], ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [ecx+edi*4+4]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+edi*4+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	imul	ebx, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+204]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[esp+5248], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T2[esp+5248], xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	add	ebx, DWORD PTR $T2[esp+5252]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	sar	ebx, cl
	mov	ecx, DWORD PTR tv1154[esp+5248]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1639 :     const int blx = block.GetX() * nPel + block.GetMV().x;

	mov	edi, DWORD PTR [ecx+edi*4]
	imul	edi, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+200]
	add	edi, DWORD PTR $T3[esp+5248]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [edx+28]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN129@process_ch

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebx
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN132@process_ch
$LN129@process_ch:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN131@process_ch

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	esi, esi
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 1
	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN167@process_ch
$LN131@process_ch:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	esi, 2
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 2
	sar	ebx, 2
$LN167@process_ch:
	mov	edi, DWORD PTR tv1245[esp+5248]
	mov	ecx, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR tv1245[esp+5248]
	mov	esi, DWORD PTR _this$1$[esp+5248]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	add	edi, edx
	mov	edx, DWORD PTR [eax]
	imul	ebx, DWORD PTR [edx+12]
	add	edi, ebx
$LN132@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR _k$1$[esp+5248]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+5248], edi

; 1642 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edx, DWORD PTR _i$1$[esp+5248]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1642 :     np = plane_ptr->GetPitch();

	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+5248], eax
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv1154[esp+5248]
	lea	edi, DWORD PTR [edx+edx*4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	edx, DWORD PTR tv1247[esp+5248]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edi, DWORD PTR [eax+edi*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR [esi+152]
	mov	edx, DWORD PTR [eax+edx+20]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	edx, edi
	jg	SHORT $LN145@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	eax, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR _i$1$[esp+5248]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax
	jmp	$LN8@process_ch
$LN145@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [esi+140], 8
	jg	SHORT $LN146@process_ch

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	edx, edx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edi, edi

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, edx
	sub	eax, edi

; 921  :     const int den = thSAD2 + blockSAD2;

	add	edi, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN149@process_ch
	shl	eax, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
	mov	edi, DWORD PTR _i$1$[esp+5248]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax
	jmp	$LN8@process_ch
$LN149@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	edi, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
	mov	edi, DWORD PTR _i$1$[esp+5248]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax
	jmp	SHORT $LN8@process_ch
$LN146@process_ch:
	movd	xmm2, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
	movd	xmm1, edi
; File c:\github\mvtools\sources\mvdegrain3.h

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR _i$1$[esp+5248]
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	mulss	xmm2, xmm2

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, xmm3
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax

; 1646 :   else

	jmp	SHORT $LN8@process_ch
$LN107@process_ch:

; 1547 :       {
; 1548 :         use_block_uv(

	mov	eax, DWORD PTR [esi+192]
	imul	eax, ebx

; 1650 :     wref = 0;

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], 0
	add	eax, DWORD PTR _pSrcCur$1$[esp+5248]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+5248], eax
	mov	eax, DWORD PTR [esi+3660]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+5248], eax
$LN8@process_ch:

; 1546 :       for (int k = 0; k < _trad * 2; ++k)

	mov	edx, DWORD PTR tv1245[esp+5248]
	inc	ecx
	mov	eax, DWORD PTR tv1247[esp+5248]
	add	edx, 12					; 0000000cH
	add	eax, 24					; 00000018H
	mov	DWORD PTR _k$1$[esp+5248], ecx
	mov	DWORD PTR tv1245[esp+5248], edx
	mov	DWORD PTR tv1247[esp+5248], eax
	cmp	ecx, DWORD PTR $T1[esp+5248]
	jl	$LL10@process_ch
$LN9@process_ch:

; 1549 :           ref_data_ptr_arr[k],
; 1550 :           pitch_arr[k],
; 1551 :           weight_arr[k + 1], // from 1st
; 1552 :           _usable_flag_arr[k],
; 1553 :           _mv_clip_arr[k],
; 1554 :           i,
; 1555 :           _planes_ptr[k][P],
; 1556 :           pSrcCur,
; 1557 :           xx * pixelsize_super, //  the pointer increment inside knows that xx later here is incremented with nBlkSize and not nBlkSize>>_xRatioUV
; 1558 :           _src_pitch_arr[P]
; 1559 :         );
; 1560 :       }
; 1561 : 
; 1562 :       norm_weights(weight_arr, _trad); // 0th + 1..MAX_TEMP_RAD*2

	mov	edi, DWORD PTR [esi+164]
	lea	ecx, DWORD PTR _weight_arr$4[esp+5248]
	mov	edx, edi
	call	?norm_weights@MDegrainN@@CAXQAHH@Z	; MDegrainN::norm_weights

; 1563 : 
; 1564 :       // chroma
; 1565 :       // here we don't pass pixelsize, because _degrainchroma_ptr points already to the uint16_t version
; 1566 :       // if the clip was 16 bit one
; 1567 :       _degrainchroma_ptr(

	mov	ecx, DWORD PTR [esi+192]
	lea	eax, DWORD PTR _weight_arr$4[esp+5248]
	push	edi
	mov	edi, DWORD PTR _tmpPitch$1$[esp+5252]
	push	eax
	lea	eax, DWORD PTR _pitch_arr$5[esp+5256]
	push	eax
	lea	eax, DWORD PTR _ref_data_ptr_arr$6[esp+5260]
	push	eax
	push	DWORD PTR [esi+3660]
	mov	eax, ecx
	imul	ecx, edi
	imul	eax, ebx
	add	eax, DWORD PTR _pSrcCur$1$[esp+5268]
	push	eax
	movzx	eax, BYTE PTR [esi+186]
	push	ecx
	push	eax
	push	DWORD PTR _tmp_block$[esp+7328]
	lea	eax, DWORD PTR _tmp_block$[esp+5284]
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax
	add	esp, 40					; 00000028H

; 1568 :         &tmp_block._d[0], tmp_block._lsb_ptr, _lsb_flag, tmpPitch * pixelsize_super,
; 1569 :         pSrcCur + xx * pixelsize_super, _src_pitch_arr[P],
; 1570 :         ref_data_ptr_arr, pitch_arr, weight_arr, _trad
; 1571 :       );
; 1572 :       if (_lsb_flag)

	cmp	BYTE PTR [esi+186], 0
	je	SHORT $LN11@process_ch

; 1573 :       {
; 1574 :         _overschroma_lsb_ptr(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+200]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+5252]
	lea	eax, DWORD PTR _tmp_block$[esp+5256]
	push	edi
	push	DWORD PTR _tmp_block$[esp+7308]
	push	eax
	mov	eax, DWORD PTR _pDstInt$1$[esp+5268]
	push	DWORD PTR [esi+288]
	lea	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	eax, DWORD PTR [esi+248]
	call	eax
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN15@process_ch
$LN11@process_ch:

; 1575 :           pDstInt + xx, _dst_int_pitch,
; 1576 :           &tmp_block._d[0], tmp_block._lsb_ptr, tmpPitch,
; 1577 :           winOverUV, nBlkSizeX >> _xratiouv_log
; 1578 :         );
; 1579 :       }
; 1580 :       else if(pixelsize_super == 1)

	mov	eax, DWORD PTR [esi+192]
	cmp	eax, 1
	jne	SHORT $LN13@process_ch

; 1581 :       {
; 1582 :         _overschroma_ptr(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+200]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+5252]
	lea	eax, DWORD PTR _tmp_block$[esp+5256]
	push	edi
	push	eax
	mov	eax, DWORD PTR _pDstShort$1$[esp+5264]
	push	DWORD PTR [esi+272]
	lea	eax, DWORD PTR [eax+ebx*2]
	push	eax
	mov	eax, DWORD PTR [esi+232]
	jmp	SHORT $LN168@process_ch
$LN13@process_ch:

; 1583 :           pDstShort + xx, _dst_short_pitch,
; 1584 :           &tmp_block._d[0], tmpPitch,
; 1585 :           winOverUV, nBlkSizeX >> _xratiouv_log);
; 1586 :       } else if (pixelsize_super == 2)

	cmp	eax, 2
	jne	SHORT $LN15@process_ch

; 1587 :       {
; 1588 :         _overschroma16_ptr(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+200]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+5252]
	lea	eax, DWORD PTR [edi+edi]
	push	eax
	lea	eax, DWORD PTR _tmp_block$[esp+5260]
	push	eax
	mov	eax, DWORD PTR _pDstInt$1$[esp+5264]
	push	DWORD PTR [esi+288]
	lea	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	eax, DWORD PTR [esi+240]
$LN168@process_ch:
	call	eax
	add	esp, 24					; 00000018H
$LN15@process_ch:

; 1589 :           (uint16_t*)(pDstInt + xx), _dst_int_pitch, 
; 1590 :           &tmp_block._d[0], tmpPitch*pixelsize_super, 
; 1591 :           winOverUV, nBlkSizeX >> _xratiouv_log);
; 1592 :       }
; 1593 : 
; 1594 :       xx += ((nBlkSizeX - nOverlapX) >> nLogxRatioUV); // no pixelsize here

	mov	eax, DWORD PTR [esi+76]
	sub	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+128]
	mov	edi, DWORD PTR [esi+64]
	movss	xmm3, DWORD PTR __real@43800000
	sar	eax, cl
	add	ebx, eax
	mov	eax, DWORD PTR _bx$1$[esp+5248]
	inc	eax
	mov	DWORD PTR _xx$1$[esp+5248], ebx
	mov	DWORD PTR _bx$1$[esp+5248], eax
	cmp	eax, edi
	jl	$LL7@process_ch
$LN166@process_ch:

; 1595 : 
; 1596 :     } // for bx
; 1597 : 
; 1598 :     pSrcCur += effective_nSrcPitch; // pitch is byte granularity

	mov	eax, DWORD PTR _effective_nSrcPitch$1$[esp+5248]
	add	DWORD PTR _pSrcCur$1$[esp+5248], eax

; 1599 :     pDstShort += effective_dstShortPitch; // pitch is short granularity

	mov	eax, DWORD PTR tv1250[esp+5248]
	mov	ebx, DWORD PTR _y_beg$[ebp]
	add	DWORD PTR _pDstShort$1$[esp+5248], eax
	inc	ebx

; 1600 :     pDstInt += effective_dstIntPitch; // pitch is int granularity

	mov	eax, DWORD PTR tv1249[esp+5248]
	add	DWORD PTR _pDstInt$1$[esp+5248], eax
	mov	DWORD PTR _y_beg$[ebp], ebx
	cmp	ebx, DWORD PTR _y_end$[ebp]
	jl	$LL4@process_ch
$LN3@process_ch:

; 1601 :   } // for by
; 1602 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??$process_chroma_overlap_slice@$00@MDegrainN@@AAEXHH@Z ENDP ; MDegrainN::process_chroma_overlap_slice<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mdegrainn.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mdegrainn.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
; File c:\github\mvtools\sources\mvdegrain3.h
; File c:\github\mvtools\sources\mdegrainn.cpp
;	COMDAT ??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z
_TEXT	SEGMENT
tv1242 = -5232						; size = 4
_pDstInt$1$ = -5228					; size = 4
_pSrcCur$1$ = -5224					; size = 4
_pDstShort$1$ = -5220					; size = 4
_this$1$ = -5216					; size = 4
tv1244 = -5212						; size = 4
_winOverUV$1$ = -5208					; size = 4
_bx$1$ = -5204						; size = 4
tv1151 = -5200						; size = 4
_i$1$ = -5196						; size = 4
_k$1$ = -5192						; size = 4
_xx$1$ = -5188						; size = 4
_wby$1$ = -5184						; size = 4
$T1 = -5180						; size = 4
_tmpPitch$1$ = -5176					; size = 4
_effective_nSrcPitch$1$ = -5172				; size = 4
tv1247 = -5168						; size = 4
tv1246 = -5164						; size = 4
$T2 = -5160						; size = 12
$T3 = -5148						; size = 12
_weight_arr$4 = -5136					; size = 1028
_tmp_block$ = -4104					; size = 2052
_pitch_arr$5 = -2048					; size = 1024
_ref_data_ptr_arr$6 = -1024				; size = 1024
_y_beg$ = 8						; size = 4
_y_end$ = 12						; size = 4
??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z PROC ; MDegrainN::process_chroma_overlap_slice<2>, COMDAT
; _this$ = ecx

; 1516 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, 5236				; 00001474H
	call	__chkstk
	push	ebx

; 1520 :   const BYTE *pSrcCur = _src_ptr_arr[P] + y_beg * rowsize * _src_pitch_arr[P];

	mov	ebx, DWORD PTR _y_beg$[ebp]
; File c:\github\mvtools\sources\mdegrainn.h

; 78   :     TmpBlock() : _lsb_ptr(&_d[AREA]) {}

	lea	eax, DWORD PTR _tmp_block$[esp+6264]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1516 : {

	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\mdegrainn.h

; 78   :     TmpBlock() : _lsb_ptr(&_d[AREA]) {}

	mov	DWORD PTR _tmp_block$[esp+7292], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1516 : {

	push	edi
	mov	DWORD PTR _this$1$[esp+5248], esi

; 1517 :   TmpBlock       tmp_block;
; 1518 : 
; 1519 :   const int rowsize = (nBlkSizeY - nOverlapY) >> _yratiouv_log; // bad name. it's height really

	mov	edx, DWORD PTR [esi+80]
	sub	edx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [esi+204]

; 1520 :   const BYTE *pSrcCur = _src_ptr_arr[P] + y_beg * rowsize * _src_pitch_arr[P];

	mov	edi, DWORD PTR [esi+3664]
	mov	eax, edi
	sar	edx, cl
	imul	eax, edx
	imul	eax, ebx
	add	eax, DWORD PTR [esi+3640]
	mov	DWORD PTR _pSrcCur$1$[esp+5248], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+260]
	cmp	eax, DWORD PTR [esi+264]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1522 :   unsigned short *pDstShort = (_dst_short.empty()) ? 0 : &_dst_short[0] + y_beg * rowsize * _dst_short_pitch;

	jne	SHORT $LN17@process_ch
	mov	DWORD PTR _pDstShort$1$[esp+5248], 0
	jmp	SHORT $LN18@process_ch
$LN17@process_ch:
	mov	ecx, DWORD PTR [esi+272]
	imul	ecx, edx
	imul	ecx, ebx
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _pDstShort$1$[esp+5248], eax
$LN18@process_ch:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi+276]
	cmp	eax, DWORD PTR [esi+280]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1523 :   int *pDstInt = (_dst_int.empty()) ? 0 : &_dst_int[0] + y_beg * rowsize * _dst_int_pitch;

	jne	SHORT $LN19@process_ch
	mov	DWORD PTR _pDstInt$1$[esp+5248], 0
	jmp	SHORT $LN20@process_ch
$LN19@process_ch:
	mov	ecx, DWORD PTR [esi+288]
	imul	ecx, edx
	imul	ecx, ebx
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pDstInt$1$[esp+5248], eax
$LN20@process_ch:

; 1524 :   const int tmpPitch = nBlkSizeX;

	mov	eax, DWORD PTR [esi+76]

; 1525 :   assert(tmpPitch <= TmpBlock::MAX_SIZE);
; 1526 : 
; 1527 :   int effective_nSrcPitch = ((nBlkSizeY - nOverlapY) >> _yratiouv_log) * _src_pitch_arr[P]; // pitch is byte granularity
; 1528 :   int effective_dstShortPitch = ((nBlkSizeY - nOverlapY) >> _yratiouv_log) * _dst_short_pitch; // pitch is short granularity
; 1529 :   int effective_dstIntPitch = ((nBlkSizeY - nOverlapY) >> _yratiouv_log) * _dst_int_pitch; // pitch is int granularity

	mov	ecx, DWORD PTR [esi+288]
	imul	edi, edx
	mov	DWORD PTR _tmpPitch$1$[esp+5248], eax
	mov	eax, DWORD PTR [esi+272]
	imul	eax, edx
	imul	ecx, edx
	mov	DWORD PTR _effective_nSrcPitch$1$[esp+5248], edi

; 1530 : 
; 1531 :   for (int by = y_beg; by < y_end; ++by)

	cmp	ebx, DWORD PTR _y_end$[ebp]
	jge	$LN3@process_ch

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	movss	xmm3, DWORD PTR __real@43800000
	add	eax, eax
	mov	DWORD PTR tv1247[esp+5248], eax
	lea	eax, DWORD PTR [ecx*4]
	mov	DWORD PTR tv1246[esp+5248], eax
$LL4@process_ch:

; 1532 :   {
; 1533 :     int wby = ((by + nBlkY - 3) / (nBlkY - 2)) * 3;

	mov	ecx, DWORD PTR [esi+68]
	lea	eax, DWORD PTR [ebx-3]
	add	eax, ecx

; 1534 :     int xx = 0; // logical offset. Mul by 2 for pixelsize_super==2. Don't mul for indexing int* array
; 1535 :     for (int bx = 0; bx < nBlkX; ++bx)

	mov	edi, DWORD PTR [esi+64]
	cdq
	add	ecx, -2					; fffffffeH
	idiv	ecx
	xor	ebx, ebx
	mov	DWORD PTR _xx$1$[esp+5248], ebx
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _wby$1$[esp+5248], eax
	xor	eax, eax
	mov	DWORD PTR _bx$1$[esp+5248], eax
	test	edi, edi
	jle	$LN166@process_ch
$LL7@process_ch:

; 1539 :       short *winOverUV = _overwins_uv->GetWindow(wby + wbx);

	add	eax, -3					; fffffffdH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	esi, DWORD PTR [esi+224]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1539 :       short *winOverUV = _overwins_uv->GetWindow(wby + wbx);

	add	eax, edi
	lea	ecx, DWORD PTR [edi-2]
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	ecx, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1539 :       short *winOverUV = _overwins_uv->GetWindow(wby + wbx);

	add	eax, DWORD PTR _wby$1$[esp+5248]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	imul	eax, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1546 :       for (int k = 0; k < _trad * 2; ++k)

	mov	esi, DWORD PTR _this$1$[esp+5248]
	imul	edi, DWORD PTR _y_beg$[ebp]
	add	edi, DWORD PTR _bx$1$[esp+5248]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	lea	eax, DWORD PTR [ecx+eax*2]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1541 :       int i = by * nBlkX + bx;

	mov	DWORD PTR _i$1$[esp+5248], edi
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	DWORD PTR _winOverUV$1$[esp+5248], eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1546 :       for (int k = 0; k < _trad * 2; ++k)

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+164]
	add	eax, eax
	mov	DWORD PTR _k$1$[esp+5248], ecx
	mov	DWORD PTR $T1[esp+5248], eax
	test	eax, eax
	jle	$LN9@process_ch

; 1547 :       {
; 1548 :         use_block_uv(

	xor	eax, eax
	lea	edx, DWORD PTR [esi+556]
	mov	DWORD PTR tv1244[esp+5248], eax
	mov	DWORD PTR tv1242[esp+5248], edx
	npad	15
$LL10@process_ch:

; 1636 :   if (usable_flag)

	cmp	BYTE PTR [esi+ecx+292], 0

; 1547 :       {
; 1548 :         use_block_uv(

	mov	edx, DWORD PTR [edx]

; 1636 :   if (usable_flag)

	je	$LN107@process_ch
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	ecx, DWORD PTR [esi+152]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	edi, DWORD PTR [edi+edi*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	DWORD PTR tv1151[esp+5248], ecx
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	mov	ebx, DWORD PTR [ecx+edi*4+4]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+edi*4+8]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	imul	ebx, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+204]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[esp+5248], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T2[esp+5248], xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1640 :     const int bly = block.GetY() * nPel + block.GetMV().y;

	add	ebx, DWORD PTR $T2[esp+5252]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	sar	ebx, cl
	mov	ecx, DWORD PTR tv1151[esp+5248]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1639 :     const int blx = block.GetX() * nPel + block.GetMV().x;

	mov	edi, DWORD PTR [ecx+edi*4]
	imul	edi, DWORD PTR [esi+104]

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR [esi+200]
	add	edi, DWORD PTR $T3[esp+5248]
	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [edx+28]

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN129@process_ch

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebx
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [edx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN132@process_ch
$LN129@process_ch:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	esi, ebx

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN131@process_ch

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	esi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	esi, esi
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 1
	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN167@process_ch
$LN131@process_ch:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	esi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	esi, 2
	or	esi, eax

; 67   : 
; 68   :       nX >>= NPELL2;
; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, edi
	sar	edx, 2
	sar	ebx, 2
$LN167@process_ch:
	mov	edi, DWORD PTR tv1242[esp+5248]
	mov	ecx, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR tv1242[esp+5248]
	mov	esi, DWORD PTR _this$1$[esp+5248]
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	add	edi, edx
	mov	edx, DWORD PTR [eax]
	imul	ebx, DWORD PTR [edx+12]
	add	edi, ebx
$LN132@process_ch:
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1641 :     p = plane_ptr->GetPointer(blx >> _xratiouv_log, bly >> _yratiouv_log);

	mov	ecx, DWORD PTR _k$1$[esp+5248]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+5248], edi

; 1642 :     np = plane_ptr->GetPitch();

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edx, DWORD PTR _i$1$[esp+5248]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1642 :     np = plane_ptr->GetPitch();

	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+5248], eax
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR tv1151[esp+5248]
	lea	edi, DWORD PTR [edx+edx*4]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	edx, DWORD PTR tv1244[esp+5248]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	edi, DWORD PTR [eax+edi*4+16]
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	eax, DWORD PTR [esi+152]
	mov	edx, DWORD PTR [eax+edx+20]
; File c:\github\mvtools\sources\mvdegrain3.h

; 913  :   if (thSAD <= blockSAD)

	cmp	edx, edi
	jg	SHORT $LN145@process_ch
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
; File c:\github\mvtools\sources\mvdegrain3.h

; 915  :     return 0;

	xor	eax, eax
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR _i$1$[esp+5248]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax
	jmp	$LN8@process_ch
$LN145@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 917  :   if(bits_per_pixels <= 8) {

	cmp	DWORD PTR [esi+140], 8
	jg	SHORT $LN146@process_ch

; 918  :     const int thSAD2    = thSAD    * thSAD;

	imul	edx, edx

; 919  :     const int blockSAD2 = blockSAD * blockSAD;

	imul	edi, edi

; 920  :     const int num = thSAD2 - blockSAD2;

	mov	eax, edx
	sub	eax, edi

; 921  :     const int den = thSAD2 + blockSAD2;

	add	edi, edx

; 923  :     const int      res = int((num < (1<<23))

	cmp	eax, 8388608				; 00800000H
	jge	SHORT $LN149@process_ch
	shl	eax, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
	mov	edi, DWORD PTR _i$1$[esp+5248]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax
	jmp	$LN8@process_ch
$LN149@process_ch:
; File c:\github\mvtools\sources\mvdegrain3.h

; 923  :     const int      res = int((num < (1<<23))

	sar	edi, 8
	cdq
	idiv	edi
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
	mov	edi, DWORD PTR _i$1$[esp+5248]
	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax
	jmp	SHORT $LN8@process_ch
$LN146@process_ch:
	movd	xmm2, edx
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	cvtdq2ps xmm2, xmm2
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	ebx, DWORD PTR _xx$1$[esp+5248]
	movd	xmm1, edi
; File c:\github\mvtools\sources\mvdegrain3.h

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	cvtdq2ps xmm1, xmm1
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1646 :   else

	mov	edi, DWORD PTR _i$1$[esp+5248]
; File c:\github\mvtools\sources\mvdegrain3.h

; 934  :     const float sq_thSAD = float(thSAD) * float(thSAD); // std::powf(float(thSAD), 2.0f); 

	mulss	xmm2, xmm2

; 936  :     const float sq_blockSAD = float(blockSAD) * float(blockSAD); // std::powf(float(blockSAD), 2.0f);

	mulss	xmm1, xmm1

; 937  :     return (int)(256.0f*(sq_thSAD - sq_blockSAD) / (sq_thSAD + sq_blockSAD));

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	addss	xmm1, xmm2
	mulss	xmm0, xmm3
	divss	xmm0, xmm1
	cvttss2si eax, xmm0
; File c:\github\mvtools\sources\mdegrainn.cpp

; 1644 :     wref = DegrainWeight(c_info._thsadc, block_sad, bits_per_pixel);

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], eax

; 1646 :   else

	jmp	SHORT $LN8@process_ch
$LN107@process_ch:

; 1547 :       {
; 1548 :         use_block_uv(

	mov	eax, DWORD PTR [esi+192]
	imul	eax, ebx

; 1650 :     wref = 0;

	mov	DWORD PTR _weight_arr$4[esp+ecx*4+5252], 0
	add	eax, DWORD PTR _pSrcCur$1$[esp+5248]
	mov	DWORD PTR _ref_data_ptr_arr$6[esp+ecx*4+5248], eax
	mov	eax, DWORD PTR [esi+3664]
	mov	DWORD PTR _pitch_arr$5[esp+ecx*4+5248], eax
$LN8@process_ch:

; 1546 :       for (int k = 0; k < _trad * 2; ++k)

	mov	edx, DWORD PTR tv1242[esp+5248]
	inc	ecx
	mov	eax, DWORD PTR tv1244[esp+5248]
	add	edx, 12					; 0000000cH
	add	eax, 24					; 00000018H
	mov	DWORD PTR _k$1$[esp+5248], ecx
	mov	DWORD PTR tv1242[esp+5248], edx
	mov	DWORD PTR tv1244[esp+5248], eax
	cmp	ecx, DWORD PTR $T1[esp+5248]
	jl	$LL10@process_ch
$LN9@process_ch:

; 1549 :           ref_data_ptr_arr[k],
; 1550 :           pitch_arr[k],
; 1551 :           weight_arr[k + 1], // from 1st
; 1552 :           _usable_flag_arr[k],
; 1553 :           _mv_clip_arr[k],
; 1554 :           i,
; 1555 :           _planes_ptr[k][P],
; 1556 :           pSrcCur,
; 1557 :           xx * pixelsize_super, //  the pointer increment inside knows that xx later here is incremented with nBlkSize and not nBlkSize>>_xRatioUV
; 1558 :           _src_pitch_arr[P]
; 1559 :         );
; 1560 :       }
; 1561 : 
; 1562 :       norm_weights(weight_arr, _trad); // 0th + 1..MAX_TEMP_RAD*2

	mov	edi, DWORD PTR [esi+164]
	lea	ecx, DWORD PTR _weight_arr$4[esp+5248]
	mov	edx, edi
	call	?norm_weights@MDegrainN@@CAXQAHH@Z	; MDegrainN::norm_weights

; 1563 : 
; 1564 :       // chroma
; 1565 :       // here we don't pass pixelsize, because _degrainchroma_ptr points already to the uint16_t version
; 1566 :       // if the clip was 16 bit one
; 1567 :       _degrainchroma_ptr(

	mov	ecx, DWORD PTR [esi+192]
	lea	eax, DWORD PTR _weight_arr$4[esp+5248]
	push	edi
	mov	edi, DWORD PTR _tmpPitch$1$[esp+5252]
	push	eax
	lea	eax, DWORD PTR _pitch_arr$5[esp+5256]
	push	eax
	lea	eax, DWORD PTR _ref_data_ptr_arr$6[esp+5260]
	push	eax
	push	DWORD PTR [esi+3664]
	mov	eax, ecx
	imul	ecx, edi
	imul	eax, ebx
	add	eax, DWORD PTR _pSrcCur$1$[esp+5268]
	push	eax
	movzx	eax, BYTE PTR [esi+186]
	push	ecx
	push	eax
	push	DWORD PTR _tmp_block$[esp+7328]
	lea	eax, DWORD PTR _tmp_block$[esp+5284]
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax
	add	esp, 40					; 00000028H

; 1568 :         &tmp_block._d[0], tmp_block._lsb_ptr, _lsb_flag, tmpPitch * pixelsize_super,
; 1569 :         pSrcCur + xx * pixelsize_super, _src_pitch_arr[P],
; 1570 :         ref_data_ptr_arr, pitch_arr, weight_arr, _trad
; 1571 :       );
; 1572 :       if (_lsb_flag)

	cmp	BYTE PTR [esi+186], 0
	je	SHORT $LN11@process_ch

; 1573 :       {
; 1574 :         _overschroma_lsb_ptr(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+200]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+5252]
	lea	eax, DWORD PTR _tmp_block$[esp+5256]
	push	edi
	push	DWORD PTR _tmp_block$[esp+7308]
	push	eax
	mov	eax, DWORD PTR _pDstInt$1$[esp+5268]
	push	DWORD PTR [esi+288]
	lea	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	eax, DWORD PTR [esi+248]
	call	eax
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN15@process_ch
$LN11@process_ch:

; 1575 :           pDstInt + xx, _dst_int_pitch,
; 1576 :           &tmp_block._d[0], tmp_block._lsb_ptr, tmpPitch,
; 1577 :           winOverUV, nBlkSizeX >> _xratiouv_log
; 1578 :         );
; 1579 :       }
; 1580 :       else if(pixelsize_super == 1)

	mov	eax, DWORD PTR [esi+192]
	cmp	eax, 1
	jne	SHORT $LN13@process_ch

; 1581 :       {
; 1582 :         _overschroma_ptr(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+200]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+5252]
	lea	eax, DWORD PTR _tmp_block$[esp+5256]
	push	edi
	push	eax
	mov	eax, DWORD PTR _pDstShort$1$[esp+5264]
	push	DWORD PTR [esi+272]
	lea	eax, DWORD PTR [eax+ebx*2]
	push	eax
	mov	eax, DWORD PTR [esi+232]
	jmp	SHORT $LN168@process_ch
$LN13@process_ch:

; 1583 :           pDstShort + xx, _dst_short_pitch,
; 1584 :           &tmp_block._d[0], tmpPitch,
; 1585 :           winOverUV, nBlkSizeX >> _xratiouv_log);
; 1586 :       } else if (pixelsize_super == 2)

	cmp	eax, 2
	jne	SHORT $LN15@process_ch

; 1587 :       {
; 1588 :         _overschroma16_ptr(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+200]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+5252]
	lea	eax, DWORD PTR [edi+edi]
	push	eax
	lea	eax, DWORD PTR _tmp_block$[esp+5260]
	push	eax
	mov	eax, DWORD PTR _pDstInt$1$[esp+5264]
	push	DWORD PTR [esi+288]
	lea	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	eax, DWORD PTR [esi+240]
$LN168@process_ch:
	call	eax
	add	esp, 24					; 00000018H
$LN15@process_ch:

; 1589 :           (uint16_t*)(pDstInt + xx), _dst_int_pitch, 
; 1590 :           &tmp_block._d[0], tmpPitch*pixelsize_super, 
; 1591 :           winOverUV, nBlkSizeX >> _xratiouv_log);
; 1592 :       }
; 1593 : 
; 1594 :       xx += ((nBlkSizeX - nOverlapX) >> nLogxRatioUV); // no pixelsize here

	mov	eax, DWORD PTR [esi+76]
	sub	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+128]
	mov	edi, DWORD PTR [esi+64]
	movss	xmm3, DWORD PTR __real@43800000
	sar	eax, cl
	add	ebx, eax
	mov	eax, DWORD PTR _bx$1$[esp+5248]
	inc	eax
	mov	DWORD PTR _xx$1$[esp+5248], ebx
	mov	DWORD PTR _bx$1$[esp+5248], eax
	cmp	eax, edi
	jl	$LL7@process_ch
$LN166@process_ch:

; 1595 : 
; 1596 :     } // for bx
; 1597 : 
; 1598 :     pSrcCur += effective_nSrcPitch; // pitch is byte granularity

	mov	eax, DWORD PTR _effective_nSrcPitch$1$[esp+5248]
	add	DWORD PTR _pSrcCur$1$[esp+5248], eax

; 1599 :     pDstShort += effective_dstShortPitch; // pitch is short granularity

	mov	eax, DWORD PTR tv1247[esp+5248]
	mov	ebx, DWORD PTR _y_beg$[ebp]
	add	DWORD PTR _pDstShort$1$[esp+5248], eax
	inc	ebx

; 1600 :     pDstInt += effective_dstIntPitch; // pitch is int granularity

	mov	eax, DWORD PTR tv1246[esp+5248]
	add	DWORD PTR _pDstInt$1$[esp+5248], eax
	mov	DWORD PTR _y_beg$[ebp], ebx
	cmp	ebx, DWORD PTR _y_end$[ebp]
	jl	$LL4@process_ch
$LN3@process_ch:

; 1601 :   } // for by
; 1602 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??$process_chroma_overlap_slice@$01@MDegrainN@@AAEXHH@Z ENDP ; MDegrainN::process_chroma_overlap_slice<2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$dead$ = 16					; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$dead$ = 24					; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1083 : 		{	// insert value_type(_Val...) at _Where

	push	edi

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	push	DWORD PTR _<_Val_1>$[esp+4]
	mov	edi, ecx
	push	ecx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, edi
	push	eax
	push	DWORD PTR __Where$[esp+8]
	push	DWORD PTR ___$ReturnUdt$[esp+12]
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	pop	edi

; 1086 : 			this->_Myval(_Newnode), _Newnode));
; 1087 : 		}

	ret	20					; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$AtomicInt@H@conc@@$$V@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$AtomicInt@H@conc@@$$V@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z PROC ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN7@construct
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 54   : :	_val ()

	mov	DWORD PTR [eax], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	4
??$construct@V?$AtomicInt@H@conc@@$$V@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z ENDP ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MDegrainN@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VMvClipInfo@MDegrainN@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z PROC ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN7@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [eax], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [eax+4], 0

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [eax+8], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [eax+12], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	4
??$construct@VMvClipInfo@MDegrainN@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAV?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAV?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z PROC ; std::_Unchecked<conc::AtomicInt<int> *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAV?$AtomicInt@H@conc@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@@Z ENDP ; std::_Unchecked<conc::AtomicInt<int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move_al_unchecked@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAV?$AtomicInt@H@conc@@PAV12@@std@@YAAAPAV?$AtomicInt@H@conc@@AAPAV12@PAV12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAV?$AtomicInt@H@conc@@PAV12@@std@@YAAAPAV?$AtomicInt@H@conc@@AAPAV12@PAV12@@Z PROC ; std::_Rechecked<conc::AtomicInt<int> *,conc::AtomicInt<int> *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAV?$AtomicInt@H@conc@@PAV12@@std@@YAAAPAV?$AtomicInt@H@conc@@AAPAV12@PAV12@@Z ENDP ; std::_Rechecked<conc::AtomicInt<int> *,conc::AtomicInt<int> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
??$_Unchecked@PAH@std@@YAPAHPAH@Z PROC			; std::_Unchecked<int *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAH@std@@YAPAHPAH@Z ENDP			; std::_Unchecked<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<int *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 306  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z
_TEXT	SEGMENT
??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z PROC	; std::_Rechecked<int *,int *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z ENDP	; std::_Rechecked<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 306  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned short *,unsigned short *,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAVMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAVMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z PROC ; std::_Unchecked<MDegrainN::MvClipInfo *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAVMvClipInfo@MDegrainN@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@@Z ENDP ; std::_Unchecked<MDegrainN::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAVMvClipInfo@MDegrainN@@PAV12@@std@@YAAAPAVMvClipInfo@MDegrainN@@AAPAV12@PAV12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAVMvClipInfo@MDegrainN@@PAV12@@std@@YAAAPAVMvClipInfo@MDegrainN@@AAPAV12@PAV12@@Z PROC ; std::_Rechecked<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAVMvClipInfo@MDegrainN@@PAV12@@std@@YAAAPAVMvClipInfo@MDegrainN@@AAPAV12@PAV12@@Z ENDP ; std::_Rechecked<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VMvClipInfo@MDegrainN@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VMvClipInfo@MDegrainN@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z PROC ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::destroy<MDegrainN::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	??1MvClipInfo@MDegrainN@@QAE@XZ

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@VMvClipInfo@MDegrainN@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::destroy<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 2059 : 		{	// find leftmost node not less than _Keyval

	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [ecx]

; 2060 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [edi+4]

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN110@Lbound
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	esi, DWORD PTR __Keyval$[esp+8]
	mov	ebx, DWORD PTR [esi+12]
$LL2@Lbound:
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, ebx
	jl	SHORT $LN66@Lbound
	cmp	ebx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [esi+8]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [esi+4]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LN66@Lbound
$LN4@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2068 : 				_Wherenode = _Pnode;

	mov	edi, eax

; 2069 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN5@Lbound
$LN66@Lbound:

; 2064 : 			if (_Compare(this->_Key(_Pnode), _Keyval))
; 2065 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN5@Lbound:

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Lbound
	pop	esi
	pop	ebx
$LN110@Lbound:

; 2070 : 				}
; 2071 : 
; 2072 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, edi
	pop	edi

; 2073 : 		}

	ret	4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z PROC ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>, COMDAT
; __Val$ = ecx

; 62   : 		return (_Val.first);

	mov	eax, ecx

; 63   : 		}

	ret	0
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ENDP ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Compare, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	push	esi
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [ecx+12]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx+4]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ecx]
	jl	SHORT $LN16@Compare
$LN15@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	xor	al, al
	pop	esi

; 2048 : 		}

	ret	8
$LN16@Compare:

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	mov	al, 1
	pop	esi

; 2048 : 		}

	ret	8
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 906  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicmem.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicmem.hpp
;	COMDAT ?cas@?$AtomicMem@$01@conc@@SAHACHHH@Z
_TEXT	SEGMENT
_comp$ = 8						; size = 4
?cas@?$AtomicMem@$01@conc@@SAHACHHH@Z PROC		; conc::AtomicMem<2>::cas, COMDAT
; _dest$ = ecx
; _excg$ = edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, DWORD PTR _comp$[esp-4]
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicmem.hpp

; 55   : }

	ret	0
?cas@?$AtomicMem@$01@conc@@SAHACHHH@Z ENDP		; conc::AtomicMem<2>::cas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$dead$ = 8					; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$dead$ = 16					; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

	push	esi

; 881  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode0
	mov	edx, eax

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edx+16]

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN65@Buynode
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	ecx, DWORD PTR _<_Val_1>$[esp]
	mov	ecx, DWORD PTR [ecx]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 895  : 		return (_Pnode);

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [esi+16], 0
$LN65@Buynode:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 896  : 		}

	pop	esi
	ret	12					; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
$T2 = -24						; size = 8
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1655 : 		{	// try to insert node using _Where as a hint

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx

; 1656 : 		const_iterator _Next;
; 1657 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1658 : 
; 1659 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1660 : 
; 1661 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1662 : 		if (_Where._Getcont() != &this->_Get_data())
; 1663 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1664 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1665 : 
; 1666 : 		if (size() == 0)

	cmp	DWORD PTR [ebx+4], 0
	mov	DWORD PTR _this$1$[ebp], ebx
	jne	SHORT $LN3@Insert_hin

; 1667 : 			return (_Insert_at(true, this->_Myhead(),

	push	DWORD PTR __Newnode$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	push	DWORD PTR [ebx]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@Insert_hin:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edi, DWORD PTR [ebx]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	esi, DWORD PTR __Where$[ebp]
	cmp	esi, DWORD PTR [edi]

; 1668 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1669 : 		else if (this->_Multi)
; 1670 : 			{	// insert even if duplicate
; 1671 : 			if (_Where == begin())
; 1672 : 				{	// insert at beginning if before first element
; 1673 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1674 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1675 : 					return (_Insert_at(true, _Where._Mynode(),
; 1676 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1677 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1678 : 				}
; 1679 : 			else if (_Where == end())
; 1680 : 				{	// insert at end if after last element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1683 : 					return (_Insert_at(false, _Rmost(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				}
; 1686 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1687 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1688 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1689 : 					this->_Kfn(_Val),
; 1690 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1691 : 				{	// insert before _Where
; 1692 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1693 : 					return (_Insert_at(false, _Next._Mynode(),
; 1694 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1695 : 				else
; 1696 : 					return (_Insert_at(true, _Where._Mynode(),
; 1697 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1698 : 				}
; 1699 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1701 : 				&& (++(_Next = _Where) == end()
; 1702 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1703 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1704 : 				{	// insert after _Where
; 1705 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1706 : 					return (_Insert_at(false, _Where._Mynode(),
; 1707 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1708 : 				else
; 1709 : 					return (_Insert_at(true, _Next._Mynode(),
; 1710 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1711 : 				}
; 1712 : 			else
; 1713 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1714 : 			}
; 1715 : 		else
; 1716 : 			{	// insert only if unique
; 1717 : 			if (_Where == begin())

	jne	SHORT $LN22@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1719 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1720 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1721 : 					return (_Insert_at(true, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN22@Insert_hin:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi

; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				}
; 1724 : 			else if (_Where == end())

	jne	SHORT $LN25@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1727 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1728 : 					return (_Insert_at(false, _Rmost(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN25@Insert_hin:

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	ebx, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	ebx
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN28@Insert_hin

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	DWORD PTR __Next$[ebp], esi

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator--

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	ebx, DWORD PTR __Next$[ebp]
	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN761@Insert_hin

; 1734 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1735 : 					this->_Kfn(_Val)))
; 1736 : 				{	// insert before _Where
; 1737 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [ebx+8]

; 1738 : 					return (_Insert_at(false, _Next._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN30@Insert_hin
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN30@Insert_hin:

; 1739 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1740 : 				else
; 1741 : 					return (_Insert_at(true, _Where._Mynode(),

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN761@Insert_hin:
	mov	ebx, DWORD PTR __Val$[ebp]
$LN28@Insert_hin:

; 1746 : 				&& (++(_Next = _Where) == end()

	push	ebx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1746 : 				&& (++(_Next = _Where) == end()

	mov	DWORD PTR __Next$[ebp], esi

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator++

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR __Next$[ebp]
	cmp	ebx, edi

; 1746 : 				&& (++(_Next = _Where) == end()

	je	SHORT $LN33@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1746 : 				&& (++(_Next = _Where) == end()

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN35@Insert_hin
$LN33@Insert_hin:

; 1747 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1749 : 				{	// insert after _Where
; 1750 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

	mov	eax, DWORD PTR [esi+8]

; 1751 : 					return (_Insert_at(false, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN34@Insert_hin
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN34@Insert_hin:

; 1752 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1753 : 				else
; 1754 : 					return (_Insert_at(true, _Next._Mynode(),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1760 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN764@Insert_hin:
$LN35@Insert_hin:

; 1761 : 		_CATCH_END
; 1762 : 
; 1763 : 		return (_Insert_nohint(_Leftish,

	push	DWORD PTR __Newnode$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	push	DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN763@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@@Z
_TEXT	SEGMENT
??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@@Z PROC ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN5@construct
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 54   : :	_val ()

	mov	DWORD PTR [edx], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@@Z ENDP ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z
_TEXT	SEGMENT
??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z PROC ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN5@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [edx], xmm0
	movq	QWORD PTR [edx+16], xmm0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [edx], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [edx+4], 0

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [edx+8], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [edx+12], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z ENDP ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$AtomicInt@H@conc@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$AtomicInt@H@conc@@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@V?$AtomicInt@H@conc@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$AtomicInt@H@conc@@0@Z PROC ; std::_Ptr_move_cat<conc::AtomicInt<int>,conc::AtomicInt<int> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	xor	al, al

; 811  : 	}

	ret	0
??$_Ptr_move_cat@V?$AtomicInt@H@conc@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$AtomicInt@H@conc@@0@Z ENDP ; std::_Ptr_move_cat<conc::AtomicInt<int>,conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	esi, edx
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN28@Uninitiali
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 72   : :	_val (other._val)

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN28@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 4
	add	eax, 4
	cmp	esi, edx
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);
; 285  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@PAV?$AtomicInt@H@conc@@PAV12@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@YAPAV?$AtomicInt@H@conc@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<conc::AtomicInt<int> *,conc::AtomicInt<int> *,std::allocator<conc::AtomicInt<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z PROC ; std::_Ptr_move_cat<int,int>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	mov	eax, ecx

; 811  : 	}

	ret	0
??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ENDP ; std::_Ptr_move_cat<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<int,int,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 294  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<int,int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z PROC ; std::_Ptr_move_cat<unsigned short,unsigned short>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	mov	eax, ecx

; 811  : 	}

	ret	0
??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ENDP ; std::_Ptr_move_cat<unsigned short,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@GGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@GGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<unsigned short,unsigned short,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 294  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@GGV?$allocator@G@std@@@std@@YAPAGPAG00AAU?$_Wrap_alloc@V?$allocator@G@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<unsigned short,unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@VMvClipInfo@MDegrainN@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MDegrainN@@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@VMvClipInfo@MDegrainN@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MDegrainN@@0@Z PROC ; std::_Ptr_move_cat<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	xor	al, al

; 811  : 	}

	ret	0
??$_Ptr_move_cat@VMvClipInfo@MDegrainN@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MDegrainN@@0@Z ENDP ; std::_Ptr_move_cat<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN3@Uninitiali
	push	esi
	lea	esi, DWORD PTR [ecx+4]
	npad	4
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN28@Uninitiali
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	ecx, DWORD PTR [esi-4]
	mov	DWORD PTR [eax], ecx

; 56   : ,	_count_ptr (other._count_ptr)

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+4], ecx

; 259  : 	if (_count_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN40@Uninitiali

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [ecx]
$LN40@Uninitiali:

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], ecx

; 56   : ,	_count_ptr (other._count_ptr)

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+12], ecx

; 259  : 	if (_count_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN45@Uninitiali

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [ecx]
$LN45@Uninitiali:
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+20], ecx
$LN28@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 24					; 00000018H
	add	eax, 24					; 00000018H
	lea	ecx, DWORD PTR [esi-4]
	cmp	ecx, edx
	jne	SHORT $LL4@Uninitiali
	pop	esi
$LN3@Uninitiali:

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);
; 285  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MDegrainN@@PAV12@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@YAPAVMvClipInfo@MDegrainN@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<MDegrainN::MvClipInfo *,MDegrainN::MvClipInfo *,std::allocator<MDegrainN::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VMvClipInfo@MDegrainN@@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z
_TEXT	SEGMENT
??$destroy@VMvClipInfo@MDegrainN@@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z PROC ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::destroy<MDegrainN::MvClipInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 863  : 		{	// destroy object at _Ptr

	mov	ecx, edx
	jmp	??1MvClipInfo@MDegrainN@@QAE@XZ
??$destroy@VMvClipInfo@MDegrainN@@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@@Z ENDP ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::destroy<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

	mov	eax, esi
	pop	esi

; 314  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 210  : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Freenode0, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 876  : 		}

	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 849  : 		{	// allocate a non-value node

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN73@Buynode0
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
$LN73@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN187@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN187@Buynode0:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 864  : 		return (_Pnode);

	mov	eax, esi
	pop	esi

; 865  : 		}

	ret	0
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1645 : 		}

	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::size, COMDAT
; _this$ = ecx

; 1171 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1172 : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 946  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z
_TEXT	SEGMENT
??$move@AAV?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z PROC ; std::move<conc::AtomicInt<int> &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAV?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z ENDP ; std::move<conc::AtomicInt<int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAVMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z
_TEXT	SEGMENT
??$move@AAVMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z PROC ; std::move<MDegrainN::MvClipInfo &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAVMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z ENDP ; std::move<MDegrainN::MvClipInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN25@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN25@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z PROC ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@0@AAU10@@Z ENDP ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	push	edi
	mov	edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 119304646				; 071c71c6H
	jb	SHORT $LN5@Insert_at
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Node$[esp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1831 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN716@Insert_at:
$LN5@Insert_at:
	push	ebx

; 1832 : 			}
; 1833 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1834 : 			_STD forward<_Valty>(_Val));
; 1835 : 
; 1836 : 		++this->_Mysize();
; 1837 : 		_Newnode->_Parent = _Wherenode;

	mov	ebx, DWORD PTR __Node$[esp+4]
	inc	eax
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Wherenode$[esp+4]
	push	esi
	mov	DWORD PTR [ebx+4], eax

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1842 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+8], 0
	je	SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	ecx, DWORD PTR [edi]

; 1848 : 			if (_Wherenode == _Lmost())

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1850 : 			}
; 1851 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	ecx, DWORD PTR [edi]

; 1854 : 			if (_Wherenode == _Rmost())

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1855 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
	npad	1
$LL2@Insert_at:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN714@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1878 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN361@Insert_at

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN361@Insert_at:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2119 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN362@Insert_at

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN362@Insert_at:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN364@Insert_at

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN364@Insert_at:

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	SHORT $LN713@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN714@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1904 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN560@Insert_at

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN560@Insert_at:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2089 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN561@Insert_at

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN564@Insert_at
$LN561@Insert_at:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN563@Insert_at

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2093 : 		else

	jmp	SHORT $LN564@Insert_at
$LN563@Insert_at:

; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN564@Insert_at:

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN713@Insert_at:

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ebx
	pop	ebx
	pop	edi

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1916 : 		}

	ret	20					; 00000014H
$LN715@Insert_at:
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
tv1241 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
$T3 = 16						; size = 4
__Where$4 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	eax, ecx

; 1772 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	ebx
	push	esi
	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR [eax]

; 1773 : 		_Nodeptr _Trynode = _Root();
; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1771 : 		{	// try to insert node, on left if _Leftish

	mov	DWORD PTR _this$1$[ebp], eax

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	al, 1
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, DWORD PTR [ecx+4]

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv1241[ebp], ecx

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], al

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN3@Insert_noh
	mov	esi, DWORD PTR [edi+12]
$LL2@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1779 : 			_Wherenode = _Trynode;

	mov	ebx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	cmp	esi, eax
	jl	SHORT $LN142@Insert_noh
	cmp	eax, esi
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edx+24]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edx+20]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN142@Insert_noh
$LN141@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	mov	edx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	xor	al, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	jmp	SHORT $LN420@Insert_noh
$LN142@Insert_noh:
	mov	edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	al, 1
$LN420@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	BYTE PTR __Addleft$2[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	je	SHORT $LL2@Insert_noh
	mov	ecx, DWORD PTR tv1241[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	esi, ebx
	mov	DWORD PTR __Where$4[ebp], esi

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1798 : 			if (!_Addleft)

	test	al, al
	je	SHORT $LN12@Insert_noh

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ebx, DWORD PTR [ecx]

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	1
$LN421@Insert_noh:
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator--
	mov	esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edi+4]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edi]
	jl	SHORT $LN296@Insert_noh
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN296@Insert_noh:

; 1802 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 			else
; 1804 : 				--_Where;	// need to test if insert before is okay
; 1805 : 
; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	DWORD PTR __Addleft$2[ebp]
	jmp	$LN421@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1819 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN422@Insert_noh:
$LN419@Insert_noh:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z PROC ; std::allocator<conc::AtomicInt<int> >::construct<conc::AtomicInt<int> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@construct
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 54   : :	_val ()

	mov	DWORD PTR [eax], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	4
??$construct@V?$AtomicInt@H@conc@@$$V@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@@Z ENDP ; std::allocator<conc::AtomicInt<int> >::construct<conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z PROC ; std::allocator<MDegrainN::MvClipInfo>::construct<MDegrainN::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [eax], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [eax+4], 0

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [eax+8], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [eax+12], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	4
??$construct@VMvClipInfo@MDegrainN@@$$V@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ENDP ; std::allocator<MDegrainN::MvClipInfo>::construct<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$AtomicInt@H@conc@@V12@@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$AtomicInt@H@conc@@V12@@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 72   : :	_val (other._val)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	8
??$construct@V?$AtomicInt@H@conc@@V12@@?$_Wrap_alloc@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2301 : 	{	// implement copy-like function as memmove

	push	esi

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;
; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	ret	0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z PROC		; std::_Copy_memmove<unsigned short *,unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2301 : 	{	// implement copy-like function as memmove

	push	esi

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;
; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	ret	0
??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z ENDP		; std::_Copy_memmove<unsigned short *,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MDegrainN@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VMvClipInfo@MDegrainN@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN25@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN25@construct:

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN30@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN30@construct:
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	8
??$construct@VMvClipInfo@MDegrainN@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VMvClipInfo@MDegrainN@@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VMvClipInfo@MDegrainN@@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z PROC ; std::allocator<MDegrainN::MvClipInfo>::destroy<MDegrainN::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 743  : 		{	// destroy object at _Ptr

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	??1MvClipInfo@MDegrainN@@QAE@XZ

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@VMvClipInfo@MDegrainN@@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@@Z ENDP ; std::allocator<MDegrainN::MvClipInfo>::destroy<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0MvClipInfo@MDegrainN@@QAE@XZ
_TEXT	SEGMENT
??0MvClipInfo@MDegrainN@@QAE@XZ PROC			; MDegrainN::MvClipInfo::MvClipInfo, COMDAT
; _this$ = ecx

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [ecx+4], 0

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx+8], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [ecx+12], 0
	ret	0
??0MvClipInfo@MDegrainN@@QAE@XZ ENDP			; MDegrainN::MvClipInfo::MvClipInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMvClipInfo@MDegrainN@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GMvClipInfo@MDegrainN@@QAEPAXI@Z PROC		; MDegrainN::MvClipInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MvClipInfo@MDegrainN@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	4
??_GMvClipInfo@MDegrainN@@QAEPAXI@Z ENDP		; MDegrainN::MvClipInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??1MvClipInfo@MDegrainN@@QAE@XZ
_TEXT	SEGMENT
??1MvClipInfo@MDegrainN@@QAE@XZ PROC			; MDegrainN::MvClipInfo::~MvClipInfo, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN8@MvClipInfo

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+12]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@MvClipInfo
	push	edi

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN13@MvClipInfo
	mov	ecx, edi
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@MvClipInfo:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+12], 0
	pop	edi
$LN8@MvClipInfo:

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN21@MvClipInfo

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN21@MvClipInfo

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN23@MvClipInfo
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN23@MvClipInfo:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN21@MvClipInfo:
	pop	esi
	ret	0
??1MvClipInfo@MDegrainN@@QAE@XZ ENDP			; MDegrainN::MvClipInfo::~MvClipInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,std::_Iterator_base0>::operator--

; 425  : 		--static_cast<_Mybase&>(*this);
; 426  : 		return (*this);

	mov	eax, esi
	pop	esi

; 427  : 		}

	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1176 : 		return (this->_Getal().max_size());

	mov	eax, 119304647				; 071c71c7H

; 1177 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 119304647				; 071c71c7H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 119304647				; 071c71c7H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 119304647				; 071c71c7H

; 750  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0?$SharedPtr@VMVClip@@@@QAE@XZ
_TEXT	SEGMENT
??0?$SharedPtr@VMVClip@@@@QAE@XZ PROC			; SharedPtr<MVClip>::SharedPtr<MVClip>, COMDAT
; _this$ = ecx

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx], 0

; 38   : 	// Nothing
; 39   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$SharedPtr@VMVClip@@@@QAE@XZ ENDP			; SharedPtr<MVClip>::SharedPtr<MVClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ
_TEXT	SEGMENT
??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ PROC		; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>, COMDAT
; _this$ = ecx

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx], 0

; 38   : 	// Nothing
; 39   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@XZ ENDP		; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??0?$AtomicInt@H@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$AtomicInt@H@conc@@QAE@XZ PROC			; conc::AtomicInt<int>::AtomicInt<int>, COMDAT
; _this$ = ecx

; 54   : :	_val ()

	mov	DWORD PTR [ecx], 0

; 56   : 	assert (is_ptr_aligned_nz ((const void *) (&_val), sizeof (_val)));
; 57   : }

	mov	eax, ecx
	ret	0
??0?$AtomicInt@H@conc@@QAE@XZ ENDP			; conc::AtomicInt<int>::AtomicInt<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
_<_Args_2>$dead$ = 16					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN14@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN14@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &>, COMDAT
; _this$dead$ = ecx

; 1630 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[esp-4]

; 1631 : 		}

	ret	8
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z
_TEXT	SEGMENT
??$forward@V?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z PROC ; std::forward<conc::AtomicInt<int> >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$AtomicInt@H@conc@@@std@@YA$$QAV?$AtomicInt@H@conc@@AAV12@@Z ENDP ; std::forward<conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@$$QAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@$$QAV34@@Z PROC ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 72   : :	_val (other._val)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator_traits@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@SAXAAV?$allocator@V?$AtomicInt@H@conc@@@1@PAV?$AtomicInt@H@conc@@$$QAV34@@Z ENDP ; std::allocator_traits<std::allocator<conc::AtomicInt<int> > >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@VMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z
_TEXT	SEGMENT
??$forward@VMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z PROC ; std::forward<MDegrainN::MvClipInfo>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@VMvClipInfo@MDegrainN@@@std@@YA$$QAVMvClipInfo@MDegrainN@@AAV12@@Z ENDP ; std::forward<MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@$$QAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@$$QAV34@@Z PROC ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN20@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN20@construct:

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN25@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN25@construct:
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MDegrainN@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MDegrainN@@@1@PAVMvClipInfo@MDegrainN@@$$QAV34@@Z ENDP ; std::allocator_traits<std::allocator<MDegrainN::MvClipInfo> >::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z PROC ; std::allocator<conc::AtomicInt<int> >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 72   : :	_val (other._val)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	8
??$construct@V?$AtomicInt@H@conc@@V12@@?$allocator@V?$AtomicInt@H@conc@@@std@@QAEXPAV?$AtomicInt@H@conc@@$$QAV23@@Z ENDP ; std::allocator<conc::AtomicInt<int> >::construct<conc::AtomicInt<int>,conc::AtomicInt<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z PROC ; std::allocator<MDegrainN::MvClipInfo>::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN15@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN15@construct:

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN20@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN20@construct:
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	8
??$construct@VMvClipInfo@MDegrainN@@V12@@?$allocator@VMvClipInfo@MDegrainN@@@std@@QAEXPAVMvClipInfo@MDegrainN@@$$QAV23@@Z ENDP ; std::allocator<MDegrainN::MvClipInfo>::construct<MDegrainN::MvClipInfo,MDegrainN::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0MvClipInfo@MDegrainN@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0MvClipInfo@MDegrainN@@QAE@$$QAV01@@Z PROC		; MDegrainN::MvClipInfo::MvClipInfo, COMDAT
; _this$ = ecx

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR ___that$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN6@MvClipInfo

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN6@MvClipInfo:

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN11@MvClipInfo

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN11@MvClipInfo:
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, ecx
	ret	4
??0MvClipInfo@MDegrainN@@QAE@$$QAV01@@Z ENDP		; MDegrainN::MvClipInfo::MvClipInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0?$SharedPtr@VMVClip@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??0?$SharedPtr@VMVClip@@@@QAE@ABV0@@Z PROC		; SharedPtr<MVClip>::SharedPtr<MVClip>, COMDAT
; _this$ = ecx

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR _other$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN6@SharedPtr

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN6@SharedPtr:

; 58   : 	assert (other.is_valid ());
; 59   : 	add_ref ();
; 60   : 	assert (is_consistent (other));
; 61   : }

	mov	eax, ecx
	ret	4
??0?$SharedPtr@VMVClip@@@@QAE@ABV0@@Z ENDP		; SharedPtr<MVClip>::SharedPtr<MVClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@ABV0@@Z PROC	; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>, COMDAT
; _this$ = ecx

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR _other$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN6@SharedPtr

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN6@SharedPtr:

; 58   : 	assert (other.is_valid ());
; 59   : 	add_ref ();
; 60   : 	assert (is_consistent (other));
; 61   : }

	mov	eax, ecx
	ret	4
??0?$SharedPtr@VMVGroupOfFrames@@@@QAE@ABV0@@Z ENDP	; SharedPtr<MVGroupOfFrames>::SharedPtr<MVGroupOfFrames>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??0?$AtomicInt@H@conc@@QAE@ABV01@@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??0?$AtomicInt@H@conc@@QAE@ABV01@@Z PROC		; conc::AtomicInt<int>::AtomicInt<int>, COMDAT
; _this$ = ecx

; 72   : :	_val (other._val)

	mov	eax, DWORD PTR _other$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 74   : 	assert (is_ptr_aligned_nz ((const void *) (&_val), sizeof (_val)));
; 75   : 	assert (&other != 0);
; 76   : }

	mov	eax, ecx
	ret	4
??0?$AtomicInt@H@conc@@QAE@ABV01@@Z ENDP		; conc::AtomicInt<int>::AtomicInt<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)><std::tuple<int,int,int,enum arch_t> &&>, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1197 : 		}

	mov	eax, ecx

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+16], 0

; 1197 : 		}

	ret	12					; 0000000cH
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)><std::tuple<int,int,int,enum arch_t> &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1183 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+16], 0
	ret	16					; 00000010H
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AXPAE0_NHPBEHQAPBEQAH4H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,void (__cdecl*)(unsigned char *,unsigned char *,bool,int,unsigned char const *,int,unsigned char const * * const,int * const,int * const,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
_TEXT	ENDS
END
