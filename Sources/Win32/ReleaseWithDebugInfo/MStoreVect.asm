; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mstorevect.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EE@NAALHOCC@MStoreVect?3?5all?5vector?5clips?5sho@ ; `string'
PUBLIC	??_C@_0CD@DMGMBPGF@MStoreVect?3?5invalid?5vector?5strea@ ; `string'
PUBLIC	??_7MStoreVect@@6B@				; MStoreVect::`vftable'
PUBLIC	??_R0?AVMStoreVect@@@8				; MStoreVect `RTTI Type Descriptor'
PUBLIC	??_R4MStoreVect@@6B@				; MStoreVect::`RTTI Complete Object Locator'
PUBLIC	??_R2MStoreVect@@8				; MStoreVect::`RTTI Base Class Array'
PUBLIC	??_R3MStoreVect@@8				; MStoreVect::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@MStoreVect@@8			; MStoreVect::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@MStoreVect@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MStoreVect@@8 DD FLAT:??_R0?AVMStoreVect@@@8 ; MStoreVect::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MStoreVect@@8
rdata$r	ENDS
;	COMDAT ??_R3MStoreVect@@8
rdata$r	SEGMENT
??_R3MStoreVect@@8 DD 00H				; MStoreVect::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2MStoreVect@@8
rdata$r	ENDS
;	COMDAT ??_R2MStoreVect@@8
rdata$r	SEGMENT
??_R2MStoreVect@@8 DD FLAT:??_R1A@?0A@EA@MStoreVect@@8	; MStoreVect::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
rdata$r	ENDS
;	COMDAT ??_R4MStoreVect@@6B@
rdata$r	SEGMENT
??_R4MStoreVect@@6B@ DD 00H				; MStoreVect::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMStoreVect@@@8
	DD	FLAT:??_R3MStoreVect@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMStoreVect@@@8
data$r	SEGMENT
??_R0?AVMStoreVect@@@8 DD FLAT:??_7type_info@@6B@	; MStoreVect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMStoreVect@@', 00H
data$r	ENDS
;	COMDAT ?ver@?1??GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z@4HB
CONST	SEGMENT
?ver@?1??GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z@4HB DD 05H ; `MStoreVect::GetFrame'::`2'::ver
CONST	ENDS
;	COMDAT ??_7MStoreVect@@6B@
CONST	SEGMENT
??_7MStoreVect@@6B@ DD FLAT:??_R4MStoreVect@@6B@	; MStoreVect::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@GenericVideoFilter@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMStoreVect@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?key@?1??GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z@4HB
CONST	SEGMENT
?key@?1??GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z@4HB DD 0beadH ; `MStoreVect::GetFrame'::`2'::key
CONST	ENDS
;	COMDAT ??_C@_0CD@DMGMBPGF@MStoreVect?3?5invalid?5vector?5strea@
CONST	SEGMENT
??_C@_0CD@DMGMBPGF@MStoreVect?3?5invalid?5vector?5strea@ DB 'MStoreVect: '
	DB	'invalid vector stream.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@NAALHOCC@MStoreVect?3?5all?5vector?5clips?5sho@
CONST	SEGMENT
??_C@_0EE@NAALHOCC@MStoreVect?3?5all?5vector?5clips?5sho@ DB 'MStoreVect:'
	DB	' all vector clips should have the same number of frames.', 00H ; `string'
PUBLIC	??0VectData@MStoreVect@@QAE@$$QAV01@@Z		; MStoreVect::VectData::VectData
PUBLIC	??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z ; std::allocator<MStoreVect::VectData>::construct<MStoreVect::VectData,MStoreVect::VectData>
PUBLIC	??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData,MStoreVect::VectData>
PUBLIC	??$forward@VVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z ; std::forward<MStoreVect::VectData>
PUBLIC	??1VectData@MStoreVect@@QAE@XZ			; MStoreVect::VectData::~VectData
PUBLIC	??_GVectData@MStoreVect@@QAEPAXI@Z		; MStoreVect::VectData::`scalar deleting destructor'
PUBLIC	??0VectData@MStoreVect@@QAE@XZ			; MStoreVect::VectData::VectData
PUBLIC	??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z ; std::allocator<MStoreVect::VectData>::destroy<MStoreVect::VectData>
PUBLIC	??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData,MStoreVect::VectData>
PUBLIC	??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z ; std::allocator<MStoreVect::VectData>::construct<MStoreVect::VectData>
PUBLIC	??$move@AAVVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z ; std::move<MStoreVect::VectData &>
PUBLIC	??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::destroy<MStoreVect::VectData>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
PUBLIC	??$_Ptr_move_cat@VVectData@MStoreVect@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVVectData@MStoreVect@@0@Z ; std::_Ptr_move_cat<MStoreVect::VectData,MStoreVect::VectData>
PUBLIC	??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData>
PUBLIC	??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::destroy<MStoreVect::VectData>
PUBLIC	??$_Rechecked@PAVVectData@MStoreVect@@PAV12@@std@@YAAAPAVVectData@MStoreVect@@AAPAV12@PAV12@@Z ; std::_Rechecked<MStoreVect::VectData *,MStoreVect::VectData *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
PUBLIC	??$_Unchecked@PAVVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z ; std::_Unchecked<MStoreVect::VectData *>
PUBLIC	??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData>
PUBLIC	??$_Unfancy@VVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z ; std::_Unfancy<MStoreVect::VectData>
PUBLIC	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
PUBLIC	??$_Uninitialized_move@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ; std::_Uninitialized_move<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >
PUBLIC	??0?$allocator@VVectData@MStoreVect@@@std@@QAE@XZ ; std::allocator<MStoreVect::VectData>::allocator<MStoreVect::VectData>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::_Wrap_alloc<std::allocator<MStoreVect::VectData> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >::_Vector_val<std::_Simple_types<MStoreVect::VectData> >
PUBLIC	??$_Destroy_range@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
PUBLIC	??$_Umove@PAVVectData@MStoreVect@@@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEPAVVectData@MStoreVect@@PAV23@00@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Umove<MStoreVect::VectData *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1><>
PUBLIC	??$_Uninitialized_default_fill_n@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >
PUBLIC	?max_size@?$allocator@VVectData@MStoreVect@@@std@@QBEIXZ ; std::allocator<MStoreVect::VectData>::max_size
PUBLIC	?allocate@?$allocator@VVectData@MStoreVect@@@std@@QAEPAVVectData@MStoreVect@@I@Z ; std::allocator<MStoreVect::VectData>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAIABV?$allocator@VVectData@MStoreVect@@@2@@Z ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@I@Z ; std::allocator<MStoreVect::VectData>::deallocate
PUBLIC	?capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEPAVVectData@MStoreVect@@I@Z ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_second
PUBLIC	?_Unused_capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Unused_capacity
PUBLIC	?max_size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::max_size
PUBLIC	?_Destroy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXPAVVectData@MStoreVect@@0@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Destroy
PUBLIC	?_Grow_to@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEII@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reallocate
PUBLIC	?_Xlen@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEXXZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myend
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@I@Z ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_first
PUBLIC	?_Pop_back_n@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Pop_back_n
PUBLIC	?_Reserve@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reserve
PUBLIC	?_Tidy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXXZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Mylast
PUBLIC	??A?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEAAVPClip@@I@Z ; std::vector<PClip,std::allocator<PClip> >::operator[]
PUBLIC	??0?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >
PUBLIC	??1?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::~vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >
PUBLIC	?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::resize
PUBLIC	?size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::size
PUBLIC	??A?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEAAVVectData@MStoreVect@@I@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::operator[]
PUBLIC	?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z	; MStoreVect::write_to_clip
PUBLIC	?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MStoreVect::GetFrame
PUBLIC	??_GMStoreVect@@UAEPAXI@Z			; MStoreVect::`scalar deleting destructor'
PUBLIC	??1MStoreVect@@UAE@XZ				; MStoreVect::~MStoreVect
PUBLIC	??4PClip@@QAEXABV0@@Z				; PClip::operator=
PUBLIC	??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z ; MStoreVect::MStoreVect
EXTRN	??_EMStoreVect@@UAEPAXI@Z:PROC			; MStoreVect::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MStoreVect@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MStoreVect@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MStoreVect@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MStoreVect@@UAE@XZ$33
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z$63
__catchsym$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z$63 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z$53
__catchsym$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z$53 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$2
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$4
__catchsym$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$5
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$8
__catchsym$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GVectData@MStoreVect@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GVectData@MStoreVect@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_GVectData@MStoreVect@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GVectData@MStoreVect@@QAEPAXI@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1VectData@MStoreVect@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1VectData@MStoreVect@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1VectData@MStoreVect@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1VectData@MStoreVect@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\mstorevect.cpp
;	COMDAT ??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_nbr_clips$1$ = -44					; size = 4
tv843 = -40						; size = 4
_data_len_pix$1$ = -36					; size = 4
_mad$1$ = -36						; size = 4
_this$1$ = -32						; size = 4
_this$ = -28						; size = 4
_clip_cnt$1$ = -24					; size = 4
_data_offset$1$ = -20					; size = 4
_max_blk_x$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_clip_arr$ = 8						; size = 12
_vccs_0$ = 20						; size = 4
tv835 = 24						; size = 4
$T2 = 24						; size = 1
_env$ = 24						; size = 4
??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z PROC ; MStoreVect::MStoreVect, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mstorevect.cpp

; 34   : :	GenericVideoFilter (clip_arr [0])

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN28@MStoreVect
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN28@MStoreVect
	push	DWORD PTR _clip_arr$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN28@MStoreVect:
; File c:\github\mvtools\sources\mstorevect.cpp

; 34   : :	GenericVideoFilter (clip_arr [0])

	mov	ecx, ebx
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 35   : ,	_vect_arr ()

	lea	eax, DWORD PTR [ebx+64]

; 36   : {

	mov	DWORD PTR [ebx], OFFSET ??_7MStoreVect@@6B@
	mov	DWORD PTR _this$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [eax], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [eax+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [eax+8], 0
; File c:\github\mvtools\sources\mstorevect.cpp

; 35   : ,	_vect_arr ()

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 41   : 	_vect_arr.resize (nbr_clips);

	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR _clip_arr$[ebp+4]
	sub	esi, DWORD PTR _clip_arr$[ebp]
	sar	esi, 2
; File c:\github\mvtools\sources\mstorevect.cpp

; 41   : 	_vect_arr.resize (nbr_clips);

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	DWORD PTR _nbr_clips$1$[ebp], esi
; File c:\github\mvtools\sources\mstorevect.cpp

; 41   : 	_vect_arr.resize (nbr_clips);

	call	?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::resize

; 45   : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	mov	edi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR [esi+4]
	xor	edx, edx
	mov	DWORD PTR _data_offset$1$[ebp], ecx
	xor	eax, eax
	mov	DWORD PTR _max_blk_x$1$[ebp], edx
	mov	DWORD PTR _clip_cnt$1$[ebp], eax
	test	esi, esi
	jle	$LN3@MStoreVect

; 34   : :	GenericVideoFilter (clip_arr [0])

	mov	DWORD PTR tv835[ebp], edx
	npad	10
$LL4@MStoreVect:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	ebx, DWORD PTR [ecx]
; File c:\github\mvtools\sources\mstorevect.cpp

; 45   : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	lea	ecx, DWORD PTR [eax*4]

; 48   : 		const ::VideoInfo &	vd_vi = clip_arr [clip_cnt]->GetVideoInfo ();

	mov	eax, DWORD PTR _clip_arr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	add	ebx, edx
; File c:\github\mvtools\sources\mstorevect.cpp

; 45   : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	mov	DWORD PTR tv843[ebp], ecx

; 48   : 		const ::VideoInfo &	vd_vi = clip_arr [clip_cnt]->GetVideoInfo ();

	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN10@MStoreVect
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	esi, DWORD PTR [ecx+16]
	jmp	SHORT $LN9@MStoreVect
$LN10@MStoreVect:
	push	ecx
; File c:\github\mvtools\sources\mstorevect.cpp

; 48   : 		const ::VideoInfo &	vd_vi = clip_arr [clip_cnt]->GetVideoInfo ();

	call	eax
	mov	esi, eax
$LN9@MStoreVect:

; 49   : 
; 50   : 		// Checks basic parameters
; 51   : 		if (vd_vi.num_frames != vi.num_frames)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR [eax+32]
	je	SHORT $LN5@MStoreVect

; 52   : 		{
; 53   : 			env.ThrowError (

	mov	ecx, DWORD PTR [edi]
	push	OFFSET ??_C@_0EE@NAALHOCC@MStoreVect?3?5all?5vector?5clips?5sho@
	push	edi
	call	DWORD PTR [ecx+20]
	add	esp, 8
$LN5@MStoreVect:

; 54   : 				"MStoreVect: all vector clips should have the same number of frames."
; 55   : 			);
; 56   : 		}
; 57   : 
; 58   : 		// Checks if the clip contains vectors
; 59   : 		if (vd_vi.nchannels >= 0 && vd_vi.nchannels < 9)

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	js	SHORT $LN6@MStoreVect
	cmp	eax, 9
	jge	SHORT $LN6@MStoreVect

; 60   : 		{
; 61   : 			env.ThrowError ("MStoreVect: invalid vector stream.");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CD@DMGMBPGF@MStoreVect?3?5invalid?5vector?5strea@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN6@MStoreVect:

; 62   : 		}
; 63   : #if !defined(_WIN64)
; 64   : 		const MVAnalysisData &	mad =

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _mad$1$[ebp], eax

; 65   : 			*reinterpret_cast <MVAnalysisData *> (vd_vi.nchannels);
; 66   : #else
; 67   : 		// hack!
; 68   : 		uintptr_t p = (((uintptr_t)(unsigned int)vi.nchannels ^ 0x80000000) << 32) | (uintptr_t)(unsigned int)vi.sample_type;
; 69   : 		const MVAnalysisData &	mad = *reinterpret_cast <MVAnalysisData *> (p);
; 70   : #endif
; 71   : 		if (mad.GetMagicKey () != MVAnalysisData::MOTION_MAGIC_KEY)

	cmp	DWORD PTR [eax], 22093			; 0000564dH
	je	SHORT $LN7@MStoreVect

; 72   : 		{
; 73   : 			env.ThrowError ("MStoreVect: invalid vector stream.");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CD@DMGMBPGF@MStoreVect?3?5invalid?5vector?5strea@
	push	edi
	call	DWORD PTR [eax+20]
	mov	eax, DWORD PTR _mad$1$[ebp]
	add	esp, 8
$LN7@MStoreVect:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR _max_blk_x$1$[ebp]
	cmp	ecx, eax
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ecx, eax
; File c:\github\mvtools\sources\mstorevect.cpp

; 79   : 		const int		data_len_pix   = vd_vi.width * vd_vi.height;

	mov	eax, DWORD PTR [esi+4]
	imul	eax, DWORD PTR [esi]
	mov	DWORD PTR _max_blk_x$1$[ebp], ecx
	mov	DWORD PTR _data_len_pix$1$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	test	edx, edx
	je	SHORT $LN93@MStoreVect
	cmp	DWORD PTR [edx], 152			; 00000098H
	jbe	SHORT $LN93@MStoreVect
	mov	eax, DWORD PTR [edx+152]
	mov	ecx, esi
	call	eax
	mov	esi, eax
	mov	eax, DWORD PTR _data_len_pix$1$[ebp]
	jmp	SHORT $LN94@MStoreVect
$LN93@MStoreVect:
	xor	esi, esi
$LN94@MStoreVect:

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mstorevect.cpp

; 80   : 		const int		bytes_per_pix  = vd_vi.BitsPerPixel () >> 3;

	sar	esi, 3

; 81   : 		const int		data_len_bytes = data_len_pix * bytes_per_pix;

	imul	esi, eax

; 82   : 		const int		data_len       = data_len_bytes / sizeof (int32_t);

	shr	esi, 2
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	test	edx, edx
	je	SHORT $LN108@MStoreVect
	cmp	DWORD PTR [edx], 244			; 000000f4H
	jbe	SHORT $LN108@MStoreVect
; File c:\github\mvtools\sources\mstorevect.cpp

; 45   : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	mov	eax, DWORD PTR _clip_arr$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	ecx, ebx
; File c:\github\mvtools\sources\mstorevect.cpp

; 45   : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	add	eax, DWORD PTR tv843[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	push	eax
	mov	eax, DWORD PTR [edx+244]
	call	eax
$LN108@MStoreVect:
; File c:\github\mvtools\sources\mstorevect.cpp

; 86   : 		vect_data._data_offset = data_offset;

	mov	ecx, DWORD PTR _data_offset$1$[ebp]
	mov	eax, DWORD PTR _clip_cnt$1$[ebp]
	mov	edx, DWORD PTR tv835[ebp]
	inc	eax
	mov	DWORD PTR [ebx+4], ecx
	add	edx, 12					; 0000000cH

; 87   : 		vect_data._data_len    = data_len;
; 88   : 		data_offset += data_len;

	add	ecx, esi
	mov	DWORD PTR [ebx+8], esi
	mov	DWORD PTR _data_offset$1$[ebp], ecx
	mov	DWORD PTR _clip_cnt$1$[ebp], eax
	mov	DWORD PTR tv835[ebp], edx
	cmp	eax, DWORD PTR _nbr_clips$1$[ebp]
	jl	$LL4@MStoreVect
	mov	ebx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _max_blk_x$1$[ebp]
$LN3@MStoreVect:

; 89   : 	}
; 90   : 	_end_offset = data_offset;
; 91   : 	assert (max_blk_x > 0);
; 92   : 
; 93   : 	const int		total_len_bytes = _end_offset * sizeof (int32_t);
; 94   : 	ClipFnc::format_vector_clip (

	push	edi
	push	OFFSET ??_C@_0L@OGKEKMEE@MStoreVect?$AA@
	lea	eax, DWORD PTR [ecx*4]
	mov	DWORD PTR [ebx+76], ecx
	push	eax
	push	DWORD PTR _vccs_0$[ebp]
	lea	ecx, DWORD PTR [ebx+16]
	push	edx
	xor	dl, dl
	call	?format_vector_clip@ClipFnc@@SAXAAUVideoInfo@@_NHPBDH2AAVIScriptEnvironment@@@Z ; ClipFnc::format_vector_clip

; 99   : 	vi.height = (vi.height + 1) & -2;

	mov	eax, DWORD PTR [ebx+20]
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR _clip_arr$[ebp]
; File c:\github\mvtools\sources\mstorevect.cpp

; 99   : 	vi.height = (vi.height + 1) & -2;

	inc	eax
	and	eax, -2					; fffffffeH
	mov	DWORD PTR [ebx+20], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN114@MStoreVect
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR _clip_arr$[ebp+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR _clip_arr$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR _clip_arr$[ebp]
	sub	eax, ecx
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN191@MStoreVect
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN236@MStoreVect:
$LN191@MStoreVect:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN192@MStoreVect

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN193@MStoreVect
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN237@MStoreVect:
$LN193@MStoreVect:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN194@MStoreVect
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN238@MStoreVect:
$LN194@MStoreVect:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN195@MStoreVect
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN239@MStoreVect:
$LN195@MStoreVect:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN196@MStoreVect
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN240@MStoreVect:
$LN196@MStoreVect:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN192@MStoreVect:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN114@MStoreVect:
; File c:\github\mvtools\sources\mstorevect.cpp

; 100  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN235@MStoreVect:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _clip_arr$[ebp]
	jmp	??1?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ; std::vector<PClip,std::allocator<PClip> >::~vector<PClip,std::allocator<PClip> >
__unwindfunclet$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::~vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >
__ehhandler$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z ENDP ; MStoreVect::MStoreVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??4PClip@@QAEXABV0@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4PClip@@QAEXABV0@@Z PROC				; PClip::operator=, COMDAT
; _this$ = ecx

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@operator
	cmp	DWORD PTR [eax], 244			; 000000f4H
	jbe	SHORT $LN3@operator
	mov	eax, DWORD PTR [eax+244]
	jmp	eax
$LN3@operator:
	ret	4
??4PClip@@QAEXABV0@@Z ENDP				; PClip::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mstorevect.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.h
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.h
;	COMDAT ??1MStoreVect@@UAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 1
__$EHRec$ = -12						; size = 12
??1MStoreVect@@UAE@XZ PROC				; MStoreVect::~MStoreVect, COMDAT
; _this$ = ecx

; 45   : 	virtual			~MStoreVect () {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1MStoreVect@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi], OFFSET ??_7MStoreVect@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi+64]
	test	ecx, ecx
	je	SHORT $LN7@MStoreVect
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [edi+68]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR [edi+72]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [edi+64]
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [edi+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi+64], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+68], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+72], 0
$LN7@MStoreVect:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN121@MStoreVect
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN121@MStoreVect
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [edi+8]
	call	eax
$LN121@MStoreVect:
; File c:\github\mvtools\sources\mstorevect.h

; 45   : 	virtual			~MStoreVect () {}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [edi], OFFSET ??_7IClip@@6B@
	pop	edi
; File c:\github\mvtools\sources\mstorevect.h

; 45   : 	virtual			~MStoreVect () {}

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MStoreVect@@UAE@XZ$33:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MStoreVect@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MStoreVect@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MStoreVect@@UAE@XZ ENDP				; MStoreVect::~MStoreVect
; Function compile flags: /Ogtpy
;	COMDAT ??_GMStoreVect@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMStoreVect@@UAEPAXI@Z PROC				; MStoreVect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MStoreVect@@UAE@XZ			; MStoreVect::~MStoreVect
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	80					; 00000050H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMStoreVect@@UAEPAXI@Z ENDP				; MStoreVect::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
;	COMDAT ?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
tv449 = -28						; size = 4
_clip_ptr$3 = -28					; size = 4
_end_offset$ = -28					; size = 4
_data_offset$4 = -28					; size = 4
_nbr_clips$1$ = -24					; size = 4
_nbr_clips$ = -24					; size = 4
_data_ptr$1$ = -20					; size = 4
_pitch$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dst_pos$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_n$ = 16						; size = 4
_env_ptr$ = 20						; size = 4
?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MStoreVect::GetFrame, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H

; 106  : 	assert (n >= 0);
; 107  : 	assert (n < vi.num_frames);
; 108  : 	assert (env_ptr != 0);
; 109  : 
; 110  : 	::PVideoFrame	dst_ptr = env_ptr->NewVideoFrame (vi);

	mov	edx, DWORD PTR _env_ptr$[ebp]
	push	ebx
	push	esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 0
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	32					; 00000020H
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	ebx
	push	edx
	call	DWORD PTR [ecx+56]

; 144  : 	}
; 145  : 
; 146  : 	return (dst_ptr);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR $T2[ebp], 1
	test	eax, eax
	je	SHORT $LN16@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN16@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+220]
	push	0
	call	eax
	mov	edi, eax
	mov	DWORD PTR _data_ptr$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN17@GetFrame
$LN16@GetFrame:
	xor	edi, edi
	mov	DWORD PTR _data_ptr$1$[ebp], edi
$LN17@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN22@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN22@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+192]
	push	0
	call	eax
	mov	ebx, eax
	mov	DWORD PTR _pitch$1$[ebp], eax
	jmp	SHORT $LN23@GetFrame
$LN22@GetFrame:
	xor	ebx, ebx
	mov	DWORD PTR _pitch$1$[ebp], ebx
$LN23@GetFrame:
; File c:\github\mvtools\sources\mstorevect.cpp

; 119  : 	write_to_clip (dst_pos, data_ptr, &key, sizeof (key), pitch);

	push	ebx
	push	4
	push	OFFSET ?key@?1??GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z@4HB
	push	edi
	lea	eax, DWORD PTR _dst_pos$[ebp]
	mov	DWORD PTR _dst_pos$[ebp], 0
	push	eax
	mov	ecx, esi
	call	?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z ; MStoreVect::write_to_clip

; 120  : 	write_to_clip (dst_pos, data_ptr, &ver, sizeof (ver), pitch);

	push	ebx
	push	4
	push	OFFSET ?ver@?1??GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z@4HB
	push	edi
	lea	eax, DWORD PTR _dst_pos$[ebp]
	mov	ecx, esi
	push	eax
	call	?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z ; MStoreVect::write_to_clip
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi+68]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [esi+64]
	imul	ecx
; File c:\github\mvtools\sources\mstorevect.cpp

; 122  : 	write_to_clip (dst_pos, data_ptr, &nbr_clips, sizeof (nbr_clips), pitch);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
; File c:\github\mvtools\sources\mstorevect.cpp

; 122  : 	write_to_clip (dst_pos, data_ptr, &nbr_clips, sizeof (nbr_clips), pitch);

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\github\mvtools\sources\mstorevect.cpp

; 121  : 	const int32_t	nbr_clips = _vect_arr.size ();

	mov	DWORD PTR _nbr_clips$[ebp], eax

; 122  : 	write_to_clip (dst_pos, data_ptr, &nbr_clips, sizeof (nbr_clips), pitch);

	lea	eax, DWORD PTR _nbr_clips$[ebp]
	push	4
	push	eax
	push	edi
	lea	eax, DWORD PTR _dst_pos$[ebp]
	push	eax
	call	?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z ; MStoreVect::write_to_clip

; 123  : 
; 124  : 	// Clip offsets
; 125  : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	mov	ebx, DWORD PTR _nbr_clips$[ebp]
	mov	DWORD PTR _nbr_clips$1$[ebp], ebx
	test	ebx, ebx
	jle	SHORT $LN3@GetFrame

; 111  : 
; 112  : 	uint8_t *		data_ptr = dst_ptr->GetWritePtr ();
; 113  : 	const int		pitch    = dst_ptr->GetPitch ();
; 114  : 	int				dst_pos = 0;

	xor	edi, edi
	npad	7
$LL4@GetFrame:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+64]
; File c:\github\mvtools\sources\mstorevect.cpp

; 129  : 		write_to_clip (dst_pos, data_ptr, &data_offset, sizeof (data_offset), pitch);

	mov	ecx, esi
	push	DWORD PTR _pitch$1$[ebp]
	push	4
	mov	eax, DWORD PTR [eax+edi+4]
	mov	DWORD PTR _data_offset$4[ebp], eax
	lea	eax, DWORD PTR _data_offset$4[ebp]
	push	eax
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _dst_pos$[ebp]
	push	eax
	call	?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z ; MStoreVect::write_to_clip
	lea	edi, DWORD PTR [edi+12]
	sub	ebx, 1
	jne	SHORT $LL4@GetFrame
	mov	ebx, DWORD PTR _nbr_clips$1$[ebp]
	mov	edi, DWORD PTR _data_ptr$1$[ebp]
$LN3@GetFrame:

; 132  : 	write_to_clip (dst_pos, data_ptr, &end_offset, sizeof (end_offset), pitch);

	push	DWORD PTR _pitch$1$[ebp]
	mov	eax, DWORD PTR [esi+76]
	mov	ecx, esi
	mov	DWORD PTR _end_offset$[ebp], eax
	lea	eax, DWORD PTR _end_offset$[ebp]
	push	4
	push	eax
	push	edi
	lea	eax, DWORD PTR _dst_pos$[ebp]
	push	eax
	call	?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z ; MStoreVect::write_to_clip

; 135  : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	test	ebx, ebx
	jle	$LN88@GetFrame

; 130  : 	}
; 131  : 	const int32_t	end_offset = _end_offset;

	xor	ebx, ebx
$LL7@GetFrame:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edi, DWORD PTR [esi+64]
; File c:\github\mvtools\sources\mstorevect.cpp

; 140  : 		::PVideoFrame	clip_ptr = vect_info._clip_sptr->GetFrame (n, env_ptr);

	lea	edx, DWORD PTR _clip_ptr$3[ebp]
	push	DWORD PTR _env_ptr$[ebp]
	push	DWORD PTR _n$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+ebx]
; File c:\github\mvtools\sources\mstorevect.cpp

; 140  : 		::PVideoFrame	clip_ptr = vect_info._clip_sptr->GetFrame (n, env_ptr);

	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN73@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN73@GetFrame
	mov	ecx, DWORD PTR _clip_ptr$3[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN74@GetFrame
$LN73@GetFrame:
	xor	ecx, ecx
$LN74@GetFrame:
; File c:\github\mvtools\sources\mstorevect.cpp

; 143  : 		write_to_clip (dst_pos, data_ptr, src_ptr, len_bytes, pitch);

	push	DWORD PTR _pitch$1$[ebp]
	mov	eax, DWORD PTR [edi+ebx+8]
	shl	eax, 2
	push	eax
	push	ecx
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _dst_pos$[ebp]
	mov	ecx, esi
	push	eax
	call	?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z ; MStoreVect::write_to_clip
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN77@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN77@GetFrame
	mov	edx, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _clip_ptr$3[ebp]
	call	edx
$LN77@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\mstorevect.cpp

; 135  : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	add	ebx, 12					; 0000000cH
	sub	DWORD PTR _nbr_clips$1$[ebp], 1
	jne	$LL7@GetFrame
$LN88@GetFrame:

; 144  : 	}
; 145  : 
; 146  : 	return (dst_ptr);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 147  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN10@GetFrame
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN10@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _clip_ptr$3[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MStoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MStoreVect::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mstorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mstorevect.cpp
;	COMDAT ?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z
_TEXT	SEGMENT
_dst_pos$ = 8						; size = 4
_base_ptr$ = 12						; size = 4
_src_ptr$ = 16						; size = 4
_len$ = 20						; size = 4
_stride$ = 24						; size = 4
?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z PROC	; MStoreVect::write_to_clip, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	push	edi
; File c:\github\mvtools\sources\mstorevect.cpp

; 163  : {

	mov	edi, ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	test	eax, eax
	je	SHORT $LN9@write_to_c
	cmp	DWORD PTR [eax], 152			; 00000098H
	jbe	SHORT $LN9@write_to_c
	mov	eax, DWORD PTR [eax+152]
; File c:\github\mvtools\sources\mstorevect.cpp

; 164  : 	const int		bytes_per_pix  = vi.BitsPerPixel () >> 3;

	lea	ecx, DWORD PTR [edi+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	call	eax
	mov	esi, eax
	jmp	SHORT $LN10@write_to_c
$LN9@write_to_c:
	xor	esi, esi
$LN10@write_to_c:
; File c:\github\mvtools\sources\mstorevect.cpp

; 164  : 	const int		bytes_per_pix  = vi.BitsPerPixel () >> 3;

	sar	esi, 3

; 165  : 	const int		row_size       = vi.width  * bytes_per_pix;

	imul	esi, DWORD PTR [edi+16]

; 166  : 	const int		available_size = vi.height * row_size;
; 167  : 	assert (dst_pos >= 0);
; 168  : 	assert (dst_pos + len <= available_size);
; 169  : 	assert (base_ptr != 0);
; 170  : 	assert (len > 0);
; 171  : 	assert (src_ptr != 0);
; 172  : 	assert (stride > 0);
; 173  : 
; 174  : 	if (stride == row_size)
; 175  : 	{
; 176  : 		memcpy (base_ptr + dst_pos, src_ptr, len);

	mov	edi, DWORD PTR _len$[esp+4]
	cmp	DWORD PTR _stride$[esp+4], esi
	jne	SHORT $LN4@write_to_c
	mov	esi, DWORD PTR _dst_pos$[esp+4]
	push	edi
	push	DWORD PTR _src_ptr$[esp+8]
	mov	eax, DWORD PTR [esi]
	add	eax, DWORD PTR _base_ptr$[esp+12]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 177  : 		dst_pos += len;

	add	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 194  : 		}
; 195  : 	}
; 196  : }

	ret	20					; 00000014H
$LN4@write_to_c:
	push	ebp

; 178  : 	}
; 179  : 	else
; 180  : 	{
; 181  : 		int				src_pos  = 0;

	xor	ebp, ebp

; 182  : 		while (src_pos < len)

	test	edi, edi
	jle	SHORT $LN18@write_to_c
	mov	eax, DWORD PTR _dst_pos$[esp+8]
	push	ebx
$LL2@write_to_c:

; 183  : 		{
; 184  : 			const int		y = dst_pos / row_size;

	mov	ebx, DWORD PTR [eax]

; 185  : 			const int		x = dst_pos - y * row_size;	// In bytes
; 186  : 			const int		work_len = std::min (len - src_pos, row_size - x);

	sub	edi, ebp
	mov	eax, ebx
	cdq
	idiv	esi
	mov	edx, eax

; 187  : 			memcpy (

	mov	eax, DWORD PTR _src_ptr$[esp+12]
	mov	ecx, edx
	imul	ecx, esi
	sub	ebx, ecx
	mov	ecx, esi
	sub	ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	ecx, edi
	cmovl	edi, ecx
; File c:\github\mvtools\sources\mstorevect.cpp

; 187  : 			memcpy (

	imul	edx, DWORD PTR _stride$[esp+12]
	push	edi
	add	eax, ebp
	push	eax
	add	edx, ebx
	add	edx, DWORD PTR _base_ptr$[esp+20]
	push	edx
	call	_memcpy

; 188  : 				base_ptr + y * stride + x,
; 189  : 				reinterpret_cast <const uint8_t *> (src_ptr) + src_pos,
; 190  : 				work_len
; 191  : 			);
; 192  : 			dst_pos += work_len;

	mov	eax, DWORD PTR _dst_pos$[esp+24]

; 193  : 			src_pos += work_len;

	add	ebp, edi
	add	esp, 12					; 0000000cH
	add	DWORD PTR [eax], edi
	mov	edi, DWORD PTR _len$[esp+12]
	cmp	ebp, edi
	jl	SHORT $LL2@write_to_c
	pop	ebx
$LN18@write_to_c:
	pop	ebp
	pop	edi
	pop	esi

; 194  : 		}
; 195  : 	}
; 196  : }

	ret	20					; 00000014H
?write_to_clip@MStoreVect@@AAEXAAHQAEPBXHH@Z ENDP	; MStoreVect::write_to_clip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEAAVVectData@MStoreVect@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEAAVVectData@MStoreVect@@I@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 1243 : 		}

	ret	4
??A?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEAAVVectData@MStoreVect@@I@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1181 : 		}

	ret	0
?size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
$T3 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH

; 1133 : 		{	// determine new length, padding as needed

	push	esi
	push	edi

; 1134 : 		if (_Newsize < size())

	mov	edi, DWORD PTR __Newsize$[ebp]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [ebx+4]
	mov	edx, esi
	sub	edx, DWORD PTR [ebx]
	imul	edx

; 1133 : 		{	// determine new length, padding as needed

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	ecx, edx

; 1133 : 		{	// determine new length, padding as needed

	mov	DWORD PTR _this$[ebp], ebx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1134 : 		if (_Newsize < size())

	cmp	ecx, edi
	jbe	SHORT $LN204@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	sub	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	lea	eax, DWORD PTR [edi+edi*2]
	lea	esi, DWORD PTR [esi+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	ecx, esi
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [ebx+4], esi
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN204@resize:

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	mov	eax, edi
	sub	eax, ecx
	mov	ecx, ebx
	push	eax
	call	?_Reserve@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reserve

; 1139 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [ebx+4]
	sub	ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
	mov	ecx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),

	mov	edx, edi
	sub	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	call	??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx

; 1147 : 			}
; 1148 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1145 : 			_CATCH_END
; 1146 : 			this->_Mylast() += _Newsize - size();

	sub	edi, eax
	lea	eax, DWORD PTR [edi+edi*2]

; 1147 : 			}
; 1148 : 		}

	pop	edi
	shl	eax, 2
	add	DWORD PTR [ebx+4], eax
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z$0:

; 1141 : 				this->_Getal());
; 1142 : 			_CATCH_ALL
; 1143 : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXXZ ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Tidy

; 1144 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN205@resize:
$LN203@resize:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resize@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::resize
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
??1?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::~vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	pop	ecx
	ret	0
??1?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::~vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEAAVPClip@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEAAVPClip@@I@Z PROC ; std::vector<PClip,std::allocator<PClip> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1243 : 		}

	ret	4
??A?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEAAVPClip@@I@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
?_Tidy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXXZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXXZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebx
	mov	ebx, ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, 715827883				; 2aaaaaabH
	push	ebp
	push	esi
	push	edi
	mov	ebp, DWORD PTR [ebx+8]
	mov	edx, ebp
	mov	esi, DWORD PTR [ebx+4]
	sub	edx, esi

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	edi, DWORD PTR __Count$[esp+12]

; 1048 : 		return (this->_Myend() - this->_Mylast());

	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, edi
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	esi, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	esi

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, 357913941				; 15555555H

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN135@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	ebp, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebp

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edi, ecx
	xor	ecx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 357913941				; 15555555H
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	add	eax, esi
	cmp	edx, esi
	cmovae	ecx, eax
	cmp	ecx, edi
	cmovae	edi, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, ebx
	push	edi
	call	?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN134@Reserve:
?_Reserve@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	eax, DWORD PTR __Count$[esp-4]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1527 : 		{	// erase _Count elements at end

	mov	edi, ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	edx, DWORD PTR [edi+4]
	mov	esi, edx
	sub	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	ecx, esi
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAPAVVectData@MStoreVect@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEXXZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEXXZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
$T2 = -20						; size = 1
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Count$[ebp]
	call	?allocate@?$allocator@VVectData@MStoreVect@@@std@@QAEPAVVectData@MStoreVect@@I@Z ; std::allocator<MStoreVect::VectData>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1604 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [esi+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx

; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]

; 1621 : 		this->_Mylast() = _Ptr + _Size;
; 1622 : 		this->_Myfirst() = _Ptr;
; 1623 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+8], eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1608 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN194@Reallocate:
$LN193@Reallocate:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Reallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEII@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Grow_to, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	push	esi
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 357913941				; 15555555H
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IBEII@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXPAVVectData@MStoreVect@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXPAVVectData@MStoreVect@@0@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Destroy, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp-4]
	mov	edx, DWORD PTR __Last$[esp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1582 : 		}

	ret	8
?_Destroy@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEXPAVVectData@MStoreVect@@0@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 357913941				; 15555555H

; 1186 : 		}

	ret	0
?max_size@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx+4]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 357913941				; 15555555H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEPAVVectData@MStoreVect@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEPAVVectData@MStoreVect@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@VVectData@MStoreVect@@@std@@QAEPAVVectData@MStoreVect@@I@Z ; std::allocator<MStoreVect::VectData>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEPAVVectData@MStoreVect@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABQAVVectData@MStoreVect@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MStoreVect::VectData,std::allocator<MStoreVect::VectData> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1044 : 		}

	ret	0
?capacity@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QBEIXZ ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@I@Z PROC ; std::allocator<MStoreVect::VectData>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@I@Z ENDP ; std::allocator<MStoreVect::VectData>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAIABV?$allocator@VVectData@MStoreVect@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAIABV?$allocator@VVectData@MStoreVect@@@2@@Z PROC ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 357913941				; 15555555H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAIABV?$allocator@VVectData@MStoreVect@@@2@@Z ENDP ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VVectData@MStoreVect@@@std@@QAEPAVVectData@MStoreVect@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VVectData@MStoreVect@@@std@@QAEPAVVectData@MStoreVect@@I@Z PROC ; std::allocator<MStoreVect::VectData>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@VVectData@MStoreVect@@@std@@QAEPAVVectData@MStoreVect@@I@Z ENDP ; std::allocator<MStoreVect::VectData>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VVectData@MStoreVect@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VVectData@MStoreVect@@@std@@QBEIXZ PROC ; std::allocator<MStoreVect::VectData>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 750  : 		}

	ret	0
?max_size@?$allocator@VVectData@MStoreVect@@@std@@QBEIXZ ENDP ; std::allocator<MStoreVect::VectData>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ecx

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Uninitialized_default_fill_n@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >,std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAVVectData@MStoreVect@@@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEPAVVectData@MStoreVect@@PAV23@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVVectData@MStoreVect@@@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEPAVVectData@MStoreVect@@PAV23@00@Z PROC ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Umove<MStoreVect::VectData *>, COMDAT
; _this$dead$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Ptr$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
??$_Umove@PAVVectData@MStoreVect@@@?$vector@VVectData@MStoreVect@@V?$allocator@VVectData@MStoreVect@@@std@@@std@@IAEPAVVectData@MStoreVect@@PAV23@00@Z ENDP ; std::vector<MStoreVect::VectData,std::allocator<MStoreVect::VectData> >::_Umove<MStoreVect::VectData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	ecx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Destroy_range@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >::_Vector_val<std::_Simple_types<MStoreVect::VectData> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<MStoreVect::VectData> >::_Vector_val<std::_Simple_types<MStoreVect::VectData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::_Wrap_alloc<std::allocator<MStoreVect::VectData> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::_Wrap_alloc<std::allocator<MStoreVect::VectData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VVectData@MStoreVect@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VVectData@MStoreVect@@@std@@QAE@XZ PROC	; std::allocator<MStoreVect::VectData>::allocator<MStoreVect::VectData>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@VVectData@MStoreVect@@@std@@QAE@XZ ENDP	; std::allocator<MStoreVect::VectData>::allocator<MStoreVect::VectData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 1
__Next$ = -24						; size = 4
__First$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 454  : 	_FwdIt _Next = _First;
; 455  : 
; 456  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, edx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __First$[ebp], ecx
	mov	DWORD PTR __Next$[ebp], esi
$LL4@Uninitiali:

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	test	edi, edi
	je	SHORT $LN3@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN29@Uninitiali
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR [esi+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN29@Uninitiali
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN29@Uninitiali
	mov	eax, DWORD PTR [eax+228]
	mov	ecx, esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN29@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	dec	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	esi, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Next$[ebp]
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 461  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN38@Uninitiali:
$LN3@Uninitiali:

; 462  : 	_CATCH_END
; 463  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$2:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_default_fill_n1@PAVVectData@MStoreVect@@IV?$allocator@VVectData@MStoreVect@@@std@@@std@@YAXPAVVectData@MStoreVect@@IAAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<MStoreVect::VectData *,unsigned int,std::allocator<MStoreVect::VectData> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z PROC ; std::_Uninitialized_move<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN3@Destroy_ra
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	npad	9
$LL4@Destroy_ra:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN23@Destroy_ra
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN23@Destroy_ra
	mov	eax, DWORD PTR [eax+248]
	mov	ecx, esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN23@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	add	esi, 12					; 0000000cH
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	jne	SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@VVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z PROC ; std::_Unfancy<MStoreVect::VectData>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@VVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z ENDP ; std::_Unfancy<MStoreVect::VectData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z PROC ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	-1
	push	__ehhandler$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN17@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN17@construct
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN17@construct
	mov	eax, DWORD PTR [eax+228]
	call	eax
$LN17@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VVectData@MStoreVect@@$$V@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAVVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAVVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z PROC ; std::_Unchecked<MStoreVect::VectData *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAVVectData@MStoreVect@@@std@@YAPAVVectData@MStoreVect@@PAV12@@Z ENDP ; std::_Unchecked<MStoreVect::VectData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move_al_unchecked@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAVVectData@MStoreVect@@PAV12@@std@@YAAAPAVVectData@MStoreVect@@AAPAV12@PAV12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAVVectData@MStoreVect@@PAV12@@std@@YAAAPAVVectData@MStoreVect@@AAPAV12@PAV12@@Z PROC ; std::_Rechecked<MStoreVect::VectData *,MStoreVect::VectData *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAVVectData@MStoreVect@@PAV12@@std@@YAAAPAVVectData@MStoreVect@@AAPAV12@PAV12@@Z ENDP ; std::_Rechecked<MStoreVect::VectData *,MStoreVect::VectData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z PROC ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::destroy<MStoreVect::VectData>, COMDAT
; _this$dead$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN16@destroy
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN16@destroy
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$destroy@VVectData@MStoreVect@@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::destroy<MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z PROC ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edx, edx
	je	SHORT $LN15@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN15@construct
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN15@construct
	mov	eax, DWORD PTR [eax+228]
	mov	ecx, edx
	call	eax
$LN15@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VVectData@MStoreVect@@$$V@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z ENDP ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@VVectData@MStoreVect@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVVectData@MStoreVect@@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@VVectData@MStoreVect@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVVectData@MStoreVect@@0@Z PROC ; std::_Ptr_move_cat<MStoreVect::VectData,MStoreVect::VectData>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	xor	al, al

; 811  : 	}

	ret	0
??$_Ptr_move_cat@VVectData@MStoreVect@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVVectData@MStoreVect@@0@Z ENDP ; std::_Ptr_move_cat<MStoreVect::VectData,MStoreVect::VectData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 274  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	mov	ebx, edx
	push	edi

; 275  : 
; 276  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	edi, ecx
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
$LL4@Uninitiali:

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	edi, ebx
	je	SHORT $LN3@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN28@Uninitiali
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN41@Uninitiali
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN41@Uninitiali
	mov	eax, DWORD PTR [edx+232]
	mov	ecx, esi
	push	edi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN41@Uninitiali:
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
$LN28@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 12					; 0000000cH
	jmp	SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Next$[ebp]
	call	??$_Destroy_range1@V?$allocator@VVectData@MStoreVect@@@std@@PAVVectData@MStoreVect@@@std@@YAXPAVVectData@MStoreVect@@0AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MStoreVect::VectData>,MStoreVect::VectData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 281  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN50@Uninitiali:
$LN3@Uninitiali:

; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);
; 285  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$5:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move_al_unchecked1@PAVVectData@MStoreVect@@PAV12@V?$allocator@VVectData@MStoreVect@@@std@@@std@@YAPAVVectData@MStoreVect@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<MStoreVect::VectData *,MStoreVect::VectData *,std::allocator<MStoreVect::VectData> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z PROC ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::destroy<MStoreVect::VectData>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 863  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN14@destroy
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN14@destroy
	mov	eax, DWORD PTR [eax+248]
	mov	ecx, edx
	call	eax
$LN14@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$destroy@VVectData@MStoreVect@@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@@Z ENDP ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::destroy<MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAVVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z
_TEXT	SEGMENT
??$move@AAVVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z PROC ; std::move<MStoreVect::VectData &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAVVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z ENDP ; std::move<MStoreVect::VectData &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z PROC ; std::allocator<MStoreVect::VectData>::construct<MStoreVect::VectData>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	-1
	push	__ehhandler$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN13@construct
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN13@construct
	mov	eax, DWORD PTR [eax+228]
	call	eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VVectData@MStoreVect@@$$V@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z ENDP ; std::allocator<MStoreVect::VectData>::construct<MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData,MStoreVect::VectData>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	esi, DWORD PTR __Ptr$[ebp]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, DWORD PTR _<_Args_0>$[ebp]
	test	eax, eax
	je	SHORT $LN26@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN26@construct
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, esi
	push	edi
	call	eax
$LN26@construct:
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z$2:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VVectData@MStoreVect@@V12@@?$_Wrap_alloc@V?$allocator@VVectData@MStoreVect@@@std@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData,MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z PROC ; std::allocator<MStoreVect::VectData>::destroy<MStoreVect::VectData>, COMDAT
; _this$dead$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN12@destroy
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN12@destroy
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN12@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$destroy@VVectData@MStoreVect@@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@@Z ENDP ; std::allocator<MStoreVect::VectData>::destroy<MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0VectData@MStoreVect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VectData@MStoreVect@@QAE@XZ PROC			; MStoreVect::VectData::VectData, COMDAT
; _this$ = ecx
	push	ecx

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi
	test	eax, eax
	je	SHORT $LN8@VectData
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN8@VectData
	mov	eax, DWORD PTR [eax+228]
	call	eax
$LN8@VectData:
	mov	eax, esi
	pop	esi
	pop	ecx
	ret	0
??0VectData@MStoreVect@@QAE@XZ ENDP			; MStoreVect::VectData::VectData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??_GVectData@MStoreVect@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$dead$ = 8					; size = 4
??_GVectData@MStoreVect@@QAEPAXI@Z PROC			; MStoreVect::VectData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_GVectData@MStoreVect@@QAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN12@scalar
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN12@scalar
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN12@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GVectData@MStoreVect@@QAEPAXI@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_GVectData@MStoreVect@@QAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GVectData@MStoreVect@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GVectData@MStoreVect@@QAEPAXI@Z ENDP			; MStoreVect::VectData::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??1VectData@MStoreVect@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1VectData@MStoreVect@@QAE@XZ PROC			; MStoreVect::VectData::~VectData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1VectData@MStoreVect@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN5@VectData
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN5@VectData
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN5@VectData:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1VectData@MStoreVect@@QAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1VectData@MStoreVect@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1VectData@MStoreVect@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1VectData@MStoreVect@@QAE@XZ ENDP			; MStoreVect::VectData::~VectData
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@VVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z
_TEXT	SEGMENT
??$forward@VVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z PROC ; std::forward<MStoreVect::VectData>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@VVectData@MStoreVect@@@std@@YA$$QAVVectData@MStoreVect@@AAV12@@Z ENDP ; std::forward<MStoreVect::VectData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 4
??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z PROC ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData,MStoreVect::VectData>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	SHORT $LN8@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	edi
	mov	edi, DWORD PTR _<_Args_0>$[ebp]
	test	eax, eax
	je	SHORT $LN21@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN21@construct
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, esi
	push	edi
	call	eax
$LN21@construct:
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
	pop	edi
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z$1:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VVectData@MStoreVect@@V12@@?$allocator_traits@V?$allocator@VVectData@MStoreVect@@@std@@@std@@SAXAAV?$allocator@VVectData@MStoreVect@@@1@PAVVectData@MStoreVect@@$$QAV34@@Z ENDP ; std::allocator_traits<std::allocator<MStoreVect::VectData> >::construct<MStoreVect::VectData,MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z PROC ; std::allocator<MStoreVect::VectData>::construct<MStoreVect::VectData,MStoreVect::VectData>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	esi, DWORD PTR __Ptr$[ebp]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	SHORT $LN3@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, DWORD PTR _<_Args_0>$[ebp]
	test	eax, eax
	je	SHORT $LN16@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN16@construct
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, esi
	push	edi
	call	eax
$LN16@construct:
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VVectData@MStoreVect@@V12@@?$allocator@VVectData@MStoreVect@@@std@@QAEXPAVVectData@MStoreVect@@$$QAV23@@Z ENDP ; std::allocator<MStoreVect::VectData>::construct<MStoreVect::VectData,MStoreVect::VectData>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0VectData@MStoreVect@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0VectData@MStoreVect@@QAE@$$QAV01@@Z PROC		; MStoreVect::VectData::VectData, COMDAT
; _this$ = ecx
	push	ecx

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+8]
	test	eax, eax
	je	SHORT $LN6@VectData
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN6@VectData
	mov	eax, DWORD PTR [eax+232]
	push	edi
	call	eax
$LN6@VectData:
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ecx
	ret	4
??0VectData@MStoreVect@@QAE@$$QAV01@@Z ENDP		; MStoreVect::VectData::VectData
_TEXT	ENDS
END
