; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvclip.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BP@HAJOHLII@MVTools?3?5invalid?5vector?5stream?$AA@ ; `string'
PUBLIC	??_C@_0CP@DDHEPPCI@MVTools?3?5incompatible?5version?5of@ ; `string'
PUBLIC	??_C@_0EG@OFOOOFOK@MVTools?3?5width?5and?5pitch?5are?5not@ ; `string'
PUBLIC	??_C@_0CP@NDEDCOJD@MVTools?3?5vector?5clip?5is?5too?5smal@ ; `string'
PUBLIC	??_R1A@?0A@EA@MVClip@@8				; MVClip::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2FakeGroupOfPlanes@@8			; FakeGroupOfPlanes::`RTTI Base Class Array'
PUBLIC	??_R0?AVFakeGroupOfPlanes@@@8			; FakeGroupOfPlanes `RTTI Type Descriptor'
PUBLIC	??_R2MVAnalysisData@@8				; MVAnalysisData::`RTTI Base Class Array'
PUBLIC	??_R3MVClip@@8					; MVClip::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVMVClip@@@8				; MVClip `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@FakeGroupOfPlanes@@8		; FakeGroupOfPlanes::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMVAnalysisData@@@8			; MVAnalysisData `RTTI Type Descriptor'
PUBLIC	??_R4MVClip@@6B@				; MVClip::`RTTI Complete Object Locator'
PUBLIC	??_R1HE@?0A@EA@MVAnalysisData@@8		; MVAnalysisData::`RTTI Base Class Descriptor at (116,-1,0,64)'
PUBLIC	??_R3FakeGroupOfPlanes@@8			; FakeGroupOfPlanes::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1EA@?0A@EA@FakeGroupOfPlanes@@8		; FakeGroupOfPlanes::`RTTI Base Class Descriptor at (64,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@MVAnalysisData@@8			; MVAnalysisData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7MVClip@@6B@					; MVClip::`vftable'
PUBLIC	??_R3MVAnalysisData@@8				; MVAnalysisData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MVClip@@8					; MVClip::`RTTI Base Class Array'
;	COMDAT ??_R2MVClip@@8
rdata$r	SEGMENT
??_R2MVClip@@8 DD FLAT:??_R1A@?0A@EA@MVClip@@8		; MVClip::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@FakeGroupOfPlanes@@8
	DD	FLAT:??_R1HE@?0A@EA@MVAnalysisData@@8
rdata$r	ENDS
;	COMDAT ??_R3MVAnalysisData@@8
rdata$r	SEGMENT
??_R3MVAnalysisData@@8 DD 00H				; MVAnalysisData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MVAnalysisData@@8
rdata$r	ENDS
;	COMDAT ??_7MVClip@@6B@
CONST	SEGMENT
??_7MVClip@@6B@ DD FLAT:??_R4MVClip@@6B@		; MVClip::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@MVClip@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@GenericVideoFilter@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVClip@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@MVAnalysisData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVAnalysisData@@8 DD FLAT:??_R0?AVMVAnalysisData@@@8 ; MVAnalysisData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVAnalysisData@@8
rdata$r	ENDS
;	COMDAT ??_R1EA@?0A@EA@FakeGroupOfPlanes@@8
rdata$r	SEGMENT
??_R1EA@?0A@EA@FakeGroupOfPlanes@@8 DD FLAT:??_R0?AVFakeGroupOfPlanes@@@8 ; FakeGroupOfPlanes::`RTTI Base Class Descriptor at (64,-1,0,64)'
	DD	00H
	DD	040H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FakeGroupOfPlanes@@8
rdata$r	ENDS
;	COMDAT ??_R3FakeGroupOfPlanes@@8
rdata$r	SEGMENT
??_R3FakeGroupOfPlanes@@8 DD 00H			; FakeGroupOfPlanes::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2FakeGroupOfPlanes@@8
rdata$r	ENDS
;	COMDAT ??_R1HE@?0A@EA@MVAnalysisData@@8
rdata$r	SEGMENT
??_R1HE@?0A@EA@MVAnalysisData@@8 DD FLAT:??_R0?AVMVAnalysisData@@@8 ; MVAnalysisData::`RTTI Base Class Descriptor at (116,-1,0,64)'
	DD	00H
	DD	074H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVAnalysisData@@8
rdata$r	ENDS
;	COMDAT ??_R4MVClip@@6B@
rdata$r	SEGMENT
??_R4MVClip@@6B@ DD 00H					; MVClip::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVClip@@@8
	DD	FLAT:??_R3MVClip@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVAnalysisData@@@8
data$r	SEGMENT
??_R0?AVMVAnalysisData@@@8 DD FLAT:??_7type_info@@6B@	; MVAnalysisData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVAnalysisData@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@FakeGroupOfPlanes@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FakeGroupOfPlanes@@8 DD FLAT:??_R0?AVFakeGroupOfPlanes@@@8 ; FakeGroupOfPlanes::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FakeGroupOfPlanes@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVClip@@@8
data$r	SEGMENT
??_R0?AVMVClip@@@8 DD FLAT:??_7type_info@@6B@		; MVClip `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVClip@@', 00H
data$r	ENDS
;	COMDAT ??_R3MVClip@@8
rdata$r	SEGMENT
??_R3MVClip@@8 DD 00H					; MVClip::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2MVClip@@8
rdata$r	ENDS
;	COMDAT ??_R2MVAnalysisData@@8
rdata$r	SEGMENT
??_R2MVAnalysisData@@8 DD FLAT:??_R1A@?0A@EA@MVAnalysisData@@8 ; MVAnalysisData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVFakeGroupOfPlanes@@@8
data$r	SEGMENT
??_R0?AVFakeGroupOfPlanes@@@8 DD FLAT:??_7type_info@@6B@ ; FakeGroupOfPlanes `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFakeGroupOfPlanes@@', 00H
data$r	ENDS
;	COMDAT ??_R2FakeGroupOfPlanes@@8
rdata$r	SEGMENT
??_R2FakeGroupOfPlanes@@8 DD FLAT:??_R1A@?0A@EA@FakeGroupOfPlanes@@8 ; FakeGroupOfPlanes::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVClip@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVClip@@8 DD FLAT:??_R0?AVMVClip@@@8	; MVClip::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVClip@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CP@NDEDCOJD@MVTools?3?5vector?5clip?5is?5too?5smal@
CONST	SEGMENT
??_C@_0CP@NDEDCOJD@MVTools?3?5vector?5clip?5is?5too?5smal@ DB 'MVTools: v'
	DB	'ector clip is too small (corrupted?)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OFOOOFOK@MVTools?3?5width?5and?5pitch?5are?5not@
CONST	SEGMENT
??_C@_0EG@OFOOOFOK@MVTools?3?5width?5and?5pitch?5are?5not@ DB 'MVTools: w'
	DB	'idth and pitch are not equal in this multi-line vector clip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DDHEPPCI@MVTools?3?5incompatible?5version?5of@
CONST	SEGMENT
??_C@_0CP@DDHEPPCI@MVTools?3?5incompatible?5version?5of@ DB 'MVTools: inc'
	DB	'ompatible version of vector stream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HAJOHLII@MVTools?3?5invalid?5vector?5stream?$AA@
CONST	SEGMENT
??_C@_0BP@HAJOHLII@MVTools?3?5invalid?5vector?5stream?$AA@ DB 'MVTools: i'
	DB	'nvalid vector stream', 00H			; `string'
PUBLIC	?use_ref_frame@MVClip@@QAEXAAHAA_NAAVPClip@@HPAVIScriptEnvironment@@@Z ; MVClip::use_ref_frame
PUBLIC	?GetParity@MVClip@@UAG_NH@Z			; MVClip::GetParity
PUBLIC	?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVClip::GetFrame
PUBLIC	?get_child_frame_index@MVClip@@QBEHH@Z		; MVClip::get_child_frame_index
PUBLIC	?update_analysis_data@MVClip@@QAEXABVMVAnalysisData@@@Z ; MVClip::update_analysis_data
PUBLIC	??_GMVClip@@UAEPAXI@Z				; MVClip::`scalar deleting destructor'
PUBLIC	?GetVPadding@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetVPadding
PUBLIC	?GetHPadding@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetHPadding
PUBLIC	?GetOverlapY@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetOverlapY
PUBLIC	?GetBlkSizeY@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetBlkSizeY
PUBLIC	?GetBitsPerPixel@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetBitsPerPixel
PUBLIC	?GetPixelSize@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetPixelSize
PUBLIC	?GetXRatioUV@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetXRatioUV
PUBLIC	?GetYRatioUV@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetYRatioUV
PUBLIC	?GetPixelType@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetPixelType
PUBLIC	?GetBlkY@MVAnalysisData@@QBEHXZ			; MVAnalysisData::GetBlkY
PUBLIC	?GetBlkX@MVAnalysisData@@QBEHXZ			; MVAnalysisData::GetBlkX
PUBLIC	?GetOverlapX@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetOverlapX
PUBLIC	?GetHeight@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetHeight
PUBLIC	?GetWidth@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetWidth
PUBLIC	?IsBackward@MVAnalysisData@@QBE_NXZ		; MVAnalysisData::IsBackward
PUBLIC	?GetLevelCount@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetLevelCount
PUBLIC	?GetPel@MVAnalysisData@@QBEHXZ			; MVAnalysisData::GetPel
PUBLIC	?GetBlkSizeX@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetBlkSizeX
PUBLIC	?IsChromaMotion@MVAnalysisData@@QBE_NXZ		; MVAnalysisData::IsChromaMotion
PUBLIC	?GetFlags@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetFlags
PUBLIC	?IsValid@FakeGroupOfPlanes@@QBE_NXZ		; FakeGroupOfPlanes::IsValid
PUBLIC	??1MVClip@@UAE@XZ				; MVClip::~MVClip
PUBLIC	?IsUsable@MVClip@@QBE_NHH@Z			; MVClip::IsUsable
PUBLIC	?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z ; MVClip::use_ref_frame
PUBLIC	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
PUBLIC	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
EXTRN	??_EMVClip@@UAEPAXI@Z:PROC			; MVClip::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVClip@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MVClip@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVClip@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVClip@@UAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GMVClip@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GMVClip@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_GMVClip@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GMVClip@@UAEPAXI@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_vectors$ = 8						; size = 4
__nSCD1$ = 12						; size = 4
__nSCD2$ = 16						; size = 4
_env$ = 20						; size = 4
_group_len$ = 24					; size = 4
_group_ofs$ = 28					; size = 4
??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z PROC ; MVClip::MVClip, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvclip.cpp

; 27   : :	GenericVideoFilter(vectors) 

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN12@MVClip
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN12@MVClip
	push	DWORD PTR _vectors$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN12@MVClip:
; File c:\github\mvtools\sources\mvclip.cpp

; 27   : :	GenericVideoFilter(vectors) 

	mov	ecx, esi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 57   : 	InitializeCriticalSection(&cs); // 16.03.08 moved here from ::Create

	lea	eax, DWORD PTR [esi+92]
; File c:\github\mvtools\sources\mvclip.cpp

; 27   : :	GenericVideoFilter(vectors) 

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 57   : 	InitializeCriticalSection(&cs); // 16.03.08 moved here from ::Create

	push	eax
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 58   : 	planes = 0;

	mov	DWORD PTR [esi+88], 0
; File c:\github\mvtools\sources\mvclip.cpp

; 29   : ,	_group_ofs (group_ofs)

	mov	ecx, DWORD PTR _group_ofs$[ebp]
	mov	edi, DWORD PTR _group_len$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 32   : 	vi.num_frames = (vi.num_frames - group_ofs + group_len - 1) / group_len;

	mov	eax, DWORD PTR [esi+32]
	sub	eax, ecx
	mov	DWORD PTR [esi], OFFSET ??_7MVClip@@6B@
	dec	eax
	mov	DWORD PTR [esi+228], edi
	add	eax, edi
	mov	DWORD PTR [esi+232], ecx
	cdq
	idiv	edi
	mov	BYTE PTR [esi+236], 1
	mov	DWORD PTR [esi+32], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 671  :   void MulDivFPS(unsigned multiplier, unsigned divisor) AVS_BakedCode(AVS_LinkCall(MulDivFPS)(multiplier, divisor))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN18@MVClip
	cmp	DWORD PTR [eax], 164			; 000000a4H
	jbe	SHORT $LN18@MVClip
	mov	eax, DWORD PTR [eax+164]
; File c:\github\mvtools\sources\mvclip.cpp

; 33   : 	vi.MulDivFPS (1, group_len);

	lea	ecx, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 671  :   void MulDivFPS(unsigned multiplier, unsigned divisor) AVS_BakedCode(AVS_LinkCall(MulDivFPS)(multiplier, divisor))

	push	edi
	push	1
	call	eax
$LN18@MVClip:
; File c:\github\mvtools\sources\mvclip.cpp

; 47   :     MVAnalysisData *pAnalyseFilter = reinterpret_cast<MVAnalysisData *>(vi.nchannels);

	mov	edi, DWORD PTR [esi+56]

; 48   : #else
; 49   :     uintptr_t p = (((uintptr_t)(unsigned int)vi.nchannels ^ 0x80000000) << 32) | (uintptr_t)(unsigned int)vi.sample_type;
; 50   :     MVAnalysisData *pAnalyseFilter = reinterpret_cast<MVAnalysisData *>(p); 
; 51   : #endif
; 52   : 	if (vi.nchannels >= 0 &&  vi.nchannels < 9) // seems some normal clip instead of vectors

	mov	ebx, DWORD PTR _env$[ebp]
	test	edi, edi
	js	SHORT $LN2@MVClip
	cmp	edi, 9
	jge	SHORT $LN2@MVClip

; 53   : 	     env->ThrowError("MVTools: invalid vector stream");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0BP@HAJOHLII@MVTools?3?5invalid?5vector?5stream?$AA@
	push	ebx
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@MVClip:

; 54   : 
; 55   : 	// 'magic' key, just to check :
; 56   : 	if ( pAnalyseFilter->GetMagicKey() != MVAnalysisData::MOTION_MAGIC_KEY )

	cmp	DWORD PTR [edi], 22093			; 0000564dH
	je	SHORT $LN3@MVClip

; 57   :       env->ThrowError("MVTools: invalid vector stream");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0BP@HAJOHLII@MVTools?3?5invalid?5vector?5stream?$AA@
	push	ebx
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN3@MVClip:

; 58   : 
; 59   : 	update_analysis_data (*pAnalyseFilter);

	push	edi
	mov	ecx, esi
	call	?update_analysis_data@MVClip@@QAEXABVMVAnalysisData@@@Z ; MVClip::update_analysis_data

; 60   : 
; 61   :    // SCD thresholds
; 62   :     nSCD1 = _nSCD1;
; 63   :     if (pixelsize == 2)

	cmp	DWORD PTR [esi+188], 2
	mov	edx, DWORD PTR __nSCD1$[ebp]
	mov	DWORD PTR [esi+216], edx
	jne	SHORT $LN4@MVClip

; 64   :         nSCD1 = sad_t(nSCD1 / 255.0 * ((1 << bits_per_pixel) - 1));

	movd	xmm0, edx
	mov	eax, 1
	cvtdq2pd xmm0, xmm0
	mov	ecx, DWORD PTR [esi+192]
	shl	eax, cl
	dec	eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	mulsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	mov	DWORD PTR [esi+216], eax
$LN4@MVClip:

; 65   :     nSCD1 = nSCD1 * (nBlkSizeX * nBlkSizeY) / (8 * 8); // this is normalized to 8x8 block sizes

	mov	eax, DWORD PTR [esi+124]
	imul	eax, DWORD PTR [esi+128]
	imul	eax, DWORD PTR [esi+216]
	cdq
	and	edx, 63					; 0000003fH
	lea	ebx, DWORD PTR [edx+eax]
	sar	ebx, 6
	mov	DWORD PTR [esi+216], ebx

; 66   :     if (pAnalyseFilter->IsChromaMotion())

	mov	ecx, DWORD PTR [edi+32]
	shr	ecx, 11					; 0000000bH
	test	cl, 1
	je	SHORT $LN5@MVClip

; 67   :         nSCD1 += nSCD1 / (xRatioUV * yRatioUV) * 2; // *2: two additional planes: UV

	mov	ecx, DWORD PTR [esi+184]
	mov	eax, ebx
	imul	ecx, DWORD PTR [esi+180]
	cdq
	idiv	ecx
	lea	eax, DWORD PTR [ebx+eax*2]
	mov	DWORD PTR [esi+216], eax
$LN5@MVClip:

; 68   : 
; 69   :    // Threshold which sets how many blocks have to change for the frame to be considered as a scene change. 
; 70   :    // It is ranged from 0 to 255, 0 meaning 0 %, 255 meaning 100 %. Default is 130 (which means 51 %).
; 71   :    nSCD2 = _nSCD2 * nBlkCount / 256; 
; 72   :    // FakeGroupOfPlane creation
; 73   :    FakeGroupOfPlanes::Create(nBlkSizeX, nBlkSizeY, nLvCount, nPel, nOverlapX, nOverlapY, xRatioUV, yRatioUV, nBlkX, nBlkY);

	push	DWORD PTR [esi+172]
	mov	eax, DWORD PTR [esi+204]
	lea	ecx, DWORD PTR [esi+64]
	push	DWORD PTR [esi+168]
	imul	eax, DWORD PTR __nSCD2$[ebp]
	push	DWORD PTR [esi+180]
	push	DWORD PTR [esi+184]
	push	DWORD PTR [esi+164]
	cdq
	push	DWORD PTR [esi+160]
	and	edx, 255				; 000000ffH
	push	DWORD PTR [esi+132]
	add	eax, edx
	push	DWORD PTR [esi+136]
	sar	eax, 8
	push	DWORD PTR [esi+128]
	mov	DWORD PTR [esi+220], eax
	push	DWORD PTR [esi+124]
	call	?Create@FakeGroupOfPlanes@@QAEXHHHHHHHHHH@Z ; FakeGroupOfPlanes::Create

; 74   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
__ehhandler$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ENDP ; MVClip::MVClip
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_data_size$1$ = -4					; size = 4
_fn$ = 8						; size = 4
_env$ = 12						; size = 4
?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z PROC ; MVClip::Update, COMDAT
; _this$ = ecx

; 184  : {

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	ebx
	push	ebp
; File c:\github\mvtools\sources\mvclip.cpp

; 184  : {

	mov	ebp, ecx
	push	esi
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	test	eax, eax
	je	SHORT $LN9@Update
	cmp	DWORD PTR [eax], 152			; 00000098H
	jbe	SHORT $LN9@Update
	mov	eax, DWORD PTR [eax+152]
; File c:\github\mvtools\sources\mvclip.cpp

; 188  : 	const int		bytes_per_pix = vi.BitsPerPixel () >> 3; 

	lea	ecx, DWORD PTR [ebp+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN10@Update
$LN9@Update:
	xor	edi, edi
$LN10@Update:
; File c:\github\mvtools\sources\mvclip.cpp

; 194  : 	int				data_size = vi.height * line_size / sizeof(int);	// in 32-bit words

	mov	ecx, DWORD PTR [ebp+20]
	sar	edi, 3
	imul	edi, DWORD PTR [ebp+16]
	imul	ecx, edi
	shr	ecx, 2
	mov	DWORD PTR _data_size$1$[esp+20], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 976  :   VideoFrame* operator->() const { return p; }

	mov	ecx, DWORD PTR _fn$[esp+16]
	mov	edx, DWORD PTR [ecx]

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN15@Update
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN15@Update
	mov	eax, DWORD PTR [eax+212]
	mov	ecx, edx
	push	0
	call	eax
	mov	ecx, DWORD PTR _fn$[esp+16]
	mov	ebx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN16@Update
$LN15@Update:
	xor	ebx, ebx
$LN16@Update:
; File c:\github\mvtools\sources\mvclip.cpp

; 197  : 	if (vi.height > 1 && fn->GetPitch () != line_size)

	cmp	DWORD PTR [ebp+20], 1
	mov	esi, DWORD PTR _env$[esp+16]
	jle	SHORT $LN2@Update
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN21@Update
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN21@Update
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+192]
	push	0
	call	eax
	jmp	SHORT $LN22@Update
$LN21@Update:
	xor	eax, eax
$LN22@Update:
; File c:\github\mvtools\sources\mvclip.cpp

; 197  : 	if (vi.height > 1 && fn->GetPitch () != line_size)

	cmp	eax, edi
	je	SHORT $LN2@Update

; 198  : 	{
; 199  : 		env->ThrowError("MVTools: width and pitch are not equal in this multi-line vector clip");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0EG@OFOOOFOK@MVTools?3?5width?5and?5pitch?5are?5not@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@Update:

; 200  : 	}
; 201  : 	int header_size = pMv[0];
; 202  : 	int nMagicKey1 = pMv[1];
; 203  : 	if (nMagicKey1 != MVAnalysisData::MOTION_MAGIC_KEY)

	cmp	DWORD PTR [ebx+4], 22093		; 0000564dH
	mov	edi, DWORD PTR [ebx]
	je	SHORT $LN3@Update

; 204  : 	{
; 205  : 		env->ThrowError("MVTools: invalid vector stream");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0BP@HAJOHLII@MVTools?3?5invalid?5vector?5stream?$AA@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN3@Update:

; 206  : 	}
; 207  : 	int nVersion1 = pMv[2];
; 208  : 	if (nVersion1 != MVAnalysisData::VERSION)

	cmp	DWORD PTR [ebx+8], 5
	je	SHORT $LN4@Update

; 209  : 	{
; 210  : 		env->ThrowError("MVTools: incompatible version of vector stream");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CP@DDHEPPCI@MVTools?3?5incompatible?5version?5of@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN4@Update:

; 211  : 	}
; 212  : 
; 213  : 	const int		hs_i32 = header_size / sizeof(int);
; 214  : 	pMv       += hs_i32;									// go to data - v1.8.1
; 215  : 	data_size -= hs_i32;

	mov	eax, DWORD PTR _data_size$1$[esp+20]

; 216  : 	const bool		ok_flag = FakeGroupOfPlanes::Update(pMv, data_size);	// fixed a bug with lost frames

	lea	ecx, DWORD PTR [ebp+64]
	shr	edi, 2
	sub	eax, edi
	push	eax
	lea	eax, DWORD PTR [ebx+edi*4]
	push	eax
	call	?Update@FakeGroupOfPlanes@@QAE_NPBHH@Z	; FakeGroupOfPlanes::Update

; 217  : 	if (! ok_flag)

	test	al, al
	jne	SHORT $LN5@Update

; 218  : 	{
; 219  : 		env->ThrowError("MVTools: vector clip is too small (corrupted?)");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CP@NDEDCOJD@MVTools?3?5vector?5clip?5is?5too?5smal@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN5@Update:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 220  : 	}
; 221  : }

	pop	ecx
	ret	8
?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ENDP ; MVClip::Update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_ref$ = 8						; size = 4
$T2 = 12						; size = 4
_usable_flag$ = 12					; size = 4
_super$ = 16						; size = 4
_n$ = 20						; size = 4
_env_ptr$ = 24						; size = 4
?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z PROC ; MVClip::use_ref_frame, COMDAT
; _this$ = ecx

; 251  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi

; 229  : 	if (usable_flag)

	mov	edi, DWORD PTR _usable_flag$[ebp]
	cmp	BYTE PTR [edi], 0
	je	$LN26@use_ref_fr
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	esi, DWORD PTR [ecx+140]
; File c:\github\mvtools\sources\mvclip.cpp

; 232  : 		if (off > 0)

	test	esi, esi
	jle	SHORT $LN7@use_ref_fr
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [ecx+144]
; File c:\github\mvtools\sources\mvclip.cpp

; 234  : 			off *= (IsBackward ()) ? 1 : -1;

	xor	ecx, ecx
	test	al, al
	setne	cl
	lea	ecx, DWORD PTR [ecx*2-1]
	imul	esi, ecx

; 235  : 			ref_index = n + off;

	add	esi, DWORD PTR _n$[ebp]

; 236  : 		}
; 237  : 		else

	jmp	SHORT $LN8@use_ref_fr
$LN7@use_ref_fr:

; 238  : 		{
; 239  : 			ref_index = -off;

	neg	esi
$LN8@use_ref_fr:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ebx, DWORD PTR _super$[ebp]
	mov	eax, DWORD PTR [ebx]
; File c:\github\mvtools\sources\mvclip.cpp

; 242  : 		const ::VideoInfo &vi_super = super->GetVideoInfo ();

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+20]

; 243  : 		if (ref_index < 0 || ref_index >= vi_super.num_frames)

	test	esi, esi
	js	SHORT $LN10@use_ref_fr
	cmp	esi, DWORD PTR [eax+16]
	jge	SHORT $LN10@use_ref_fr

; 252  : 	int				ref_index;
; 253  : 	use_ref_frame (ref_index, usable_flag, super, n, env_ptr);
; 254  : 	if (usable_flag)

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN26@use_ref_fr
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx]
; File c:\github\mvtools\sources\mvclip.cpp

; 256  : 		ref = super->GetFrame (ref_index, env_ptr);

	lea	edx, DWORD PTR $T2[ebp]
	push	DWORD PTR _env_ptr$[ebp]
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN22@use_ref_fr
	cmp	DWORD PTR [eax], 268			; 0000010cH
	jbe	SHORT $LN22@use_ref_fr
	mov	eax, DWORD PTR [eax+268]
	push	ecx
	mov	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN22@use_ref_fr:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN26@use_ref_fr
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN26@use_ref_fr
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR $T2[ebp]
	call	eax
; File c:\github\mvtools\sources\mvclip.cpp

; 258  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN10@use_ref_fr:

; 245  : 			usable_flag = false;

	mov	BYTE PTR [edi], 0
$LN26@use_ref_fr:

; 258  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?use_ref_frame@MVClip@@QAEXAAVPVideoFrame@@AA_NAAVPClip@@HPAVIScriptEnvironment@@@Z ENDP ; MVClip::use_ref_frame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?IsUsable@MVClip@@QBE_NHH@Z
_TEXT	SEGMENT
_nSCD1_$ = 8						; size = 4
_nSCD2_$ = 12						; size = 4
?IsUsable@MVClip@@QBE_NHH@Z PROC			; MVClip::IsUsable, COMDAT
; _this$ = ecx

; 263  : {

	push	esi
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR _nSCD2_$[esp]
; File c:\github\mvtools\sources\mvclip.cpp

; 263  : {

	mov	esi, ecx
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR _nSCD1_$[esp+4]
	mov	ecx, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	SHORT $LN3@IsUsable
	cmp	BYTE PTR [esi+68], al
	je	SHORT $LN3@IsUsable
	mov	al, 1
	pop	esi

; 265  : }

	ret	8
$LN3@IsUsable:

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	xor	al, al
	pop	esi

; 265  : }

	ret	8
?IsUsable@MVClip@@QBE_NHH@Z ENDP			; MVClip::IsUsable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ??1MVClip@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVClip@@UAE@XZ PROC					; MVClip::~MVClip, COMDAT
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVClip@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 79   : }

	lea	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [esi], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN14@MVClip
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN14@MVClip
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN14@MVClip:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVClip@@UAE@XZ$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVClip@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVClip@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVClip@@UAE@XZ ENDP					; MVClip::~MVClip
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakegroupofplanes.h
;	COMDAT ?IsValid@FakeGroupOfPlanes@@QBE_NXZ
_TEXT	SEGMENT
?IsValid@FakeGroupOfPlanes@@QBE_NXZ PROC		; FakeGroupOfPlanes::IsValid, COMDAT
; _this$ = ecx

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ecx+4]
	ret	0
?IsValid@FakeGroupOfPlanes@@QBE_NXZ ENDP		; FakeGroupOfPlanes::IsValid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetFlags@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetFlags@MVAnalysisData@@QBEHXZ PROC			; MVAnalysisData::GetFlags, COMDAT
; _this$ = ecx

; 111  :    inline int GetFlags() const { return nFlags; }

	mov	eax, DWORD PTR [ecx+32]
	ret	0
?GetFlags@MVAnalysisData@@QBEHXZ ENDP			; MVAnalysisData::GetFlags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?IsChromaMotion@MVAnalysisData@@QBE_NXZ
_TEXT	SEGMENT
?IsChromaMotion@MVAnalysisData@@QBE_NXZ PROC		; MVAnalysisData::IsChromaMotion, COMDAT
; _this$ = ecx

; 112  :    inline bool IsChromaMotion() const { return (nFlags & MOTION_USE_CHROMA_MOTION) != 0; }

	mov	eax, DWORD PTR [ecx+32]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	ret	0
?IsChromaMotion@MVAnalysisData@@QBE_NXZ ENDP		; MVAnalysisData::IsChromaMotion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetBlkSizeX@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetBlkSizeX@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetBlkSizeX, COMDAT
; _this$ = ecx

; 113  :    inline int GetBlkSizeX() const { return nBlkSizeX; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?GetBlkSizeX@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetBlkSizeX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetPel@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetPel@MVAnalysisData@@QBEHXZ PROC			; MVAnalysisData::GetPel, COMDAT
; _this$ = ecx

; 114  :    inline int GetPel() const { return nPel; }

	mov	eax, DWORD PTR [ecx+16]
	ret	0
?GetPel@MVAnalysisData@@QBEHXZ ENDP			; MVAnalysisData::GetPel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetLevelCount@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetLevelCount@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetLevelCount, COMDAT
; _this$ = ecx

; 115  :    inline int GetLevelCount() const { return nLvCount; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?GetLevelCount@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetLevelCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?IsBackward@MVAnalysisData@@QBE_NXZ
_TEXT	SEGMENT
?IsBackward@MVAnalysisData@@QBE_NXZ PROC		; MVAnalysisData::IsBackward, COMDAT
; _this$ = ecx

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [ecx+28]
	ret	0
?IsBackward@MVAnalysisData@@QBE_NXZ ENDP		; MVAnalysisData::IsBackward
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetWidth@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetWidth@MVAnalysisData@@QBEHXZ PROC			; MVAnalysisData::GetWidth, COMDAT
; _this$ = ecx

; 119  :    inline int GetWidth() const { return nWidth; }

	mov	eax, DWORD PTR [ecx+36]
	ret	0
?GetWidth@MVAnalysisData@@QBEHXZ ENDP			; MVAnalysisData::GetWidth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetHeight@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetHeight@MVAnalysisData@@QBEHXZ PROC			; MVAnalysisData::GetHeight, COMDAT
; _this$ = ecx

; 120  :    inline int GetHeight() const { return nHeight; }

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?GetHeight@MVAnalysisData@@QBEHXZ ENDP			; MVAnalysisData::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetOverlapX@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetOverlapX@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetOverlapX, COMDAT
; _this$ = ecx

; 121  :    inline int GetOverlapX() const { return nOverlapX; }

	mov	eax, DWORD PTR [ecx+44]
	ret	0
?GetOverlapX@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetOverlapX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetBlkX@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetBlkX@MVAnalysisData@@QBEHXZ PROC			; MVAnalysisData::GetBlkX, COMDAT
; _this$ = ecx

; 122  :    inline int GetBlkX() const { return nBlkX; }

	mov	eax, DWORD PTR [ecx+52]
	ret	0
?GetBlkX@MVAnalysisData@@QBEHXZ ENDP			; MVAnalysisData::GetBlkX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetBlkY@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetBlkY@MVAnalysisData@@QBEHXZ PROC			; MVAnalysisData::GetBlkY, COMDAT
; _this$ = ecx

; 123  :    inline int GetBlkY() const { return nBlkY; }

	mov	eax, DWORD PTR [ecx+56]
	ret	0
?GetBlkY@MVAnalysisData@@QBEHXZ ENDP			; MVAnalysisData::GetBlkY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetPixelType@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetPixelType@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetPixelType, COMDAT
; _this$ = ecx

; 124  :    inline int GetPixelType() const { return pixelType; }

	mov	eax, DWORD PTR [ecx+60]
	ret	0
?GetPixelType@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetPixelType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetYRatioUV@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetYRatioUV@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetYRatioUV, COMDAT
; _this$ = ecx

; 125  :    inline int GetYRatioUV() const { return yRatioUV; }

	mov	eax, DWORD PTR [ecx+64]
	ret	0
?GetYRatioUV@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetYRatioUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetXRatioUV@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetXRatioUV@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetXRatioUV, COMDAT
; _this$ = ecx

; 126  :    inline int GetXRatioUV() const { return xRatioUV; }

	mov	eax, DWORD PTR [ecx+68]
	ret	0
?GetXRatioUV@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetXRatioUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetPixelSize@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetPixelSize@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetPixelSize, COMDAT
; _this$ = ecx

; 127  :    inline int GetPixelSize() const { return pixelsize; } // PF

	mov	eax, DWORD PTR [ecx+72]
	ret	0
?GetPixelSize@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetPixelSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetBitsPerPixel@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetBitsPerPixel@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetBitsPerPixel, COMDAT
; _this$ = ecx

; 128  :    inline int GetBitsPerPixel() const { return bits_per_pixel; } // PF

	mov	eax, DWORD PTR [ecx+76]
	ret	0
?GetBitsPerPixel@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetBitsPerPixel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetBlkSizeY@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetBlkSizeY@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetBlkSizeY, COMDAT
; _this$ = ecx

; 131  :    inline int GetBlkSizeY() const { return nBlkSizeY; }

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?GetBlkSizeY@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetBlkSizeY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetOverlapY@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetOverlapY@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetOverlapY, COMDAT
; _this$ = ecx

; 132  :    inline int GetOverlapY() const { return nOverlapY; }

	mov	eax, DWORD PTR [ecx+48]
	ret	0
?GetOverlapY@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetOverlapY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetHPadding@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetHPadding@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetHPadding, COMDAT
; _this$ = ecx

; 133  :    inline int GetHPadding() const { return nHPadding; }

	mov	eax, DWORD PTR [ecx+80]
	ret	0
?GetHPadding@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetHPadding
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetVPadding@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetVPadding@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetVPadding, COMDAT
; _this$ = ecx

; 134  :    inline int GetVPadding() const { return nVPadding; }

	mov	eax, DWORD PTR [ecx+84]
	ret	0
?GetVPadding@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetVPadding
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??_GMVClip@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GMVClip@@UAEPAXI@Z PROC				; MVClip::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_GMVClip@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [esi], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN12@scalar
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN12@scalar
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN12@scalar:
	test	BYTE PTR ___flags$[ebp], 1

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	je	SHORT $LN18@scalar
	push	240					; 000000f0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GMVClip@@UAEPAXI@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_GMVClip@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GMVClip@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GMVClip@@UAEPAXI@Z ENDP				; MVClip::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?update_analysis_data@MVClip@@QAEXABVMVAnalysisData@@@Z
_TEXT	SEGMENT
_adata$ = 8						; size = 4
?update_analysis_data@MVClip@@QAEXABVMVAnalysisData@@@Z PROC ; MVClip::update_analysis_data, COMDAT
; _this$ = ecx

; 104  : {

	mov	edx, ecx

; 105  : 	assert (&adata != 0);
; 106  : 
; 107  :    // MVAnalysisData
; 108  :    nBlkSizeX   = adata.GetBlkSizeX();

	mov	ecx, DWORD PTR _adata$[esp-4]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+124], eax

; 109  :    nBlkSizeY   = adata.GetBlkSizeY();

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+128], eax

; 110  :    nPel        = adata.GetPel();

	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+132], eax

; 111  :    isBackward  = adata.IsBackward();

	mov	al, BYTE PTR [ecx+28]
	mov	BYTE PTR [edx+144], al

; 112  :    nLvCount    = adata.GetLevelCount();

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+136], eax

; 113  :    nDeltaFrame = adata.GetDeltaFrame();

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+140], eax

; 114  :    nWidth      = adata.GetWidth();

	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+152], eax

; 115  :    nHeight     = adata.GetHeight();

	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [edx+156], eax

; 116  :    nMagicKey   = adata.GetMagicKey();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+116], eax

; 117  :    nOverlapX   = adata.GetOverlapX();

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [edx+160], eax

; 118  :    nOverlapY   = adata.GetOverlapY();

	mov	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR [edx+164], eax

; 119  :    pixelType   = adata.GetPixelType();

	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR [edx+176], eax

; 120  :    xRatioUV    = adata.GetXRatioUV(); // PF

	mov	eax, DWORD PTR [ecx+68]
	mov	DWORD PTR [edx+184], eax

; 121  :    yRatioUV    = adata.GetYRatioUV(); 

	mov	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR [edx+180], eax

; 122  :    pixelsize = adata.GetPixelSize();

	mov	eax, DWORD PTR [ecx+72]
	mov	DWORD PTR [edx+188], eax

; 123  :    bits_per_pixel = adata.GetBitsPerPixel();

	mov	eax, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+192], eax

; 124  : //	sharp       = adata.GetSharp();
; 125  : //	usePelClip  = adata.UsePelClip();
; 126  : 	nVPadding   = adata.GetVPadding();

	mov	eax, DWORD PTR [ecx+84]
	mov	DWORD PTR [edx+212], eax

; 127  : 	nHPadding   = adata.GetHPadding();

	mov	eax, DWORD PTR [ecx+80]
	mov	DWORD PTR [edx+208], eax

; 128  : 	nFlags      = adata.GetFlags();

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [edx+148], eax

; 129  : 
; 130  :    // MVClip
; 131  : //	nVPadding   = nBlkSizeY;
; 132  : //	nHPadding   = nBlkSizeX;
; 133  : 	nBlkX       = adata.GetBlkX();

	mov	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR [edx+168], eax

; 134  : 	nBlkY       = adata.GetBlkY();

	mov	ecx, DWORD PTR [ecx+56]

; 135  :    nBlkCount   = nBlkX * nBlkY;

	imul	eax, ecx
	mov	DWORD PTR [edx+172], ecx
	mov	DWORD PTR [edx+204], eax

; 136  : }

	ret	4
?update_analysis_data@MVClip@@QAEXABVMVAnalysisData@@@Z ENDP ; MVClip::update_analysis_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?get_child_frame_index@MVClip@@QBEHH@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?get_child_frame_index@MVClip@@QBEHH@Z PROC		; MVClip::get_child_frame_index, COMDAT
; _this$ = ecx

; 142  : 	return (n * _group_len + _group_ofs);

	mov	eax, DWORD PTR [ecx+228]
	imul	eax, DWORD PTR _n$[esp-4]
	add	eax, DWORD PTR [ecx+232]

; 143  : }

	ret	4
?get_child_frame_index@MVClip@@QBEHH@Z ENDP		; MVClip::get_child_frame_index
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ana_data$1$ = 8					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_n$ = 16						; size = 4
_env_ptr$ = 20						; size = 4
?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVClip::GetFrame, COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi

; 142  : 	return (n * _group_len + _group_ofs);

	mov	esi, DWORD PTR _this$[ebp]

; 148  : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 0

; 150  : 	::PVideoFrame	frame_ptr = child->GetFrame (child_n, env_ptr);

	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 142  : 	return (n * _group_len + _group_ofs);

	mov	edx, DWORD PTR [esi+228]
	imul	edx, DWORD PTR _n$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+8]
	push	edi
; File c:\github\mvtools\sources\mvclip.cpp

; 150  : 	::PVideoFrame	frame_ptr = child->GetFrame (child_n, env_ptr);

	mov	edi, DWORD PTR _env_ptr$[ebp]
	push	edi

; 142  : 	return (n * _group_len + _group_ofs);

	add	edx, DWORD PTR [esi+232]

; 150  : 	::PVideoFrame	frame_ptr = child->GetFrame (child_n, env_ptr);

	mov	ecx, DWORD PTR [eax]
	push	edx
	push	ebx
	push	eax
	call	DWORD PTR [ecx+4]

; 167  : 	}
; 168  : 
; 169  : 	return (frame_ptr);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	BYTE PTR [esi+236], 0
	mov	DWORD PTR $T2[ebp], 1
	je	SHORT $LN18@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN16@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN16@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+212]
	push	0
	call	eax
	jmp	SHORT $LN17@GetFrame
$LN16@GetFrame:
	xor	eax, eax
$LN17@GetFrame:
; File c:\github\mvtools\sources\mvclip.cpp

; 154  : 		const MVAnalysisData &	ana_data =

	add	eax, 4
	mov	DWORD PTR _ana_data$1$[ebp], eax

; 155  : 			*reinterpret_cast <const MVAnalysisData *> (frame_data_ptr + sizeof (int));
; 156  : 		if (ana_data.nMagicKey != MVAnalysisData::MOTION_MAGIC_KEY)

	cmp	DWORD PTR [eax], 22093			; 0000564dH
	je	SHORT $LN3@GetFrame

; 157  : 		{
; 158  : 			env_ptr->ThrowError("MVTools: invalid vector stream");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BP@HAJOHLII@MVTools?3?5invalid?5vector?5stream?$AA@
	push	edi
	call	DWORD PTR [eax+20]
	mov	eax, DWORD PTR _ana_data$1$[ebp]
	add	esp, 8
$LN3@GetFrame:

; 159  : 		}
; 160  : 		if (ana_data.nVersion != MVAnalysisData::VERSION)

	cmp	DWORD PTR [eax+4], 5
	je	SHORT $LN4@GetFrame

; 161  : 		{
; 162  : 			env_ptr->ThrowError("MVTools: incompatible version of vector stream");

	mov	ecx, DWORD PTR [edi]
	push	OFFSET ??_C@_0CP@DDHEPPCI@MVTools?3?5incompatible?5version?5of@
	push	edi
	call	DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _ana_data$1$[ebp]
	add	esp, 8
$LN4@GetFrame:

; 163  : 		}
; 164  : 		update_analysis_data (ana_data);

	push	eax
	mov	ecx, esi
	call	?update_analysis_data@MVClip@@QAEXABVMVAnalysisData@@@Z ; MVClip::update_analysis_data

; 165  : 
; 166  : 		_frame_update_flag = false;

	mov	BYTE PTR [esi+236], 0
$LN18@GetFrame:

; 170  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN7@GetFrame
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN7@GetFrame:
	ret	0
__ehhandler$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVClip@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVClip::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?GetParity@MVClip@@UAG_NH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_n$ = 12						; size = 4
?GetParity@MVClip@@UAG_NH@Z PROC			; MVClip::GetParity, COMDAT

; 142  : 	return (n * _group_len + _group_ofs);

	mov	eax, DWORD PTR _this$[esp-4]
	mov	edx, DWORD PTR [eax+228]
	imul	edx, DWORD PTR _n$[esp-4]
	add	edx, DWORD PTR [eax+232]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvclip.cpp

; 178  : 	return (child->GetParity (child_n));

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _n$[esp-4], edx
	mov	DWORD PTR _this$[esp-4], eax
	jmp	DWORD PTR [ecx+8]
?GetParity@MVClip@@UAG_NH@Z ENDP			; MVClip::GetParity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
;	COMDAT ?use_ref_frame@MVClip@@QAEXAAHAA_NAAVPClip@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_ref_index$ = 8						; size = 4
_usable_flag$ = 12					; size = 4
_super$ = 16						; size = 4
_n$ = 20						; size = 4
?use_ref_frame@MVClip@@QAEXAAHAA_NAAVPClip@@HPAVIScriptEnvironment@@@Z PROC ; MVClip::use_ref_frame, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	edx, DWORD PTR [ecx+140]
	push	esi
; File c:\github\mvtools\sources\mvclip.cpp

; 235  : 			ref_index = n + off;

	mov	esi, DWORD PTR _ref_index$[esp]
	test	edx, edx
	jle	SHORT $LN3@use_ref_fr

; 229  : 	if (usable_flag)
; 230  : 	{
; 231  : 		int				off = GetDeltaFrame ();
; 232  : 		if (off > 0)
; 233  : 		{
; 234  : 			off *= (IsBackward ()) ? 1 : -1;

	xor	eax, eax
	cmp	BYTE PTR [ecx+144], al
	setne	al
	lea	eax, DWORD PTR [eax*2-1]
	imul	eax, edx

; 235  : 			ref_index = n + off;

	add	eax, DWORD PTR _n$[esp]
	mov	DWORD PTR [esi], eax

; 236  : 		}
; 237  : 		else

	jmp	SHORT $LN4@use_ref_fr
$LN3@use_ref_fr:

; 238  : 		{
; 239  : 			ref_index = -off;

	neg	edx
	mov	DWORD PTR [esi], edx
$LN4@use_ref_fr:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR _super$[esp]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvclip.cpp

; 242  : 		const ::VideoInfo &vi_super = super->GetVideoInfo ();

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+20]

; 243  : 		if (ref_index < 0 || ref_index >= vi_super.num_frames)

	mov	ecx, DWORD PTR [esi]
	pop	esi
	test	ecx, ecx
	js	SHORT $LN6@use_ref_fr
	cmp	ecx, DWORD PTR [eax+16]
	jl	SHORT $LN5@use_ref_fr
$LN6@use_ref_fr:

; 244  : 		{
; 245  : 			usable_flag = false;

	mov	eax, DWORD PTR _usable_flag$[esp-4]
	mov	BYTE PTR [eax], 0
$LN5@use_ref_fr:

; 246  : 		}
; 247  : 	}
; 248  : }

	ret	16					; 00000010H
?use_ref_frame@MVClip@@QAEXAAHAA_NAAVPClip@@HPAVIScriptEnvironment@@@Z ENDP ; MVClip::use_ref_frame
_TEXT	ENDS
END
