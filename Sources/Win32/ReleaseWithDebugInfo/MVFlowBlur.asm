; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvflowblur.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EF@OKILMPEN@MFlowBlur?3?5cannot?5use?5motion?5vec@ ; `string'
PUBLIC	??_C@_0CD@BNDHIOGF@MFlowBlur?5?3?5wrong?5super?5frame?5cl@ ; `string'
PUBLIC	??_C@_0O@FPHICKBJ@InternalCache?$AA@		; `string'
PUBLIC	??_R0?AVMVFlowBlur@@@8				; MVFlowBlur `RTTI Type Descriptor'
PUBLIC	??_R3MVFlowBlur@@8				; MVFlowBlur::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7MVFlowBlur@@6B@				; MVFlowBlur::`vftable'
PUBLIC	??_R1A@?0A@EA@MVFlowBlur@@8			; MVFlowBlur::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2MVFlowBlur@@8				; MVFlowBlur::`RTTI Base Class Array'
PUBLIC	??_R4MVFlowBlur@@6B@				; MVFlowBlur::`RTTI Complete Object Locator'
;	COMDAT ??_R4MVFlowBlur@@6B@
rdata$r	SEGMENT
??_R4MVFlowBlur@@6B@ DD 00H				; MVFlowBlur::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVFlowBlur@@@8
	DD	FLAT:??_R3MVFlowBlur@@8
rdata$r	ENDS
;	COMDAT ??_R2MVFlowBlur@@8
rdata$r	SEGMENT
??_R2MVFlowBlur@@8 DD FLAT:??_R1A@?0A@EA@MVFlowBlur@@8	; MVFlowBlur::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVFlowBlur@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVFlowBlur@@8 DD FLAT:??_R0?AVMVFlowBlur@@@8 ; MVFlowBlur::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVFlowBlur@@8
rdata$r	ENDS
;	COMDAT ??_7MVFlowBlur@@6B@
CONST	SEGMENT
??_7MVFlowBlur@@6B@ DD FLAT:??_R4MVFlowBlur@@6B@	; MVFlowBlur::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVFlowBlur@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVFlowBlur@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3MVFlowBlur@@8
rdata$r	SEGMENT
??_R3MVFlowBlur@@8 DD 00H				; MVFlowBlur::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVFlowBlur@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVFlowBlur@@@8
data$r	SEGMENT
??_R0?AVMVFlowBlur@@@8 DD FLAT:??_7type_info@@6B@	; MVFlowBlur `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVFlowBlur@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0O@FPHICKBJ@InternalCache?$AA@
CONST	SEGMENT
??_C@_0O@FPHICKBJ@InternalCache?$AA@ DB 'InternalCache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BNDHIOGF@MFlowBlur?5?3?5wrong?5super?5frame?5cl@
CONST	SEGMENT
??_C@_0CD@BNDHIOGF@MFlowBlur?5?3?5wrong?5super?5frame?5cl@ DB 'MFlowBlur '
	DB	': wrong super frame clip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@OKILMPEN@MFlowBlur?3?5cannot?5use?5motion?5vec@
CONST	SEGMENT
??_C@_0EF@OKILMPEN@MFlowBlur?3?5cannot?5use?5motion?5vec@ DB 'MFlowBlur: '
	DB	'cannot use motion vectors with absolute frame references.', 00H ; `string'
PUBLIC	??$FlowBlur@G@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned short>
PUBLIC	??$FlowBlur@E@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned char>
PUBLIC	?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVFlowBlur::GetFrame
PUBLIC	??1MVFlowBlur@@UAE@XZ				; MVFlowBlur::~MVFlowBlur
PUBLIC	??_GMVFlowBlur@@UAEPAXI@Z			; MVFlowBlur::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVFlowBlur@@UAGHHH@Z		; MVFlowBlur::SetCacheHints
PUBLIC	??0AVSValue@@QAE@PBV0@H@Z			; AVSValue::AVSValue
PUBLIC	??0AVSValue@@QAE@ABVPClip@@@Z			; AVSValue::AVSValue
PUBLIC	??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z ; MVFlowBlur::MVFlowBlur
EXTRN	??_EMVFlowBlur@@UAEPAXI@Z:PROC			; MVFlowBlur::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$9
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$12
	DD	09H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$14
	DD	0aH
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$15
	DD	0aH
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$19
	DD	09H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$20
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$21
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$22
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$24
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVFlowBlur@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1MVFlowBlur@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVFlowBlur@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowBlur@@UAE@XZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowBlur@@UAE@XZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowBlur@@UAE@XZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowBlur@@UAE@XZ$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
;	COMDAT ??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 8
_cache_args$3 = -24					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
_super$ = 12						; size = 4
__mvbw$ = 16						; size = 4
__mvfw$ = 20						; size = 4
__blur256$ = 24						; size = 4
__prec$ = 28						; size = 4
_nSuperPel$1$ = 32					; size = 4
_nSCD1$ = 32						; size = 4
_nSuperHPad$1$ = 36					; size = 4
_nSCD2$ = 36						; size = 4
_nSuperWidth$1$ = 40					; size = 4
tv1464 = 40						; size = 4
$T4 = 40						; size = 4
$T5 = 40						; size = 4
$T6 = 40						; size = 4
$T7 = 40						; size = 4
$T8 = 40						; size = 4
__isse$ = 40						; size = 1
_nHeightS$1$ = 44					; size = 4
__planar$ = 44						; size = 1
_env$ = 48						; size = 4
??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z PROC ; MVFlowBlur::MVFlowBlur, COMDAT
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowblur.cpp

; 29   :   GenericVideoFilter(_child),

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN46@MVFlowBlur
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN46@MVFlowBlur
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN46@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 29   :   GenericVideoFilter(_child),

	mov	ecx, ebx
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 30   :   MVFilter(_mvfw, "MFlowBlur", env, 1, 0),

	mov	esi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	push	0
	push	1
	push	esi
	push	OFFSET ??_C@_09CKNECHMI@MFlowBlur?$AA@
	push	ecx
	lea	ecx, DWORD PTR [ebx+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter

; 31   :   mvClipB(_mvbw, nSCD1, nSCD2, env, 1, 0),

	mov	edi, DWORD PTR _nSCD2$[ebp]
	lea	ecx, DWORD PTR __mvbw$[ebp]
	push	0
	push	1
	push	esi
	mov	esi, DWORD PTR _nSCD1$[ebp]
	push	edi
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [ebx+152]

; 33   : {

	mov	DWORD PTR [ebx], OFFSET ??_7MVFlowBlur@@6B@
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	push	0
	push	1
	push	DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	edi
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [ebx+392]
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN50@MVFlowBlur
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN50@MVFlowBlur
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR [ebx+640]
	call	eax
$LN50@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 34   :   blur256 = _blur256;

	mov	eax, DWORD PTR __blur256$[ebp]

; 35   :   prec = _prec;
; 36   :   isse = _isse;
; 37   :   planar = _planar;
; 38   : 
; 39   :   CheckSimilarity(mvClipB, "mvbw", env);

	lea	ecx, DWORD PTR [ebx+64]
	mov	esi, DWORD PTR _env$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	DWORD PTR [ebx+632], eax
	mov	eax, DWORD PTR __prec$[ebp]
	mov	DWORD PTR [ebx+636], eax
	mov	al, BYTE PTR __isse$[ebp]
	mov	BYTE PTR [ebx+644], al
	mov	al, BYTE PTR __planar$[ebp]
	push	esi
	mov	BYTE PTR [ebx+645], al
	lea	eax, DWORD PTR [ebx+152]
	push	OFFSET ??_C@_04DNAGLECB@mvbw?$AA@
	push	eax
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity

; 40   :   CheckSimilarity(mvClipF, "mvfw", env);

	push	esi
	push	OFFSET ??_C@_04DKAPBMPN@mvfw?$AA@
	lea	eax, DWORD PTR [ebx+392]
	push	eax
	lea	ecx, DWORD PTR [ebx+64]
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity

; 41   : 
; 42   :   if (mvClipB.GetDeltaFrame() <= 0 || mvClipF.GetDeltaFrame() <= 0)

	cmp	DWORD PTR [ebx+292], 0
	jle	SHORT $LN3@MVFlowBlur
	cmp	DWORD PTR [ebx+532], 0
	jg	SHORT $LN2@MVFlowBlur
$LN3@MVFlowBlur:

; 43   :     env->ThrowError("MFlowBlur: cannot use motion vectors with absolute frame references.");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0EF@OKILMPEN@MFlowBlur?3?5cannot?5use?5motion?5vec@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@MVFlowBlur:
	mov	eax, DWORD PTR _super$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN20@MVFlowBlur
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN19@MVFlowBlur
$LN20@MVFlowBlur:
	push	eax
; File c:\github\mvtools\sources\mvflowblur.cpp

; 46   :   memcpy(&params, &super->GetVideoInfo().num_audio_samples, 8);

	call	ecx
	mov	edx, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN19@MVFlowBlur:
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [edx+36]

; 47   :   int nHeightS = params.nHeight;

	movzx	edi, cx

; 48   :   int nSuperHPad = params.nHPad;

	shr	ecx, 16					; 00000010H
	movzx	ecx, cl
	mov	DWORD PTR _nSuperHPad$1$[ebp], ecx

; 49   :   int nSuperVPad = params.nVPad;
; 50   :   int nSuperPel = params.nPel;

	movzx	ecx, dl
	mov	DWORD PTR _nSuperPel$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nHeightS$1$[ebp], edi
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN22@MVFlowBlur
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN21@MVFlowBlur
$LN22@MVFlowBlur:
	push	eax
; File c:\github\mvtools\sources\mvflowblur.cpp

; 53   :   int nSuperWidth = super->GetVideoInfo().width; // really super

	call	ecx
	mov	edx, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN21@MVFlowBlur:
	mov	ecx, DWORD PTR [eax]
	lea	edi, DWORD PTR [ebx+640]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _nSuperWidth$1$[ebp], edx
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	je	SHORT $LN23@MVFlowBlur

; 54   :   int nSuperHeight = super->GetVideoInfo().height;

	push	eax
	call	ecx
	mov	edx, DWORD PTR _nSuperWidth$1$[ebp]
$LN23@MVFlowBlur:

; 55   : 
; 56   :   if (nHeight != nHeightS
; 57   :     || nWidth != nSuperWidth - nSuperHPad * 2
; 58   :     || nPel != nSuperPel)

	mov	eax, DWORD PTR _nHeightS$1$[ebp]
	cmp	DWORD PTR [ebx+96], eax
	jne	SHORT $LN5@MVFlowBlur
	mov	eax, DWORD PTR _nSuperHPad$1$[ebp]
	add	eax, eax
	sub	edx, eax
	cmp	DWORD PTR [ebx+92], edx
	jne	SHORT $LN5@MVFlowBlur
	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	cmp	DWORD PTR [ebx+104], eax
	je	SHORT $LN4@MVFlowBlur
$LN5@MVFlowBlur:

; 59   :   {
; 60   :     env->ThrowError("MFlowBlur : wrong super frame clip");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CD@BNDHIOGF@MFlowBlur?5?3?5wrong?5super?5frame?5cl@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN4@MVFlowBlur:

; 61   :   }
; 62   : 
; 63   :   if (nPel == 1)

	cmp	DWORD PTR [ebx+104], 1
	jne	SHORT $LN6@MVFlowBlur
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	$LN7@MVFlowBlur
	cmp	DWORD PTR [eax], 244			; 000000f4H
	jbe	$LN7@MVFlowBlur
	mov	eax, DWORD PTR [eax+244]
	lea	ecx, DWORD PTR _super$[ebp]
	push	ecx
	mov	ecx, edi
	call	eax
; File c:\github\mvtools\sources\mvflowblur.cpp

; 65   :   else

	jmp	$LN7@MVFlowBlur
$LN6@MVFlowBlur:

; 67   :     finest = new MVFinest(super, isse, env);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR $T8[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	movzx	ecx, BYTE PTR [ebx+644]
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowblur.cpp

; 67   :     finest = new MVFinest(super, isse, env);

	push	ecx
	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN74@MVFlowBlur
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN74@MVFlowBlur
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _super$[ebp]
	push	edx
	call	eax
$LN74@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 67   :     finest = new MVFinest(super, isse, env);

	mov	ecx, DWORD PTR $T8[ebp]
	call	??0MVFinest@@QAE@VPClip@@_NPAVIScriptEnvironment@@@Z ; MVFinest::MVFinest
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 939  :   void operator=(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN82@MVFlowBlur
	cmp	DWORD PTR [eax], 240			; 000000f0H
	jbe	SHORT $LN78@MVFlowBlur
	mov	eax, DWORD PTR [eax+240]
	push	ecx
	mov	ecx, edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN78@MVFlowBlur:

; 1000 :   AVSValue(const PClip& c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR2)(c) )

	test	eax, eax
	je	SHORT $LN82@MVFlowBlur
	cmp	DWORD PTR [eax], 284			; 0000011cH
	jbe	SHORT $LN82@MVFlowBlur
	mov	eax, DWORD PTR [eax+284]
	lea	ecx, DWORD PTR _cache_args$3[ebp]
	push	edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN82@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 69   :     finest = env->Invoke("InternalCache", AVSValue(cache_args, 1)).AsClip(); // add cache for speed

	lea	ecx, DWORD PTR $T7[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	ecx
	push	0
	sub	esp, 8
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 1007 :   AVSValue(const AVSValue* a, int size) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR8)(a, size) )

	test	eax, eax
	je	SHORT $LN86@MVFlowBlur
	cmp	DWORD PTR [eax], 308			; 00000134H
	jbe	SHORT $LN86@MVFlowBlur
	mov	eax, DWORD PTR [eax+308]
	lea	edx, DWORD PTR _cache_args$3[ebp]
	push	1
	push	edx
	call	eax
$LN86@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 69   :     finest = env->Invoke("InternalCache", AVSValue(cache_args, 1)).AsClip(); // add cache for speed

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T2[ebp]
	push	OFFSET ??_C@_0O@FPHICKBJ@InternalCache?$AA@
	push	ecx
	push	esi
	call	DWORD PTR [eax+32]
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN90@MVFlowBlur
	cmp	DWORD PTR [eax], 244			; 000000f4H
	jbe	SHORT $LN90@MVFlowBlur
	mov	eax, DWORD PTR [eax+244]
	push	ecx
	mov	ecx, edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN90@MVFlowBlur:

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	eax, eax
	je	SHORT $LN94@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN94@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR $T7[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN94@MVFlowBlur:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	eax, eax
	je	SHORT $LN99@MVFlowBlur
	cmp	DWORD PTR [eax], 316			; 0000013cH
	jbe	SHORT $LN99@MVFlowBlur
	mov	eax, DWORD PTR [eax+316]
	lea	ecx, DWORD PTR $T2[ebp]
	call	eax
$LN99@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 70   :   }

	push	OFFSET ??1AVSValue@@QAE@XZ		; AVSValue::~AVSValue
	push	1
	push	8
	lea	eax, DWORD PTR _cache_args$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
$LN7@MVFlowBlur:

; 71   : 
; 72   : //	if (   nWidth  != vi.width  || (nWidth  + nHPadding*2)*nPel != finest->GetVideoInfo().width
; 73   : //	    || nHeight != vi.height || (nHeight + nVPadding*2)*nPel != finest->GetVideoInfo().height)
; 74   : //		env->ThrowError("MVFlowBlur: wrong source of finest frame size");
; 75   : 
; 76   : 
; 77   :   nHeightUV = nHeight / yRatioUV;

	mov	eax, DWORD PTR [ebx+96]
	mov	ebx, DWORD PTR [ebx+124]
	mov	DWORD PTR tv1464[ebp], eax
	cdq
	idiv	ebx
	mov	ecx, DWORD PTR _this$[ebp]

; 78   :   nWidthUV = nWidth / xRatioUV;// orig: /2 for YV12
; 79   :   nHPaddingUV = nHPadding / xRatioUV;
; 80   :   nVPaddingUV = nHPadding / yRatioUV;
; 81   : 
; 82   :   VPitchY = nWidth;
; 83   :   VPitchUV = nWidthUV;
; 84   : 
; 85   :   VXFullYB = (short*)_aligned_malloc(2 * nHeight*VPitchY + 128, 128);

	push	128					; 00000080H
	mov	esi, DWORD PTR [ecx+120]
	mov	DWORD PTR [ecx+740], eax
	mov	eax, DWORD PTR [ecx+92]
	cdq
	idiv	esi
	mov	edi, eax
	mov	DWORD PTR [ecx+736], edi
	mov	ecx, DWORD PTR [ecx+84]
	mov	eax, ecx
	cdq
	idiv	esi
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __imp___aligned_malloc
	mov	DWORD PTR [edx+752], eax
	mov	eax, ecx
	cdq
	idiv	ebx
	mov	ebx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ebx+756], eax
	mov	eax, DWORD PTR [ebx+92]
	mov	DWORD PTR [ebx+744], eax
	imul	eax, DWORD PTR tv1464[ebp]
	mov	DWORD PTR [ebx+748], edi
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+648], eax

; 86   :   VXFullUVB = (short*)_aligned_malloc(2 * nHeightUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+740]
	imul	eax, DWORD PTR [ebx+748]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+652], eax

; 87   :   VYFullYB = (short*)_aligned_malloc(2 * nHeight*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+744]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+656], eax

; 88   :   VYFullUVB = (short*)_aligned_malloc(2 * nHeightUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+740]
	imul	eax, DWORD PTR [ebx+748]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+660], eax

; 89   : 
; 90   :   VXFullYF = (short*)_aligned_malloc(2 * nHeight*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+744]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+664], eax

; 91   :   VXFullUVF = (short*)_aligned_malloc(2 * nHeightUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+740]
	imul	eax, DWORD PTR [ebx+748]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+668], eax

; 92   :   VYFullYF = (short*)_aligned_malloc(2 * nHeight*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+744]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+672], eax

; 93   :   VYFullUVF = (short*)_aligned_malloc(2 * nHeightUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+740]
	imul	eax, DWORD PTR [ebx+748]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+676], eax
	add	esp, 64					; 00000040H

; 94   : 
; 95   :   VXSmallYB = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+680], eax

; 96   :   VYSmallYB = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+688], eax

; 97   :   VXSmallUVB = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+684], eax

; 98   :   VYSmallUVB = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+692], eax

; 99   : 
; 100  :   VXSmallYF = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+696], eax

; 101  :   VYSmallYF = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+704], eax

; 102  :   VXSmallUVF = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+700], eax

; 103  :   VYSmallUVF = (short*)_aligned_malloc(2 * nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+708], eax
	add	esp, 64					; 00000040H

; 104  : 
; 105  :   MaskSmallB = (unsigned char*)_aligned_malloc(nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+712], eax

; 106  :   MaskFullYB = (unsigned char*)_aligned_malloc(nHeight*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+744]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+716], eax

; 107  :   MaskFullUVB = (unsigned char*)_aligned_malloc(nHeightUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+740]
	imul	eax, DWORD PTR [ebx+748]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+720], eax

; 108  : 
; 109  :   MaskSmallF = (unsigned char*)_aligned_malloc(nBlkX*nBlkY + 128, 128);

	mov	eax, DWORD PTR [ebx+64]
	imul	eax, DWORD PTR [ebx+68]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+724], eax

; 110  :   MaskFullYF = (unsigned char*)_aligned_malloc(nHeight*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+744]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+728], eax

; 111  :   MaskFullUVF = (unsigned char*)_aligned_malloc(nHeightUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+740]
	imul	eax, DWORD PTR [ebx+748]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi

; 112  : 
; 113  :   int CPUF_Resize = env->GetCPUFlags();

	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 48					; 00000030H
	mov	DWORD PTR [ebx+732], eax
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+4]
	mov	esi, eax

; 114  :   if (!isse) CPUF_Resize = (CPUF_Resize & !CPUF_INTEGER_SSE) & !CPUF_SSE2;

	xor	eax, eax
	cmp	BYTE PTR [ebx+644], al

; 115  : 
; 116  :   upsizer = new SimpleResize(nWidth, nHeight, nBlkX, nBlkY, CPUF_Resize);

	push	40					; 00000028H
	cmove	esi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+68]
	push	DWORD PTR [ebx+64]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize

; 117  :   upsizerUV = new SimpleResize(nWidthUV, nHeightUV, nBlkX, nBlkY, CPUF_Resize);

	push	40					; 00000028H
	mov	DWORD PTR [ebx+760], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+68]
	push	DWORD PTR [ebx+64]
	push	DWORD PTR [ebx+740]
	push	DWORD PTR [ebx+736]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize
	mov	DWORD PTR [ebx+764], eax

; 118  : 
; 119  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN9@MVFlowBlur
	cmp	BYTE PTR [ebx+645], 0
	jne	SHORT $LN9@MVFlowBlur

; 120  :   {
; 121  :     DstPlanes = new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes
	mov	DWORD PTR [ebx+768], eax
$LN9@MVFlowBlur:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN104@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN104@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN104@MVFlowBlur:
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	eax, eax
	je	SHORT $LN109@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN109@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN109@MVFlowBlur:
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	eax, eax
	je	SHORT $LN114@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN114@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mvbw$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN114@MVFlowBlur:
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN122@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN122@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	call	eax
$LN122@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 123  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR __mvfw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR __mvbw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 640				; 00000280H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$9:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$12:
	push	OFFSET ??1AVSValue@@QAE@XZ		; AVSValue::~AVSValue
	push	1
	push	8
	lea	eax, DWORD PTR _cache_args$3[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$14:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$15:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$19:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$20:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$21:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$22:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z ENDP ; MVFlowBlur::MVFlowBlur
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0AVSValue@@QAE@ABVPClip@@@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
??0AVSValue@@QAE@ABVPClip@@@Z PROC			; AVSValue::AVSValue, COMDAT
; _this$ = ecx

; 1000 :   AVSValue(const PClip& c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR2)(c) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@AVSValue
	cmp	DWORD PTR [eax], 284			; 0000011cH
	jbe	SHORT $LN5@AVSValue
	push	DWORD PTR _c$[esp]
	mov	eax, DWORD PTR [eax+284]
	call	eax
$LN5@AVSValue:
	mov	eax, esi
	pop	esi
	ret	4
??0AVSValue@@QAE@ABVPClip@@@Z ENDP			; AVSValue::AVSValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0AVSValue@@QAE@PBV0@H@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_size$dead$ = 12					; size = 4
??0AVSValue@@QAE@PBV0@H@Z PROC				; AVSValue::AVSValue, COMDAT
; _this$ = ecx

; 1007 :   AVSValue(const AVSValue* a, int size) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR8)(a, size) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@AVSValue
	cmp	DWORD PTR [eax], 308			; 00000134H
	jbe	SHORT $LN5@AVSValue
	mov	eax, DWORD PTR [eax+308]
	push	1
	push	DWORD PTR _a$[esp+4]
	call	eax
$LN5@AVSValue:
	mov	eax, esi
	pop	esi
	ret	8
??0AVSValue@@QAE@PBV0@H@Z ENDP				; AVSValue::AVSValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowblur.h
;	COMDAT ?SetCacheHints@MVFlowBlur@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVFlowBlur@@UAGHHH@Z PROC		; MVFlowBlur::SetCacheHints, COMDAT

; 75   :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 76   :   }

	ret	12					; 0000000cH
?SetCacheHints@MVFlowBlur@@UAGHHH@Z ENDP		; MVFlowBlur::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVFlowBlur@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVFlowBlur@@UAEPAXI@Z PROC				; MVFlowBlur::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVFlowBlur@@UAE@XZ			; MVFlowBlur::~MVFlowBlur
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	776					; 00000308H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVFlowBlur@@UAEPAXI@Z ENDP				; MVFlowBlur::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
;	COMDAT ??1MVFlowBlur@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVFlowBlur@@UAE@XZ PROC				; MVFlowBlur::~MVFlowBlur, COMDAT
; _this$ = ecx

; 126  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVFlowBlur@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 127  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	edi, DWORD PTR __imp___aligned_free
	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [esi], OFFSET ??_7MVFlowBlur@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN11@MVFlowBlur
	cmp	BYTE PTR [esi+645], 0
	jne	SHORT $LN11@MVFlowBlur

; 128  :   {
; 129  :     delete DstPlanes;

	mov	ebx, DWORD PTR [esi+768]
	test	ebx, ebx
	je	SHORT $LN11@MVFlowBlur
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN11@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 132  :   delete upsizer;

	mov	ebx, DWORD PTR [esi+760]
	test	ebx, ebx
	je	SHORT $LN18@MVFlowBlur
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN18@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 133  :   delete upsizerUV;

	mov	ebx, DWORD PTR [esi+764]
	test	ebx, ebx
	je	SHORT $LN25@MVFlowBlur
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN25@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 135  :   _aligned_free(VXFullYB);

	push	DWORD PTR [esi+648]
	call	edi

; 136  :   _aligned_free(VXFullUVB);

	push	DWORD PTR [esi+652]
	call	edi

; 137  :   _aligned_free(VYFullYB);

	push	DWORD PTR [esi+656]
	call	edi

; 138  :   _aligned_free(VYFullUVB);

	push	DWORD PTR [esi+660]
	call	edi

; 139  :   _aligned_free(VXSmallYB);

	push	DWORD PTR [esi+680]
	call	edi

; 140  :   _aligned_free(VYSmallYB);

	push	DWORD PTR [esi+688]
	call	edi

; 141  :   _aligned_free(VXSmallUVB);

	push	DWORD PTR [esi+684]
	call	edi

; 142  :   _aligned_free(VYSmallUVB);

	push	DWORD PTR [esi+692]
	call	edi

; 143  :   _aligned_free(VXFullYF);

	push	DWORD PTR [esi+664]
	call	edi

; 144  :   _aligned_free(VXFullUVF);

	push	DWORD PTR [esi+668]
	call	edi

; 145  :   _aligned_free(VYFullYF);

	push	DWORD PTR [esi+672]
	call	edi

; 146  :   _aligned_free(VYFullUVF);

	push	DWORD PTR [esi+676]
	call	edi

; 147  :   _aligned_free(VXSmallYF);

	push	DWORD PTR [esi+696]
	call	edi

; 148  :   _aligned_free(VYSmallYF);

	push	DWORD PTR [esi+704]
	call	edi

; 149  :   _aligned_free(VXSmallUVF);

	push	DWORD PTR [esi+700]
	call	edi

; 150  :   _aligned_free(VYSmallUVF);

	push	DWORD PTR [esi+708]
	call	edi
	add	esp, 64					; 00000040H

; 151  :   _aligned_free(MaskSmallB);

	push	DWORD PTR [esi+712]
	call	edi

; 152  :   _aligned_free(MaskFullYB);

	push	DWORD PTR [esi+716]
	call	edi

; 153  :   _aligned_free(MaskFullUVB);

	push	DWORD PTR [esi+720]
	call	edi

; 154  :   _aligned_free(MaskSmallF);

	push	DWORD PTR [esi+724]
	call	edi

; 155  :   _aligned_free(MaskFullYF);

	push	DWORD PTR [esi+728]
	call	edi

; 156  :   _aligned_free(MaskFullUVF);

	push	DWORD PTR [esi+732]
	call	edi
	add	esp, 24					; 00000018H
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN33@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN33@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 159  : }

	lea	ecx, DWORD PTR [esi+640]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
$LN33@MVFlowBlur:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+456]
	mov	DWORD PTR [esi+392], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN44@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN44@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+400]
	call	eax
$LN44@MVFlowBlur:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+392], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN58@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN58@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN58@MVFlowBlur:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN75@MVFlowBlur
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN75@MVFlowBlur
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN75@MVFlowBlur:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 159  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvflowblur.cpp

; 159  : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVFlowBlur@@UAE@XZ$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowBlur@@UAE@XZ$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowBlur@@UAE@XZ$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowBlur@@UAE@XZ$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVFlowBlur@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVFlowBlur@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVFlowBlur@@UAE@XZ ENDP				; MVFlowBlur::~MVFlowBlur
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowblur.cpp
;	COMDAT ?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -80						; size = 4
_mvF$ = -76						; size = 4
_mvB$ = -72						; size = 4
_pDstYUY2$1$ = -68					; size = 4
_nDstPitchYUY2$1$ = -64					; size = 4
$T3 = -64						; size = 4
_pRef$3$ = -60						; size = 4
_nRefPitches$3$ = -56					; size = 4
_pRef$2$ = -52						; size = 4
_nDstPitches$3$ = -48					; size = 4
_nRefPitches$2$ = -44					; size = 4
_pDst$3$ = -40						; size = 4
_nDstPitches$2$ = -36					; size = 4
_nOffsetUV$1$ = -32					; size = 4
_nOffsetY$1$ = -28					; size = 4
_pRef$1$ = -24						; size = 4
_nRefPitches$1$ = -20					; size = 4
_dst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pDst$1$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_nDstPitchYUY2$ = 16					; size = 4
_pDstYUY2$ = 16						; size = 4
_ref$4 = 16						; size = 4
_n$ = 16						; size = 4
_nDstPitches$1$ = 20					; size = 4
_env$ = 20						; size = 4
?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVFlowBlur::GetFrame, COMDAT

; 328  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR $T2[ebp], 0
	test	eax, eax
	je	SHORT $LN23@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN23@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
$LN23@GetFrame:
	push	ebx
	push	esi
	push	edi
; File c:\github\mvtools\sources\mvflowblur.cpp

; 329  :   PVideoFrame dst;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	edi, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 337  :   if (off <= 0)

	mov	esi, DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	ebx, DWORD PTR [edi+292]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 337  :   if (off <= 0)

	test	ebx, ebx
	jg	SHORT $LN2@GetFrame

; 338  :   {
; 339  :     env->ThrowError("MFlowBlur: cannot use motion vectors with absolute frame references.");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0EF@OKILMPEN@MFlowBlur?3?5cannot?5use?5motion?5vec@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@GetFrame:
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [edi+296]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 341  :   if (!mvClipB.IsBackward())

	test	al, al
	jne	SHORT $LN3@GetFrame

; 342  :     off = -off;

	neg	ebx
$LN3@GetFrame:

; 343  : 
; 344  :   PVideoFrame mvF = mvClipF.GetFrame(n + off, env);

	mov	eax, DWORD PTR _n$[ebp]
	lea	edx, DWORD PTR [edi+392]
	mov	ecx, DWORD PTR [edx]
	add	eax, ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR _mvF$[ebp]
	push	eax
	push	edx
	call	DWORD PTR [ecx+4]

; 345  :   mvClipF.Update(mvF, env);// forward from current to next

	push	esi
	lea	eax, DWORD PTR _mvF$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	lea	ecx, DWORD PTR [edi+392]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN31@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN31@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvF$[ebp]
	push	0
	call	eax
$LN31@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 348  :   PVideoFrame mvB = mvClipB.GetFrame(n - off, env);

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edi+152]
	sub	eax, ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR _mvB$[ebp]
	push	eax
	lea	ebx, DWORD PTR [edi+152]
	push	ebx
	call	DWORD PTR [ecx+4]

; 349  :   mvClipB.Update(mvB, env);// backward from current to prev

	push	esi
	lea	eax, DWORD PTR _mvB$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	eax
	mov	ecx, ebx
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN35@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN35@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvB$[ebp]
	push	0
	call	eax
$LN35@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [ebx+220]
	mov	ecx, DWORD PTR [ebx+88]
	push	DWORD PTR [ebx+216]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN4@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ebx+68]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN4@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [edi+612]
	mov	ecx, DWORD PTR [edi+480]
	push	DWORD PTR [edi+608]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN4@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [edi+460]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN4@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+640]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 354  :     PVideoFrame ref = finest->GetFrame(n, env);//  ref for  compensation

	lea	edx, DWORD PTR _ref$4[ebp]
	push	esi
	push	DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]

; 355  :     dst = env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [edi+16]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR [esi]
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	push	esi
	call	DWORD PTR [ecx+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN61@GetFrame
	cmp	DWORD PTR [esi], 268			; 0000010cH
	jbe	SHORT $LN61@GetFrame
	push	eax
	mov	eax, DWORD PTR [esi+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN61@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	esi, esi
	je	SHORT $LN65@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN65@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR $T3[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN65@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\mvflowblur.cpp

; 357  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN6@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN72@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN72@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$1$[ebp], eax
	jmp	SHORT $LN73@GetFrame
$LN72@GetFrame:
	mov	DWORD PTR _pRef$1$[ebp], 0
$LN73@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN78@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN78@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN79@GetFrame
$LN78@GetFrame:
	xor	eax, eax
$LN79@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 361  :       pRef[1] = pRef[0] + ref->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	add	ebx, DWORD PTR _pRef$1$[ebp]
	mov	DWORD PTR _pRef$2$[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN84@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN84@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN85@GetFrame
$LN84@GetFrame:
	xor	eax, eax
$LN85@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 362  :       pRef[2] = pRef[1] + ref->GetRowSize() / 4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, ebx
	mov	DWORD PTR _pRef$3$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN90@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN90@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN256@GetFrame
$LN90@GetFrame:
	xor	eax, eax
$LN256@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 367  :       if (!planar)

	cmp	BYTE PTR [edi+645], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	mov	DWORD PTR _nRefPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvflowblur.cpp

; 364  :       nRefPitches[1] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$2$[ebp], eax

; 365  :       nRefPitches[2] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$3$[ebp], eax

; 367  :       if (!planar)

	jne	SHORT $LN8@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN96@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN96@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	jmp	SHORT $LN97@GetFrame
$LN96@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN97@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN102@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN102@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
	jmp	SHORT $LN103@GetFrame
$LN102@GetFrame:
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], 0
$LN103@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [edi+768]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 371  :         pDst[0] = DstPlanes->GetPtr();

	mov	ecx, DWORD PTR [eax]

; 372  :         pDst[1] = DstPlanes->GetPtrU();

	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR _pDst$1$[ebp], ecx

; 373  :         pDst[2] = DstPlanes->GetPtrV();

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pDst$3$[ebp], ecx

; 374  :         nDstPitches[0] = DstPlanes->GetPitch();

	mov	ecx, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 374  :         nDstPitches[0] = DstPlanes->GetPitch();

	mov	DWORD PTR _nDstPitches$1$[ebp], ecx
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	DWORD PTR _nDstPitches$2$[ebp], eax
; File c:\github\mvtools\sources\mvflowblur.cpp

; 376  :         nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 377  :       }
; 378  :       else

	jmp	$LN7@GetFrame
$LN8@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN120@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN120@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN121@GetFrame
$LN120@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN121@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN126@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN126@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN127@GetFrame
$LN126@GetFrame:
	xor	eax, eax
$LN127@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 381  :         pDst[1] = pDst[0] + dst->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	add	ebx, DWORD PTR _pDst$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN132@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN132@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN133@GetFrame
$LN132@GetFrame:
	xor	eax, eax
$LN133@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 382  :         pDst[2] = pDst[1] + dst->GetRowSize() / 4;;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, ebx
	mov	DWORD PTR _pDst$3$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN138@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN138@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvflowblur.cpp

; 384  :         nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$2$[ebp], eax

; 385  :         nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 386  :       }
; 387  :     }
; 388  :     else

	jmp	$LN211@GetFrame
$LN138@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	xor	eax, eax
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvflowblur.cpp

; 384  :         nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$2$[ebp], eax

; 385  :         nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 386  :       }
; 387  :     }
; 388  :     else

	jmp	$LN211@GetFrame
$LN6@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN144@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN144@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN145@GetFrame
$LN144@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN145@GetFrame:
	test	esi, esi
	je	SHORT $LN150@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN150@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ebx, eax
	jmp	SHORT $LN151@GetFrame
$LN150@GetFrame:
	xor	ebx, ebx
$LN151@GetFrame:
	test	esi, esi
	je	SHORT $LN156@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN156@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$3$[ebp], eax
	jmp	SHORT $LN157@GetFrame
$LN156@GetFrame:
	mov	DWORD PTR _pDst$3$[ebp], 0
$LN157@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN162@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN162@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
	jmp	SHORT $LN163@GetFrame
$LN162@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], 0
$LN163@GetFrame:
	test	esi, esi
	je	SHORT $LN168@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN168@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	jmp	SHORT $LN169@GetFrame
$LN168@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN169@GetFrame:
	test	esi, esi
	je	SHORT $LN174@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN174@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	jmp	SHORT $LN175@GetFrame
$LN174@GetFrame:
	mov	DWORD PTR _nDstPitches$3$[ebp], 0
$LN175@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN180@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN180@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$1$[ebp], eax
	jmp	SHORT $LN181@GetFrame
$LN180@GetFrame:
	mov	DWORD PTR _pRef$1$[ebp], 0
$LN181@GetFrame:
	test	esi, esi
	je	SHORT $LN186@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN186@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$2$[ebp], eax
	jmp	SHORT $LN187@GetFrame
$LN186@GetFrame:
	mov	DWORD PTR _pRef$2$[ebp], 0
$LN187@GetFrame:
	test	esi, esi
	je	SHORT $LN192@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN192@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$3$[ebp], eax
	jmp	SHORT $LN193@GetFrame
$LN192@GetFrame:
	mov	DWORD PTR _pRef$3$[ebp], 0
$LN193@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN198@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN198@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$1$[ebp], eax
	jmp	SHORT $LN199@GetFrame
$LN198@GetFrame:
	mov	DWORD PTR _nRefPitches$1$[ebp], 0
$LN199@GetFrame:
	test	esi, esi
	je	SHORT $LN204@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN204@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$2$[ebp], eax
	jmp	SHORT $LN205@GetFrame
$LN204@GetFrame:
	mov	DWORD PTR _nRefPitches$2$[ebp], 0
$LN205@GetFrame:
	test	esi, esi
	je	SHORT $LN210@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN210@GetFrame
	mov	ecx, DWORD PTR _ref$4[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$3$[ebp], eax
	jmp	SHORT $LN211@GetFrame
$LN210@GetFrame:
	mov	DWORD PTR _nRefPitches$3$[ebp], 0
$LN211@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 402  :       nRefPitches[2] = VPITCH(ref);

	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN7@GetFrame:

; 403  :     }
; 404  : 
; 405  :     int nOffsetY = nRefPitches[0] * nVPadding*nPel + nHPadding*nPel*pixelsize;

	mov	eax, DWORD PTR [edi+88]
	imul	eax, DWORD PTR _nRefPitches$1$[ebp]
	mov	ecx, DWORD PTR [edi+136]

; 406  :     int nOffsetUV = nRefPitches[1] * nVPaddingUV*nPel + nHPaddingUV*nPel*pixelsize;
; 407  : 
; 408  : 
; 409  :     // make  vector vx and vy small masks
; 410  :     MakeVectorSmallMasks(mvClipB, nBlkX, nBlkY, VXSmallYB, nBlkX, VYSmallYB, nBlkX);

	mov	edx, DWORD PTR [edi+64]
	push	edx
	push	DWORD PTR [edi+688]
	mov	DWORD PTR _nOffsetY$1$[ebp], eax
	mov	eax, DWORD PTR [edi+84]
	imul	eax, ecx
	push	edx
	push	DWORD PTR [edi+680]
	push	DWORD PTR [edi+68]
	add	DWORD PTR _nOffsetY$1$[ebp], eax
	mov	eax, DWORD PTR _nOffsetY$1$[ebp]
	imul	eax, DWORD PTR [edi+104]
	mov	DWORD PTR _nOffsetY$1$[ebp], eax
	mov	eax, DWORD PTR [edi+756]
	imul	eax, DWORD PTR _nRefPitches$2$[ebp]
	mov	DWORD PTR _nOffsetUV$1$[ebp], eax
	mov	eax, DWORD PTR [edi+752]
	imul	eax, ecx
	mov	ecx, DWORD PTR _nOffsetUV$1$[ebp]
	add	ecx, eax
	imul	ecx, DWORD PTR [edi+104]
	mov	DWORD PTR _nOffsetUV$1$[ebp], ecx
	lea	ecx, DWORD PTR [edi+152]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 411  :     VectorSmallMaskYToHalfUV(VXSmallYB, nBlkX, nBlkY, VXSmallUVB, xRatioUV);

	push	DWORD PTR [edi+120]
	mov	edx, DWORD PTR [edi+64]
	push	DWORD PTR [edi+684]
	mov	ecx, DWORD PTR [edi+680]
	push	DWORD PTR [edi+68]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 412  :     VectorSmallMaskYToHalfUV(VYSmallYB, nBlkX, nBlkY, VYSmallUVB, yRatioUV);

	push	DWORD PTR [edi+124]
	mov	edx, DWORD PTR [edi+64]
	push	DWORD PTR [edi+692]
	mov	ecx, DWORD PTR [edi+688]
	push	DWORD PTR [edi+68]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 413  : 
; 414  :     MakeVectorSmallMasks(mvClipF, nBlkX, nBlkY, VXSmallYF, nBlkX, VYSmallYF, nBlkX);

	mov	edx, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR [edi+392]
	push	edx
	push	DWORD PTR [edi+704]
	push	edx
	push	DWORD PTR [edi+696]
	push	DWORD PTR [edi+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 415  :     VectorSmallMaskYToHalfUV(VXSmallYF, nBlkX, nBlkY, VXSmallUVF, xRatioUV);

	mov	edx, DWORD PTR [edi+64]
	add	esp, 64					; 00000040H
	mov	ecx, DWORD PTR [edi+696]
	push	DWORD PTR [edi+120]
	push	DWORD PTR [edi+700]
	push	DWORD PTR [edi+68]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 416  :     VectorSmallMaskYToHalfUV(VYSmallYF, nBlkX, nBlkY, VYSmallUVF, yRatioUV);

	push	DWORD PTR [edi+124]
	mov	edx, DWORD PTR [edi+64]
	push	DWORD PTR [edi+708]
	mov	ecx, DWORD PTR [edi+704]
	push	DWORD PTR [edi+68]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 417  : 
; 418  :       // analyse vectors field to detect occlusion
; 419  : 
; 420  :       // upsize (bilinear interpolate) vector masks to fullframe size
; 421  : 
; 422  : 
; 423  :     int dummyplane = PLANAR_Y; // use luma plane resizer code for all planes if we resize from luma small mask
; 424  :     upsizer->SimpleResizeDo_uint16(VXFullYB, nWidth, nHeight, VPitchY, VXSmallYB, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [edi+760]
	push	eax
	push	eax
	push	DWORD PTR [edi+680]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	push	DWORD PTR [edi+648]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 425  :     upsizer->SimpleResizeDo_uint16(VYFullYB, nWidth, nHeight, VPitchY, VYSmallYB, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [edi+760]
	push	eax
	push	eax
	push	DWORD PTR [edi+688]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	push	DWORD PTR [edi+656]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 426  :     upsizerUV->SimpleResizeDo_uint16(VXFullUVB, nWidthUV, nHeightUV, VPitchUV, VXSmallUVB, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [edi+764]
	push	eax
	push	eax
	push	DWORD PTR [edi+684]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+652]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 427  :     upsizerUV->SimpleResizeDo_uint16(VYFullUVB, nWidthUV, nHeightUV, VPitchUV, VYSmallUVB, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [edi+764]
	push	eax
	push	eax
	push	DWORD PTR [edi+692]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+660]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 428  : 
; 429  :     upsizer->SimpleResizeDo_uint16(VXFullYF, nWidth, nHeight, VPitchY, VXSmallYF, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [edi+760]
	push	eax
	push	eax
	push	DWORD PTR [edi+696]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	push	DWORD PTR [edi+664]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 430  :     upsizer->SimpleResizeDo_uint16(VYFullYF, nWidth, nHeight, VPitchY, VYSmallYF, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [edi+760]
	push	eax
	push	eax
	push	DWORD PTR [edi+704]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	push	DWORD PTR [edi+672]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 431  :     upsizerUV->SimpleResizeDo_uint16(VXFullUVF, nWidthUV, nHeightUV, VPitchUV, VXSmallUVF, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [edi+764]
	push	eax
	push	eax
	push	DWORD PTR [edi+700]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+668]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 432  :     upsizerUV->SimpleResizeDo_uint16(VYFullUVF, nWidthUV, nHeightUV, VPitchUV, VYSmallUVF, nBlkX, nBlkX);

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR [edi+764]
	push	eax
	push	eax
	push	DWORD PTR [edi+708]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+676]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 433  : 
; 434  : 
; 435  :     if (pixelsize == 1) {
; 436  :       FlowBlur<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0],

	push	DWORD PTR [edi+636]
	mov	eax, DWORD PTR _pRef$1$[ebp]
	mov	ecx, edi
	push	DWORD PTR [edi+632]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	cmp	DWORD PTR [edi+136], 1
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+672]
	push	DWORD PTR [edi+656]
	push	DWORD PTR [edi+664]
	push	DWORD PTR [edi+648]
	push	DWORD PTR _nRefPitches$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDst$1$[ebp]
	jne	$LN10@GetFrame
	call	??$FlowBlur@E@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned char>

; 437  :         VXFullYB, VXFullYF, VYFullYB, VYFullYF, VPitchY,
; 438  :         nWidth, nHeight, blur256, prec);
; 439  :       FlowBlur<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [edi+636]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	mov	ecx, edi
	push	DWORD PTR [edi+632]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+676]
	push	DWORD PTR [edi+660]
	push	DWORD PTR [edi+668]
	push	DWORD PTR [edi+652]
	push	DWORD PTR _nRefPitches$2$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	ebx
	call	??$FlowBlur@E@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned char>

; 440  :         VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, VPitchUV,
; 441  :         nWidthUV, nHeightUV, blur256, prec);
; 442  :       FlowBlur<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2],

	push	DWORD PTR [edi+636]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	mov	ecx, edi
	push	DWORD PTR [edi+632]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+676]
	push	DWORD PTR [edi+660]
	push	DWORD PTR [edi+668]
	push	DWORD PTR [edi+652]
	push	DWORD PTR _nRefPitches$3$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	call	??$FlowBlur@E@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned char>

; 443  :         VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, VPitchUV,
; 444  :         nWidthUV, nHeightUV, blur256, prec);
; 445  :     }
; 446  :     else { // pixelsize == 2

	jmp	$LN11@GetFrame
$LN10@GetFrame:

; 447  :       FlowBlur<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, nRefPitches[0],

	call	??$FlowBlur@G@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned short>

; 448  :         VXFullYB, VXFullYF, VYFullYB, VYFullYF, VPitchY,
; 449  :         nWidth, nHeight, blur256, prec);
; 450  :       FlowBlur<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [edi+636]
	mov	eax, DWORD PTR _pRef$2$[ebp]
	mov	ecx, edi
	push	DWORD PTR [edi+632]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+676]
	push	DWORD PTR [edi+660]
	push	DWORD PTR [edi+668]
	push	DWORD PTR [edi+652]
	push	DWORD PTR _nRefPitches$2$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	ebx
	call	??$FlowBlur@G@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned short>

; 451  :         VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, VPitchUV,
; 452  :         nWidthUV, nHeightUV, blur256, prec);
; 453  :       FlowBlur<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, nRefPitches[2],

	push	DWORD PTR [edi+636]
	mov	eax, DWORD PTR _pRef$3$[ebp]
	mov	ecx, edi
	push	DWORD PTR [edi+632]
	add	eax, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+676]
	push	DWORD PTR [edi+660]
	push	DWORD PTR [edi+668]
	push	DWORD PTR [edi+652]
	push	DWORD PTR _nRefPitches$3$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	call	??$FlowBlur@G@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ; MVFlowBlur::FlowBlur<unsigned short>
$LN11@GetFrame:

; 454  :         VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, VPitchUV,
; 455  :         nWidthUV, nHeightUV, blur256, prec);
; 456  :     }
; 457  : 
; 458  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN12@GetFrame
	cmp	BYTE PTR [edi+645], 0
	jne	SHORT $LN12@GetFrame

; 459  :     {
; 460  :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	movzx	eax, BYTE PTR [edi+644]
	mov	edx, DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	ecx, DWORD PTR _pDstYUY2$1$[ebp]
	push	eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	push	ebx
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDst$1$[ebp]
	push	DWORD PTR [edi+96]
	push	DWORD PTR [edi+92]
	call	?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z	; YUY2FromPlanes
	add	esp, 32					; 00000020H
$LN12@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	test	esi, esi
	je	SHORT $LN214@GetFrame
	cmp	DWORD PTR [esi], 256			; 00000100H
	jbe	SHORT $LN214@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN214@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	esi, esi
	je	SHORT $LN218@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN218@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _ref$4[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN218@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	test	esi, esi
	je	SHORT $LN223@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN223@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN223@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	test	esi, esi
	je	SHORT $LN228@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN228@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN228@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	test	esi, esi
	je	SHORT $LN233@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN233@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN233@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 463  :     return dst;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 470  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN4@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mvflowblur.cpp

; 467  :     return child->GetFrame(n, env);

	push	esi
	push	DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	eax
	call	DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN240@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN240@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN240@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	edx, edx
	je	SHORT $LN245@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN245@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN245@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	edx, edx
	je	SHORT $LN250@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN250@GetFrame
	mov	edx, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN250@GetFrame:
; File c:\github\mvtools\sources\mvflowblur.cpp

; 470  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _dst$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _mvF$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _mvB$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR _ref$4[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVFlowBlur@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVFlowBlur::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
;	COMDAT ??$FlowBlur@E@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z
_TEXT	SEGMENT
_vyB0$2$ = -52						; size = 4
_i$1$ = -52						; size = 4
_VYFullB$2$ = -52					; size = 4
_w$1$ = -48						; size = 4
_vyB0$1$ = -48						; size = 4
_height$2$ = -48					; size = 4
tv1811 = -48						; size = 4
_VXFullF$1$ = -44					; size = 4
_VYFullB$1$ = -44					; size = 4
tv1813 = -44						; size = 4
_vyB0$2$ = -40						; size = 4
_i$1$ = -40						; size = 4
_w$1$ = -40						; size = 4
_VYFullF$1$ = -40					; size = 4
_vxB0$2$ = -36						; size = 4
_vxB0$1$ = -36						; size = 4
_vyF0$2$ = -36						; size = 4
_vyB0$2$ = -36						; size = 4
_i$1$ = -36						; size = 4
_height$1$ = -36					; size = 4
_VYFullF$2$ = -32					; size = 4
tv1801 = -32						; size = 4
tv1778 = -32						; size = 4
_height$3$ = -28					; size = 4
tv1781 = -28						; size = 4
tv1775 = -28						; size = 4
_i$1$ = -24						; size = 4
_vyB0$1$ = -24						; size = 4
tv1800 = -24						; size = 4
tv1785 = -24						; size = 4
tv1783 = -20						; size = 4
tv1779 = -20						; size = 4
tv1777 = -20						; size = 4
tv1784 = -16						; size = 4
tv1776 = -16						; size = 4
tv1773 = -16						; size = 4
_i$1$ = -12						; size = 4
_vyB0$1$ = -12						; size = 4
_vyF0$1$ = -12						; size = 4
_i$1$ = -12						; size = 4
tv1771 = -12						; size = 4
tv1782 = -8						; size = 4
tv1774 = -8						; size = 4
tv1768 = -8						; size = 4
tv1802 = -4						; size = 4
tv1772 = -4						; size = 4
tv1769 = -4						; size = 4
_pdst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_vxB0$2$ = 16						; size = 4
_vxB0$1$ = 16						; size = 4
_vyF0$2$ = 16						; size = 4
_vyF0$1$ = 16						; size = 4
_vxB0$2$ = 16						; size = 4
_vxB0$1$ = 16						; size = 4
_vyF0$2$ = 16						; size = 4
_vyF0$1$ = 16						; size = 4
_VXFullB$1$ = 16					; size = 4
_pref8$ = 16						; size = 4
_ref_pitch$ = 20					; size = 4
$T1 = 24						; size = 4
_vxF0$2$ = 24						; size = 4
_vxF0$1$ = 24						; size = 4
tv1786 = 24						; size = 4
tv1770 = 24						; size = 4
_VXFullB$ = 24						; size = 4
$T2 = 28						; size = 4
$T3 = 28						; size = 4
_mB$1$ = 28						; size = 4
_mB$1$ = 28						; size = 4
_VXFullF$2$ = 28					; size = 4
_VXFullF$ = 28						; size = 4
$T4 = 32						; size = 4
$T5 = 32						; size = 4
$T6 = 32						; size = 4
$T7 = 32						; size = 4
$T8 = 32						; size = 4
$T9 = 32						; size = 4
_VYFullB$ = 32						; size = 4
$T10 = 36						; size = 4
$T11 = 36						; size = 4
$T12 = 36						; size = 4
_vxF0$2$ = 36						; size = 4
_vxF0$1$ = 36						; size = 4
_mB$1$ = 36						; size = 4
_vxF0$2$ = 36						; size = 4
_vxF0$1$ = 36						; size = 4
_VYFullF$ = 36						; size = 4
_mF$1$ = 40						; size = 4
_mF$1$ = 40						; size = 4
_mF$1$ = 40						; size = 4
_VPitch$ = 40						; size = 4
_width$ = 44						; size = 4
_bluredsum$1$ = 48					; size = 4
_bluredsum$1$ = 48					; size = 4
_bluredsum$1$ = 48					; size = 4
_height$ = 48						; size = 4
_blur256$ = 52						; size = 4
_prec$ = 56						; size = 4
??$FlowBlur@E@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z PROC ; MVFlowBlur::FlowBlur<unsigned char>, COMDAT
; _this$ = ecx

; 166  :   dst_pitch /= sizeof(pixel_t);
; 167  :   ref_pitch /= sizeof(pixel_t);
; 168  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 169  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 170  : 
; 171  :   // very slow, but precise motion blur
; 172  :   if (nPel == 1)

	mov	eax, DWORD PTR [ecx+104]
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pref8$[esp+60]
	push	edi
	cmp	eax, 1
	jne	$LN38@FlowBlur

; 173  :   {
; 174  :     for (int h = 0; h < height; h++)

	mov	ecx, DWORD PTR _height$[esp+64]
	mov	DWORD PTR _height$1$[esp+68], ecx
	test	ecx, ecx
	jle	$LN27@FlowBlur
	mov	eax, DWORD PTR _VPitch$[esp+64]
	mov	edi, DWORD PTR _VXFullF$[esp+64]
	add	eax, eax
	mov	edx, DWORD PTR _VYFullF$[esp+64]
	mov	ebp, DWORD PTR _ref_pitch$[esp+64]
	mov	DWORD PTR tv1802[esp+68], eax
	mov	eax, DWORD PTR _VXFullB$[esp+64]
	sub	eax, edi
	mov	DWORD PTR _VXFullF$1$[esp+68], edi
	mov	DWORD PTR tv1781[esp+68], eax
	mov	eax, DWORD PTR _VYFullB$[esp+64]
	sub	eax, edi
	mov	DWORD PTR _VYFullF$1$[esp+68], edx
	mov	DWORD PTR tv1778[esp+68], eax
	mov	eax, DWORD PTR _width$[esp+64]
	npad	3
$LL4@FlowBlur:

; 175  :     {
; 176  :       for (int w = 0; w < width; w++)

	xor	ebx, ebx
	test	eax, eax
	jle	$LN6@FlowBlur
	mov	eax, edi
	mov	DWORD PTR tv1786[esp+64], edx
	sub	eax, edx
	mov	ecx, edx
	mov	DWORD PTR tv1785[esp+68], eax
	mov	eax, DWORD PTR tv1781[esp+68]
	sub	eax, edx
	add	eax, edi
	mov	DWORD PTR tv1779[esp+68], eax
	mov	eax, DWORD PTR tv1778[esp+68]
	sub	eax, edx
	mov	edx, esi
	add	eax, edi
	mov	edi, DWORD PTR _pdst8$[esp+64]
	sub	edx, edi
	mov	DWORD PTR tv1776[esp+68], eax
	mov	DWORD PTR tv1782[esp+68], edx
	npad	4
$LL7@FlowBlur:

; 177  :       {
; 178  :         int bluredsum = pref[w];

	lea	eax, DWORD PTR [ebx+edi]
	movzx	edi, BYTE PTR [eax+edx]

; 179  :         int vxF0 = (VXFullF[w] * blur256);

	mov	eax, DWORD PTR tv1785[esp+68]
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vxF0$1$[esp+64], eax

; 180  :         int vyF0 = (VYFullF[w] * blur256);

	movsx	eax, WORD PTR [ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyF0$1$[esp+64], eax

; 181  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 181  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	sar	eax, 8
	mov	DWORD PTR _mF$1$[esp+64], eax

; 182  :         if (mF > 0)

	test	eax, eax
	jle	$LN104@FlowBlur

; 183  :         {
; 184  :           vxF0 /= mF;

	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, ecx
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR $T3[esp+64], ecx
	mov	edi, eax
	mov	DWORD PTR $T9[esp+64], ecx

; 185  :           vyF0 /= mF;

	mov	eax, DWORD PTR _vyF0$1$[esp+64]
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _vxF0$2$[esp+64], edi
	mov	DWORD PTR _vyF0$2$[esp+64], eax

; 186  :           int vxF = vxF0;
; 187  :           int vyF = vyF0;

	mov	edx, eax

; 188  :           for (int i = 0; i < mF; i++)

	mov	eax, DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _i$1$[esp+68], ecx
	cmp	eax, 2
	jl	SHORT $LC105@FlowBlur
	lea	ebp, DWORD PTR [eax-2]
	shr	ebp, 1
	inc	ebp
	lea	eax, DWORD PTR [ebp*2]
	mov	DWORD PTR _i$1$[esp+68], eax
$LL107@FlowBlur:

; 189  :           {
; 190  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + w];

	mov	ecx, edx
	mov	eax, edi

; 192  :             vxF += vxF0;
; 193  :             vyF += vyF0;

	add	edx, DWORD PTR _vyF0$2$[esp+64]
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T3[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T9[esp+64], eax
	sub	ebp, 1
	jne	SHORT $LL107@FlowBlur
	mov	ebp, DWORD PTR _ref_pitch$[esp+64]
	mov	ecx, DWORD PTR $T3[esp+64]
	mov	eax, DWORD PTR _mF$1$[esp+64]
$LC105@FlowBlur:

; 188  :           for (int i = 0; i < mF; i++)

	cmp	DWORD PTR _i$1$[esp+68], eax
	jge	SHORT $LN143@FlowBlur

; 189  :           {
; 190  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + w];

	sar	edx, 8
	imul	edx, ebp
	sar	edi, 8
	add	edx, ebx
	add	edi, edx
	movzx	eax, BYTE PTR [edi+esi]

; 191  :             bluredsum += dstF;

	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, eax
	jmp	SHORT $LN106@FlowBlur
$LN143@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN106@FlowBlur:
	mov	eax, DWORD PTR $T9[esp+64]
	add	eax, ecx
	add	edi, eax
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
$LN104@FlowBlur:

; 194  :           }
; 195  :         }
; 196  :         int vxB0 = (VXFullB[w] * blur256);

	mov	ecx, DWORD PTR tv1786[esp+64]
	mov	eax, DWORD PTR tv1779[esp+68]
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vxB0$1$[esp+64], eax

; 197  :         int vyB0 = (VYFullB[w] * blur256);

	mov	eax, DWORD PTR tv1776[esp+68]
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyB0$1$[esp+68], eax

; 198  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _vxB0$1$[esp+64]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 198  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	sar	eax, 8
	mov	DWORD PTR _mB$1$[esp+64], eax

; 199  :         if (mB > 0)

	test	eax, eax
	jle	$LN108@FlowBlur

; 200  :         {
; 201  :           vxB0 /= mB;

	mov	eax, DWORD PTR _vxB0$1$[esp+64]
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR $T8[esp+64], 0
	mov	ecx, eax
	mov	DWORD PTR $T12[esp+64], 0

; 202  :           vyB0 /= mB;

	mov	eax, DWORD PTR _vyB0$1$[esp+68]

; 203  :           int vxB = vxB0;

	mov	edi, ecx
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR _vxB0$2$[esp+64], ecx

; 204  :           int vyB = vyB0;
; 205  :           for (int i = 0; i < mB; i++)

	xor	ecx, ecx
	mov	DWORD PTR _vyB0$2$[esp+68], eax
	mov	edx, eax
	mov	eax, DWORD PTR _mB$1$[esp+64]
	cmp	eax, 2
	jl	SHORT $LC109@FlowBlur
	add	eax, -2					; fffffffeH
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv1811[esp+68], eax
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+68], eax
$LL111@FlowBlur:

; 206  :           {
; 207  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + w];

	mov	ecx, edx
	mov	eax, edi

; 209  :             vxB += vxB0;
; 210  :             vyB += vyB0;

	add	edx, DWORD PTR _vyB0$2$[esp+68]
	add	edi, DWORD PTR _vxB0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, ebp
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyB0$2$[esp+68]
	sar	ecx, 8
	imul	ecx, ebp
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T8[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxB0$2$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T12[esp+64], eax
	sub	DWORD PTR tv1811[esp+68], 1
	jne	SHORT $LL111@FlowBlur
	mov	eax, DWORD PTR _mB$1$[esp+64]
	mov	ecx, DWORD PTR _i$1$[esp+68]
$LC109@FlowBlur:

; 204  :           int vyB = vyB0;
; 205  :           for (int i = 0; i < mB; i++)

	cmp	ecx, eax
	jge	SHORT $LN142@FlowBlur

; 206  :           {
; 207  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + w];

	sar	edx, 8
	imul	edx, ebp
	sar	edi, 8
	add	edx, ebx
	add	edi, edx
	movzx	ecx, BYTE PTR [edi+esi]

; 208  :             bluredsum += dstB;

	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, ecx
	jmp	SHORT $LN110@FlowBlur
$LN142@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN110@FlowBlur:
	mov	ecx, DWORD PTR $T8[esp+64]
	add	ecx, DWORD PTR $T12[esp+64]
	add	edi, ecx
$LN108@FlowBlur:

; 211  :           }
; 212  :         }
; 213  :         pdst[w] = bluredsum / (mF + mB + 1);

	mov	ecx, DWORD PTR _mF$1$[esp+64]
	inc	ecx
	add	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, DWORD PTR _pdst8$[esp+64]
	mov	ecx, DWORD PTR tv1786[esp+64]
	mov	edx, DWORD PTR tv1782[esp+68]
	add	ecx, 2
	mov	DWORD PTR tv1786[esp+64], ecx
	mov	BYTE PTR [ebx+edi], al
	inc	ebx
	mov	eax, DWORD PTR _width$[esp+64]
	cmp	ebx, eax
	jl	$LL7@FlowBlur
	mov	edx, DWORD PTR _VYFullF$1$[esp+68]
	mov	edi, DWORD PTR _VXFullF$1$[esp+68]
	mov	ecx, DWORD PTR _height$1$[esp+68]
$LN6@FlowBlur:

; 214  :       }
; 215  :       pdst += dst_pitch;

	mov	ebx, DWORD PTR _pdst8$[esp+64]

; 216  :       pref += ref_pitch;

	add	esi, ebp
	add	ebx, DWORD PTR _dst_pitch$[esp+64]

; 217  :       VXFullB += VPitch;
; 218  :       VYFullB += VPitch;
; 219  :       VXFullF += VPitch;

	add	edi, DWORD PTR tv1802[esp+68]

; 220  :       VYFullF += VPitch;

	add	edx, DWORD PTR tv1802[esp+68]
	sub	ecx, 1
	mov	DWORD PTR _pdst8$[esp+64], ebx
	mov	DWORD PTR _VXFullF$1$[esp+68], edi
	mov	DWORD PTR _VYFullF$1$[esp+68], edx
	mov	DWORD PTR _height$1$[esp+68], ecx
	jne	$LL4@FlowBlur
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 323  :     }
; 324  :   }
; 325  : }

	add	esp, 52					; 00000034H
	ret	52					; 00000034H
$LN38@FlowBlur:

; 221  :     }
; 222  :   }
; 223  :   else if (nPel == 2)

	cmp	eax, 2
	jne	$LN42@FlowBlur

; 224  :   {
; 225  :     for (int h = 0; h < height; h++)

	mov	edi, DWORD PTR _height$[esp+64]
	mov	DWORD PTR _height$2$[esp+68], edi
	test	edi, edi
	jle	$LN27@FlowBlur
	mov	eax, DWORD PTR _VPitch$[esp+64]
	mov	ebx, DWORD PTR _VYFullB$[esp+64]
	add	eax, eax
	mov	edx, DWORD PTR _VXFullF$[esp+64]
	mov	ebp, DWORD PTR _ref_pitch$[esp+64]
	mov	DWORD PTR tv1801[esp+68], eax
	mov	eax, DWORD PTR _VXFullB$[esp+64]
	sub	eax, ebx
	mov	DWORD PTR _VYFullB$1$[esp+68], ebx
	mov	DWORD PTR tv1774[esp+68], eax
	mov	eax, DWORD PTR _VYFullF$[esp+64]
	sub	eax, ebx
	mov	DWORD PTR _VXFullF$2$[esp+64], edx
	mov	DWORD PTR tv1772[esp+68], eax
	mov	eax, DWORD PTR _width$[esp+64]
$LL16@FlowBlur:

; 226  :     {
; 227  :       for (int w = 0; w < width; w++)

	xor	ecx, ecx
	mov	DWORD PTR _w$1$[esp+68], ecx
	test	eax, eax
	jle	$LN18@FlowBlur
	mov	eax, DWORD PTR tv1772[esp+68]
	mov	edi, esi
	sub	eax, edx
	sub	edi, edx
	add	eax, ebx
	mov	DWORD PTR tv1775[esp+68], edi
	mov	DWORD PTR tv1771[esp+68], eax
	mov	eax, DWORD PTR tv1774[esp+68]
	sub	eax, edx
	add	eax, ebx
	mov	DWORD PTR tv1773[esp+68], eax
	mov	eax, ebx
	sub	eax, edx
	mov	DWORD PTR tv1777[esp+68], eax
	npad	8
$LL19@FlowBlur:
	lea	ebx, DWORD PTR [ecx+ecx]

; 228  :       {
; 229  :         int bluredsum = pref[w << 1];
; 230  :         int vxF0 = (VXFullF[w] * blur256);

	movsx	eax, WORD PTR [ebx+edx]
	lea	ecx, DWORD PTR [ebx+edx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	movzx	edi, BYTE PTR [ecx+edi]
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
	mov	DWORD PTR _vxF0$1$[esp+64], eax

; 231  :         int vyF0 = (VYFullF[w] * blur256);

	mov	eax, DWORD PTR tv1771[esp+68]
	movsx	eax, WORD PTR [ecx+eax]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyF0$1$[esp+64], eax

; 232  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 232  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	sar	eax, 8
	mov	DWORD PTR _mF$1$[esp+64], eax

; 233  :         if (mF > 0)

	test	eax, eax
	jle	$LN112@FlowBlur

; 234  :         {
; 235  :           vxF0 /= mF;

	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, ecx
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR $T7[esp+64], ecx
	mov	edi, eax
	mov	DWORD PTR $T11[esp+64], ecx

; 236  :           vyF0 /= mF;

	mov	eax, DWORD PTR _vyF0$1$[esp+64]
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _vxF0$2$[esp+64], edi
	mov	DWORD PTR _vyF0$2$[esp+64], eax

; 237  :           int vxF = vxF0;
; 238  :           int vyF = vyF0;

	mov	edx, eax

; 239  :           for (int i = 0; i < mF; i++)

	mov	eax, DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _i$1$[esp+68], ecx
	cmp	eax, 2
	jl	SHORT $LC113@FlowBlur
	lea	ebp, DWORD PTR [eax-2]
	shr	ebp, 1
	inc	ebp
	lea	eax, DWORD PTR [ebp*2]
	mov	DWORD PTR _i$1$[esp+68], eax
	npad	5
$LL115@FlowBlur:

; 240  :           {
; 241  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + (w << 1)];

	mov	ecx, edx
	mov	eax, edi

; 243  :             vxF += vxF0;
; 244  :             vyF += vyF0;

	add	edx, DWORD PTR _vyF0$2$[esp+64]
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T7[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T11[esp+64], eax
	sub	ebp, 1
	jne	SHORT $LL115@FlowBlur
	mov	ebp, DWORD PTR _ref_pitch$[esp+64]
	mov	ecx, DWORD PTR $T7[esp+64]
	mov	eax, DWORD PTR _mF$1$[esp+64]
$LC113@FlowBlur:

; 239  :           for (int i = 0; i < mF; i++)

	cmp	DWORD PTR _i$1$[esp+68], eax
	jge	SHORT $LN145@FlowBlur

; 240  :           {
; 241  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + (w << 1)];

	sar	edx, 8
	imul	edx, ebp
	sar	edi, 8
	add	edx, ebx
	add	edi, edx
	movzx	eax, BYTE PTR [edi+esi]

; 242  :             bluredsum += dstF;

	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, eax
	jmp	SHORT $LN114@FlowBlur
$LN145@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN114@FlowBlur:
	mov	eax, DWORD PTR $T11[esp+64]
	add	eax, ecx
	add	edi, eax
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
$LN112@FlowBlur:

; 245  :           }
; 246  :         }
; 247  :         int vxB0 = (VXFullB[w] * blur256);

	mov	eax, DWORD PTR _VXFullF$2$[esp+64]
	mov	edx, DWORD PTR tv1773[esp+68]
	add	eax, ebx

; 248  :         int vyB0 = (VYFullB[w] * blur256);

	mov	ecx, DWORD PTR tv1777[esp+68]
	movsx	ebp, WORD PTR [eax+edx]
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	imul	ebp, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyB0$1$[esp+68], eax

; 249  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	DWORD PTR _vxB0$1$[esp+64], ebp
	xor	ecx, edx
	mov	eax, ebp
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 249  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	sar	eax, 8
	mov	DWORD PTR _mB$1$[esp+64], eax

; 250  :         if (mB > 0)

	test	eax, eax
	jle	$LN116@FlowBlur

; 251  :         {
; 252  :           vxB0 /= mB;

	mov	eax, DWORD PTR _vxB0$1$[esp+64]
	xor	ebp, ebp
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR $T6[esp+64], ebp
	mov	ecx, eax
	mov	DWORD PTR $T1[esp+64], ebp

; 253  :           vyB0 /= mB;

	mov	eax, DWORD PTR _vyB0$1$[esp+68]

; 254  :           int vxB = vxB0;

	mov	edi, ecx
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR _vxB0$2$[esp+64], ecx

; 255  :           int vyB = vyB0;
; 256  :           for (int i = 0; i < mB; i++)

	xor	ecx, ecx
	mov	DWORD PTR _vyB0$2$[esp+68], eax
	mov	edx, eax
	mov	eax, DWORD PTR _mB$1$[esp+64]
	cmp	eax, 2
	jl	SHORT $LC117@FlowBlur
	lea	ebp, DWORD PTR [eax-2]
	shr	ebp, 1
	inc	ebp
	lea	eax, DWORD PTR [ebp*2]
	mov	DWORD PTR _i$1$[esp+68], eax
	npad	5
$LL119@FlowBlur:

; 257  :           {
; 258  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + (w << 1)];

	mov	ecx, edx
	mov	eax, edi

; 260  :             vxB += vxB0;
; 261  :             vyB += vyB0;

	add	edx, DWORD PTR _vyB0$2$[esp+68]
	add	edi, DWORD PTR _vxB0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyB0$2$[esp+68]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T6[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxB0$2$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T1[esp+64], eax
	sub	ebp, 1
	jne	SHORT $LL119@FlowBlur
	mov	ebp, DWORD PTR $T6[esp+64]
	mov	eax, DWORD PTR _mB$1$[esp+64]
	mov	ecx, DWORD PTR _i$1$[esp+68]
$LC117@FlowBlur:

; 255  :           int vyB = vyB0;
; 256  :           for (int i = 0; i < mB; i++)

	cmp	ecx, eax
	jge	SHORT $LN144@FlowBlur

; 257  :           {
; 258  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + (w << 1)];

	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+64]
	sar	edi, 8
	add	edx, ebx
	add	edi, edx
	movzx	ecx, BYTE PTR [edi+esi]

; 259  :             bluredsum += dstB;

	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, ecx
	jmp	SHORT $LN118@FlowBlur
$LN144@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN118@FlowBlur:
	mov	ecx, DWORD PTR $T1[esp+64]
	add	ecx, ebp
	add	edi, ecx
$LN116@FlowBlur:

; 262  :           }
; 263  :         }
; 264  :         pdst[w] = bluredsum / (mF + mB + 1);

	mov	ecx, DWORD PTR _mF$1$[esp+64]
	inc	ecx
	mov	ebp, DWORD PTR _ref_pitch$[esp+64]
	add	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _w$1$[esp+68]
	mov	edx, DWORD PTR _pdst8$[esp+64]
	mov	edi, DWORD PTR tv1775[esp+68]
	mov	BYTE PTR [ecx+edx], al
	inc	ecx
	mov	eax, DWORD PTR _width$[esp+64]
	mov	edx, DWORD PTR _VXFullF$2$[esp+64]
	mov	DWORD PTR _w$1$[esp+68], ecx
	cmp	ecx, eax
	jl	$LL19@FlowBlur
	mov	ebx, DWORD PTR _VYFullB$1$[esp+68]
	mov	edi, DWORD PTR _height$2$[esp+68]
$LN18@FlowBlur:

; 265  :       }
; 266  :       pdst += dst_pitch;

	mov	ecx, DWORD PTR _pdst8$[esp+64]

; 267  :       pref += (ref_pitch << 1);

	lea	esi, DWORD PTR [esi+ebp*2]
	add	ecx, DWORD PTR _dst_pitch$[esp+64]

; 268  :       VXFullB += VPitch;
; 269  :       VYFullB += VPitch;

	add	ebx, DWORD PTR tv1801[esp+68]

; 270  :       VXFullF += VPitch;

	add	edx, DWORD PTR tv1801[esp+68]
	sub	edi, 1
	mov	DWORD PTR _pdst8$[esp+64], ecx
	mov	DWORD PTR _VYFullB$1$[esp+68], ebx
	mov	DWORD PTR _VXFullF$2$[esp+64], edx
	mov	DWORD PTR _height$2$[esp+68], edi
	jne	$LL16@FlowBlur
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 323  :     }
; 324  :   }
; 325  : }

	add	esp, 52					; 00000034H
	ret	52					; 00000034H
$LN42@FlowBlur:

; 271  :       VYFullF += VPitch;
; 272  :     }
; 273  :   }
; 274  :   else if (nPel == 4)

	cmp	eax, 4
	jne	$LN27@FlowBlur

; 275  :   {
; 276  :     for (int h = 0; h < height; h++)

	mov	eax, DWORD PTR _height$[esp+64]
	mov	DWORD PTR _height$3$[esp+68], eax
	test	eax, eax
	jle	$LN27@FlowBlur
	mov	eax, DWORD PTR _VPitch$[esp+64]
	mov	edi, DWORD PTR _VYFullB$[esp+64]
	add	eax, eax
	mov	ebx, DWORD PTR _VYFullF$[esp+64]
	mov	edx, DWORD PTR _VXFullB$[esp+64]
	mov	ebp, DWORD PTR _ref_pitch$[esp+64]
	mov	DWORD PTR tv1800[esp+68], eax
	mov	eax, DWORD PTR _VXFullF$[esp+64]
	sub	eax, edi
	mov	DWORD PTR _VYFullB$2$[esp+68], edi
	mov	DWORD PTR tv1769[esp+68], eax
	mov	eax, DWORD PTR _width$[esp+64]
	mov	DWORD PTR _VYFullF$2$[esp+68], ebx
	mov	DWORD PTR _VXFullB$1$[esp+64], edx
$LL28@FlowBlur:

; 277  :     {
; 278  :       for (int w = 0; w < width; w++)

	xor	ecx, ecx
	mov	DWORD PTR _w$1$[esp+68], ecx
	test	eax, eax
	jle	$LN30@FlowBlur
	mov	eax, DWORD PTR tv1769[esp+68]
	mov	edx, ebx
	sub	eax, ebx
	mov	DWORD PTR tv1770[esp+64], ebx
	add	eax, edi
	mov	DWORD PTR tv1768[esp+68], eax
	mov	eax, DWORD PTR _VXFullB$1$[esp+64]
	sub	eax, ebx
	mov	DWORD PTR tv1784[esp+68], eax
	mov	eax, edi
	sub	eax, ebx
	mov	DWORD PTR tv1783[esp+68], eax
	npad	13
$LL31@FlowBlur:

; 279  :       {
; 280  :         int bluredsum = pref[w << 2];
; 281  :         int vxF0 = (VXFullF[w] * blur256);

	mov	eax, DWORD PTR tv1768[esp+68]
	lea	ebx, DWORD PTR [ecx*4]
	movzx	edi, BYTE PTR [ebx+esi]
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
	movsx	eax, WORD PTR [edx+eax]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vxF0$1$[esp+64], eax

; 282  :         int vyF0 = (VYFullF[w] * blur256);

	movsx	eax, WORD PTR [edx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyF0$1$[esp+68], eax

; 283  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 283  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	sar	eax, 8
	mov	DWORD PTR _mF$1$[esp+64], eax

; 284  :         if (mF > 0)

	test	eax, eax
	jle	$LN120@FlowBlur

; 285  :         {
; 286  :           vxF0 /= mF;

	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, ecx
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR $T2[esp+64], ecx
	mov	edi, eax
	mov	DWORD PTR $T5[esp+64], ecx

; 287  :           vyF0 /= mF;

	mov	eax, DWORD PTR _vyF0$1$[esp+68]
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _vxF0$2$[esp+64], edi
	mov	DWORD PTR _vyF0$2$[esp+68], eax

; 288  :           int vxF = vxF0;
; 289  :           int vyF = vyF0;

	mov	edx, eax

; 290  :           for (int i = 0; i < mF; i++)

	mov	eax, DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _i$1$[esp+68], ecx
	cmp	eax, 2
	jl	SHORT $LC121@FlowBlur
	lea	ebp, DWORD PTR [eax-2]
	shr	ebp, 1
	inc	ebp
	lea	eax, DWORD PTR [ebp*2]
	mov	DWORD PTR _i$1$[esp+68], eax
	npad	5
$LL123@FlowBlur:

; 291  :           {
; 292  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + (w << 2)];

	mov	ecx, edx
	mov	eax, edi

; 294  :             vxF += vxF0;
; 295  :             vyF += vyF0;

	add	edx, DWORD PTR _vyF0$2$[esp+68]
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyF0$2$[esp+68]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+64]
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T2[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T5[esp+64], eax
	sub	ebp, 1
	jne	SHORT $LL123@FlowBlur
	mov	ebp, DWORD PTR _ref_pitch$[esp+64]
	mov	ecx, DWORD PTR $T2[esp+64]
	mov	eax, DWORD PTR _mF$1$[esp+64]
$LC121@FlowBlur:

; 290  :           for (int i = 0; i < mF; i++)

	cmp	DWORD PTR _i$1$[esp+68], eax
	jge	SHORT $LN141@FlowBlur

; 291  :           {
; 292  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + (w << 2)];

	sar	edx, 8
	imul	edx, ebp
	sar	edi, 8
	add	edx, ebx
	add	edi, edx
	movzx	eax, BYTE PTR [edi+esi]

; 293  :             bluredsum += dstF;

	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, eax
	jmp	SHORT $LN122@FlowBlur
$LN141@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN122@FlowBlur:
	mov	eax, DWORD PTR $T5[esp+64]
	add	eax, ecx
	add	edi, eax
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
$LN120@FlowBlur:

; 296  :           }
; 297  :         }
; 298  :         int vxB0 = (VXFullB[w] * blur256);

	mov	ecx, DWORD PTR tv1770[esp+64]
	mov	eax, DWORD PTR tv1784[esp+68]
	movsx	eax, WORD PTR [ecx+eax]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vxB0$1$[esp+68], eax

; 299  :         int vyB0 = (VYFullB[w] * blur256);

	mov	eax, DWORD PTR tv1783[esp+68]
	movsx	eax, WORD PTR [ecx+eax]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyB0$1$[esp+68], eax

; 300  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _vxB0$1$[esp+68]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 300  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	mov	ecx, eax
	sar	ecx, 8
	mov	DWORD PTR _mB$1$[esp+64], ecx

; 301  :         if (mB > 0)

	test	ecx, ecx
	jle	$LN124@FlowBlur

; 302  :         {
; 303  :           vxB0 /= mB;

	mov	eax, DWORD PTR _vxB0$1$[esp+68]
	cdq
	idiv	ecx
	mov	DWORD PTR $T4[esp+64], 0
	mov	ecx, eax
	mov	DWORD PTR $T10[esp+64], 0

; 304  :           vyB0 /= mB;

	mov	eax, DWORD PTR _vyB0$1$[esp+68]

; 305  :           int vxB = vxB0;

	mov	edi, ecx
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR _vxB0$2$[esp+68], ecx

; 306  :           int vyB = vyB0;
; 307  :           for (int i = 0; i < mB; i++)

	xor	ecx, ecx
	mov	DWORD PTR _vyB0$2$[esp+68], eax
	mov	edx, eax
	mov	eax, DWORD PTR _mB$1$[esp+64]
	cmp	eax, 2
	jl	SHORT $LC125@FlowBlur
	add	eax, -2					; fffffffeH
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv1813[esp+68], eax
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+68], eax
$LL127@FlowBlur:

; 308  :           {
; 309  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + (w << 2)];

	mov	ecx, edx
	mov	eax, edi

; 311  :             vxB += vxB0;
; 312  :             vyB += vyB0;

	add	edx, DWORD PTR _vyB0$2$[esp+68]
	add	edi, DWORD PTR _vxB0$2$[esp+68]
	sar	ecx, 8
	imul	ecx, ebp
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyB0$2$[esp+68]
	sar	ecx, 8
	imul	ecx, ebp
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T4[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxB0$2$[esp+68]
	sar	eax, 8
	add	ecx, ebx
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+esi]
	add	DWORD PTR $T10[esp+64], eax
	sub	DWORD PTR tv1813[esp+68], 1
	jne	SHORT $LL127@FlowBlur
	mov	eax, DWORD PTR _mB$1$[esp+64]
	mov	ecx, DWORD PTR _i$1$[esp+68]
$LC125@FlowBlur:

; 306  :           int vyB = vyB0;
; 307  :           for (int i = 0; i < mB; i++)

	cmp	ecx, eax
	jge	SHORT $LN140@FlowBlur

; 308  :           {
; 309  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + (w << 2)];

	sar	edx, 8
	imul	edx, ebp
	sar	edi, 8
	add	edx, ebx
	add	edi, edx
	movzx	ecx, BYTE PTR [edi+esi]

; 310  :             bluredsum += dstB;

	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, ecx
	jmp	SHORT $LN126@FlowBlur
$LN140@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN126@FlowBlur:
	mov	ecx, DWORD PTR $T10[esp+64]
	add	ecx, DWORD PTR $T4[esp+64]
	add	edi, ecx
	mov	ecx, DWORD PTR _mB$1$[esp+64]
$LN124@FlowBlur:

; 313  :           }
; 314  :         }
; 315  :         pdst[w] = bluredsum / (mF + mB + 1);

	mov	eax, DWORD PTR _mF$1$[esp+64]
	inc	eax
	add	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _w$1$[esp+68]
	mov	edx, DWORD PTR _pdst8$[esp+64]
	mov	BYTE PTR [ecx+edx], al
	inc	ecx
	mov	edx, DWORD PTR tv1770[esp+64]
	mov	eax, DWORD PTR _width$[esp+64]
	add	edx, 2
	mov	DWORD PTR _w$1$[esp+68], ecx
	mov	DWORD PTR tv1770[esp+64], edx
	cmp	ecx, eax
	jl	$LL31@FlowBlur
	mov	ebx, DWORD PTR _VYFullF$2$[esp+68]
	mov	edi, DWORD PTR _VYFullB$2$[esp+68]
	mov	edx, DWORD PTR _VXFullB$1$[esp+64]
$LN30@FlowBlur:

; 316  :       }
; 317  :       pdst += dst_pitch;

	mov	ecx, DWORD PTR _pdst8$[esp+64]
	add	ecx, DWORD PTR _dst_pitch$[esp+64]
	mov	DWORD PTR _pdst8$[esp+64], ecx

; 318  :       pref += (ref_pitch << 2);

	lea	ecx, DWORD PTR [ebp*4]
	add	esi, ecx

; 319  :       VXFullB += VPitch;

	mov	ecx, DWORD PTR tv1800[esp+68]
	add	edx, ecx

; 320  :       VYFullB += VPitch;

	add	edi, ecx

; 321  :       VXFullF += VPitch;
; 322  :       VYFullF += VPitch;

	add	ebx, ecx
	mov	DWORD PTR _VXFullB$1$[esp+64], edx
	sub	DWORD PTR _height$3$[esp+68], 1
	mov	DWORD PTR _VYFullB$2$[esp+68], edi
	mov	DWORD PTR _VYFullF$2$[esp+68], ebx
	jne	$LL28@FlowBlur
$LN27@FlowBlur:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 323  :     }
; 324  :   }
; 325  : }

	add	esp, 52					; 00000034H
	ret	52					; 00000034H
??$FlowBlur@E@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ENDP ; MVFlowBlur::FlowBlur<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowblur.cpp
;	COMDAT ??$FlowBlur@G@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z
_TEXT	SEGMENT
_VYFullB$1$ = -52					; size = 4
_VXFullF$1$ = -48					; size = 4
_height$3$ = -44					; size = 4
_height$1$ = -44					; size = 4
tv1631 = -40						; size = 4
tv1649 = -36						; size = 4
tv1633 = -36						; size = 4
tv1654 = -32						; size = 4
tv1653 = -32						; size = 4
tv1636 = -32						; size = 4
tv1648 = -28						; size = 4
tv1630 = -28						; size = 4
tv1623 = -28						; size = 4
_vyB0$2$ = -24						; size = 4
tv1632 = -24						; size = 4
tv1622 = -24						; size = 4
_vyB0$2$ = -20						; size = 4
tv1635 = -20						; size = 4
tv1625 = -20						; size = 4
_i$1$ = -16						; size = 4
tv1627 = -16						; size = 4
tv1624 = -16						; size = 4
_vxB0$2$ = -12						; size = 4
_vxF0$2$ = -12						; size = 4
tv1634 = -12						; size = 4
tv1626 = -12						; size = 4
_vxB0$2$ = -8						; size = 4
_vxF0$2$ = -8						; size = 4
tv1656 = -8						; size = 4
tv1620 = -8						; size = 4
tv1651 = -4						; size = 4
tv1628 = -4						; size = 4
tv1621 = -4						; size = 4
_pdst8$ = 8						; size = 4
_mF$1$ = 12						; size = 4
_vxB0$2$ = 12						; size = 4
_vxB0$1$ = 12						; size = 4
_vyF0$2$ = 12						; size = 4
_vyF0$1$ = 12						; size = 4
_VYFullB$2$ = 12					; size = 4
_dst_pitch$ = 12					; size = 4
_i$1$ = 16						; size = 4
_VYFullF$2$ = 16					; size = 4
_height$2$ = 16						; size = 4
tv1669 = 16						; size = 4
_pref8$ = 16						; size = 4
_vyB0$2$ = 20						; size = 4
_vyB0$1$ = 20						; size = 4
_VYFullB$3$ = 20					; size = 4
_VYFullF$1$ = 20					; size = 4
tv1668 = 20						; size = 4
_ref_pitch$ = 20					; size = 4
_vyB0$1$ = 24						; size = 4
_vyF0$2$ = 24						; size = 4
_vyF0$1$ = 24						; size = 4
_mF$1$ = 24						; size = 4
tv1667 = 24						; size = 4
tv1637 = 24						; size = 4
_VXFullB$ = 24						; size = 4
$T1 = 28						; size = 4
_vyB0$1$ = 28						; size = 4
_vyF0$2$ = 28						; size = 4
_vyF0$1$ = 28						; size = 4
_vxF0$2$ = 28						; size = 4
_vxF0$1$ = 28						; size = 4
_VXFullF$2$ = 28					; size = 4
tv1666 = 28						; size = 4
_VXFullF$ = 28						; size = 4
$T2 = 32						; size = 4
$T3 = 32						; size = 4
_VXFullB$2$ = 32					; size = 4
_VXFullB$1$ = 32					; size = 4
_VYFullB$ = 32						; size = 4
$T4 = 36						; size = 4
_mB$1$ = 36						; size = 4
tv1629 = 36						; size = 4
tv1619 = 36						; size = 4
_VYFullF$ = 36						; size = 4
_mB$1$ = 40						; size = 4
_vxF0$1$ = 40						; size = 4
_mB$1$ = 40						; size = 4
_vxF0$1$ = 40						; size = 4
_mF$1$ = 40						; size = 4
tv1671 = 40						; size = 4
tv1664 = 40						; size = 4
_VPitch$ = 40						; size = 4
_width$ = 44						; size = 4
_w$1$ = 48						; size = 4
_w$1$ = 48						; size = 4
_bluredsum$1$ = 48					; size = 4
_height$ = 48						; size = 4
_blur256$ = 52						; size = 4
_prec$ = 56						; size = 4
??$FlowBlur@G@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z PROC ; MVFlowBlur::FlowBlur<unsigned short>, COMDAT
; _this$ = ecx

; 166  :   dst_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _dst_pitch$[esp-4]
	sub	esp, 52					; 00000034H

; 167  :   ref_pitch /= sizeof(pixel_t);
; 168  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 169  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 170  : 
; 171  :   // very slow, but precise motion blur
; 172  :   if (nPel == 1)

	mov	ecx, DWORD PTR [ecx+104]
	shr	eax, 1
	push	ebx
	mov	ebx, DWORD PTR _ref_pitch$[esp+52]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pref8$[esp+60]
	shr	ebx, 1
	push	edi
	cmp	ecx, 1
	jne	$LN38@FlowBlur

; 173  :   {
; 174  :     for (int h = 0; h < height; h++)

	mov	ecx, DWORD PTR _height$[esp+64]
	mov	DWORD PTR _height$1$[esp+68], ecx
	test	ecx, ecx
	jle	$LN27@FlowBlur
	mov	edi, DWORD PTR _VYFullB$[esp+64]
	add	eax, eax
	mov	edx, DWORD PTR _VXFullF$[esp+64]
	mov	DWORD PTR tv1656[esp+68], eax
	mov	eax, DWORD PTR _VPitch$[esp+64]
	add	eax, eax
	mov	DWORD PTR _VYFullB$1$[esp+68], edi
	mov	DWORD PTR tv1651[esp+68], eax
	mov	eax, DWORD PTR _VXFullB$[esp+64]
	sub	eax, edi
	mov	DWORD PTR _VXFullF$1$[esp+68], edx
	mov	DWORD PTR tv1633[esp+68], eax
	mov	eax, DWORD PTR _VYFullF$[esp+64]
	sub	eax, edi
	mov	DWORD PTR tv1631[esp+68], eax
	mov	eax, DWORD PTR _width$[esp+64]
	npad	5
$LL4@FlowBlur:

; 175  :     {
; 176  :       for (int w = 0; w < width; w++)

	xor	ebp, ebp
	test	eax, eax
	jle	$LN6@FlowBlur
	mov	eax, esi
	mov	DWORD PTR tv1637[esp+64], edx
	sub	eax, edx
	mov	ecx, edx
	mov	DWORD PTR tv1636[esp+68], eax
	mov	eax, DWORD PTR tv1631[esp+68]
	sub	eax, edx
	add	eax, edi
	mov	DWORD PTR tv1630[esp+68], eax
	mov	eax, DWORD PTR tv1633[esp+68]
	sub	eax, edx
	add	eax, edi
	mov	DWORD PTR tv1632[esp+68], eax
	mov	eax, edi
	sub	eax, edx
	mov	DWORD PTR tv1635[esp+68], eax
	mov	eax, DWORD PTR _pdst8$[esp+64]
	sub	eax, edx
	mov	DWORD PTR tv1634[esp+68], eax
$LL7@FlowBlur:

; 177  :       {
; 178  :         int bluredsum = pref[w];

	mov	eax, DWORD PTR tv1636[esp+68]
	movzx	edi, WORD PTR [eax+ecx]

; 179  :         int vxF0 = (VXFullF[w] * blur256);

	movsx	eax, WORD PTR [ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
	mov	DWORD PTR _vxF0$1$[esp+64], eax

; 180  :         int vyF0 = (VYFullF[w] * blur256);

	mov	eax, DWORD PTR tv1630[esp+68]
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyF0$1$[esp+64], eax

; 181  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 181  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	sar	eax, 8
	mov	DWORD PTR _mF$1$[esp+64], eax

; 182  :         if (mF > 0)

	test	eax, eax
	jle	$LN104@FlowBlur

; 183  :         {
; 184  :           vxF0 /= mF;

	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	xor	ecx, ecx
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR $T4[esp+64], ecx
	mov	edi, eax
	mov	DWORD PTR $T3[esp+64], ecx

; 185  :           vyF0 /= mF;

	mov	eax, DWORD PTR _vyF0$1$[esp+64]
	cdq
	idiv	DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _vxF0$2$[esp+64], edi
	mov	DWORD PTR _vyF0$2$[esp+64], eax

; 186  :           int vxF = vxF0;
; 187  :           int vyF = vyF0;

	mov	edx, eax

; 188  :           for (int i = 0; i < mF; i++)

	mov	eax, DWORD PTR _mF$1$[esp+64]
	mov	DWORD PTR _i$1$[esp+64], ecx
	cmp	eax, 2
	jl	SHORT $LC105@FlowBlur
	add	eax, -2					; fffffffeH
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv1668[esp+64], eax
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+64], eax
	npad	7
$LL107@FlowBlur:

; 189  :           {
; 190  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + w];

	mov	ecx, edx
	mov	eax, edi

; 192  :             vxF += vxF0;
; 193  :             vyF += vyF0;

	add	edx, DWORD PTR _vyF0$2$[esp+64]
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, ebx
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, ebx
	movzx	eax, WORD PTR [esi+eax*2]
	add	DWORD PTR $T4[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxF0$2$[esp+64]
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	movzx	eax, WORD PTR [esi+eax*2]
	add	DWORD PTR $T3[esp+64], eax
	sub	DWORD PTR tv1668[esp+64], 1
	jne	SHORT $LL107@FlowBlur
	mov	ecx, DWORD PTR $T4[esp+64]
	mov	eax, DWORD PTR _mF$1$[esp+64]
$LC105@FlowBlur:

; 188  :           for (int i = 0; i < mF; i++)

	cmp	DWORD PTR _i$1$[esp+64], eax
	jge	SHORT $LN125@FlowBlur

; 189  :           {
; 190  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + w];

	sar	edx, 8

; 191  :             bluredsum += dstF;

	imul	edx, ebx
	sar	edi, 8
	add	edx, ebp
	add	edi, edx
	movzx	eax, WORD PTR [esi+edi*2]
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, eax
	jmp	SHORT $LN106@FlowBlur
$LN125@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN106@FlowBlur:
	mov	eax, DWORD PTR $T3[esp+64]
	add	eax, ecx
	add	edi, eax
	mov	DWORD PTR _bluredsum$1$[esp+64], edi
$LN104@FlowBlur:

; 194  :           }
; 195  :         }
; 196  :         int vxB0 = (VXFullB[w] * blur256);

	mov	ecx, DWORD PTR tv1637[esp+64]
	mov	eax, DWORD PTR tv1632[esp+68]
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vxB0$1$[esp+64], eax

; 197  :         int vyB0 = (VYFullB[w] * blur256);

	mov	eax, DWORD PTR tv1635[esp+68]
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyB0$1$[esp+64], eax

; 198  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _vxB0$1$[esp+64]
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 198  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	sar	eax, 8
	mov	DWORD PTR _mB$1$[esp+64], eax

; 199  :         if (mB > 0)

	test	eax, eax
	jle	$LN108@FlowBlur

; 200  :         {
; 201  :           vxB0 /= mB;

	mov	eax, DWORD PTR _vxB0$1$[esp+64]
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR $T2[esp+64], 0
	mov	ecx, eax
	mov	DWORD PTR $T1[esp+64], 0

; 202  :           vyB0 /= mB;

	mov	eax, DWORD PTR _vyB0$1$[esp+64]

; 203  :           int vxB = vxB0;

	mov	edi, ecx
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR _vxB0$2$[esp+64], ecx

; 204  :           int vyB = vyB0;
; 205  :           for (int i = 0; i < mB; i++)

	xor	ecx, ecx
	mov	DWORD PTR _vyB0$2$[esp+64], eax
	mov	edx, eax
	mov	eax, DWORD PTR _mB$1$[esp+64]
	cmp	eax, 2
	jl	SHORT $LC109@FlowBlur
	add	eax, -2					; fffffffeH
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv1669[esp+64], eax
	add	eax, eax
	mov	DWORD PTR _i$1$[esp+68], eax
	npad	6
$LL111@FlowBlur:

; 206  :           {
; 207  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + w];

	mov	ecx, edx
	mov	eax, edi

; 209  :             vxB += vxB0;
; 210  :             vyB += vyB0;

	add	edx, DWORD PTR _vyB0$2$[esp+64]
	add	edi, DWORD PTR _vxB0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, ebx
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	mov	ecx, edx
	add	edx, DWORD PTR _vyB0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, ebx
	movzx	eax, WORD PTR [esi+eax*2]
	add	DWORD PTR $T2[esp+64], eax
	mov	eax, edi
	add	edi, DWORD PTR _vxB0$2$[esp+64]
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	movzx	eax, WORD PTR [esi+eax*2]
	add	DWORD PTR $T1[esp+64], eax
	sub	DWORD PTR tv1669[esp+64], 1
	jne	SHORT $LL111@FlowBlur
	mov	eax, DWORD PTR _mB$1$[esp+64]
	mov	ecx, DWORD PTR _i$1$[esp+68]
$LC109@FlowBlur:

; 204  :           int vyB = vyB0;
; 205  :           for (int i = 0; i < mB; i++)

	cmp	ecx, eax
	jge	SHORT $LN124@FlowBlur

; 206  :           {
; 207  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + w];

	sar	edx, 8

; 208  :             bluredsum += dstB;

	imul	edx, ebx
	sar	edi, 8
	add	edx, ebp
	add	edi, edx
	movzx	ecx, WORD PTR [esi+edi*2]
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
	add	edi, ecx
	jmp	SHORT $LN110@FlowBlur
$LN124@FlowBlur:
	mov	edi, DWORD PTR _bluredsum$1$[esp+64]
$LN110@FlowBlur:
	mov	ecx, DWORD PTR $T2[esp+64]
	add	ecx, DWORD PTR $T1[esp+64]
	add	edi, ecx
$LN108@FlowBlur:

; 211  :           }
; 212  :         }
; 213  :         pdst[w] = bluredsum / (mF + mB + 1);

	mov	ecx, DWORD PTR _mF$1$[esp+64]
	inc	ebp
	inc	ecx
	add	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR tv1637[esp+64]
	mov	edx, DWORD PTR tv1634[esp+68]
	mov	WORD PTR [edx+ecx], ax
	add	ecx, 2
	mov	eax, DWORD PTR _width$[esp+64]
	mov	DWORD PTR tv1637[esp+64], ecx
	cmp	ebp, eax
	jl	$LL7@FlowBlur
	mov	edx, DWORD PTR _VXFullF$1$[esp+68]
	mov	edi, DWORD PTR _VYFullB$1$[esp+68]
	mov	ecx, DWORD PTR _height$1$[esp+68]
$LN6@FlowBlur:

; 214  :       }
; 215  :       pdst += dst_pitch;

	mov	ebp, DWORD PTR _pdst8$[esp+64]

; 216  :       pref += ref_pitch;

	lea	esi, DWORD PTR [esi+ebx*2]
	add	ebp, DWORD PTR tv1656[esp+68]

; 217  :       VXFullB += VPitch;
; 218  :       VYFullB += VPitch;

	add	edi, DWORD PTR tv1651[esp+68]

; 219  :       VXFullF += VPitch;

	add	edx, DWORD PTR tv1651[esp+68]
	sub	ecx, 1
	mov	DWORD PTR _pdst8$[esp+64], ebp
	lea	ebp, DWORD PTR [ebx+ebx]
	mov	DWORD PTR _VYFullB$1$[esp+68], edi
	mov	DWORD PTR _VXFullF$1$[esp+68], edx
	mov	DWORD PTR _height$1$[esp+68], ecx
	jne	$LL4@FlowBlur
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 323  :     }
; 324  :   }
; 325  : }

	add	esp, 52					; 00000034H
	ret	52					; 00000034H
$LN38@FlowBlur:

; 220  :       VYFullF += VPitch;
; 221  :     }
; 222  :   }
; 223  :   else if (nPel == 2)

	cmp	ecx, 2
	jne	$LN42@FlowBlur

; 224  :   {
; 225  :     for (int h = 0; h < height; h++)

	mov	ecx, DWORD PTR _height$[esp+64]
	mov	DWORD PTR _height$2$[esp+64], ecx
	test	ecx, ecx
	jle	$LN27@FlowBlur
	mov	edi, DWORD PTR _VYFullB$[esp+64]
	add	eax, eax
	mov	ebp, DWORD PTR _VYFullF$[esp+64]
	mov	edx, DWORD PTR _VXFullB$[esp+64]
	mov	DWORD PTR tv1654[esp+68], eax
	mov	eax, DWORD PTR _VPitch$[esp+64]
	add	eax, eax
	mov	DWORD PTR _VYFullB$2$[esp+64], edi
	mov	DWORD PTR tv1649[esp+68], eax
	mov	eax, DWORD PTR _VXFullF$[esp+64]
	sub	eax, edi
	mov	DWORD PTR _VYFullF$1$[esp+64], ebp
	mov	DWORD PTR tv1621[esp+68], eax
	mov	eax, DWORD PTR _width$[esp+64]
	mov	DWORD PTR _VXFullB$1$[esp+64], edx
	npad	4
$LL16@FlowBlur:

; 226  :     {
; 227  :       for (int w = 0; w < width; w++)

	xor	ecx, ecx
	mov	DWORD PTR _w$1$[esp+64], ecx
	test	eax, eax
	jle	$LN18@FlowBlur
	mov	eax, DWORD PTR tv1621[esp+68]
	mov	edx, ebp
	sub	eax, ebp
	mov	DWORD PTR tv1629[esp+64], ebp
	add	eax, edi
	mov	DWORD PTR tv1620[esp+68], eax
	mov	eax, DWORD PTR _VXFullB$1$[esp+64]
	sub	eax, ebp
	mov	DWORD PTR tv1627[esp+68], eax
	mov	eax, edi
	sub	eax, ebp
	mov	DWORD PTR tv1625[esp+68], eax
	mov	eax, DWORD PTR _pdst8$[esp+64]
	sub	eax, ebp
	mov	DWORD PTR tv1623[esp+68], eax
	npad	4
$LL19@FlowBlur:

; 228  :       {
; 229  :         int bluredsum = pref[w << 1];
; 230  :         int vxF0 = (VXFullF[w] * blur256);

	mov	eax, DWORD PTR tv1620[esp+68]
	movzx	edi, WORD PTR [esi+ecx*4]
	movsx	ebp, WORD PTR [eax+edx]

; 231  :         int vyF0 = (VYFullF[w] * blur256);

	movsx	eax, WORD PTR [edx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	imul	ebp, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyF0$1$[esp+64], eax

; 232  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	DWORD PTR _vxF0$1$[esp+64], ebp
	xor	ecx, edx
	mov	eax, ebp
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 232  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	mov	ebp, eax
	sar	ebp, 8
	mov	DWORD PTR _mF$1$[esp+64], ebp

; 233  :         if (mF > 0)

	test	ebp, ebp
	jle	SHORT $LN21@FlowBlur

; 234  :         {
; 235  :           vxF0 /= mF;

	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	cdq
	idiv	ebp
	mov	ecx, eax

; 236  :           vyF0 /= mF;

	mov	eax, DWORD PTR _vyF0$1$[esp+64]
	cdq
	idiv	ebp
	mov	DWORD PTR _vxF0$2$[esp+68], ecx

; 237  :           int vxF = vxF0;

	mov	edx, ecx
	mov	DWORD PTR _vyF0$2$[esp+64], eax

; 238  :           int vyF = vyF0;

	mov	ebp, eax

; 239  :           for (int i = 0; i < mF; i++)

	mov	eax, DWORD PTR _mF$1$[esp+64]
	test	eax, eax
	jle	SHORT $LN21@FlowBlur

; 234  :         {
; 235  :           vxF0 /= mF;

	mov	DWORD PTR tv1671[esp+64], eax
	npad	2
$LL22@FlowBlur:

; 240  :           {
; 241  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + (w << 1)];

	mov	ecx, ebp
	mov	eax, edx

; 242  :             bluredsum += dstF;
; 243  :             vxF += vxF0;

	add	edx, DWORD PTR _vxF0$2$[esp+68]

; 244  :             vyF += vyF0;

	add	ebp, DWORD PTR _vyF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, ebx
	sar	eax, 8
	add	ecx, eax
	mov	eax, DWORD PTR _w$1$[esp+64]
	lea	eax, DWORD PTR [ecx+eax*2]
	movzx	eax, WORD PTR [esi+eax*2]
	add	edi, eax
	sub	DWORD PTR tv1671[esp+64], 1
	jne	SHORT $LL22@FlowBlur
$LN21@FlowBlur:

; 245  :           }
; 246  :         }
; 247  :         int vxB0 = (VXFullB[w] * blur256);

	mov	eax, DWORD PTR tv1629[esp+64]
	mov	ecx, DWORD PTR tv1627[esp+68]
	movsx	ebp, WORD PTR [ecx+eax]

; 248  :         int vyB0 = (VYFullB[w] * blur256);

	mov	ecx, DWORD PTR tv1625[esp+68]
	imul	ebp, DWORD PTR _blur256$[esp+64]
	movsx	eax, WORD PTR [ecx+eax]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyB0$1$[esp+64], eax

; 249  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, ebp
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 249  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	mov	ecx, eax
	sar	ecx, 8
	mov	DWORD PTR _mB$1$[esp+64], ecx

; 250  :         if (mB > 0)

	test	ecx, ecx
	jle	SHORT $LN24@FlowBlur

; 251  :         {
; 252  :           vxB0 /= mB;

	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ecx, eax

; 253  :           vyB0 /= mB;

	mov	eax, DWORD PTR _vyB0$1$[esp+64]
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR _vxB0$2$[esp+68], ecx

; 254  :           int vxB = vxB0;

	mov	edx, ecx

; 255  :           int vyB = vyB0;
; 256  :           for (int i = 0; i < mB; i++)

	mov	ecx, DWORD PTR _mB$1$[esp+64]
	mov	ebp, eax
	mov	DWORD PTR _vyB0$2$[esp+68], eax
	test	ecx, ecx
	jle	SHORT $LN24@FlowBlur

; 251  :         {
; 252  :           vxB0 /= mB;

	mov	DWORD PTR tv1666[esp+64], ecx
	npad	6
$LL25@FlowBlur:

; 257  :           {
; 258  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + (w << 1)];

	mov	ecx, ebp
	mov	eax, edx

; 259  :             bluredsum += dstB;
; 260  :             vxB += vxB0;

	add	edx, DWORD PTR _vxB0$2$[esp+68]

; 261  :             vyB += vyB0;

	add	ebp, DWORD PTR _vyB0$2$[esp+68]
	sar	ecx, 8
	imul	ecx, ebx
	sar	eax, 8
	add	ecx, eax
	mov	eax, DWORD PTR _w$1$[esp+64]
	lea	eax, DWORD PTR [ecx+eax*2]
	movzx	ecx, WORD PTR [esi+eax*2]
	add	edi, ecx
	sub	DWORD PTR tv1666[esp+64], 1
	jne	SHORT $LL25@FlowBlur
	mov	ecx, DWORD PTR _mB$1$[esp+64]
$LN24@FlowBlur:

; 262  :           }
; 263  :         }
; 264  :         pdst[w] = bluredsum / (mF + mB + 1);

	mov	eax, DWORD PTR _mF$1$[esp+64]
	inc	eax
	add	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edx, DWORD PTR tv1629[esp+64]
	mov	ecx, DWORD PTR tv1623[esp+68]
	mov	WORD PTR [ecx+edx], ax
	add	edx, 2
	mov	ecx, DWORD PTR _w$1$[esp+64]
	mov	eax, DWORD PTR _width$[esp+64]
	inc	ecx
	mov	DWORD PTR _w$1$[esp+64], ecx
	mov	DWORD PTR tv1629[esp+64], edx
	cmp	ecx, eax
	jl	$LL19@FlowBlur
	mov	ebp, DWORD PTR _VYFullF$1$[esp+64]
	mov	edi, DWORD PTR _VYFullB$2$[esp+64]
	mov	edx, DWORD PTR _VXFullB$1$[esp+64]
$LN18@FlowBlur:

; 265  :       }
; 266  :       pdst += dst_pitch;

	mov	ecx, DWORD PTR _pdst8$[esp+64]
	add	ecx, DWORD PTR tv1654[esp+68]
	mov	DWORD PTR _pdst8$[esp+64], ecx

; 267  :       pref += (ref_pitch << 1);

	lea	ecx, DWORD PTR [ebx*4]
	add	esi, ecx

; 268  :       VXFullB += VPitch;

	mov	ecx, DWORD PTR tv1649[esp+68]
	add	edx, ecx

; 269  :       VYFullB += VPitch;

	add	edi, ecx

; 270  :       VXFullF += VPitch;
; 271  :       VYFullF += VPitch;

	add	ebp, ecx
	mov	DWORD PTR _VXFullB$1$[esp+64], edx
	sub	DWORD PTR _height$2$[esp+64], 1
	mov	DWORD PTR _VYFullB$2$[esp+64], edi
	mov	DWORD PTR _VYFullF$1$[esp+64], ebp
	jne	$LL16@FlowBlur
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 323  :     }
; 324  :   }
; 325  : }

	add	esp, 52					; 00000034H
	ret	52					; 00000034H
$LN42@FlowBlur:

; 272  :     }
; 273  :   }
; 274  :   else if (nPel == 4)

	cmp	ecx, 4
	jne	$LN27@FlowBlur

; 275  :   {
; 276  :     for (int h = 0; h < height; h++)

	mov	ecx, DWORD PTR _height$[esp+64]
	mov	DWORD PTR _height$3$[esp+68], ecx
	test	ecx, ecx
	jle	$LN27@FlowBlur
	mov	edi, DWORD PTR _VYFullB$[esp+64]
	add	eax, eax
	mov	edx, DWORD PTR _VYFullF$[esp+64]
	mov	ebp, DWORD PTR _width$[esp+64]
	mov	DWORD PTR tv1653[esp+68], eax
	mov	eax, DWORD PTR _VPitch$[esp+64]
	mov	DWORD PTR _VYFullF$2$[esp+64], edx
	mov	DWORD PTR _VYFullB$3$[esp+64], edi
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _VXFullF$[esp+64]
	mov	DWORD PTR _VXFullF$2$[esp+64], eax
	mov	eax, DWORD PTR _VXFullB$[esp+64]
	mov	DWORD PTR tv1648[esp+68], ecx
	mov	DWORD PTR _VXFullB$2$[esp+64], eax
	npad	3
$LL28@FlowBlur:

; 277  :     {
; 278  :       for (int w = 0; w < width; w++)

	xor	eax, eax
	mov	DWORD PTR _w$1$[esp+64], eax
	test	ebp, ebp
	jle	$LN30@FlowBlur
	mov	ebp, DWORD PTR _VXFullF$2$[esp+64]
	mov	ecx, edx
	sub	ebp, edx
	mov	DWORD PTR tv1619[esp+64], edx
	mov	DWORD PTR tv1628[esp+68], ebp
	mov	ebp, DWORD PTR _VXFullB$2$[esp+64]
	sub	ebp, edx
	mov	DWORD PTR tv1626[esp+68], ebp
	mov	ebp, edi
	sub	ebp, edx
	mov	DWORD PTR tv1624[esp+68], ebp
	mov	ebp, DWORD PTR _pdst8$[esp+64]
	sub	ebp, edx
	mov	DWORD PTR tv1622[esp+68], ebp
	npad	6
$LL31@FlowBlur:

; 279  :       {
; 280  :         int bluredsum = pref[w << 2];

	movzx	edi, WORD PTR [esi+eax*8]

; 281  :         int vxF0 = (VXFullF[w] * blur256);

	mov	eax, DWORD PTR tv1628[esp+68]
	movsx	ebp, WORD PTR [ecx+eax]

; 282  :         int vyF0 = (VYFullF[w] * blur256);

	movsx	eax, WORD PTR [ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	imul	ebp, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyF0$1$[esp+64], eax

; 283  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	DWORD PTR _vxF0$1$[esp+64], ebp
	xor	ecx, edx
	mov	eax, ebp
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 283  :         int mF = (std::max(abs(vxF0), abs(vyF0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	mov	ebp, eax
	sar	ebp, 8
	mov	DWORD PTR _mF$1$[esp+64], ebp

; 284  :         if (mF > 0)

	test	ebp, ebp
	jle	SHORT $LN33@FlowBlur

; 285  :         {
; 286  :           vxF0 /= mF;

	mov	eax, DWORD PTR _vxF0$1$[esp+64]
	cdq
	idiv	ebp
	mov	ecx, eax

; 287  :           vyF0 /= mF;

	mov	eax, DWORD PTR _vyF0$1$[esp+64]
	cdq
	idiv	ebp
	mov	DWORD PTR _vxF0$2$[esp+68], ecx

; 288  :           int vxF = vxF0;

	mov	edx, ecx
	mov	DWORD PTR _vyF0$2$[esp+64], eax

; 289  :           int vyF = vyF0;

	mov	ebp, eax

; 290  :           for (int i = 0; i < mF; i++)

	mov	eax, DWORD PTR _mF$1$[esp+64]
	test	eax, eax
	jle	SHORT $LN33@FlowBlur

; 285  :         {
; 286  :           vxF0 /= mF;

	mov	DWORD PTR tv1664[esp+64], eax
	npad	2
$LL34@FlowBlur:

; 291  :           {
; 292  :             int dstF = pref[(vyF >> 8)*ref_pitch + (vxF >> 8) + (w << 2)];

	mov	ecx, ebp
	mov	eax, edx

; 293  :             bluredsum += dstF;
; 294  :             vxF += vxF0;

	add	edx, DWORD PTR _vxF0$2$[esp+68]

; 295  :             vyF += vyF0;

	add	ebp, DWORD PTR _vyF0$2$[esp+64]
	sar	ecx, 8
	imul	ecx, ebx
	sar	eax, 8
	add	ecx, eax
	mov	eax, DWORD PTR _w$1$[esp+64]
	lea	eax, DWORD PTR [ecx+eax*4]
	movzx	eax, WORD PTR [esi+eax*2]
	add	edi, eax
	sub	DWORD PTR tv1664[esp+64], 1
	jne	SHORT $LL34@FlowBlur
$LN33@FlowBlur:

; 296  :           }
; 297  :         }
; 298  :         int vxB0 = (VXFullB[w] * blur256);

	mov	eax, DWORD PTR tv1619[esp+64]
	mov	ecx, DWORD PTR tv1626[esp+68]
	movsx	ebp, WORD PTR [eax+ecx]

; 299  :         int vyB0 = (VYFullB[w] * blur256);

	mov	ecx, DWORD PTR tv1624[esp+68]
	imul	ebp, DWORD PTR _blur256$[esp+64]
	movsx	eax, WORD PTR [eax+ecx]
	imul	eax, DWORD PTR _blur256$[esp+64]
	mov	DWORD PTR _vyB0$1$[esp+64], eax

; 300  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	mov	ecx, eax
	mov	eax, ebp
	xor	ecx, edx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ecx
	cmovl	eax, ecx
; File c:\github\mvtools\sources\mvflowblur.cpp

; 300  :         int mB = (std::max(abs(vxB0), abs(vyB0)) / prec) >> 8;

	cdq
	idiv	DWORD PTR _prec$[esp+64]
	mov	ecx, eax
	sar	ecx, 8
	mov	DWORD PTR _mB$1$[esp+64], ecx

; 301  :         if (mB > 0)

	test	ecx, ecx
	jle	SHORT $LN36@FlowBlur

; 302  :         {
; 303  :           vxB0 /= mB;

	mov	eax, ebp
	cdq
	idiv	ecx
	mov	ecx, eax

; 304  :           vyB0 /= mB;

	mov	eax, DWORD PTR _vyB0$1$[esp+64]
	cdq
	idiv	DWORD PTR _mB$1$[esp+64]
	mov	DWORD PTR _vxB0$2$[esp+68], ecx

; 305  :           int vxB = vxB0;

	mov	edx, ecx

; 306  :           int vyB = vyB0;
; 307  :           for (int i = 0; i < mB; i++)

	mov	ecx, DWORD PTR _mB$1$[esp+64]
	mov	ebp, eax
	mov	DWORD PTR _vyB0$2$[esp+68], eax
	test	ecx, ecx
	jle	SHORT $LN36@FlowBlur

; 302  :         {
; 303  :           vxB0 /= mB;

	mov	DWORD PTR tv1667[esp+64], ecx
	npad	6
$LL37@FlowBlur:

; 308  :           {
; 309  :             int dstB = pref[(vyB >> 8)*ref_pitch + (vxB >> 8) + (w << 2)];

	mov	ecx, ebp
	mov	eax, edx

; 310  :             bluredsum += dstB;
; 311  :             vxB += vxB0;

	add	edx, DWORD PTR _vxB0$2$[esp+68]

; 312  :             vyB += vyB0;

	add	ebp, DWORD PTR _vyB0$2$[esp+68]
	sar	ecx, 8
	imul	ecx, ebx
	sar	eax, 8
	add	ecx, eax
	mov	eax, DWORD PTR _w$1$[esp+64]
	lea	eax, DWORD PTR [ecx+eax*4]
	movzx	ecx, WORD PTR [esi+eax*2]
	add	edi, ecx
	sub	DWORD PTR tv1667[esp+64], 1
	jne	SHORT $LL37@FlowBlur
	mov	ecx, DWORD PTR _mB$1$[esp+64]
$LN36@FlowBlur:

; 313  :           }
; 314  :         }
; 315  :         pdst[w] = bluredsum / (mF + mB + 1);

	mov	eax, DWORD PTR _mF$1$[esp+64]
	inc	eax
	mov	ebp, DWORD PTR _width$[esp+64]
	add	ecx, eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR tv1619[esp+64]
	mov	edx, DWORD PTR tv1622[esp+68]
	mov	WORD PTR [ecx+edx], ax
	add	ecx, 2
	mov	eax, DWORD PTR _w$1$[esp+64]
	inc	eax
	mov	DWORD PTR tv1619[esp+64], ecx
	mov	DWORD PTR _w$1$[esp+64], eax
	cmp	eax, ebp
	jl	$LL31@FlowBlur
	mov	edx, DWORD PTR _VYFullF$2$[esp+64]
	mov	ecx, DWORD PTR tv1648[esp+68]
	mov	edi, DWORD PTR _VYFullB$3$[esp+64]
$LN30@FlowBlur:

; 316  :       }
; 317  :       pdst += dst_pitch;

	mov	eax, DWORD PTR _pdst8$[esp+64]

; 318  :       pref += (ref_pitch << 2);
; 319  :       VXFullB += VPitch;
; 320  :       VYFullB += VPitch;

	add	edi, ecx
	add	eax, DWORD PTR tv1653[esp+68]

; 321  :       VXFullF += VPitch;
; 322  :       VYFullF += VPitch;

	add	edx, ecx
	add	DWORD PTR _VXFullB$2$[esp+64], ecx
	add	DWORD PTR _VXFullF$2$[esp+64], ecx
	mov	DWORD PTR _pdst8$[esp+64], eax
	lea	eax, DWORD PTR [ebx*8]
	add	esi, eax
	mov	DWORD PTR _VYFullB$3$[esp+64], edi
	sub	DWORD PTR _height$3$[esp+68], 1
	mov	DWORD PTR _VYFullF$2$[esp+64], edx
	jne	$LL28@FlowBlur
$LN27@FlowBlur:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 323  :     }
; 324  :   }
; 325  : }

	add	esp, 52					; 00000034H
	ret	52					; 00000034H
??$FlowBlur@G@MVFlowBlur@@AAEXPAEHPBEHPAF222HHHHH@Z ENDP ; MVFlowBlur::FlowBlur<unsigned short>
_TEXT	ENDS
END
