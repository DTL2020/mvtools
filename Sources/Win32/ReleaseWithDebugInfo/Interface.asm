; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\interface.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?AVS_linkage@@3PBUAVS_Linkage@@B		; AVS_linkage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BJ@OBPMADJF@MVMask?3?5ML?5must?5be?5?$DO?50?40?$AA@ ; `string'
PUBLIC	??_C@_0CM@CLNNBAEJ@MVFlow?3?5Time?5must?5be?5from?50?5to?51@ ; `string'
PUBLIC	??_C@_0DB@GLOKBGKK@MVFlowInter?3?5Time?5must?5be?5from?50@ ; `string'
PUBLIC	??_C@_0BO@GMCDCOIB@MVFlowInter?3?5ML?5must?5be?5?$DO?50?40?$AA@ ; `string'
PUBLIC	??_C@_0BM@JGLGHEMH@MVFlowFps?3?5ML?5must?5be?5?$DO?50?40?$AA@ ; `string'
PUBLIC	??_C@_0DF@LGEGMKFC@MVFlowBlur?3?5Blur?5time?5must?5be?5fr@ ; `string'
PUBLIC	??_C@_0DH@CPPJDDLD@MStoreVect?3?5you?5must?5specify?5at?5@ ; `string'
PUBLIC	??_C@_0EM@NAKFNCAA@cc?$FLscale?$FNi?$FLsil?$FNi?$FLtol?$FNi?$FLshowsad?$FNb@ ; `string'
PUBLIC	??_C@_05FPCPEODF@MShow?$AA@			; `string'
PUBLIC	??_C@_0BCB@KLDOCAHB@c?$FLblksize?$FNi?$FLblksizeV?$FNi?$FLlevels?$FNi?$FL@ ; `string'
PUBLIC	??_C@_08MPPFBKIE@MAnalyse?$AA@			; `string'
PUBLIC	??_C@_0EG@HAJCMFCN@cc?$FLml?$FNf?$FLgamma?$FNf?$FLkind?$FNi?$FLtime?$FNf?$FLYs@ ; `string'
PUBLIC	??_C@_05OLMCPBF@MMask?$AA@			; `string'
PUBLIC	??_C@_0HL@HEAJFDF@ccc?$FLscbehavior?$FNb?$FLrecursion?$FNf?$FLthS@ ; `string'
PUBLIC	??_C@_0M@NJDGAAIB@MCompensate?$AA@		; `string'
PUBLIC	??_C@_0CC@KMGONIIC@cc?$FLYth?$FNi?$FLthSCD1?$FNi?$FLthSCD2?$FNi?$FLisse?$FN@ ; `string'
PUBLIC	??_C@_0N@CLNGJOF@MSCDetection?$AA@		; `string'
PUBLIC	??_C@_0HC@HLJFBMGH@cc?$FLmask?$FNc?$FLzoom?$FNb?$FLrot?$FNb?$FLpixaspect@ ; `string'
PUBLIC	??_C@_06FLAAMDNN@MDepan?$AA@			; `string'
PUBLIC	??_C@_0EF@KDBNKAPJ@ccc?$FLtime?$FNf?$FLmode?$FNi?$FLfields?$FNb?$FLthSCD@ ; `string'
PUBLIC	??_C@_05HIENMBJA@MFlow?$AA@			; `string'
PUBLIC	??_C@_0ED@CGOJKPH@cccc?$FLtime?$FNf?$FLml?$FNf?$FLblend?$FNb?$FLthSCD1?$FN@ ; `string'
PUBLIC	??_C@_0L@DJEOPEOC@MFlowInter?$AA@		; `string'
PUBLIC	??_C@_0EH@BLHGHBNC@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmask?$FNi?$FLml?$FNf?$FLble@ ; `string'
PUBLIC	??_C@_08MJADCGCO@MFlowFps?$AA@			; `string'
PUBLIC	??_C@_0DF@DPJMOPHB@cccc?$FLblur?$FNf?$FLprec?$FNi?$FLthSCD1?$FNi?$FLthSC@ ; `string'
PUBLIC	??_C@_09CKNECHMI@MFlowBlur?$AA@			; `string'
PUBLIC	??_C@_0FM@HNKAHCLO@cccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@ ; `string'
PUBLIC	??_C@_09CNHDOAA@MDegrain1?$AA@			; `string'
PUBLIC	??_C@_0FO@HLKNGIOP@cccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FL@ ; `string'
PUBLIC	??_C@_09CJPKGNMD@MDegrain2?$AA@			; `string'
PUBLIC	??_C@_0GA@CFGPPLIN@cccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FN@ ; `string'
PUBLIC	??_C@_09DAOBFMIC@MDegrain3?$AA@			; `string'
PUBLIC	??_C@_0GC@BLKCGOJE@cccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplan@ ; `string'
PUBLIC	??_C@_09HPKAMKEF@MDegrain4?$AA@			; `string'
PUBLIC	??_C@_0GE@MHJOIK@cccccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLpl@ ; `string'
PUBLIC	??_C@_09GGLLPLAE@MDegrain5?$AA@			; `string'
PUBLIC	??_C@_0GP@OJFJMPLO@ccci?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@ ; `string'
PUBLIC	??_C@_09KKHAFLDJ@MDegrainN?$AA@			; `string'
PUBLIC	??_C@_0LJ@LNPKOIAB@cc?$FLthsad?$FNi?$FLsmooth?$FNi?$FLblksize?$FNi?$FLbl@ ; `string'
PUBLIC	??_C@_0N@HIPOLGGP@MRecalculate?$AA@		; `string'
PUBLIC	??_C@_0EM@FHHOOIJP@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmode?$FNi?$FLml?$FNi?$FLble@ ; `string'
PUBLIC	??_C@_09PDPBMHMM@MBlockFps?$AA@			; `string'
PUBLIC	??_C@_0FJ@KJGJJNIF@c?$FLhpad?$FNi?$FLvpad?$FNi?$FLpel?$FNi?$FLlevels?$FNi?$FLc@ ; `string'
PUBLIC	??_C@_06MEENJDPN@MSuper?$AA@			; `string'
PUBLIC	??_C@_09OIPLNGMI@c?$CL?$FLvccs?$FNs?$AA@	; `string'
PUBLIC	??_C@_0L@OGKEKMEE@MStoreVect?$AA@		; `string'
PUBLIC	??_C@_09HOOICLHG@c?$FLindex?$FNi?$AA@		; `string'
PUBLIC	??_C@_0N@NLLEADCO@MRestoreVect?$AA@		; `string'
PUBLIC	??_C@_0DA@IJJIFBPP@c?$FLscale?$FNf?$FLscaleV?$FNf?$FLmode?$FNi?$FLflip?$FNb@ ; `string'
PUBLIC	??_C@_0L@MGOHGFN@MScaleVect?$AA@		; `string'
PUBLIC	??_C@_0DL@BMMDLPLH@MVTools?5?3?5set?5of?5tools?5based?5on?5@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
	ALIGN	4

?AVS_linkage@@3PBUAVS_Linkage@@B DD 01H DUP (?)		; AVS_linkage
_BSS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BMMDLPLH@MVTools?5?3?5set?5of?5tools?5based?5on?5@
CONST	SEGMENT
??_C@_0DL@BMMDLPLH@MVTools?5?3?5set?5of?5tools?5based?5on?5@ DB 'MVTools '
	DB	': set of tools based on a motion estimation engine', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MGOHGFN@MScaleVect?$AA@
CONST	SEGMENT
??_C@_0L@MGOHGFN@MScaleVect?$AA@ DB 'MScaleVect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IJJIFBPP@c?$FLscale?$FNf?$FLscaleV?$FNf?$FLmode?$FNi?$FLflip?$FNb@
CONST	SEGMENT
??_C@_0DA@IJJIFBPP@c?$FLscale?$FNf?$FLscaleV?$FNf?$FLmode?$FNi?$FLflip?$FNb@ DB 'c'
	DB	'[scale]f[scaleV]f[mode]i[flip]b[adjustSubPel]b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLLEADCO@MRestoreVect?$AA@
CONST	SEGMENT
??_C@_0N@NLLEADCO@MRestoreVect?$AA@ DB 'MRestoreVect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HOOICLHG@c?$FLindex?$FNi?$AA@
CONST	SEGMENT
??_C@_09HOOICLHG@c?$FLindex?$FNi?$AA@ DB 'c[index]i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGKEKMEE@MStoreVect?$AA@
CONST	SEGMENT
??_C@_0L@OGKEKMEE@MStoreVect?$AA@ DB 'MStoreVect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OIPLNGMI@c?$CL?$FLvccs?$FNs?$AA@
CONST	SEGMENT
??_C@_09OIPLNGMI@c?$CL?$FLvccs?$FNs?$AA@ DB 'c+[vccs]s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MEENJDPN@MSuper?$AA@
CONST	SEGMENT
??_C@_06MEENJDPN@MSuper?$AA@ DB 'MSuper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@KJGJJNIF@c?$FLhpad?$FNi?$FLvpad?$FNi?$FLpel?$FNi?$FLlevels?$FNi?$FLc@
CONST	SEGMENT
??_C@_0FJ@KJGJJNIF@c?$FLhpad?$FNi?$FLvpad?$FNi?$FLpel?$FNi?$FLlevels?$FNi?$FLc@ DB 'c'
	DB	'[hpad]i[vpad]i[pel]i[levels]i[chroma]b[sharp]i[rfilter]i[pelc'
	DB	'lip]c[isse]b[planar]b[mt]b', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDPBMHMM@MBlockFps?$AA@
CONST	SEGMENT
??_C@_09PDPBMHMM@MBlockFps?$AA@ DB 'MBlockFps', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@FHHOOIJP@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmode?$FNi?$FLml?$FNi?$FLble@
CONST	SEGMENT
??_C@_0EM@FHHOOIJP@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmode?$FNi?$FLml?$FNi?$FLble@ DB 'c'
	DB	'ccc[num]i[den]i[mode]i[ml]i[blend]b[thSCD1]i[thSCD2]i[isse]b['
	DB	'planar]b[mt]b', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HIPOLGGP@MRecalculate?$AA@
CONST	SEGMENT
??_C@_0N@HIPOLGGP@MRecalculate?$AA@ DB 'MRecalculate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LJ@LNPKOIAB@cc?$FLthsad?$FNi?$FLsmooth?$FNi?$FLblksize?$FNi?$FLbl@
CONST	SEGMENT
??_C@_0LJ@LNPKOIAB@cc?$FLthsad?$FNi?$FLsmooth?$FNi?$FLblksize?$FNi?$FLbl@ DB 'c'
	DB	'c[thsad]i[smooth]i[blksize]i[blksizeV]i[search]i[searchparam]'
	DB	'i[lambda]i[chroma]b[truemotion]b[pnew]i[overlap]i[overlapV]i['
	DB	'outfile]s[dct]i[divide]i[sadx264]i[isse]b[meander]b[tr]i[mt]b'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09KKHAFLDJ@MDegrainN?$AA@
CONST	SEGMENT
??_C@_09KKHAFLDJ@MDegrainN?$AA@ DB 'MDegrainN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@OJFJMPLO@ccci?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@
CONST	SEGMENT
??_C@_0GP@OJFJMPLO@ccci?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@ DB 'c'
	DB	'cci[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2'
	DB	']i[isse]b[planar]b[lsb]b[thsad2]i[thsadc2]i[mt]b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GGLLPLAE@MDegrain5?$AA@
CONST	SEGMENT
??_C@_09GGLLPLAE@MDegrain5?$AA@ DB 'MDegrain5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@MHJOIK@cccccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLpl@
CONST	SEGMENT
??_C@_0GE@MHJOIK@cccccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLpl@ DB 'ccc'
	DB	'ccccccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i['
	DB	'thSCD2]i[isse]b[planar]b[lsb]b[mt]b', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPKAMKEF@MDegrain4?$AA@
CONST	SEGMENT
??_C@_09HPKAMKEF@MDegrain4?$AA@ DB 'MDegrain4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@BLKCGOJE@cccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplan@
CONST	SEGMENT
??_C@_0GC@BLKCGOJE@cccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplan@ DB 'c'
	DB	'ccccccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i['
	DB	'thSCD2]i[isse]b[planar]b[lsb]b[mt]b', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DAOBFMIC@MDegrain3?$AA@
CONST	SEGMENT
??_C@_09DAOBFMIC@MDegrain3?$AA@ DB 'MDegrain3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CFGPPLIN@cccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FN@
CONST	SEGMENT
??_C@_0GA@CFGPPLIN@cccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FN@ DB 'c'
	DB	'ccccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[th'
	DB	'SCD2]i[isse]b[planar]b[lsb]b[mt]b', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CJPKGNMD@MDegrain2?$AA@
CONST	SEGMENT
??_C@_09CJPKGNMD@MDegrain2?$AA@ DB 'MDegrain2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@HLKNGIOP@cccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FL@
CONST	SEGMENT
??_C@_0FO@HLKNGIOP@cccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FL@ DB 'c'
	DB	'ccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSC'
	DB	'D2]i[isse]b[planar]b[lsb]b[mt]b', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNHDOAA@MDegrain1?$AA@
CONST	SEGMENT
??_C@_09CNHDOAA@MDegrain1?$AA@ DB 'MDegrain1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@HNKAHCLO@cccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@
CONST	SEGMENT
??_C@_0FM@HNKAHCLO@cccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@ DB 'c'
	DB	'ccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2'
	DB	']i[isse]b[planar]b[lsb]b[mt]b', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CKNECHMI@MFlowBlur?$AA@
CONST	SEGMENT
??_C@_09CKNECHMI@MFlowBlur?$AA@ DB 'MFlowBlur', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DPJMOPHB@cccc?$FLblur?$FNf?$FLprec?$FNi?$FLthSCD1?$FNi?$FLthSC@
CONST	SEGMENT
??_C@_0DF@DPJMOPHB@cccc?$FLblur?$FNf?$FLprec?$FNi?$FLthSCD1?$FNi?$FLthSC@ DB 'c'
	DB	'ccc[blur]f[prec]i[thSCD1]i[thSCD2]i[isse]b[planar]b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MJADCGCO@MFlowFps?$AA@
CONST	SEGMENT
??_C@_08MJADCGCO@MFlowFps?$AA@ DB 'MFlowFps', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@BLHGHBNC@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmask?$FNi?$FLml?$FNf?$FLble@
CONST	SEGMENT
??_C@_0EH@BLHGHBNC@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmask?$FNi?$FLml?$FNf?$FLble@ DB 'c'
	DB	'ccc[num]i[den]i[mask]i[ml]f[blend]b[thSCD1]i[thSCD2]i[isse]b['
	DB	'planar]b', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJEOPEOC@MFlowInter?$AA@
CONST	SEGMENT
??_C@_0L@DJEOPEOC@MFlowInter?$AA@ DB 'MFlowInter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@CGOJKPH@cccc?$FLtime?$FNf?$FLml?$FNf?$FLblend?$FNb?$FLthSCD1?$FN@
CONST	SEGMENT
??_C@_0ED@CGOJKPH@cccc?$FLtime?$FNf?$FLml?$FNf?$FLblend?$FNb?$FLthSCD1?$FN@ DB 'c'
	DB	'ccc[time]f[ml]f[blend]b[thSCD1]i[thSCD2]i[isse]b[planar]b[tcl'
	DB	'ip]c', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05HIENMBJA@MFlow?$AA@
CONST	SEGMENT
??_C@_05HIENMBJA@MFlow?$AA@ DB 'MFlow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KDBNKAPJ@ccc?$FLtime?$FNf?$FLmode?$FNi?$FLfields?$FNb?$FLthSCD@
CONST	SEGMENT
??_C@_0EF@KDBNKAPJ@ccc?$FLtime?$FNf?$FLmode?$FNi?$FLfields?$FNb?$FLthSCD@ DB 'c'
	DB	'cc[time]f[mode]i[fields]b[thSCD1]i[thSCD2]i[isse]b[planar]b[t'
	DB	'clip]c', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06FLAAMDNN@MDepan?$AA@
CONST	SEGMENT
??_C@_06FLAAMDNN@MDepan?$AA@ DB 'MDepan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@HLJFBMGH@cc?$FLmask?$FNc?$FLzoom?$FNb?$FLrot?$FNb?$FLpixaspect@
CONST	SEGMENT
??_C@_0HC@HLJFBMGH@cc?$FLmask?$FNc?$FLzoom?$FNb?$FLrot?$FNb?$FLpixaspect@ DB 'c'
	DB	'c[mask]c[zoom]b[rot]b[pixaspect]f[error]f[info]b[log]s[wrong]'
	DB	'f[zerow]f[range]i[thSCD1]i[thSCD2]i[isse]b[planar]b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLNGJOF@MSCDetection?$AA@
CONST	SEGMENT
??_C@_0N@CLNGJOF@MSCDetection?$AA@ DB 'MSCDetection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KMGONIIC@cc?$FLYth?$FNi?$FLthSCD1?$FNi?$FLthSCD2?$FNi?$FLisse?$FN@
CONST	SEGMENT
??_C@_0CC@KMGONIIC@cc?$FLYth?$FNi?$FLthSCD1?$FNi?$FLthSCD2?$FNi?$FLisse?$FN@ DB 'c'
	DB	'c[Yth]i[thSCD1]i[thSCD2]i[isse]b', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJDGAAIB@MCompensate?$AA@
CONST	SEGMENT
??_C@_0M@NJDGAAIB@MCompensate?$AA@ DB 'MCompensate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HL@HEAJFDF@ccc?$FLscbehavior?$FNb?$FLrecursion?$FNf?$FLthS@
CONST	SEGMENT
??_C@_0HL@HEAJFDF@ccc?$FLscbehavior?$FNb?$FLrecursion?$FNf?$FLthS@ DB 'cc'
	DB	'c[scbehavior]b[recursion]f[thSAD]i[fields]b[time]f[thSCD1]i[t'
	DB	'hSCD2]i[isse]b[planar]b[mt]b[tr]i[center]b[cclip]c[thSAD2]i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLMCPBF@MMask?$AA@
CONST	SEGMENT
??_C@_05OLMCPBF@MMask?$AA@ DB 'MMask', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@HAJCMFCN@cc?$FLml?$FNf?$FLgamma?$FNf?$FLkind?$FNi?$FLtime?$FNf?$FLYs@
CONST	SEGMENT
??_C@_0EG@HAJCMFCN@cc?$FLml?$FNf?$FLgamma?$FNf?$FLkind?$FNi?$FLtime?$FNf?$FLYs@ DB 'c'
	DB	'c[ml]f[gamma]f[kind]i[time]f[Ysc]i[thSCD1]i[thSCD2]i[isse]b[p'
	DB	'lanar]b', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08MPPFBKIE@MAnalyse?$AA@
CONST	SEGMENT
??_C@_08MPPFBKIE@MAnalyse?$AA@ DB 'MAnalyse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCB@KLDOCAHB@c?$FLblksize?$FNi?$FLblksizeV?$FNi?$FLlevels?$FNi?$FL@
CONST	SEGMENT
??_C@_0BCB@KLDOCAHB@c?$FLblksize?$FNi?$FLblksizeV?$FNi?$FLlevels?$FNi?$FL@ DB 'c'
	DB	'[blksize]i[blksizeV]i[levels]i[search]i[searchparam]i[pelsear'
	DB	'ch]i[isb]b[lambda]i[chroma]b[delta]i[truemotion]b[lsad]i[plev'
	DB	'el]i[global]b[pnew]i[pzero]i[pglobal]i[overlap]i[overlapV]i[o'
	DB	'utfile]s[dct]i[divide]i[sadx264]i[badSAD]i[badrange]i[isse]b['
	DB	'meander]b[temporal]b[trymany]b[multi]b[mt]b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPCPEODF@MShow?$AA@
CONST	SEGMENT
??_C@_05FPCPEODF@MShow?$AA@ DB 'MShow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@NAKFNCAA@cc?$FLscale?$FNi?$FLsil?$FNi?$FLtol?$FNi?$FLshowsad?$FNb@
CONST	SEGMENT
??_C@_0EM@NAKFNCAA@cc?$FLscale?$FNi?$FLsil?$FNi?$FLtol?$FNi?$FLshowsad?$FNb@ DB 'c'
	DB	'c[scale]i[sil]i[tol]i[showsad]b[number]i[thSCD1]i[thSCD2]i[is'
	DB	'se]b[planar]b', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CPPJDDLD@MStoreVect?3?5you?5must?5specify?5at?5@
CONST	SEGMENT
??_C@_0DH@CPPJDDLD@MStoreVect?3?5you?5must?5specify?5at?5@ DB 'MStoreVect'
	DB	': you must specify at least one vector clip.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LGEGMKFC@MVFlowBlur?3?5Blur?5time?5must?5be?5fr@
CONST	SEGMENT
??_C@_0DF@LGEGMKFC@MVFlowBlur?3?5Blur?5time?5must?5be?5fr@ DB 'MVFlowBlur'
	DB	': Blur time must be from 0 to 200 percent.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JGLGHEMH@MVFlowFps?3?5ML?5must?5be?5?$DO?50?40?$AA@
CONST	SEGMENT
??_C@_0BM@JGLGHEMH@MVFlowFps?3?5ML?5must?5be?5?$DO?50?40?$AA@ DB 'MVFlowF'
	DB	'ps: ML must be > 0.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GMCDCOIB@MVFlowInter?3?5ML?5must?5be?5?$DO?50?40?$AA@
CONST	SEGMENT
??_C@_0BO@GMCDCOIB@MVFlowInter?3?5ML?5must?5be?5?$DO?50?40?$AA@ DB 'MVFlo'
	DB	'wInter: ML must be > 0.0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GLOKBGKK@MVFlowInter?3?5Time?5must?5be?5from?50@
CONST	SEGMENT
??_C@_0DB@GLOKBGKK@MVFlowInter?3?5Time?5must?5be?5from?50@ DB 'MVFlowInte'
	DB	'r: Time must be from 0 to 100 percent.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CLNNBAEJ@MVFlow?3?5Time?5must?5be?5from?50?5to?51@
CONST	SEGMENT
??_C@_0CM@CLNNBAEJ@MVFlow?3?5Time?5must?5be?5from?50?5to?51@ DB 'MVFlow: '
	DB	'Time must be from 0 to 100 percent.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OBPMADJF@MVMask?3?5ML?5must?5be?5?$DO?50?40?$AA@
CONST	SEGMENT
??_C@_0BJ@OBPMADJF@MVMask?3?5ML?5must?5be?5?$DO?50?40?$AA@ DB 'MVMask: ML'
	DB	' must be > 0.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
PUBLIC	??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z ; std::allocator<PClip>::construct<PClip,PClip>
PUBLIC	??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip>
PUBLIC	??$forward@VPClip@@@std@@YA$$QAVPClip@@AAV1@@Z	; std::forward<PClip>
PUBLIC	??_GPClip@@QAEPAXI@Z				; PClip::`scalar deleting destructor'
PUBLIC	??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z ; std::allocator<PClip>::destroy<PClip>
PUBLIC	??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip>
PUBLIC	??$move@AAVPClip@@@std@@YA$$QAVPClip@@AAV1@@Z	; std::move<PClip &>
PUBLIC	??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z ; std::allocator_traits<std::allocator<PClip> >::destroy<PClip>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<PClip *,PClip *,std::allocator<PClip> >
PUBLIC	??$_Ptr_move_cat@VPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVPClip@@0@Z ; std::_Ptr_move_cat<PClip,PClip>
PUBLIC	??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<PClip const *,PClip *,std::allocator<PClip> >
PUBLIC	??$_Ptr_copy_cat@$$CBVPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBVPClip@@ABQAV2@@Z ; std::_Ptr_copy_cat<PClip const ,PClip>
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QBEPBVPClip@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >::_Unchecked
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<PClip> > &>
PUBLIC	??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::destroy<PClip>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<PClip *,PClip *,std::allocator<PClip> >
PUBLIC	??$_Rechecked@PAVPClip@@PAV1@@std@@YAAAPAVPClip@@AAPAV1@PAV1@@Z ; std::_Rechecked<PClip *,PClip *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<PClip const *,PClip *,std::allocator<PClip> >
PUBLIC	??$_Unchecked@PAVPClip@@@std@@YAPAVPClip@@PAV1@@Z ; std::_Unchecked<PClip *>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@YAPBVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PClip> > >
PUBLIC	??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z ; std::allocator<PClip>::construct<PClip,PClip const &>
PUBLIC	??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z ; std::allocator<PClip>::construct<PClip,PClip &>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> >
PUBLIC	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
PUBLIC	??$_Uninitialized_move@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ; std::_Uninitialized_move<PClip *,PClip *,std::allocator<PClip> >
PUBLIC	??$forward@V?$allocator@VPClip@@@std@@@std@@YA$$QAV?$allocator@VPClip@@@0@AAV10@@Z ; std::forward<std::allocator<PClip> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@PAVPClip@@V?$allocator@VPClip@@@2@@std@@YAPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >,PClip *,std::allocator<PClip> >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1><std::_Wrap_alloc<std::allocator<PClip> > >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<PClip> > >
PUBLIC	??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip const &>
PUBLIC	??$forward@ABVPClip@@@std@@YAABVPClip@@ABV1@@Z	; std::forward<PClip const &>
PUBLIC	??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip &>
PUBLIC	??$forward@AAVPClip@@@std@@YAAAVPClip@@AAV1@@Z	; std::forward<PClip &>
PUBLIC	??0?$allocator@VPClip@@@std@@QAE@XZ		; std::allocator<PClip>::allocator<PClip>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PClip> >::_Vector_val<std::_Simple_types<PClip> >
PUBLIC	??$_Destroy_range@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<PClip>,PClip *>
PUBLIC	??$_Umove@PAVPClip@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@PAV2@00@Z ; std::vector<PClip,std::allocator<PClip> >::_Umove<PClip *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1><>
PUBLIC	??$?0V?$allocator@VPClip@@@std@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAV?$allocator@VPClip@@@1@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> ><std::allocator<PClip> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@1@0PAV2@@Z ; std::vector<PClip,std::allocator<PClip> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > ><std::_Wrap_alloc<std::allocator<PClip> >,void>
PUBLIC	??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip const &>
PUBLIC	??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip &>
PUBLIC	??$_Unfancy@VPClip@@@std@@YAPAVPClip@@PAV1@@Z	; std::_Unfancy<PClip>
PUBLIC	??$addressof@$$CBVPClip@@@std@@YAPBVPClip@@ABV1@@Z ; std::addressof<PClip const >
PUBLIC	?max_size@?$allocator@VPClip@@@std@@QBEIXZ	; std::allocator<PClip>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAIABV?$allocator@VPClip@@@2@@Z ; std::allocator_traits<std::allocator<PClip> >::max_size
PUBLIC	??0?$allocator@VPClip@@@std@@QAE@ABV01@@Z	; std::allocator<PClip>::allocator<PClip>
PUBLIC	?deallocate@?$allocator@VPClip@@@std@@QAEXPAVPClip@@I@Z ; std::allocator<PClip>::deallocate
PUBLIC	?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z ; std::allocator<PClip>::allocate
PUBLIC	?capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ; std::vector<PClip,std::allocator<PClip> >::capacity
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myend
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_second
PUBLIC	?_Unused_capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ; std::vector<PClip,std::allocator<PClip> >::_Unused_capacity
PUBLIC	?max_size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ; std::vector<PClip,std::allocator<PClip> >::max_size
PUBLIC	?_Destroy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXPAVPClip@@0@Z ; std::vector<PClip,std::allocator<PClip> >::_Destroy
PUBLIC	?_Grow_to@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEII@Z ; std::vector<PClip,std::allocator<PClip> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z ; std::vector<PClip,std::allocator<PClip> >::_Reallocate
PUBLIC	?_Xlen@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXXZ ; std::vector<PClip,std::allocator<PClip> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Mylast
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEPAVPClip@@I@Z ; std::_Wrap_alloc<std::allocator<PClip> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@I@Z ; std::_Wrap_alloc<std::allocator<PClip> >::deallocate
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SA?AV?$allocator@VPClip@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<PClip> >::select_on_container_copy_construction
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QAE@PAVPClip@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_first
PUBLIC	?begin@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ ; std::vector<PClip,std::allocator<PClip> >::begin
PUBLIC	?end@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ ; std::vector<PClip,std::allocator<PClip> >::end
PUBLIC	?size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ; std::vector<PClip,std::allocator<PClip> >::size
PUBLIC	?_Buy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAE_NI@Z ; std::vector<PClip,std::allocator<PClip> >::_Buy
PUBLIC	?_Inside@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBE_NPBVPClip@@@Z ; std::vector<PClip,std::allocator<PClip> >::_Inside
PUBLIC	?_Reserve@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z ; std::vector<PClip,std::allocator<PClip> >::_Reserve
PUBLIC	?_Tidy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXXZ ; std::vector<PClip,std::allocator<PClip> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXPAVPClip@@0@Z ; std::vector<PClip,std::allocator<PClip> >::_Orphan_range
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myend
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<PClip> >::select_on_container_copy_construction
PUBLIC	??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ; std::vector<PClip,std::allocator<PClip> >::vector<PClip,std::allocator<PClip> >
PUBLIC	??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z ; std::vector<PClip,std::allocator<PClip> >::vector<PClip,std::allocator<PClip> >
PUBLIC	??1?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ; std::vector<PClip,std::allocator<PClip> >::~vector<PClip,std::allocator<PClip> >
PUBLIC	?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z ; std::vector<PClip,std::allocator<PClip> >::push_back
PUBLIC	_DllMain@12
PUBLIC	_AvisynthPluginInit3@8
PUBLIC	?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MScaleVect
PUBLIC	?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MRestoreVect
PUBLIC	?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MStoreVect
PUBLIC	?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVSuper
PUBLIC	?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVBlockFps
PUBLIC	?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVRecalculate
PUBLIC	?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MDegrainN
PUBLIC	?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDegrainX
PUBLIC	?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlowBlur
PUBLIC	?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlowFps
PUBLIC	?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlowInter
PUBLIC	?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlow
PUBLIC	?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDepan
PUBLIC	?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVMask
PUBLIC	?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVAnalyse
PUBLIC	?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVSCDetection
PUBLIC	?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVCompensate
PUBLIC	?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVShow
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??AAVSValue@@QBEABV0@H@Z			; AVSValue::operator[]
PUBLIC	?ArraySize@AVSValue@@QBEHXZ			; AVSValue::ArraySize
PUBLIC	?AsString@AVSValue@@QBEPBDPBD@Z			; AVSValue::AsString
PUBLIC	?AsFloat@AVSValue@@QBENM@Z			; AVSValue::AsFloat
PUBLIC	?AsInt@AVSValue@@QBEHH@Z			; AVSValue::AsInt
PUBLIC	?AsBool@AVSValue@@QBE_N_N@Z			; AVSValue::AsBool
PUBLIC	?AsClip@AVSValue@@QBE?AVPClip@@XZ		; AVSValue::AsClip
PUBLIC	?IsClip@AVSValue@@QBE_NXZ			; AVSValue::IsClip
PUBLIC	?Defined@AVSValue@@QBE_NXZ			; AVSValue::Defined
PUBLIC	??1AVSValue@@QAE@XZ				; AVSValue::~AVSValue
PUBLIC	??0AVSValue@@QAE@PAVIClip@@@Z			; AVSValue::AVSValue
PUBLIC	??1PClip@@QAE@XZ				; PClip::~PClip
PUBLIC	??0PClip@@QAE@PAVIClip@@@Z			; PClip::PClip
PUBLIC	??0PClip@@QAE@ABV0@@Z				; PClip::PClip
PUBLIC	??0PClip@@QAE@XZ				; PClip::PClip
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1PClip@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1AVSValue@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?AsClip@AVSValue@@QBE?AVPClip@@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?AsClip@AVSValue@@QBE?AVPClip@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AsClip@AVSValue@@QBE?AVPClip@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	07H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	07H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	06H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	06H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	07H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	07H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	08H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	08H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	040H
	DD	FLAT:__unwindtable$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$32
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	06H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6
	DD	07H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
	DD	08H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8
	DD	09H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
	DD	0aH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
	DD	0bH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11
	DD	0cH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12
	DD	0dH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$13
	DD	0eH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$14
	DD	0fH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$15
	DD	010H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$16
	DD	011H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$17
	DD	012H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$18
	DD	013H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$19
	DD	014H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$20
	DD	015H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$21
	DD	016H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$22
	DD	017H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$23
	DD	018H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$24
	DD	019H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$25
	DD	01aH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$26
	DD	01bH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$27
	DD	01cH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$28
	DD	01dH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$29
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	01fH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	020H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	021H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6
	DD	022H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
	DD	023H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8
	DD	024H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
	DD	025H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
	DD	026H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11
	DD	027H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12
	DD	028H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$13
	DD	029H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$14
	DD	02aH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$15
	DD	02bH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$16
	DD	02cH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$17
	DD	02dH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$18
	DD	02dH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$33
	DD	02cH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$34
	DD	02bH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$35
	DD	02aH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$36
	DD	029H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$37
	DD	028H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$38
	DD	027H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$39
	DD	026H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$40
	DD	025H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$41
	DD	024H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$42
	DD	023H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$43
	DD	022H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$44
	DD	021H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$45
	DD	020H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$46
	DD	01fH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$47
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$48
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$49
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	044H
	DD	FLAT:__unwindtable$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$36
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	06H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6
	DD	07H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
	DD	08H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8
	DD	09H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
	DD	0aH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
	DD	0bH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11
	DD	0cH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12
	DD	0dH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$13
	DD	0eH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$14
	DD	0fH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$15
	DD	010H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$16
	DD	011H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$17
	DD	012H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$18
	DD	013H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$19
	DD	014H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$20
	DD	015H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$21
	DD	016H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$22
	DD	017H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$23
	DD	018H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$24
	DD	019H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$25
	DD	01aH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$26
	DD	01bH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$27
	DD	01cH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$28
	DD	01dH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$29
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	01fH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	020H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
	DD	021H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6
	DD	022H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
	DD	023H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8
	DD	024H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
	DD	025H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10
	DD	026H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11
	DD	027H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12
	DD	028H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$13
	DD	029H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$14
	DD	02aH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$15
	DD	02bH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$16
	DD	02cH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$17
	DD	02dH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$18
	DD	02dH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$37
	DD	02cH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$38
	DD	02bH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$39
	DD	02aH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$40
	DD	029H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$41
	DD	028H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$42
	DD	027H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$43
	DD	026H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$44
	DD	025H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$45
	DD	024H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$46
	DD	023H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$47
	DD	022H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$48
	DD	021H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$49
	DD	020H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$50
	DD	01fH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$51
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$52
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$53
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$32
	DD	040H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$33
	DD	041H
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$34
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$54
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	05H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	05H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7
	DD	01H
	DD	FLAT:__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$40
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z$57
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z$67
__catchsym$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z$67 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z$53
__catchsym$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z$53 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6
__catchsym$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$5
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$7
__catchsym$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GPClip@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GPClip@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_GPClip@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GPClip@@QAEPAXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0PClip@@QAE@XZ
_TEXT	SEGMENT
??0PClip@@QAE@XZ PROC					; PClip::PClip, COMDAT
; _this$ = ecx

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@PClip
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN5@PClip
	mov	eax, DWORD PTR [eax+228]
	call	eax
$LN5@PClip:
	mov	eax, esi
	pop	esi
	ret	0
??0PClip@@QAE@XZ ENDP					; PClip::PClip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0PClip@@QAE@ABV0@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??0PClip@@QAE@ABV0@@Z PROC				; PClip::PClip, COMDAT
; _this$ = ecx

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@PClip
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN5@PClip
	push	DWORD PTR _x$[esp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN5@PClip:
	mov	eax, esi
	pop	esi
	ret	4
??0PClip@@QAE@ABV0@@Z ENDP				; PClip::PClip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0PClip@@QAE@PAVIClip@@@Z
_TEXT	SEGMENT
_x$dead$ = 8						; size = 4
??0PClip@@QAE@PAVIClip@@@Z PROC				; PClip::PClip, COMDAT
; _this$ = ecx

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@PClip
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN5@PClip
	mov	eax, DWORD PTR [eax+236]
	push	0
	call	eax
$LN5@PClip:
	mov	eax, esi
	pop	esi
	ret	4
??0PClip@@QAE@PAVIClip@@@Z ENDP				; PClip::PClip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??1PClip@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1PClip@@QAE@XZ PROC					; PClip::~PClip, COMDAT
; _this$ = ecx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1PClip@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@PClip
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN3@PClip
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN3@PClip:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1PClip@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1PClip@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1PClip@@QAE@XZ ENDP					; PClip::~PClip
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??0AVSValue@@QAE@PAVIClip@@@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
??0AVSValue@@QAE@PAVIClip@@@Z PROC			; AVSValue::AVSValue, COMDAT
; _this$ = ecx

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN5@AVSValue
	cmp	DWORD PTR [eax], 280			; 00000118H
	jbe	SHORT $LN5@AVSValue
	push	DWORD PTR _c$[esp]
	mov	eax, DWORD PTR [eax+280]
	call	eax
$LN5@AVSValue:
	mov	eax, esi
	pop	esi
	ret	4
??0AVSValue@@QAE@PAVIClip@@@Z ENDP			; AVSValue::AVSValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??1AVSValue@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1AVSValue@@QAE@XZ PROC				; AVSValue::~AVSValue, COMDAT
; _this$ = ecx

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1AVSValue@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@AVSValue
	cmp	DWORD PTR [eax], 316			; 0000013cH
	jbe	SHORT $LN3@AVSValue
	mov	eax, DWORD PTR [eax+316]
	call	eax
$LN3@AVSValue:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1AVSValue@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1AVSValue@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AVSValue@@QAE@XZ ENDP				; AVSValue::~AVSValue
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?Defined@AVSValue@@QBE_NXZ
_TEXT	SEGMENT
?Defined@AVSValue@@QBE_NXZ PROC				; AVSValue::Defined, COMDAT
; _this$ = ecx

; 1017 :   bool Defined() const AVS_BakedCode( return AVS_LinkCall(Defined)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@Defined
	cmp	DWORD PTR [eax], 328			; 00000148H
	jbe	SHORT $LN3@Defined
	mov	eax, DWORD PTR [eax+328]
	call	eax
	movzx	eax, al
	ret	0
$LN3@Defined:
	xor	al, al
	ret	0
?Defined@AVSValue@@QBE_NXZ ENDP				; AVSValue::Defined
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?IsClip@AVSValue@@QBE_NXZ
_TEXT	SEGMENT
?IsClip@AVSValue@@QBE_NXZ PROC				; AVSValue::IsClip, COMDAT
; _this$ = ecx

; 1018 :   bool IsClip() const AVS_BakedCode( return AVS_LinkCall(IsClip)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@IsClip
	cmp	DWORD PTR [eax], 332			; 0000014cH
	jbe	SHORT $LN3@IsClip
	mov	eax, DWORD PTR [eax+332]
	call	eax
	movzx	eax, al
	ret	0
$LN3@IsClip:
	xor	al, al
	ret	0
?IsClip@AVSValue@@QBE_NXZ ENDP				; AVSValue::IsClip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?AsClip@AVSValue@@QBE?AVPClip@@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?AsClip@AVSValue@@QBE?AVPClip@@XZ PROC			; AVSValue::AsClip, COMDAT
; _this$ = ecx

; 1026 :   PClip AsClip() const AVS_BakedCode( return AVS_LinkCall(AsClip)() )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AsClip@AVSValue@@QBE?AVPClip@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T5[ebp], 0
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	push	ebx
	push	esi
	test	edx, edx
	je	SHORT $LN22@AsClip
	mov	eax, DWORD PTR [edx]
	cmp	eax, 356				; 00000164H
	jbe	SHORT $LN3@AsClip
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+356]
	call	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR $T5[ebp], 1
	test	edx, edx
	je	SHORT $LN18@AsClip
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN18@AsClip
	push	eax
	mov	eax, DWORD PTR [edx+232]
	lea	ecx, DWORD PTR $T3[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN18@AsClip:

; 1026 :   PClip AsClip() const AVS_BakedCode( return AVS_LinkCall(AsClip)() )

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ebx, 3
	jmp	SHORT $LN47@AsClip
$LN3@AsClip:

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	cmp	eax, 236				; 000000ecH
	jbe	SHORT $LN22@AsClip
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T4[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN22@AsClip:

; 1026 :   PClip AsClip() const AVS_BakedCode( return AVS_LinkCall(AsClip)() )

	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ebx, 4
$LN47@AsClip:

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T5[ebp], ebx
	test	edx, edx
	je	SHORT $LN26@AsClip
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN26@AsClip
	push	eax
	mov	eax, DWORD PTR [edx+232]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN26@AsClip:
	or	ebx, 8

; 1026 :   PClip AsClip() const AVS_BakedCode( return AVS_LinkCall(AsClip)() )

	test	bl, 4
	je	SHORT $LN30@AsClip
	and	ebx, -5					; fffffffbH
	mov	DWORD PTR $T5[ebp], ebx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN30@AsClip
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN30@AsClip
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T4[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN30@AsClip:

; 1026 :   PClip AsClip() const AVS_BakedCode( return AVS_LinkCall(AsClip)() )

	test	bl, 2
	je	SHORT $LN35@AsClip
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T5[ebp], ebx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	edx, edx
	je	SHORT $LN35@AsClip
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN35@AsClip
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T3[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN35@AsClip:

; 1026 :   PClip AsClip() const AVS_BakedCode( return AVS_LinkCall(AsClip)() )

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	test	bl, 1
	je	SHORT $LN45@AsClip

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	edx, edx
	je	SHORT $LN45@AsClip
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN45@AsClip
	mov	edx, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T2[ebp]
	call	edx
$LN45@AsClip:

; 1026 :   PClip AsClip() const AVS_BakedCode( return AVS_LinkCall(AsClip)() )

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$0:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN6@AsClip
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN6@AsClip:
	ret	0
__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$1:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 2
	je	$LN8@AsClip
	and	DWORD PTR $T5[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN8@AsClip:
	ret	0
__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$2:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 4
	je	$LN10@AsClip
	and	DWORD PTR $T5[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN10@AsClip:
	ret	0
__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?AsClip@AVSValue@@QBE?AVPClip@@XZ$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?AsClip@AVSValue@@QBE?AVPClip@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?AsClip@AVSValue@@QBE?AVPClip@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AsClip@AVSValue@@QBE?AVPClip@@XZ ENDP			; AVSValue::AsClip
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?AsBool@AVSValue@@QBE_N_N@Z
_TEXT	SEGMENT
_def$ = 8						; size = 1
?AsBool@AVSValue@@QBE_N_N@Z PROC			; AVSValue::AsBool, COMDAT
; _this$ = ecx

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@AsBool
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN3@AsBool
	push	DWORD PTR _def$[esp-4]
	mov	eax, DWORD PTR [eax+376]
	call	eax
	movzx	eax, al
	ret	4
$LN3@AsBool:
	xor	al, al
	ret	4
?AsBool@AVSValue@@QBE_N_N@Z ENDP			; AVSValue::AsBool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?AsInt@AVSValue@@QBEHH@Z
_TEXT	SEGMENT
_def$ = 8						; size = 4
?AsInt@AVSValue@@QBEHH@Z PROC				; AVSValue::AsInt, COMDAT
; _this$ = ecx

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@AsInt
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN3@AsInt
	mov	eax, DWORD PTR [eax+380]
	jmp	eax
$LN3@AsInt:
	xor	eax, eax
	ret	4
?AsInt@AVSValue@@QBEHH@Z ENDP				; AVSValue::AsInt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?AsFloat@AVSValue@@QBENM@Z
_TEXT	SEGMENT
tv71 = -8						; size = 8
?AsFloat@AVSValue@@QBENM@Z PROC				; AVSValue::AsFloat, COMDAT
; _this$ = ecx
; _def$ = xmm1s

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	sub	esp, 8
	test	eax, eax
	je	SHORT $LN3@AsFloat
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN3@AsFloat
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	eax
	fstp	QWORD PTR tv71[esp+8]
	movsd	xmm0, QWORD PTR tv71[esp+8]
	add	esp, 8
	ret	0
$LN3@AsFloat:
	xorps	xmm0, xmm0
	add	esp, 8
	ret	0
?AsFloat@AVSValue@@QBENM@Z ENDP				; AVSValue::AsFloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?AsString@AVSValue@@QBEPBDPBD@Z
_TEXT	SEGMENT
_def$dead$ = 8						; size = 4
?AsString@AVSValue@@QBEPBDPBD@Z PROC			; AVSValue::AsString, COMDAT
; _this$ = ecx

; 1039 :   const char* AsString(const char* def) const AVS_BakedCode( return AVS_LinkCall(AsString2)(def) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@AsString
	cmp	DWORD PTR [eax], 392			; 00000188H
	jbe	SHORT $LN3@AsString
	mov	DWORD PTR _def$dead$[esp-4], OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	eax, DWORD PTR [eax+392]
	jmp	eax
$LN3@AsString:
	xor	eax, eax
	ret	4
?AsString@AVSValue@@QBEPBDPBD@Z ENDP			; AVSValue::AsString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?ArraySize@AVSValue@@QBEHXZ
_TEXT	SEGMENT
?ArraySize@AVSValue@@QBEHXZ PROC			; AVSValue::ArraySize, COMDAT
; _this$ = ecx

; 1041 :   int ArraySize() const AVS_BakedCode( return AVS_LinkCall(ArraySize)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@ArraySize
	cmp	DWORD PTR [eax], 396			; 0000018cH
	jbe	SHORT $LN3@ArraySize
	mov	eax, DWORD PTR [eax+396]
	jmp	eax
$LN3@ArraySize:
	xor	eax, eax
	ret	0
?ArraySize@AVSValue@@QBEHXZ ENDP			; AVSValue::ArraySize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??AAVSValue@@QBEABV0@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??AAVSValue@@QBEABV0@H@Z PROC				; AVSValue::operator[], COMDAT
; _this$ = ecx

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@operator
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN3@operator
	mov	eax, DWORD PTR [eax+324]
	jmp	eax
$LN3@operator:
	mov	eax, ecx
	ret	4
??AAVSValue@@QBEABV0@H@Z ENDP				; AVSValue::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 44   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
_user_data$ = 20					; size = 4
$T4 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVShow, COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR $T3[ebp], 0

; 80   : 	return new MVShow(

	push	432					; 000001b0H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN13@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN13@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN14@Create_MVS
$LN13@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN14@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN17@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN17@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN18@Create_MVS
$LN17@Create_MVS:
	xor	ecx, ecx
$LN18@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN21@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN21@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN22@Create_MVS
$LN21@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN22@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN25@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN25@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN26@Create_MVS
$LN25@Create_MVS:
	xor	ecx, ecx
$LN26@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN29@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN29@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN30@Create_MVS
$LN29@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN30@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN33@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN33@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN34@Create_MVS
$LN33@Create_MVS:
	xor	ecx, ecx
$LN34@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN37@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN37@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN38@Create_MVS
$LN37@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN38@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN41@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN41@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN42@Create_MVS
$LN41@Create_MVS:
	xor	ecx, ecx
$LN42@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN45@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN45@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN46@Create_MVS
$LN45@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN46@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN49@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN49@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	-1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN50@Create_MVS
$LN49@Create_MVS:
	xor	ecx, ecx
$LN50@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN53@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN53@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN54@Create_MVS
$LN53@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN54@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN57@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN57@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN58@Create_MVS
$LN57@Create_MVS:
	xor	ecx, ecx
$LN58@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN61@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN61@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN62@Create_MVS
$LN61@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN62@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN65@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN65@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	20000					; 00004e20H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN66@Create_MVS
$LN65@Create_MVS:
	xor	ecx, ecx
$LN66@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN69@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN69@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN70@Create_MVS
$LN69@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN70@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN73@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN73@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN74@Create_MVS
$LN73@Create_MVS:
	xor	ecx, ecx
$LN74@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN77@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN77@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN78@Create_MVS
$LN77@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN78@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN81@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN81@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN82@Create_MVS
$LN81@Create_MVS:
	xor	ecx, ecx
$LN82@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN85@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN85@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN86@Create_MVS
$LN85@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN86@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T4[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN89@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN89@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN90@Create_MVS
$LN89@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN90@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0MVShow@@QAE@VPClip@@0HHH_NHHH11PAVIScriptEnvironment@@@Z ; MVShow::MVShow
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 80   : 	return new MVShow(

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN93@Create_MVS
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN93@Create_MVS
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN93@Create_MVS:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN100@Create_MVS
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN100@Create_MVS
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN100@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	432					; 000001b0H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVShow
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
tv553 = -44						; size = 8
tv495 = -44						; size = 8
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
_user_data$ = 20					; size = 4
$T8 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVCompensate, COMDAT

; 97   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T7[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN23@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN23@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN24@Create_MVC
$LN23@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN24@Create_MVC:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN27@Create_MVC
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN27@Create_MVC
	mov	eax, DWORD PTR [eax+380]
	push	10000					; 00002710H
	call	eax
	mov	edi, eax
	jmp	SHORT $LN28@Create_MVC
$LN27@Create_MVC:
	xor	edi, edi
$LN28@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	408					; 00000198H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN31@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN31@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	15					; 0000000fH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN32@Create_MVC
$LN31@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN32@Create_MVC:

; 1018 :   bool IsClip() const AVS_BakedCode( return AVS_LinkCall(IsClip)() )

	test	eax, eax
	je	SHORT $LN43@Create_MVC
	cmp	DWORD PTR [eax], 332			; 0000014cH
	jbe	SHORT $LN3@Create_MVC
	mov	eax, DWORD PTR [eax+332]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	test	al, al
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	je	SHORT $LN3@Create_MVC
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN39@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN39@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	16					; 00000010H
	call	eax
	jmp	SHORT $LN40@Create_MVC
$LN39@Create_MVC:
	lea	eax, DWORD PTR _args$[ebp]
$LN40@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ebx, 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN180@Create_MVC
$LN3@Create_MVC:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN43@Create_MVC
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN43@Create_MVC
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T6[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN43@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	lea	esi, DWORD PTR $T6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ebx, 2
$LN180@Create_MVC:
	mov	DWORD PTR $T7[ebp], ebx
	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN47@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN47@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	16					; 00000010H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN48@Create_MVC
$LN47@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN48@Create_MVC:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN51@Create_MVC
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN51@Create_MVC
	mov	eax, DWORD PTR [eax+380]
	push	edi
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN52@Create_MVC
$LN51@Create_MVC:
	xor	ecx, ecx
$LN52@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
	push	ecx
	mov	DWORD PTR $T8[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN55@Create_MVC
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN55@Create_MVC
	mov	eax, DWORD PTR [eax+232]
	push	esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN55@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN59@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN59@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	14					; 0000000eH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN60@Create_MVC
$LN59@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN60@Create_MVC:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN63@Create_MVC
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN63@Create_MVC
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN64@Create_MVC
$LN63@Create_MVC:
	xor	ecx, ecx
$LN64@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN67@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN67@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN68@Create_MVC
$LN67@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN68@Create_MVC:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN71@Create_MVC
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN71@Create_MVC
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN72@Create_MVC
$LN71@Create_MVC:
	xor	ecx, ecx
$LN72@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN75@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN75@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN76@Create_MVC
$LN75@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN76@Create_MVC:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN79@Create_MVC
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN79@Create_MVC
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN80@Create_MVC
$LN79@Create_MVC:
	xor	ecx, ecx
$LN80@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN83@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN83@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN84@Create_MVC
$LN83@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN84@Create_MVC:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN87@Create_MVC
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN87@Create_MVC
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN88@Create_MVC
$LN87@Create_MVC:
	xor	ecx, ecx
$LN88@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN91@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN91@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN92@Create_MVC
$LN91@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN92@Create_MVC:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN95@Create_MVC
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN95@Create_MVC
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN96@Create_MVC
$LN95@Create_MVC:
	xor	ecx, ecx
$LN96@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN99@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN99@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN100@Create_MVC
$LN99@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN100@Create_MVC:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN103@Create_MVC
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN103@Create_MVC
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN104@Create_MVC
$LN103@Create_MVC:
	xor	ecx, ecx
$LN104@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN107@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN107@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN108@Create_MVC
$LN107@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN108@Create_MVC:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN111@Create_MVC
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN111@Create_MVC
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN112@Create_MVC
$LN111@Create_MVC:
	xor	ecx, ecx
$LN112@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN115@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN115@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN116@Create_MVC
$LN115@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN116@Create_MVC:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN119@Create_MVC
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN119@Create_MVC
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv495[ebp]
	movsd	xmm0, QWORD PTR tv495[ebp]
	jmp	SHORT $LN120@Create_MVC
$LN119@Create_MVC:
	xorps	xmm0, xmm0
$LN120@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN123@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN123@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN124@Create_MVC
$LN123@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN124@Create_MVC:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN127@Create_MVC
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN127@Create_MVC
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN128@Create_MVC
$LN127@Create_MVC:
	xor	ecx, ecx
$LN128@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN131@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN131@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN132@Create_MVC
$LN131@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN132@Create_MVC:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN135@Create_MVC
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN135@Create_MVC
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv553[ebp]
	movsd	xmm0, QWORD PTR tv553[ebp]
	jmp	SHORT $LN136@Create_MVC
$LN135@Create_MVC:
	xorps	xmm0, xmm0
$LN136@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN139@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN139@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN140@Create_MVC
$LN139@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN140@Create_MVC:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN143@Create_MVC
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN143@Create_MVC
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN144@Create_MVC
$LN143@Create_MVC:
	xor	ecx, ecx
$LN144@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN147@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN147@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN148@Create_MVC
$LN147@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN148@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T3[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN151@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN151@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN152@Create_MVC
$LN151@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN152@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN155@Create_MVC
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN155@Create_MVC
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN156@Create_MVC
$LN155@Create_MVC:
	lea	ecx, DWORD PTR _args$[ebp]
$LN156@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z ; MVCompensate::MVCompensate
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN159@Create_MVC
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN159@Create_MVC
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN159@Create_MVC:
	or	ebx, 4
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	test	bl, 2
	je	SHORT $LN163@Create_MVC
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T7[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 9
	test	edx, edx
	je	SHORT $LN163@Create_MVC
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN163@Create_MVC
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T6[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN163@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 100  : 	return new MVCompensate(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	bl, 1
	je	SHORT $LN168@Create_MVC
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN168@Create_MVC
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN168@Create_MVC
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T4[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN168@Create_MVC:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	edx, edx
	je	SHORT $LN176@Create_MVC
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN176@Create_MVC
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN176@Create_MVC:
; File c:\github\mvtools\sources\interface.cpp

; 120  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	408					; 00000198H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	eax, DWORD PTR $T7[ebp]
	and	eax, 1
	je	$LN10@Create_MVC
	and	DWORD PTR $T7[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN10@Create_MVC:
	ret	0
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	eax, DWORD PTR $T7[ebp]
	and	eax, 2
	je	$LN12@Create_MVC
	and	DWORD PTR $T7[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN12@Create_MVC:
	ret	0
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T8[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVCompensate
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
tv248 = -32						; size = 8
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
_user_data$ = 20					; size = 4
tv304 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVSCDetection, COMDAT

; 123  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR $T4[ebp], 0

; 124  : 	return new MVSCDetection(

	push	400					; 00000190H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T3[ebp], esi
	push	DWORD PTR _env$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN13@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN13@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN14@Create_MVS
$LN13@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN14@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN17@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN17@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN17@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 124  : 	return new MVSCDetection(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN21@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN21@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN22@Create_MVS
$LN21@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN22@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN25@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN25@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN26@Create_MVS
$LN25@Create_MVS:
	xor	ecx, ecx
$LN26@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 124  : 	return new MVSCDetection(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN29@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN29@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN30@Create_MVS
$LN29@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN30@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN33@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN33@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN34@Create_MVS
$LN33@Create_MVS:
	xor	ecx, ecx
$LN34@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 124  : 	return new MVSCDetection(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN37@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN37@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN38@Create_MVS
$LN37@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN38@Create_MVS:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN41@Create_MVS
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN41@Create_MVS
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], -971228160		; c61c3c00H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv248[ebp]
	movsd	xmm0, QWORD PTR tv248[ebp]
	jmp	SHORT $LN42@Create_MVS
$LN41@Create_MVS:
	xorps	xmm0, xmm0
$LN42@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 124  : 	return new MVSCDetection(

	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR tv304[ebp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN45@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN45@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN46@Create_MVS
$LN45@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN46@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 124  : 	return new MVSCDetection(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN49@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN49@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN50@Create_MVS
$LN49@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN50@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 124  : 	return new MVSCDetection(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	movss	xmm3, DWORD PTR tv304[ebp]
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0MVSCDetection@@QAE@VPClip@@0MHH_NPAVIScriptEnvironment@@@Z ; MVSCDetection::MVSCDetection
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 124  : 	return new MVSCDetection(

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN53@Create_MVS
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN53@Create_MVS
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN53@Create_MVS:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN60@Create_MVS
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN60@Create_MVS
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN60@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 133  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	400					; 00000190H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVSCDetection
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
_blksize$1$ = -36					; size = 4
_blksizeV$1$ = -32					; size = 4
_overlap$1$ = -28					; size = 4
_lambda$1$ = -24					; size = 4
_global$ = -20						; size = 1
_lsad$1$ = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
_user_data$ = 20					; size = 4
_env$ = 24						; size = 4
?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVAnalyse, COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN14@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN14@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN15@Create_MVA
$LN14@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN15@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN18@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN18@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	8
	call	eax
	mov	ebx, eax
	mov	DWORD PTR _blksize$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN19@Create_MVA
$LN18@Create_MVA:
	xor	ebx, ebx
	mov	DWORD PTR _blksize$1$[ebp], ebx
$LN19@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN22@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN22@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN23@Create_MVA
$LN22@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN23@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN26@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN26@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	ebx
	call	eax
	mov	edi, eax
	mov	DWORD PTR _blksizeV$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN27@Create_MVA
$LN26@Create_MVA:
	xor	edi, edi
	mov	DWORD PTR _blksizeV$1$[ebp], edi
$LN27@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN30@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN30@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	18					; 00000012H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN31@Create_MVA
$LN30@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN31@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN34@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN34@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	DWORD PTR _overlap$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN35@Create_MVA
$LN34@Create_MVA:
	mov	DWORD PTR _overlap$1$[ebp], 0
$LN35@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN38@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN38@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN39@Create_MVA
$LN38@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN39@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	$LN86@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	$LN2@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
; File c:\github\mvtools\sources\interface.cpp

; 148  : 	if (truemotion)

	test	al, al
	je	$LN315@Create_MVA
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN46@Create_MVA
	cmp	DWORD PTR [esi], 324			; 00000144H
	jbe	SHORT $LN46@Create_MVA
	mov	eax, DWORD PTR [esi+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN47@Create_MVA
$LN46@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN47@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	esi, esi
	je	SHORT $LN50@Create_MVA
	cmp	DWORD PTR [esi], 380			; 0000017cH
	jbe	SHORT $LN50@Create_MVA
; File c:\github\mvtools\sources\interface.cpp

; 150  : 		lambda = args[ 8].AsInt(1000*blksize*blksizeV/64);

	mov	eax, edi
	imul	eax, ebx
	imul	eax, eax, 1000
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
; File c:\github\mvtools\sources\include\avisynth.h

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	push	eax
	mov	eax, DWORD PTR [esi+380]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _lambda$1$[ebp], eax
	jmp	SHORT $LN51@Create_MVA
$LN50@Create_MVA:
	mov	DWORD PTR _lambda$1$[ebp], 0
$LN51@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	esi, esi
	je	SHORT $LN54@Create_MVA
	cmp	DWORD PTR [esi], 324			; 00000144H
	jbe	SHORT $LN54@Create_MVA
	mov	eax, DWORD PTR [esi+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN55@Create_MVA
$LN54@Create_MVA:
	lea	eax, DWORD PTR _args$[ebp]
$LN55@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	esi, esi
	je	SHORT $LN58@Create_MVA
	cmp	DWORD PTR [esi], 380			; 0000017cH
	jbe	SHORT $LN58@Create_MVA
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+380]
	push	1200					; 000004b0H
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _lsad$1$[ebp], eax
	jmp	SHORT $LN59@Create_MVA
$LN58@Create_MVA:
	mov	DWORD PTR _lsad$1$[ebp], 0
$LN59@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	esi, esi
	je	SHORT $LN62@Create_MVA
	cmp	DWORD PTR [esi], 324			; 00000144H
	jbe	SHORT $LN62@Create_MVA
	mov	eax, DWORD PTR [esi+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	15					; 0000000fH
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN63@Create_MVA
$LN62@Create_MVA:
	lea	eax, DWORD PTR _args$[ebp]
$LN63@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	esi, esi
	je	SHORT $LN66@Create_MVA
	cmp	DWORD PTR [esi], 380			; 0000017cH
	jbe	SHORT $LN66@Create_MVA
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+380]
	push	50					; 00000032H
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ebx, eax
	jmp	SHORT $LN67@Create_MVA
$LN66@Create_MVA:
	xor	ebx, ebx
$LN67@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	esi, esi
	je	SHORT $LN70@Create_MVA
	cmp	DWORD PTR [esi], 324			; 00000144H
	jbe	SHORT $LN70@Create_MVA
	mov	eax, DWORD PTR [esi+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN71@Create_MVA
$LN70@Create_MVA:
	lea	eax, DWORD PTR _args$[ebp]
$LN71@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	esi, esi
	je	SHORT $LN74@Create_MVA
	cmp	DWORD PTR [esi], 380			; 0000017cH
	jbe	SHORT $LN74@Create_MVA
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+380]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN75@Create_MVA
$LN74@Create_MVA:
	xor	edi, edi
$LN75@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	esi, esi
	je	SHORT $LN78@Create_MVA
	cmp	DWORD PTR [esi], 324			; 00000144H
	jbe	SHORT $LN78@Create_MVA
	mov	eax, DWORD PTR [esi+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	14					; 0000000eH
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN79@Create_MVA
$LN78@Create_MVA:
	lea	eax, DWORD PTR _args$[ebp]
$LN79@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	esi, esi
	je	SHORT $LN82@Create_MVA
	cmp	DWORD PTR [esi], 376			; 00000178H
	jbe	SHORT $LN82@Create_MVA
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+376]
	push	1
	call	eax
	mov	esi, DWORD PTR _lsad$1$[ebp]
	mov	BYTE PTR _global$[ebp], al
	jmp	SHORT $LN123@Create_MVA
$LN82@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 156  : 	else // old versions 0.9.9.1 compatibility mode

	mov	esi, DWORD PTR _lsad$1$[ebp]
$LN122@Create_MVA:
; File c:\github\mvtools\sources\include\avisynth.h

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	mov	BYTE PTR _global$[ebp], 0
$LN123@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	584					; 00000248H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	push	DWORD PTR _env$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	$LN126@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	$LN126@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	31					; 0000001fH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	$LN127@Create_MVA
$LN315@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 156  : 	else // old versions 0.9.9.1 compatibility mode

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN2@Create_MVA:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN86@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN86@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN87@Create_MVA
$LN86@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN87@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN90@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN90@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	DWORD PTR _lambda$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN91@Create_MVA
$LN90@Create_MVA:
	mov	DWORD PTR _lambda$1$[ebp], 0
$LN91@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN94@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN94@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN95@Create_MVA
$LN94@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN95@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN98@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN98@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	DWORD PTR _lsad$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR _lsad$1$[ebp]
	jmp	SHORT $LN99@Create_MVA
$LN98@Create_MVA:
	xor	esi, esi
$LN99@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN102@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN102@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	15					; 0000000fH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN103@Create_MVA
$LN102@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN103@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN106@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN106@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ebx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN107@Create_MVA
$LN106@Create_MVA:
	xor	ebx, ebx
$LN107@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN110@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN110@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN111@Create_MVA
$LN110@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN111@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN114@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN114@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN115@Create_MVA
$LN114@Create_MVA:
	xor	edi, edi
$LN115@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN118@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN118@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	14					; 0000000eH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN119@Create_MVA
$LN118@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN119@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	$LN122@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	$LN122@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	mov	BYTE PTR _global$[ebp], al
	jmp	$LN123@Create_MVA
$LN126@Create_MVA:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	lea	ecx, DWORD PTR _args$[ebp]
$LN127@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN130@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN130@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN131@Create_MVA
$LN130@Create_MVA:
	xor	ecx, ecx
$LN131@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN134@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN134@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	30					; 0000001eH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN135@Create_MVA
$LN134@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN135@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN138@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN138@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN139@Create_MVA
$LN138@Create_MVA:
	xor	ecx, ecx
$LN139@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN142@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN142@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	29					; 0000001dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN143@Create_MVA
$LN142@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN143@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN146@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN146@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN147@Create_MVA
$LN146@Create_MVA:
	xor	ecx, ecx
$LN147@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN150@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN150@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	28					; 0000001cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN151@Create_MVA
$LN150@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN151@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN154@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN154@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN155@Create_MVA
$LN154@Create_MVA:
	xor	ecx, ecx
$LN155@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN158@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN158@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	27					; 0000001bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN159@Create_MVA
$LN158@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN159@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN162@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN162@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN163@Create_MVA
$LN162@Create_MVA:
	xor	ecx, ecx
$LN163@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN166@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN166@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	26					; 0000001aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN167@Create_MVA
$LN166@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN167@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN170@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN170@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN171@Create_MVA
$LN170@Create_MVA:
	xor	ecx, ecx
$LN171@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN174@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN174@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	25					; 00000019H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN175@Create_MVA
$LN174@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN175@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN178@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN178@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	24					; 00000018H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN179@Create_MVA
$LN178@Create_MVA:
	xor	ecx, ecx
$LN179@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN182@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN182@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	24					; 00000018H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN183@Create_MVA
$LN182@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN183@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN186@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN186@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	10000					; 00002710H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN187@Create_MVA
$LN186@Create_MVA:
	xor	ecx, ecx
$LN187@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN190@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN190@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	23					; 00000017H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN191@Create_MVA
$LN190@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN191@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN194@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN194@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN194@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN198@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN198@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	22					; 00000016H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN199@Create_MVA
$LN198@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN199@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN202@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN202@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN203@Create_MVA
$LN202@Create_MVA:
	xor	ecx, ecx
$LN203@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN206@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN206@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	21					; 00000015H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN207@Create_MVA
$LN206@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN207@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN210@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN210@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN211@Create_MVA
$LN210@Create_MVA:
	xor	ecx, ecx
$LN211@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN214@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN214@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	20					; 00000014H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN215@Create_MVA
$LN214@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN215@Create_MVA:

; 1039 :   const char* AsString(const char* def) const AVS_BakedCode( return AVS_LinkCall(AsString2)(def) )

	test	eax, eax
	je	SHORT $LN218@Create_MVA
	cmp	DWORD PTR [eax], 392			; 00000188H
	jbe	SHORT $LN218@Create_MVA
	mov	eax, DWORD PTR [eax+392]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN219@Create_MVA
$LN218@Create_MVA:
	xor	ecx, ecx
$LN219@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN222@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN222@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	19					; 00000013H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN223@Create_MVA
$LN222@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN223@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN226@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN226@Create_MVA
	push	DWORD PTR _overlap$1$[ebp]
	mov	eax, DWORD PTR [eax+380]
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN227@Create_MVA
$LN226@Create_MVA:
	xor	ecx, ecx
$LN227@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
	push	DWORD PTR _overlap$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN230@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN230@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	17					; 00000011H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN231@Create_MVA
$LN230@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN231@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN234@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN234@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN235@Create_MVA
$LN234@Create_MVA:
	xor	ecx, ecx
$LN235@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN238@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN238@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	16					; 00000010H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN239@Create_MVA
$LN238@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN239@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN242@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN242@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN243@Create_MVA
$LN242@Create_MVA:
	xor	ecx, ecx
$LN243@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
	push	ebx
	push	DWORD PTR _global$[ebp]
	push	edi
	push	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN246@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN246@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN247@Create_MVA
$LN246@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN247@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN250@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN250@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN251@Create_MVA
$LN250@Create_MVA:
	xor	ecx, ecx
$LN251@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN254@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN254@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN255@Create_MVA
$LN254@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN255@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN258@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN258@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN259@Create_MVA
$LN258@Create_MVA:
	xor	ecx, ecx
$LN259@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
	push	DWORD PTR _lambda$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN262@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN262@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN263@Create_MVA
$LN262@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN263@Create_MVA:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN266@Create_MVA
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN266@Create_MVA
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN267@Create_MVA
$LN266@Create_MVA:
	xor	ecx, ecx
$LN267@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN270@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN270@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN271@Create_MVA
$LN270@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN271@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN274@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN274@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN275@Create_MVA
$LN274@Create_MVA:
	xor	ecx, ecx
$LN275@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN278@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN278@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN279@Create_MVA
$LN278@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN279@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN282@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN282@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN283@Create_MVA
$LN282@Create_MVA:
	xor	ecx, ecx
$LN283@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN286@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN286@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN287@Create_MVA
$LN286@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN287@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN290@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN290@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN291@Create_MVA
$LN290@Create_MVA:
	xor	ecx, ecx
$LN291@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN294@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN294@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN295@Create_MVA
$LN294@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN295@Create_MVA:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN298@Create_MVA
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN298@Create_MVA
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN299@Create_MVA
$LN298@Create_MVA:
	xor	ecx, ecx
$LN299@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
	push	DWORD PTR _blksizeV$1$[ebp]
	push	DWORD PTR _blksize$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN302@Create_MVA
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN302@Create_MVA
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN303@Create_MVA
$LN302@Create_MVA:
	lea	ecx, DWORD PTR _args$[ebp]
$LN303@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z ; MVAnalyse::MVAnalyse
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 165  :    return new MVAnalyse(

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN306@Create_MVA
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN306@Create_MVA
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN306@Create_MVA:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN313@Create_MVA
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN313@Create_MVA
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN313@Create_MVA:
; File c:\github\mvtools\sources\interface.cpp

; 199  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	584					; 00000248H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVAnalyse
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_ml$1$ = -36						; size = 8
_ml$ = -36						; size = 8
tv355 = -28						; size = 8
tv331 = -28						; size = 8
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T4 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVMask, COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN14@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN14@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN15@Create_MVM
$LN14@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN15@Create_MVM:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	mov	esi, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN18@Create_MVM
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN18@Create_MVM
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	eax
	fstp	QWORD PTR _ml$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 204  : 	if (ml<=0)

	movsd	xmm1, QWORD PTR _ml$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	movsd	QWORD PTR _ml$1$[ebp], xmm1
	jb	SHORT $LN2@Create_MVM
	jmp	SHORT $LN101@Create_MVM
$LN18@Create_MVM:
	xorps	xmm0, xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	movsd	QWORD PTR _ml$1$[ebp], xmm0
$LN101@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 205  : 	   env->ThrowError("MVMask: ML must be > 0.0");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0BJ@OBPMADJF@MVMask?3?5ML?5must?5be?5?$DO?50?40?$AA@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@Create_MVM:

; 208  : 	return new MVMask(

	push	496					; 000001f0H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN22@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN22@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN23@Create_MVM
$LN22@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN23@Create_MVM:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN26@Create_MVM
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN26@Create_MVM
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN27@Create_MVM
$LN26@Create_MVM:
	xor	ecx, ecx
$LN27@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN30@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN30@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN31@Create_MVM
$LN30@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN31@Create_MVM:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN34@Create_MVM
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN34@Create_MVM
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN35@Create_MVM
$LN34@Create_MVM:
	xor	ecx, ecx
$LN35@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN38@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN38@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN39@Create_MVM
$LN38@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN39@Create_MVM:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN42@Create_MVM
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN42@Create_MVM
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN43@Create_MVM
$LN42@Create_MVM:
	xor	ecx, ecx
$LN43@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN46@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN46@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN47@Create_MVM
$LN46@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN47@Create_MVM:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN50@Create_MVM
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN50@Create_MVM
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN51@Create_MVM
$LN50@Create_MVM:
	xor	ecx, ecx
$LN51@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN54@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN54@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN55@Create_MVM
$LN54@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN55@Create_MVM:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN58@Create_MVM
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN58@Create_MVM
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN59@Create_MVM
$LN58@Create_MVM:
	xor	ecx, ecx
$LN59@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN62@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN62@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN63@Create_MVM
$LN62@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN63@Create_MVM:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN66@Create_MVM
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN66@Create_MVM
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv331[ebp]
	movsd	xmm0, QWORD PTR tv331[ebp]
	jmp	SHORT $LN67@Create_MVM
$LN66@Create_MVM:
	xorps	xmm0, xmm0
$LN67@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN70@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN70@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN71@Create_MVM
$LN70@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN71@Create_MVM:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN74@Create_MVM
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN74@Create_MVM
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN75@Create_MVM
$LN74@Create_MVM:
	xor	ecx, ecx
$LN75@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN78@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN78@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN79@Create_MVM
$LN78@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN79@Create_MVM:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN82@Create_MVM
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN82@Create_MVM
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv355[ebp]
	movsd	xmm0, QWORD PTR tv355[ebp]
	jmp	SHORT $LN83@Create_MVM
$LN82@Create_MVM:
	xorps	xmm0, xmm0
$LN83@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN86@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN86@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN87@Create_MVM
$LN86@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN87@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN90@Create_MVM
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN90@Create_MVM
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN91@Create_MVM
$LN90@Create_MVM:
	lea	ecx, DWORD PTR _args$[ebp]
$LN91@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	movsd	xmm3, QWORD PTR _ml$1$[ebp]
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0MVMask@@QAE@VPClip@@0NNHNHHH_N1PAVIScriptEnvironment@@@Z ; MVMask::MVMask
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 208  : 	return new MVMask(

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN94@Create_MVM
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN94@Create_MVM
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN94@Create_MVM:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN102@Create_MVM
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN102@Create_MVM
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN102@Create_MVM:
; File c:\github\mvtools\sources\interface.cpp

; 222  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	496					; 000001f0H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVMask
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
tv486 = -40						; size = 8
tv474 = -40						; size = 8
tv436 = -40						; size = 8
tv424 = -40						; size = 8
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T7 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVDepan, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T6[ebp], 0

; 226  : 	return new MVDepan(

	push	608					; 00000260H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T3[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN22@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN22@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN23@Create_MVD
$LN22@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN23@Create_MVD:

; 1017 :   bool Defined() const AVS_BakedCode( return AVS_LinkCall(Defined)() )

	test	eax, eax
	je	SHORT $LN34@Create_MVD
	cmp	DWORD PTR [eax], 328			; 00000148H
	jbe	SHORT $LN3@Create_MVD
	mov	eax, DWORD PTR [eax+328]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	test	al, al
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	je	SHORT $LN3@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN30@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN30@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	jmp	SHORT $LN31@Create_MVD
$LN30@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN31@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ebx, 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN175@Create_MVD
$LN3@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN34@Create_MVD
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN34@Create_MVD
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T5[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN34@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	lea	esi, DWORD PTR $T5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ebx, 2
$LN175@Create_MVD:
	mov	DWORD PTR $T6[ebp], ebx
	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN38@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN38@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	15					; 0000000fH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN39@Create_MVD
$LN38@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN39@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN42@Create_MVD
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN42@Create_MVD
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN43@Create_MVD
$LN42@Create_MVD:
	xor	ecx, ecx
$LN43@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN46@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN46@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	14					; 0000000eH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN47@Create_MVD
$LN46@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN47@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN50@Create_MVD
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN50@Create_MVD
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN50@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN54@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN54@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN55@Create_MVD
$LN54@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN55@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN58@Create_MVD
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN58@Create_MVD
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN59@Create_MVD
$LN58@Create_MVD:
	xor	ecx, ecx
$LN59@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN62@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN62@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN63@Create_MVD
$LN62@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN63@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN66@Create_MVD
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN66@Create_MVD
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN67@Create_MVD
$LN66@Create_MVD:
	xor	ecx, ecx
$LN67@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN70@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN70@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN71@Create_MVD
$LN70@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN71@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN74@Create_MVD
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN74@Create_MVD
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN75@Create_MVD
$LN74@Create_MVD:
	xor	ecx, ecx
$LN75@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN78@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN78@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN79@Create_MVD
$LN78@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN79@Create_MVD:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN82@Create_MVD
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN82@Create_MVD
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1028443341		; 3d4ccccdH
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv424[ebp]
	movsd	xmm0, QWORD PTR tv424[ebp]
	jmp	SHORT $LN83@Create_MVD
$LN82@Create_MVD:
	xorps	xmm0, xmm0
$LN83@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	cvtpd2ps xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN86@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN86@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN87@Create_MVD
$LN86@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN87@Create_MVD:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN90@Create_MVD
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN90@Create_MVD
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1092616192		; 41200000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv436[ebp]
	movsd	xmm0, QWORD PTR tv436[ebp]
	jmp	SHORT $LN91@Create_MVD
$LN90@Create_MVD:
	xorps	xmm0, xmm0
$LN91@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	cvtpd2ps xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN94@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN94@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN95@Create_MVD
$LN94@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN95@Create_MVD:

; 1039 :   const char* AsString(const char* def) const AVS_BakedCode( return AVS_LinkCall(AsString2)(def) )

	test	eax, eax
	je	SHORT $LN98@Create_MVD
	cmp	DWORD PTR [eax], 392			; 00000188H
	jbe	SHORT $LN98@Create_MVD
	mov	eax, DWORD PTR [eax+392]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN99@Create_MVD
$LN98@Create_MVD:
	xor	ecx, ecx
$LN99@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN102@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN102@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN103@Create_MVD
$LN102@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN103@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN106@Create_MVD
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN106@Create_MVD
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN107@Create_MVD
$LN106@Create_MVD:
	xor	ecx, ecx
$LN107@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN110@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN110@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN111@Create_MVD
$LN110@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN111@Create_MVD:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN114@Create_MVD
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN114@Create_MVD
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1097859072		; 41700000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv474[ebp]
	movsd	xmm0, QWORD PTR tv474[ebp]
	jmp	SHORT $LN115@Create_MVD
$LN114@Create_MVD:
	xorps	xmm0, xmm0
$LN115@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	cvtpd2ps xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN118@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN118@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN119@Create_MVD
$LN118@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN119@Create_MVD:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN122@Create_MVD
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN122@Create_MVD
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv486[ebp]
	movsd	xmm0, QWORD PTR tv486[ebp]
	jmp	SHORT $LN123@Create_MVD
$LN122@Create_MVD:
	xorps	xmm0, xmm0
$LN123@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	cvtpd2ps xmm0, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN126@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN126@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN127@Create_MVD
$LN126@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN127@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN130@Create_MVD
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN130@Create_MVD
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN131@Create_MVD
$LN130@Create_MVD:
	xor	ecx, ecx
$LN131@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN134@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN134@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN135@Create_MVD
$LN134@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN135@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN138@Create_MVD
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN138@Create_MVD
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN139@Create_MVD
$LN138@Create_MVD:
	xor	ecx, ecx
$LN139@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
	push	ecx
	mov	DWORD PTR $T7[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN142@Create_MVD
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN142@Create_MVD
	mov	eax, DWORD PTR [eax+232]
	push	esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN142@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN146@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN146@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN147@Create_MVD
$LN146@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN147@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN150@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN150@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN151@Create_MVD
$LN150@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN151@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z ; MVDepan::MVDepan
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN154@Create_MVD
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN154@Create_MVD
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN154@Create_MVD:
	or	ebx, 4
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	test	bl, 2
	je	SHORT $LN158@Create_MVD
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T6[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 8
	test	edx, edx
	je	SHORT $LN158@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN158@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T5[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN158@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 226  : 	return new MVDepan(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	bl, 1
	je	SHORT $LN163@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 9
	test	edx, edx
	je	SHORT $LN163@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN163@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T4[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN163@Create_MVD:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN171@Create_MVD
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN171@Create_MVD
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN171@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 245  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	608					; 00000260H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	eax, DWORD PTR $T6[ebp]
	and	eax, 1
	je	$LN10@Create_MVD
	and	DWORD PTR $T6[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN10@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	eax, DWORD PTR $T6[ebp]
	and	eax, 2
	je	$LN12@Create_MVD
	and	DWORD PTR $T6[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN12@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T7[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVDepan
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_time$ = -44						; size = 8
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T8 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVFlow, COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T7[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN25@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN25@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN26@Create_MVF
$LN25@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN26@Create_MVF:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	mov	esi, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN29@Create_MVF
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN29@Create_MVF
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	eax
	fstp	QWORD PTR _time$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 251  : 	if (time<0 || time>100)

	movsd	xmm1, QWORD PTR _time$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	ja	SHORT $LN3@Create_MVF
	movsd	xmm0, QWORD PTR __real@4059000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN2@Create_MVF
$LN3@Create_MVF:

; 252  : 	{
; 253  : 	   env->ThrowError("MVFlow: Time must be from 0 to 100 percent.");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CM@CLNNBAEJ@MVFlow?3?5Time?5must?5be?5from?50?5to?51@
	push	esi
	call	DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _time$[ebp]
	add	esp, 8
	jmp	SHORT $LN135@Create_MVF
$LN29@Create_MVF:
	xorps	xmm1, xmm1
$LN135@Create_MVF:
	movsd	xmm0, QWORD PTR __real@4059000000000000
$LN2@Create_MVF:

; 254  : 	}
; 255  : 	int time256 = int(time*256.0/100.0);

	mulsd	xmm1, QWORD PTR __real@4070000000000000

; 256  : 	return new MVFlow(

	push	504					; 000001f8H
	divsd	xmm1, xmm0
	cvttsd2si edi, xmm1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN33@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN33@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN34@Create_MVF
$LN33@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN34@Create_MVF:

; 1018 :   bool IsClip() const AVS_BakedCode( return AVS_LinkCall(IsClip)() )

	test	eax, eax
	je	SHORT $LN45@Create_MVF
	cmp	DWORD PTR [eax], 332			; 0000014cH
	jbe	SHORT $LN5@Create_MVF
	mov	eax, DWORD PTR [eax+332]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	test	al, al
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	je	SHORT $LN5@Create_MVF
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN41@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN41@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	jmp	SHORT $LN42@Create_MVF
$LN41@Create_MVF:
	lea	eax, DWORD PTR _args$[ebp]
$LN42@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ebx, 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN136@Create_MVF
$LN5@Create_MVF:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN45@Create_MVF
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN45@Create_MVF
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T8[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN45@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	lea	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ebx, 2
$LN136@Create_MVF:
	mov	DWORD PTR $T7[ebp], ebx
	push	esi
	push	ecx
	mov	DWORD PTR $T4[ebp], esp
	mov	edx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN49@Create_MVF
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN49@Create_MVF
	mov	eax, DWORD PTR [eax+232]
	push	ecx
	mov	ecx, edx
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN49@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN53@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN53@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN54@Create_MVF
$LN53@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN54@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN57@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN57@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN58@Create_MVF
$LN57@Create_MVF:
	xor	ecx, ecx
$LN58@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN61@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN61@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN62@Create_MVF
$LN61@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN62@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN65@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN65@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN66@Create_MVF
$LN65@Create_MVF:
	xor	ecx, ecx
$LN66@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN69@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN69@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN70@Create_MVF
$LN69@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN70@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN73@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN73@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN74@Create_MVF
$LN73@Create_MVF:
	xor	ecx, ecx
$LN74@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN77@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN77@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN78@Create_MVF
$LN77@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN78@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN81@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN81@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN82@Create_MVF
$LN81@Create_MVF:
	xor	ecx, ecx
$LN82@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN85@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN85@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN86@Create_MVF
$LN85@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN86@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN89@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN89@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN90@Create_MVF
$LN89@Create_MVF:
	xor	ecx, ecx
$LN90@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN93@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN93@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN94@Create_MVF
$LN93@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN94@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN97@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN97@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN98@Create_MVF
$LN97@Create_MVF:
	xor	ecx, ecx
$LN98@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN101@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN101@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN102@Create_MVF
$LN101@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN102@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T3[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN105@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN105@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN106@Create_MVF
$LN105@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN106@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN109@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN109@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN110@Create_MVF
$LN109@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN110@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, DWORD PTR $T6[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0MVFlow@@QAE@VPClip@@00HH_NHH110PAVIScriptEnvironment@@@Z ; MVFlow::MVFlow
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN113@Create_MVF
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN113@Create_MVF
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN113@Create_MVF:
	or	ebx, 4
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	test	bl, 2
	je	SHORT $LN117@Create_MVF
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T7[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 9
	test	edx, edx
	je	SHORT $LN117@Create_MVF
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN117@Create_MVF
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T8[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN117@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 256  : 	return new MVFlow(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	bl, 1
	je	SHORT $LN122@Create_MVF
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN122@Create_MVF
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN122@Create_MVF
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T5[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN122@Create_MVF:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	edx, edx
	je	SHORT $LN131@Create_MVF
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN131@Create_MVF
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN131@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 270  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	504					; 000001f8H
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	eax, DWORD PTR $T7[ebp]
	and	eax, 1
	je	$LN12@Create_MVF
	and	DWORD PTR $T7[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN12@Create_MVF:
	ret	0
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	eax, DWORD PTR $T7[ebp]
	and	eax, 2
	je	$LN14@Create_MVF
	and	DWORD PTR $T7[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN14@Create_MVF:
	ret	0
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVFlow
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_ml$1$ = -48						; size = 8
_ml$ = -48						; size = 8
_time$ = -48						; size = 8
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
_time256$1$ = -20					; size = 4
$T7 = -20						; size = 4
$T8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T9 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVFlowInter, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T8[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN27@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN27@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN28@Create_MVF
$LN27@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN28@Create_MVF:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	mov	esi, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN31@Create_MVF
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN31@Create_MVF
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1112014848		; 42480000H
	call	eax
	fstp	QWORD PTR _time$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 275  : 	if (time<0 || time>100)

	movsd	xmm0, QWORD PTR _time$[ebp]
	xorps	xmm1, xmm1
	comisd	xmm1, xmm0
	ja	SHORT $LN3@Create_MVF
	movsd	xmm1, QWORD PTR __real@4059000000000000
	comisd	xmm0, xmm1
	ja	SHORT $LN3@Create_MVF
; File c:\github\mvtools\sources\include\avisynth.h

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN2@Create_MVF
$LN3@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 277  : 	   env->ThrowError("MVFlowInter: Time must be from 0 to 100 percent.");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0DB@GLOKBGKK@MVFlowInter?3?5Time?5must?5be?5from?50@
	push	esi
	call	DWORD PTR [eax+20]
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
	movsd	xmm0, QWORD PTR _time$[ebp]
	jmp	SHORT $LN143@Create_MVF
$LN31@Create_MVF:
	xorps	xmm1, xmm1
; File c:\github\mvtools\sources\include\avisynth.h

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	movaps	xmm0, xmm1
$LN143@Create_MVF:
	movsd	xmm1, QWORD PTR __real@4059000000000000
$LN2@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 279  : 	int time256 = int(time*256.0/100.0);

	mulsd	xmm0, QWORD PTR __real@4070000000000000
	divsd	xmm0, xmm1
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _time256$1$[ebp], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN35@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN35@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN36@Create_MVF
$LN35@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN36@Create_MVF:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN39@Create_MVF
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN39@Create_MVF
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	eax
	fstp	QWORD PTR _ml$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 281  : 	if (ml<=0)

	movsd	xmm1, QWORD PTR _ml$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	movsd	QWORD PTR _ml$1$[ebp], xmm1
	jb	SHORT $LN4@Create_MVF
	jmp	SHORT $LN137@Create_MVF
$LN39@Create_MVF:
	xorps	xmm0, xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	movsd	QWORD PTR _ml$1$[ebp], xmm0
$LN137@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 283  : 	   env->ThrowError("MVFlowInter: ML must be > 0.0");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0BO@GMCDCOIB@MVFlowInter?3?5ML?5must?5be?5?$DO?50?40?$AA@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN4@Create_MVF:

; 285  : 	return new MVFlowInter(

	push	880					; 00000370H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T5[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN43@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN43@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN44@Create_MVF
$LN43@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN44@Create_MVF:

; 1018 :   bool IsClip() const AVS_BakedCode( return AVS_LinkCall(IsClip)() )

	test	eax, eax
	je	SHORT $LN55@Create_MVF
	cmp	DWORD PTR [eax], 332			; 0000014cH
	jbe	SHORT $LN6@Create_MVF
	mov	eax, DWORD PTR [eax+332]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	test	al, al
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	je	SHORT $LN6@Create_MVF
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN51@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN51@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	jmp	SHORT $LN52@Create_MVF
$LN51@Create_MVF:
	lea	eax, DWORD PTR _args$[ebp]
$LN52@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ebx, 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN144@Create_MVF
$LN6@Create_MVF:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN55@Create_MVF
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN55@Create_MVF
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T9[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN55@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	lea	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ebx, 2
$LN144@Create_MVF:
	mov	DWORD PTR $T8[ebp], ebx
	push	esi
	push	ecx
	mov	DWORD PTR $T4[ebp], esp
	mov	edx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN59@Create_MVF
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN59@Create_MVF
	mov	eax, DWORD PTR [eax+232]
	push	ecx
	mov	ecx, edx
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN59@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN63@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN63@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN64@Create_MVF
$LN63@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN64@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN67@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN67@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN68@Create_MVF
$LN67@Create_MVF:
	xor	ecx, ecx
$LN68@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN71@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN71@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN72@Create_MVF
$LN71@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN72@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN75@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN75@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN76@Create_MVF
$LN75@Create_MVF:
	xor	ecx, ecx
$LN76@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN79@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN79@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN80@Create_MVF
$LN79@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN80@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN83@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN83@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN84@Create_MVF
$LN83@Create_MVF:
	xor	ecx, ecx
$LN84@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN87@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN87@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN88@Create_MVF
$LN87@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN88@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN91@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN91@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN92@Create_MVF
$LN91@Create_MVF:
	xor	ecx, ecx
$LN92@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN95@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN95@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN96@Create_MVF
$LN95@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN96@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN99@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN99@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN100@Create_MVF
$LN99@Create_MVF:
	xor	ecx, ecx
$LN100@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	movsd	xmm0, QWORD PTR _ml$1$[ebp]
	push	ecx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _time256$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN103@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN103@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN104@Create_MVF
$LN103@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN104@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T7[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN107@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN107@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN108@Create_MVF
$LN107@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN108@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T3[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN111@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN111@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN112@Create_MVF
$LN111@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN112@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN115@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN115@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN116@Create_MVF
$LN115@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN116@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z ; MVFlowInter::MVFlowInter
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN119@Create_MVF
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN119@Create_MVF
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN119@Create_MVF:
	or	ebx, 4
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	test	bl, 2
	je	SHORT $LN123@Create_MVF
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T8[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN123@Create_MVF
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN123@Create_MVF
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T9[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN123@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 285  : 	return new MVFlowInter(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	bl, 1
	je	SHORT $LN128@Create_MVF
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	edx, edx
	je	SHORT $LN128@Create_MVF
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN128@Create_MVF
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T6[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN128@Create_MVF:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	edx, edx
	je	SHORT $LN138@Create_MVF
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN138@Create_MVF
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN138@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 299  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	880					; 00000370H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	eax, DWORD PTR $T8[ebp]
	and	eax, 1
	je	$LN13@Create_MVF
	and	DWORD PTR $T8[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN13@Create_MVF:
	ret	0
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	eax, DWORD PTR $T8[ebp]
	and	eax, 2
	je	$LN15@Create_MVF
	and	DWORD PTR $T8[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN15@Create_MVF:
	ret	0
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR $T7[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVFlowInter
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_ml$1$ = -36						; size = 8
_ml$ = -36						; size = 8
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T6 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVFlowFps, COMDAT

; 302  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN16@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN16@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN17@Create_MVF
$LN16@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN17@Create_MVF:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	mov	esi, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN20@Create_MVF
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN20@Create_MVF
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	eax
	fstp	QWORD PTR _ml$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 304  : 	if (ml<=0)

	movsd	xmm1, QWORD PTR _ml$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	movsd	QWORD PTR _ml$1$[ebp], xmm1
	jb	SHORT $LN2@Create_MVF
	jmp	SHORT $LN111@Create_MVF
$LN20@Create_MVF:
	xorps	xmm0, xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	movsd	QWORD PTR _ml$1$[ebp], xmm0
$LN111@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 306  : 	   env->ThrowError("MVFlowFps: ML must be > 0.0");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0BM@JGLGHEMH@MVFlowFps?3?5ML?5must?5be?5?$DO?50?40?$AA@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@Create_MVF:

; 308  : 	return new MVFlowFps(

	push	920					; 00000398H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN24@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN24@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN25@Create_MVF
$LN24@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN25@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN28@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN28@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN29@Create_MVF
$LN28@Create_MVF:
	xor	ecx, ecx
$LN29@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN32@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN32@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN33@Create_MVF
$LN32@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN33@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN36@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN36@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN37@Create_MVF
$LN36@Create_MVF:
	xor	ecx, ecx
$LN37@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN40@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN40@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN41@Create_MVF
$LN40@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN41@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN44@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN44@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN45@Create_MVF
$LN44@Create_MVF:
	xor	ecx, ecx
$LN45@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN48@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN48@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN49@Create_MVF
$LN48@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN49@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN52@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN52@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN53@Create_MVF
$LN52@Create_MVF:
	xor	ecx, ecx
$LN53@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN56@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN56@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN57@Create_MVF
$LN56@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN57@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN60@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN60@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN61@Create_MVF
$LN60@Create_MVF:
	xor	ecx, ecx
$LN61@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	movsd	xmm0, QWORD PTR _ml$1$[ebp]
	push	ecx
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN64@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN64@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN65@Create_MVF
$LN64@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN65@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN68@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN68@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN69@Create_MVF
$LN68@Create_MVF:
	xor	ecx, ecx
$LN69@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN72@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN72@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN73@Create_MVF
$LN72@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN73@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN76@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN76@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN77@Create_MVF
$LN76@Create_MVF:
	xor	ecx, ecx
$LN77@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN80@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN80@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN81@Create_MVF
$LN80@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN81@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN84@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN84@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	25					; 00000019H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN85@Create_MVF
$LN84@Create_MVF:
	xor	ecx, ecx
$LN85@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN88@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN88@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN89@Create_MVF
$LN88@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN89@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T4[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN92@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN92@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN93@Create_MVF
$LN92@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN93@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T3[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN96@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN96@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN97@Create_MVF
$LN96@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN97@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN100@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN100@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN101@Create_MVF
$LN100@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN101@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0MVFlowFps@@QAE@VPClip@@000IIHN_NHH11PAVIScriptEnvironment@@@Z ; MVFlowFps::MVFlowFps
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 308  : 	return new MVFlowFps(

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN104@Create_MVF
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN104@Create_MVF
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN104@Create_MVF:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	edx, edx
	je	SHORT $LN112@Create_MVF
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN112@Create_MVF
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN112@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 324  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	920					; 00000398H
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVFlowFps
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_time$ = -36						; size = 8
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T6 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVFlowBlur, COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN17@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN17@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN18@Create_MVF
$LN17@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN18@Create_MVF:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	mov	esi, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN21@Create_MVF
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN21@Create_MVF
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1112014848		; 42480000H
	call	eax
	fstp	QWORD PTR _time$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 329  : 	if (time<0 || time>200)

	movsd	xmm1, QWORD PTR _time$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, xmm1
	ja	SHORT $LN3@Create_MVF
	movsd	xmm0, QWORD PTR __real@4069000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN2@Create_MVF
$LN3@Create_MVF:

; 330  : 	{
; 331  : 	   env->ThrowError("MVFlowBlur: Blur time must be from 0 to 200 percent.");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0DF@LGEGMKFC@MVFlowBlur?3?5Blur?5time?5must?5be?5fr@
	push	esi
	call	DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR _time$[ebp]
	add	esp, 8
	jmp	SHORT $LN92@Create_MVF
$LN21@Create_MVF:
	xorps	xmm1, xmm1
$LN92@Create_MVF:
	movsd	xmm0, QWORD PTR __real@4069000000000000
$LN2@Create_MVF:

; 332  : 	}
; 333  : 	int blur256 = int(time*256.0/200.0);

	mulsd	xmm1, QWORD PTR __real@4070000000000000

; 334  : 	return new MVFlowBlur(

	push	776					; 00000308H
	divsd	xmm1, xmm0
	cvttsd2si edi, xmm1
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN25@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN25@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN26@Create_MVF
$LN25@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN26@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN29@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN29@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN30@Create_MVF
$LN29@Create_MVF:
	xor	ecx, ecx
$LN30@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN33@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN33@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN34@Create_MVF
$LN33@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN34@Create_MVF:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN37@Create_MVF
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN37@Create_MVF
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN38@Create_MVF
$LN37@Create_MVF:
	xor	ecx, ecx
$LN38@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN41@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN41@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN42@Create_MVF
$LN41@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN42@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN45@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN45@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN46@Create_MVF
$LN45@Create_MVF:
	xor	ecx, ecx
$LN46@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN49@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN49@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN50@Create_MVF
$LN49@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN50@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN53@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN53@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN54@Create_MVF
$LN53@Create_MVF:
	xor	ecx, ecx
$LN54@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN57@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN57@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN58@Create_MVF
$LN57@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN58@Create_MVF:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN61@Create_MVF
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN61@Create_MVF
	mov	eax, DWORD PTR [eax+380]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN62@Create_MVF
$LN61@Create_MVF:
	xor	ecx, ecx
$LN62@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN65@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN65@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN66@Create_MVF
$LN65@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN66@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T4[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN69@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN69@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN70@Create_MVF
$LN69@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN70@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T3[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN73@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN73@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN74@Create_MVF
$LN73@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN74@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN77@Create_MVF
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN77@Create_MVF
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN78@Create_MVF
$LN77@Create_MVF:
	lea	ecx, DWORD PTR _args$[ebp]
$LN78@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0MVFlowBlur@@QAE@VPClip@@000HHHH_N1PAVIScriptEnvironment@@@Z ; MVFlowBlur::MVFlowBlur
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 334  : 	return new MVFlowBlur(

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN81@Create_MVF
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN81@Create_MVF
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN81@Create_MVF:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	edx, edx
	je	SHORT $LN89@Create_MVF
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN89@Create_MVF
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN89@Create_MVF:
; File c:\github\mvtools\sources\interface.cpp

; 347  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	776					; 00000308H
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVFlowBlur
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
$T8 = -100						; size = 4
$T9 = -96						; size = 4
$T10 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -88						; size = 4
$T13 = -84						; size = 4
$T14 = -80						; size = 4
$T15 = -76						; size = 4
$T16 = -72						; size = 4
$T17 = -68						; size = 4
$T18 = -64						; size = 4
$T19 = -60						; size = 4
$T20 = -56						; size = 4
$T21 = -56						; size = 4
$T22 = -52						; size = 4
$T23 = -52						; size = 4
$T24 = -48						; size = 4
$T25 = -48						; size = 4
$T26 = -44						; size = 4
$T27 = -44						; size = 4
$T28 = -40						; size = 4
$T29 = -40						; size = 4
$T30 = -36						; size = 4
$T31 = -36						; size = 4
_thSAD$1$ = -32						; size = 4
$T32 = -32						; size = 4
_limit$1$ = -28						; size = 4
$T33 = -28						; size = 4
_YUVplanes$1$ = -24					; size = 4
$T34 = -24						; size = 4
_param_index_shift$1$ = -20				; size = 4
$T35 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
$T36 = 20						; size = 4
$T37 = 20						; size = 4
_user_data$ = 20					; size = 4
$T38 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVDegrainX, COMDAT

; 450  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T35[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 451  :   int level = (intptr_t)user_data;
; 452  : 
; 453  :   int plane_param_index = 6; // base: MDegrain1
; 454  :   int thsad_param_index = 4;
; 455  :   int limit_param_index = 7;
; 456  : 
; 457  :   int param_index_shift = 0;

	xor	ebx, ebx

; 458  :   switch (level) {

	mov	eax, DWORD PTR _user_data$[ebp]
	add	eax, -2					; fffffffeH
	mov	DWORD PTR _param_index_shift$1$[ebp], ebx
	cmp	eax, 3
	ja	SHORT $LN2@Create_MVD
	jmp	DWORD PTR $LN421@Create_MVD[eax*4]
$LN6@Create_MVD:

; 459  :     case 5: param_index_shift = 8; break; // new PF 160926 MDegrain5

	mov	ebx, 8
	jmp	SHORT $LN412@Create_MVD
$LN7@Create_MVD:

; 460  :     case 4: param_index_shift = 6; break; // new PF 160926 MDegrain4

	mov	ebx, 6
	jmp	SHORT $LN412@Create_MVD
$LN8@Create_MVD:

; 461  :     case 3: param_index_shift = 4; break;

	mov	ebx, 4
	jmp	SHORT $LN412@Create_MVD
$LN9@Create_MVD:

; 462  :     case 2: param_index_shift = 2; break;

	mov	ebx, 2
$LN412@Create_MVD:
	mov	DWORD PTR _param_index_shift$1$[ebp], ebx
$LN2@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN103@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN103@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 465  : 	int plane = args[plane_param_index+param_index_shift].AsInt(4);

	lea	eax, DWORD PTR [ebx+6]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN104@Create_MVD
$LN103@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN104@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN107@Create_MVD
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN107@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	push	4
	call	eax
; File c:\github\mvtools\sources\interface.cpp

; 468  : 	switch (plane)

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	cmp	eax, 3
	jbe	SHORT $LN407@Create_MVD
$LN14@Create_MVD:

; 482  : 		case 4:
; 483  : 		default:
; 484  : 			YUVplanes = 7;

	mov	DWORD PTR _YUVplanes$1$[ebp], 7
$LN4@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN111@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN111@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 487  : 	int thSAD = args[thsad_param_index+param_index_shift].AsInt(400);  // thSAD

	lea	eax, DWORD PTR [ebx+4]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN112@Create_MVD
$LN107@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	xor	eax, eax
$LN407@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 468  : 	switch (plane)

	jmp	DWORD PTR $LN422@Create_MVD[eax*4]
$LN10@Create_MVD:

; 469  : 	{
; 470  : 		case 0:
; 471  : 			YUVplanes = 1;

	mov	DWORD PTR _YUVplanes$1$[ebp], 1

; 472  : 			break;

	jmp	SHORT $LN4@Create_MVD
$LN11@Create_MVD:

; 473  : 		case 1:
; 474  : 			YUVplanes = 2;

	mov	DWORD PTR _YUVplanes$1$[ebp], 2

; 475  : 			break;

	jmp	SHORT $LN4@Create_MVD
$LN12@Create_MVD:

; 476  : 		case 2:
; 477  : 			YUVplanes = 4;

	mov	DWORD PTR _YUVplanes$1$[ebp], 4

; 478  : 			break;

	jmp	SHORT $LN4@Create_MVD
$LN13@Create_MVD:

; 479  : 		case 3:
; 480  : 			YUVplanes = 6;

	mov	DWORD PTR _YUVplanes$1$[ebp], 6

; 481  : 			break;

	jmp	SHORT $LN4@Create_MVD
$LN111@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	lea	eax, DWORD PTR _args$[ebp]
$LN112@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN115@Create_MVD
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN115@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	push	400					; 00000190H
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _thSAD$1$[ebp], eax
	jmp	SHORT $LN116@Create_MVD
$LN115@Create_MVD:
	mov	DWORD PTR _thSAD$1$[ebp], 0
$LN116@Create_MVD:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN119@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN119@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	jmp	SHORT $LN120@Create_MVD
$LN119@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN120@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 489  :   int bits_per_pixel = args[0].AsClip()->GetVideoInfo().BitsPerComponent();

	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN35@Create_MVD

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN34@Create_MVD
$LN35@Create_MVD:
	push	ecx
; File c:\github\mvtools\sources\interface.cpp

; 489  :   int bits_per_pixel = args[0].AsClip()->GetVideoInfo().BitsPerComponent();

	call	eax
$LN34@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN127@Create_MVD
	cmp	DWORD PTR [edx], 536			; 00000218H
	jbe	SHORT $LN127@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+536]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN128@Create_MVD
$LN127@Create_MVD:
	mov	edi, 8
$LN128@Create_MVD:

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN131@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN131@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T12[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN131@Create_MVD:
	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN136@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN136@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 492  : 	int limit = args[limit_param_index+param_index_shift].AsInt((1 << bits_per_pixel) - 1); // limit. was: 255 for 8 bit

	lea	eax, DWORD PTR [ebx+7]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, eax
	jmp	SHORT $LN137@Create_MVD
$LN136@Create_MVD:
	lea	esi, DWORD PTR _args$[ebp]
$LN137@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN140@Create_MVD
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN140@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 492  : 	int limit = args[limit_param_index+param_index_shift].AsInt((1 << bits_per_pixel) - 1); // limit. was: 255 for 8 bit

	mov	ecx, edi
	mov	eax, 1
	shl	eax, cl
; File c:\github\mvtools\sources\include\avisynth.h

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	mov	ecx, esi
; File c:\github\mvtools\sources\interface.cpp

; 492  : 	int limit = args[limit_param_index+param_index_shift].AsInt((1 << bits_per_pixel) - 1); // limit. was: 255 for 8 bit

	dec	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	push	eax
	mov	eax, DWORD PTR [edx+380]
	call	eax
	mov	DWORD PTR _limit$1$[ebp], eax
	jmp	SHORT $LN141@Create_MVD
$LN140@Create_MVD:
	mov	DWORD PTR _limit$1$[ebp], 0
$LN141@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	376					; 00000178H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	esi, DWORD PTR _user_data$[ebp]
	cmp	esi, 5
	jl	SHORT $LN16@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN144@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN144@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	jmp	SHORT $LN145@Create_MVD
$LN144@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN145@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	DWORD PTR $T36[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ebx, 1
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN413@Create_MVD
$LN16@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN148@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN148@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T11[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN148@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	DWORD PTR $T36[ebp], eax
	mov	ebx, 2
$LN413@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	cmp	esi, 5
	jl	SHORT $LN18@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN152@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN152@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	jmp	SHORT $LN153@Create_MVD
$LN152@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN153@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	DWORD PTR $T30[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	or	ebx, 4
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN414@Create_MVD
$LN18@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	edx, edx
	je	SHORT $LN156@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN156@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T13[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN156@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	DWORD PTR $T30[ebp], eax
	or	ebx, 8
$LN414@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	cmp	esi, 4
	jl	SHORT $LN20@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN160@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN160@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	jmp	SHORT $LN161@Create_MVD
$LN160@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN161@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	DWORD PTR $T28[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	or	ebx, 16					; 00000010H
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN415@Create_MVD
$LN20@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	edx, edx
	je	SHORT $LN164@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN164@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T14[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN164@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	mov	DWORD PTR $T28[ebp], eax
	or	ebx, 32					; 00000020H
$LN415@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	cmp	esi, 4
	jl	SHORT $LN22@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN168@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN168@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	jmp	SHORT $LN169@Create_MVD
$LN168@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN169@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	DWORD PTR $T26[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	or	ebx, 64					; 00000040H
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN416@Create_MVD
$LN22@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	edx, edx
	je	SHORT $LN172@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN172@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T15[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN172@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	DWORD PTR $T26[ebp], eax
	or	ebx, 128				; 00000080H
$LN416@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	cmp	esi, 3
	jl	SHORT $LN24@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN176@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN176@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	jmp	SHORT $LN177@Create_MVD
$LN176@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN177@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	or	ebx, 256				; 00000100H
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN417@Create_MVD
$LN24@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	edx, edx
	je	SHORT $LN180@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN180@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T16[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN180@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	DWORD PTR $T24[ebp], eax
	or	ebx, 512				; 00000200H
$LN417@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	cmp	esi, 3
	jl	SHORT $LN26@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN184@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN184@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	jmp	SHORT $LN185@Create_MVD
$LN184@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN185@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	DWORD PTR $T22[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	or	ebx, 1024				; 00000400H
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN418@Create_MVD
$LN26@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	edx, edx
	je	SHORT $LN188@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN188@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T17[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN188@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR $T17[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	DWORD PTR $T22[ebp], eax
	or	ebx, 2048				; 00000800H
$LN418@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	cmp	esi, 2
	jl	SHORT $LN28@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN192@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN192@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	jmp	SHORT $LN193@Create_MVD
$LN192@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN193@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	or	ebx, 4096				; 00001000H
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN419@Create_MVD
$LN28@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	edx, edx
	je	SHORT $LN196@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN196@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T18[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN196@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR $T18[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	DWORD PTR $T20[ebp], eax
	or	ebx, 8192				; 00002000H
$LN419@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	cmp	esi, 2
	jl	SHORT $LN30@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN200@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN200@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	jmp	SHORT $LN201@Create_MVD
$LN200@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN201@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	edi, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	or	ebx, 16384				; 00004000H
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN420@Create_MVD
$LN30@Create_MVD:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	edx, edx
	je	SHORT $LN204@Create_MVD
	cmp	DWORD PTR [edx], 236			; 000000ecH
	jbe	SHORT $LN204@Create_MVD
	mov	eax, DWORD PTR [edx+236]
	lea	ecx, DWORD PTR $T19[ebp]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN204@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	edi, DWORD PTR $T19[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	or	ebx, 32768				; 00008000H
$LN420@Create_MVD:
	mov	DWORD PTR $T35[ebp], ebx
	push	DWORD PTR _env$[ebp]
	push	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN208@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN208@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	esi, DWORD PTR _param_index_shift$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	lea	ecx, DWORD PTR _args$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+14]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN209@Create_MVD
$LN208@Create_MVD:
	mov	esi, DWORD PTR _param_index_shift$1$[ebp]
	lea	eax, DWORD PTR _args$[ebp]
$LN209@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	edx, edx
	je	SHORT $LN212@Create_MVD
	cmp	DWORD PTR [edx], 376			; 00000178H
	jbe	SHORT $LN212@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+376]
	push	1
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	movzx	eax, al
	jmp	SHORT $LN213@Create_MVD
$LN212@Create_MVD:
	xor	eax, eax
$LN213@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN216@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN216@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+13]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN217@Create_MVD
$LN216@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN217@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	edx, edx
	je	SHORT $LN220@Create_MVD
	cmp	DWORD PTR [edx], 376			; 00000178H
	jbe	SHORT $LN220@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+376]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	movzx	eax, al
	jmp	SHORT $LN221@Create_MVD
$LN220@Create_MVD:
	xor	eax, eax
$LN221@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN224@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN224@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN225@Create_MVD
$LN224@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN225@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	edx, edx
	je	SHORT $LN228@Create_MVD
	cmp	DWORD PTR [edx], 376			; 00000178H
	jbe	SHORT $LN228@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+376]
	push	0
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	movzx	eax, al
	jmp	SHORT $LN229@Create_MVD
$LN228@Create_MVD:
	xor	eax, eax
$LN229@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN232@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN232@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+11]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN233@Create_MVD
$LN232@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN233@Create_MVD:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	edx, edx
	je	SHORT $LN236@Create_MVD
	cmp	DWORD PTR [edx], 376			; 00000178H
	jbe	SHORT $LN236@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+376]
	push	1
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	movzx	eax, al
	jmp	SHORT $LN237@Create_MVD
$LN236@Create_MVD:
	xor	eax, eax
$LN237@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN240@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN240@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+10]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN241@Create_MVD
$LN240@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN241@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN244@Create_MVD
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN244@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	push	130					; 00000082H
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN245@Create_MVD
$LN244@Create_MVD:
	xor	eax, eax
$LN245@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN248@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN248@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+9]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN249@Create_MVD
$LN248@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN249@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN252@Create_MVD
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN252@Create_MVD
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	push	400					; 00000190H
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN253@Create_MVD
$LN252@Create_MVD:
	xor	eax, eax
$LN253@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN256@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN256@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN257@Create_MVD
$LN256@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN257@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN260@Create_MVD
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN260@Create_MVD
	push	DWORD PTR _limit$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN261@Create_MVD
$LN260@Create_MVD:
	xor	eax, eax
$LN261@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
	push	DWORD PTR _limit$1$[ebp]
	push	DWORD PTR _YUVplanes$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN264@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN264@Create_MVD
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	lea	eax, DWORD PTR [esi+5]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	push	eax
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN265@Create_MVD
$LN264@Create_MVD:
	lea	eax, DWORD PTR _args$[ebp]
$LN265@Create_MVD:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN268@Create_MVD
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN268@Create_MVD
	mov	esi, DWORD PTR _thSAD$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	push	esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN269@Create_MVD
$LN268@Create_MVD:
	mov	esi, DWORD PTR _thSAD$1$[ebp]
	xor	eax, eax
$LN269@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	eax
	push	esi
	push	ecx
	mov	DWORD PTR $T38[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN272@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN272@Create_MVD
	push	DWORD PTR $T36[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN272@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	push	ecx
	mov	DWORD PTR $T37[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN276@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN276@Create_MVD
	push	DWORD PTR $T30[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN276@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	push	ecx
	mov	DWORD PTR $T31[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN280@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN280@Create_MVD
	push	DWORD PTR $T28[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN280@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	push	ecx
	mov	DWORD PTR $T29[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN284@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN284@Create_MVD
	push	DWORD PTR $T26[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN284@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	push	ecx
	mov	DWORD PTR $T27[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN288@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN288@Create_MVD
	push	DWORD PTR $T24[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN288@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	push	ecx
	mov	DWORD PTR $T25[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN292@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN292@Create_MVD
	push	DWORD PTR $T22[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN292@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	push	ecx
	mov	DWORD PTR $T23[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN296@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN296@Create_MVD
	push	DWORD PTR $T20[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN296@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	push	ecx
	mov	DWORD PTR $T21[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN300@Create_MVD
	cmp	DWORD PTR [edx], 232			; 000000e8H
	jbe	SHORT $LN300@Create_MVD
	mov	eax, DWORD PTR [edx+232]
	push	edi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN300@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN304@Create_MVD
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN304@Create_MVD
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN305@Create_MVD
$LN304@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN305@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T32[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN308@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN308@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN309@Create_MVD
$LN308@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN309@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T33[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN312@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN312@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN313@Create_MVD
$LN312@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN313@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T34[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN316@Create_MVD
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN316@Create_MVD
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN317@Create_MVD
$LN316@Create_MVD:
	lea	ecx, DWORD PTR _args$[ebp]
$LN317@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, DWORD PTR $T10[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	call	??0MVDegrainX@@QAE@VPClip@@00000000000HHHHHHH_N111HPAVIScriptEnvironment@@@Z ; MVDegrainX::MVDegrainX
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	DWORD PTR __$EHRec$[ebp+8], 46		; 0000002eH
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN320@Create_MVD
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN320@Create_MVD
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN320@Create_MVD:
	or	ebx, 65536				; 00010000H
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 32768				; 00008000H
	je	SHORT $LN324@Create_MVD
	and	ebx, -32769				; ffff7fffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 47		; 0000002fH
	test	edx, edx
	je	SHORT $LN324@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN324@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T19[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN324@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 16384				; 00004000H
	je	SHORT $LN329@Create_MVD
	and	ebx, -16385				; ffffbfffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 48		; 00000030H
	test	edx, edx
	je	SHORT $LN329@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN329@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T9[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN329@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 8192				; 00002000H
	je	SHORT $LN334@Create_MVD
	and	ebx, -8193				; ffffdfffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 49		; 00000031H
	test	edx, edx
	je	SHORT $LN334@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN334@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T18[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN334@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 4096				; 00001000H
	je	SHORT $LN339@Create_MVD
	and	ebx, -4097				; ffffefffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 50		; 00000032H
	test	edx, edx
	je	SHORT $LN339@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN339@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T8[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN339@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 2048				; 00000800H
	je	SHORT $LN344@Create_MVD
	and	ebx, -2049				; fffff7ffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 51		; 00000033H
	test	edx, edx
	je	SHORT $LN344@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN344@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T17[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN344@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 1024				; 00000400H
	je	SHORT $LN349@Create_MVD
	and	ebx, -1025				; fffffbffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 52		; 00000034H
	test	edx, edx
	je	SHORT $LN349@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN349@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T7[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN349@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 512				; 00000200H
	je	SHORT $LN354@Create_MVD
	and	ebx, -513				; fffffdffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 53		; 00000035H
	test	edx, edx
	je	SHORT $LN354@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN354@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T16[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN354@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	ebx, 256				; 00000100H
	je	SHORT $LN359@Create_MVD
	and	ebx, -257				; fffffeffH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 54		; 00000036H
	test	edx, edx
	je	SHORT $LN359@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN359@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T6[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN359@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	bl, bl
	jns	SHORT $LN364@Create_MVD
	and	ebx, -129				; ffffff7fH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 55		; 00000037H
	test	edx, edx
	je	SHORT $LN364@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN364@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T15[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN364@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	bl, 64					; 00000040H
	je	SHORT $LN369@Create_MVD
	and	ebx, -65				; ffffffbfH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 56		; 00000038H
	test	edx, edx
	je	SHORT $LN369@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN369@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T5[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN369@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	bl, 32					; 00000020H
	je	SHORT $LN374@Create_MVD
	and	ebx, -33				; ffffffdfH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 57		; 00000039H
	test	edx, edx
	je	SHORT $LN374@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN374@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T14[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN374@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	bl, 16					; 00000010H
	je	SHORT $LN379@Create_MVD
	and	ebx, -17				; ffffffefH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 58		; 0000003aH
	test	edx, edx
	je	SHORT $LN379@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN379@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T4[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN379@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	bl, 8
	je	SHORT $LN384@Create_MVD
	and	ebx, -9					; fffffff7H
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 59		; 0000003bH
	test	edx, edx
	je	SHORT $LN384@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN384@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T13[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN384@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	bl, 4
	je	SHORT $LN389@Create_MVD
	and	ebx, -5					; fffffffbH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 60		; 0000003cH
	test	edx, edx
	je	SHORT $LN389@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN389@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T3[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN389@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	test	bl, 2
	je	SHORT $LN394@Create_MVD
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T35[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 61		; 0000003dH
	test	edx, edx
	je	SHORT $LN394@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN394@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T11[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN394@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 553  : 	  return new MVDegrainX(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	bl, 1
	je	SHORT $LN399@Create_MVD
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 62		; 0000003eH
	test	edx, edx
	je	SHORT $LN399@Create_MVD
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN399@Create_MVD
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T2[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN399@Create_MVD:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 63		; 0000003fH
	test	edx, edx
	je	SHORT $LN408@Create_MVD
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN408@Create_MVD
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN408@Create_MVD:
; File c:\github\mvtools\sources\interface.cpp

; 581  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN421@Create_MVD:
	DD	$LN9@Create_MVD
	DD	$LN8@Create_MVD
	DD	$LN7@Create_MVD
	DD	$LN6@Create_MVD
$LN422@Create_MVD:
	DD	$LN10@Create_MVD
	DD	$LN11@Create_MVD
	DD	$LN12@Create_MVD
	DD	$LN13@Create_MVD
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$32:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	push	376					; 00000178H
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 1
	je	$LN40@Create_MVD
	and	DWORD PTR $T35[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN40@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 2
	je	$LN42@Create_MVD
	and	DWORD PTR $T35[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN42@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 4
	je	$LN44@Create_MVD
	and	DWORD PTR $T35[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN44@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 8
	je	$LN46@Create_MVD
	and	DWORD PTR $T35[ebp], -9			; fffffff7H
	lea	ecx, DWORD PTR $T13[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN46@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 16					; 00000010H
	je	$LN48@Create_MVD
	and	DWORD PTR $T35[ebp], -17		; ffffffefH
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN48@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 32					; 00000020H
	je	$LN50@Create_MVD
	and	DWORD PTR $T35[ebp], -33		; ffffffdfH
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN50@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 64					; 00000040H
	je	$LN52@Create_MVD
	and	DWORD PTR $T35[ebp], -65		; ffffffbfH
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN52@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 128				; 00000080H
	je	$LN54@Create_MVD
	and	DWORD PTR $T35[ebp], -129		; ffffff7fH
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN54@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 256				; 00000100H
	je	$LN56@Create_MVD
	and	DWORD PTR $T35[ebp], -257		; fffffeffH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN56@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 512				; 00000200H
	je	$LN58@Create_MVD
	and	DWORD PTR $T35[ebp], -513		; fffffdffH
	lea	ecx, DWORD PTR $T16[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN58@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$13:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 1024				; 00000400H
	je	$LN60@Create_MVD
	and	DWORD PTR $T35[ebp], -1025		; fffffbffH
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN60@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$14:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 2048				; 00000800H
	je	$LN62@Create_MVD
	and	DWORD PTR $T35[ebp], -2049		; fffff7ffH
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN62@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$15:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 4096				; 00001000H
	je	$LN64@Create_MVD
	and	DWORD PTR $T35[ebp], -4097		; ffffefffH
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN64@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$16:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 8192				; 00002000H
	je	$LN66@Create_MVD
	and	DWORD PTR $T35[ebp], -8193		; ffffdfffH
	lea	ecx, DWORD PTR $T18[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN66@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$17:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 16384				; 00004000H
	je	$LN68@Create_MVD
	and	DWORD PTR $T35[ebp], -16385		; ffffbfffH
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN68@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$18:
	mov	eax, DWORD PTR $T35[ebp]
	and	eax, 32768				; 00008000H
	je	$LN70@Create_MVD
	and	DWORD PTR $T35[ebp], -32769		; ffff7fffH
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN70@Create_MVD:
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$19:
	mov	ecx, DWORD PTR $T38[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$20:
	mov	ecx, DWORD PTR $T37[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$21:
	mov	ecx, DWORD PTR $T31[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$22:
	mov	ecx, DWORD PTR $T29[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$23:
	mov	ecx, DWORD PTR $T27[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$24:
	mov	ecx, DWORD PTR $T25[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$25:
	mov	ecx, DWORD PTR $T23[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$26:
	mov	ecx, DWORD PTR $T21[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$27:
	mov	ecx, DWORD PTR $T32[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$28:
	mov	ecx, DWORD PTR $T33[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$29:
	mov	ecx, DWORD PTR $T34[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$33:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$34:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$35:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$36:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$37:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$38:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$39:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$40:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$41:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$42:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$43:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$44:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$45:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$46:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$47:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$48:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$49:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVDegrainX
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -132						; size = 4
$T3 = -128						; size = 4
$T4 = -128						; size = 4
$T5 = -124						; size = 4
$T6 = -124						; size = 4
$T7 = -124						; size = 4
$T8 = -120						; size = 4
$T9 = -116						; size = 4
$T10 = -112						; size = 4
$T11 = -108						; size = 4
$T12 = -104						; size = 4
$T13 = -100						; size = 4
$T14 = -96						; size = 4
$T15 = -92						; size = 4
$T16 = -88						; size = 4
$T17 = -84						; size = 4
$T18 = -80						; size = 4
$T19 = -76						; size = 4
$T20 = -72						; size = 4
$T21 = -68						; size = 4
$T22 = -64						; size = 4
$T23 = -60						; size = 4
$T24 = -60						; size = 4
$T25 = -56						; size = 4
$T26 = -56						; size = 4
$T27 = -52						; size = 4
$T28 = -52						; size = 4
$T29 = -48						; size = 4
$T30 = -48						; size = 4
$T31 = -44						; size = 4
$T32 = -44						; size = 4
$T33 = -40						; size = 4
$T34 = -40						; size = 4
_thSAD$1$ = -36						; size = 4
$T35 = -36						; size = 4
_thSADC$1$ = -32					; size = 4
$T36 = -32						; size = 4
_limit$1$ = -28						; size = 4
$T37 = -28						; size = 4
_YUVplanes$1$ = -24					; size = 4
$T38 = -24						; size = 4
_tr$1$ = -20						; size = 4
$T39 = -20						; size = 4
$T40 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
_env$ = 24						; size = 4
?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MDegrainN, COMDAT

; 584  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T40[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN105@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN105@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN106@Create_MDe
$LN105@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN106@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN109@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN109@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	4
	call	eax
	mov	ecx, eax
; File c:\github\mvtools\sources\interface.cpp

; 588  : 	switch (plane)

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	cmp	ecx, 3
	jbe	SHORT $LN510@Create_MDe
$LN8@Create_MDe:

; 602  : 		case 4:
; 603  : 		default:
; 604  : 			YUVplanes = 7;

	mov	DWORD PTR _YUVplanes$1$[ebp], 7
$LN2@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN113@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN113@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN114@Create_MDe
$LN109@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	xor	ecx, ecx
$LN510@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 588  : 	switch (plane)

	jmp	DWORD PTR $LN525@Create_MDe[ecx*4]
$LN4@Create_MDe:

; 589  : 	{
; 590  : 		case 0:
; 591  : 			YUVplanes = 1;

	mov	DWORD PTR _YUVplanes$1$[ebp], 1

; 592  : 			break;

	jmp	SHORT $LN2@Create_MDe
$LN5@Create_MDe:

; 593  : 		case 1:
; 594  : 			YUVplanes = 2;

	mov	DWORD PTR _YUVplanes$1$[ebp], 2

; 595  : 			break;

	jmp	SHORT $LN2@Create_MDe
$LN6@Create_MDe:

; 596  : 		case 2:
; 597  : 			YUVplanes = 4;

	mov	DWORD PTR _YUVplanes$1$[ebp], 4

; 598  : 			break;

	jmp	SHORT $LN2@Create_MDe
$LN7@Create_MDe:

; 599  : 		case 3:
; 600  : 			YUVplanes = 6;

	mov	DWORD PTR _YUVplanes$1$[ebp], 6

; 601  : 			break;

	jmp	SHORT $LN2@Create_MDe
$LN113@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	lea	ecx, DWORD PTR _args$[ebp]
$LN114@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN117@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN117@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	1
	call	eax
	mov	ebx, eax
	mov	DWORD PTR _tr$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN118@Create_MDe
$LN117@Create_MDe:
	xor	ebx, ebx
	mov	DWORD PTR _tr$1$[ebp], ebx
$LN118@Create_MDe:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN121@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN121@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN122@Create_MDe
$LN121@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN122@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN125@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN125@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	esi, eax
	mov	DWORD PTR _thSAD$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN126@Create_MDe
$LN125@Create_MDe:
	xor	esi, esi
	mov	DWORD PTR _thSAD$1$[ebp], esi
$LN126@Create_MDe:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN129@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN129@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN130@Create_MDe
$LN129@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN130@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN133@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN133@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	esi
	call	eax
	mov	DWORD PTR _thSADC$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN134@Create_MDe
$LN133@Create_MDe:
	mov	DWORD PTR _thSADC$1$[ebp], 0
$LN134@Create_MDe:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN137@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN137@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	jmp	SHORT $LN138@Create_MDe
$LN137@Create_MDe:
	lea	eax, DWORD PTR _args$[ebp]
$LN138@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 611  :   int bits_per_pixel = args[0].AsClip()->GetVideoInfo().BitsPerComponent();

	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN33@Create_MDe

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN32@Create_MDe
$LN33@Create_MDe:
	push	ecx
; File c:\github\mvtools\sources\interface.cpp

; 611  :   int bits_per_pixel = args[0].AsClip()->GetVideoInfo().BitsPerComponent();

	call	eax
$LN32@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN145@Create_MDe
	cmp	DWORD PTR [edx], 536			; 00000218H
	jbe	SHORT $LN145@Create_MDe
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+536]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN146@Create_MDe
$LN145@Create_MDe:
	mov	edi, 8
$LN146@Create_MDe:

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN149@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN149@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T7[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN149@Create_MDe:
	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN154@Create_MDe
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN154@Create_MDe
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, eax
	jmp	SHORT $LN155@Create_MDe
$LN154@Create_MDe:
	lea	esi, DWORD PTR _args$[ebp]
$LN155@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN158@Create_MDe
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN158@Create_MDe
; File c:\github\mvtools\sources\interface.cpp

; 613  :   const int limit = args[7].AsInt((1 << bits_per_pixel) - 1); // limit. was: 255 for 8 bit

	mov	ecx, edi
	mov	eax, 1
	shl	eax, cl
; File c:\github\mvtools\sources\include\avisynth.h

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	mov	ecx, esi
; File c:\github\mvtools\sources\interface.cpp

; 613  :   const int limit = args[7].AsInt((1 << bits_per_pixel) - 1); // limit. was: 255 for 8 bit

	dec	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	push	eax
	mov	eax, DWORD PTR [edx+380]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _limit$1$[ebp], eax
	jmp	SHORT $LN159@Create_MDe
$LN158@Create_MDe:
	mov	DWORD PTR _limit$1$[ebp], 0
$LN159@Create_MDe:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN162@Create_MDe
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN162@Create_MDe
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	14					; 0000000eH
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN163@Create_MDe
$LN162@Create_MDe:
	lea	eax, DWORD PTR _args$[ebp]
$LN163@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN166@Create_MDe
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN166@Create_MDe
	push	DWORD PTR _thSAD$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN167@Create_MDe
$LN166@Create_MDe:
	xor	edi, edi
$LN167@Create_MDe:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	edx, edx
	je	SHORT $LN170@Create_MDe
	cmp	DWORD PTR [edx], 324			; 00000144H
	jbe	SHORT $LN170@Create_MDe
	mov	eax, DWORD PTR [edx+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	15					; 0000000fH
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN171@Create_MDe
$LN170@Create_MDe:
	lea	eax, DWORD PTR _args$[ebp]
$LN171@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	edx, edx
	je	SHORT $LN174@Create_MDe
	cmp	DWORD PTR [edx], 380			; 0000017cH
	jbe	SHORT $LN174@Create_MDe
	push	DWORD PTR _thSADC$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+380]
	call	eax
	mov	esi, eax
	jmp	SHORT $LN175@Create_MDe
$LN174@Create_MDe:
	xor	esi, esi
$LN175@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 618  :   if (thSAD2 == thSAD && thSADC == thSADC2)

	cmp	edi, DWORD PTR _thSAD$1$[ebp]
	jne	$LN10@Create_MDe
	cmp	DWORD PTR _thSADC$1$[ebp], esi
	jne	$LN10@Create_MDe

; 619  :   {
; 620  :     if (tr <= MAX_DEGRAIN) // up to MDegrain5 160926

	cmp	ebx, 5
	jg	$LN10@Create_MDe

; 728  :         return new MVDegrainX(

	push	376					; 00000178H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _tr$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	cmp	ecx, 5
	jl	SHORT $LN12@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN178@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN178@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T6[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN178@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T6[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ebx, 1
	jmp	SHORT $LN513@Create_MDe
$LN12@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN182@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN182@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T8[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN182@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	ebx, 2
$LN513@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	mov	DWORD PTR $T33[ebp], edx
	cmp	ecx, 5
	jl	SHORT $LN14@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN186@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN186@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T9[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN186@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	or	ebx, 4
	jmp	SHORT $LN514@Create_MDe
$LN14@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN190@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN190@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T10[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN190@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	or	ebx, 8
$LN514@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	mov	DWORD PTR $T31[ebp], edx
	cmp	ecx, 4
	jl	SHORT $LN16@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN194@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN194@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T11[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN194@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	or	ebx, 16					; 00000010H
	jmp	SHORT $LN515@Create_MDe
$LN16@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN198@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN198@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T12[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN198@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	or	ebx, 32					; 00000020H
$LN515@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	mov	DWORD PTR $T29[ebp], edx
	cmp	ecx, 4
	jl	SHORT $LN18@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN202@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN202@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T13[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN202@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	or	ebx, 64					; 00000040H
	jmp	SHORT $LN516@Create_MDe
$LN18@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN206@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN206@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T14[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN206@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T14[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	or	ebx, 128				; 00000080H
$LN516@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	mov	DWORD PTR $T27[ebp], edx
	cmp	ecx, 3
	jl	SHORT $LN20@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN210@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN210@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T15[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN210@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T15[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	or	ebx, 256				; 00000100H
	jmp	SHORT $LN517@Create_MDe
$LN20@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN214@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN214@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T16[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN214@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T16[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	or	ebx, 512				; 00000200H
$LN517@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	mov	DWORD PTR $T25[ebp], edx
	cmp	ecx, 3
	jl	SHORT $LN22@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN218@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN218@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T17[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN218@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T17[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	or	ebx, 1024				; 00000400H
	jmp	SHORT $LN518@Create_MDe
$LN22@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN222@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN222@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T18[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN222@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edx, DWORD PTR $T18[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	or	ebx, 2048				; 00000800H
$LN518@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	mov	DWORD PTR $T23[ebp], edx
	cmp	ecx, 2
	jl	SHORT $LN24@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN226@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN226@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T19[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN226@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edi, DWORD PTR $T19[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	or	ebx, 4096				; 00001000H
	jmp	SHORT $LN519@Create_MDe
$LN24@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN230@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN230@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T20[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN230@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	edi, DWORD PTR $T20[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	or	ebx, 8192				; 00002000H
$LN519@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	cmp	ecx, 2
	jl	SHORT $LN26@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN234@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN234@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR $T21[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN234@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	esi, DWORD PTR $T21[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	or	ebx, 16384				; 00004000H
	jmp	SHORT $LN520@Create_MDe
$LN26@Create_MDe:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN238@Create_MDe
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN238@Create_MDe
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T22[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, DWORD PTR _tr$1$[ebp]
$LN238@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	lea	esi, DWORD PTR $T22[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	or	ebx, 32768				; 00008000H
$LN520@Create_MDe:
	mov	DWORD PTR $T40[ebp], ebx
	push	DWORD PTR _env$[ebp]
	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN242@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN242@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	16					; 00000010H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN243@Create_MDe
$LN242@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN243@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN246@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN246@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN247@Create_MDe
$LN246@Create_MDe:
	xor	ecx, ecx
$LN247@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN250@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN250@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN251@Create_MDe
$LN250@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN251@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN254@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN254@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN255@Create_MDe
$LN254@Create_MDe:
	xor	ecx, ecx
$LN255@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN258@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN258@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN259@Create_MDe
$LN258@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN259@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN262@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN262@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN263@Create_MDe
$LN262@Create_MDe:
	xor	ecx, ecx
$LN263@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN266@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN266@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN267@Create_MDe
$LN266@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN267@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN270@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN270@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN271@Create_MDe
$LN270@Create_MDe:
	xor	ecx, ecx
$LN271@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN274@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN274@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN275@Create_MDe
$LN274@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN275@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN278@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN278@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN279@Create_MDe
$LN278@Create_MDe:
	xor	ecx, ecx
$LN279@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN282@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN282@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN283@Create_MDe
$LN282@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN283@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN286@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN286@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN287@Create_MDe
$LN286@Create_MDe:
	xor	ecx, ecx
$LN287@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN290@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN290@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN291@Create_MDe
$LN290@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN291@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN294@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN294@Create_MDe
	push	DWORD PTR _limit$1$[ebp]
	mov	eax, DWORD PTR [eax+380]
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN295@Create_MDe
$LN294@Create_MDe:
	xor	ecx, ecx
$LN295@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
	push	DWORD PTR _limit$1$[ebp]
	push	DWORD PTR _YUVplanes$1$[ebp]
	push	DWORD PTR _thSADC$1$[ebp]
	push	DWORD PTR _thSAD$1$[ebp]
	push	ecx
	mov	DWORD PTR $T35[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN298@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN298@Create_MDe
	push	DWORD PTR $T33[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN298@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	push	ecx
	mov	DWORD PTR $T34[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN302@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN302@Create_MDe
	push	DWORD PTR $T31[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN302@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	push	ecx
	mov	DWORD PTR $T32[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN306@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN306@Create_MDe
	push	DWORD PTR $T29[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN306@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	push	ecx
	mov	DWORD PTR $T30[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN310@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN310@Create_MDe
	push	DWORD PTR $T27[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN310@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	push	ecx
	mov	DWORD PTR $T28[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN314@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN314@Create_MDe
	push	DWORD PTR $T25[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN314@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	push	ecx
	mov	DWORD PTR $T26[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN318@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN318@Create_MDe
	push	DWORD PTR $T23[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN318@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	push	ecx
	mov	DWORD PTR $T24[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN322@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN322@Create_MDe
	mov	eax, DWORD PTR [eax+232]
	push	edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN322@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	push	ecx
	mov	DWORD PTR $T36[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN326@Create_MDe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN326@Create_MDe
	mov	eax, DWORD PTR [eax+232]
	push	esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN326@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	push	ecx
	mov	DWORD PTR $T37[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	test	eax, eax
	je	SHORT $LN330@Create_MDe
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN330@Create_MDe
	mov	eax, DWORD PTR [eax+228]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN330@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN334@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN334@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN335@Create_MDe
$LN334@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN335@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T38[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN338@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN338@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN339@Create_MDe
$LN338@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN339@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T39[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN342@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN342@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN343@Create_MDe
$LN342@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN343@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	call	??0MVDegrainX@@QAE@VPClip@@00000000000HHHHHHH_N111HPAVIScriptEnvironment@@@Z ; MVDegrainX::MVDegrainX
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	DWORD PTR __$EHRec$[ebp+8], 46		; 0000002eH
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN346@Create_MDe
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN346@Create_MDe
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN346@Create_MDe:
	or	ebx, 65536				; 00010000H
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 32768				; 00008000H
	je	SHORT $LN350@Create_MDe
	and	ebx, -32769				; ffff7fffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 47		; 0000002fH
	test	edx, edx
	je	SHORT $LN350@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN350@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T22[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN350@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 16384				; 00004000H
	je	SHORT $LN355@Create_MDe
	and	ebx, -16385				; ffffbfffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 48		; 00000030H
	test	edx, edx
	je	SHORT $LN355@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN355@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T21[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN355@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 8192				; 00002000H
	je	SHORT $LN360@Create_MDe
	and	ebx, -8193				; ffffdfffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 49		; 00000031H
	test	edx, edx
	je	SHORT $LN360@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN360@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T20[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN360@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 4096				; 00001000H
	je	SHORT $LN365@Create_MDe
	and	ebx, -4097				; ffffefffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 50		; 00000032H
	test	edx, edx
	je	SHORT $LN365@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN365@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T19[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN365@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 2048				; 00000800H
	je	SHORT $LN370@Create_MDe
	and	ebx, -2049				; fffff7ffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 51		; 00000033H
	test	edx, edx
	je	SHORT $LN370@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN370@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T18[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN370@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 1024				; 00000400H
	je	SHORT $LN375@Create_MDe
	and	ebx, -1025				; fffffbffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 52		; 00000034H
	test	edx, edx
	je	SHORT $LN375@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN375@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T17[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN375@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 512				; 00000200H
	je	SHORT $LN380@Create_MDe
	and	ebx, -513				; fffffdffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 53		; 00000035H
	test	edx, edx
	je	SHORT $LN380@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN380@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T16[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN380@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	ebx, 256				; 00000100H
	je	SHORT $LN385@Create_MDe
	and	ebx, -257				; fffffeffH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 54		; 00000036H
	test	edx, edx
	je	SHORT $LN385@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN385@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T15[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN385@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	bl, bl
	jns	SHORT $LN390@Create_MDe
	and	ebx, -129				; ffffff7fH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 55		; 00000037H
	test	edx, edx
	je	SHORT $LN390@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN390@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T14[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN390@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	bl, 64					; 00000040H
	je	SHORT $LN395@Create_MDe
	and	ebx, -65				; ffffffbfH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 56		; 00000038H
	test	edx, edx
	je	SHORT $LN395@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN395@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T13[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN395@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	bl, 32					; 00000020H
	je	SHORT $LN400@Create_MDe
	and	ebx, -33				; ffffffdfH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 57		; 00000039H
	test	edx, edx
	je	SHORT $LN400@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN400@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T12[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN400@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	bl, 16					; 00000010H
	je	SHORT $LN405@Create_MDe
	and	ebx, -17				; ffffffefH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 58		; 0000003aH
	test	edx, edx
	je	SHORT $LN405@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN405@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T11[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN405@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	bl, 8
	je	SHORT $LN410@Create_MDe
	and	ebx, -9					; fffffff7H
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 59		; 0000003bH
	test	edx, edx
	je	SHORT $LN410@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN410@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T10[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN410@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	bl, 4
	je	SHORT $LN415@Create_MDe
	and	ebx, -5					; fffffffbH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 60		; 0000003cH
	test	edx, edx
	je	SHORT $LN415@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN415@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T9[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN415@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	test	bl, 2
	je	SHORT $LN420@Create_MDe
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T40[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 61		; 0000003dH
	test	edx, edx
	je	SHORT $LN420@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN420@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T8[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN420@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	bl, 1
	je	SHORT $LN425@Create_MDe
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 62		; 0000003eH
	test	edx, edx
	je	SHORT $LN425@Create_MDe
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN425@Create_MDe
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T6[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN425@Create_MDe:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 63		; 0000003fH
; File c:\github\mvtools\sources\interface.cpp

; 728  :         return new MVDegrainX(

	jmp	$LN524@Create_MDe
$LN10@Create_MDe:

; 759  : 	return new MDegrainN (

	push	3704					; 00000e78H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	push	DWORD PTR _env$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 64		; 00000040H
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN435@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN435@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	16					; 00000010H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN436@Create_MDe
$LN435@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN436@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN439@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN439@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN440@Create_MDe
$LN439@Create_MDe:
	xor	ecx, ecx
$LN440@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
	push	esi
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN443@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN443@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN444@Create_MDe
$LN443@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN444@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN447@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN447@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN448@Create_MDe
$LN447@Create_MDe:
	xor	ecx, ecx
$LN448@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN451@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN451@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN452@Create_MDe
$LN451@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN452@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN455@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN455@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN456@Create_MDe
$LN455@Create_MDe:
	xor	ecx, ecx
$LN456@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN459@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN459@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN460@Create_MDe
$LN459@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN460@Create_MDe:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN463@Create_MDe
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN463@Create_MDe
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN464@Create_MDe
$LN463@Create_MDe:
	xor	ecx, ecx
$LN464@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN467@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN467@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN468@Create_MDe
$LN467@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN468@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN471@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN471@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN472@Create_MDe
$LN471@Create_MDe:
	xor	ecx, ecx
$LN472@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN475@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN475@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN476@Create_MDe
$LN475@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN476@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN479@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN479@Create_MDe
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN480@Create_MDe
$LN479@Create_MDe:
	xor	ecx, ecx
$LN480@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN483@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN483@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN484@Create_MDe
$LN483@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN484@Create_MDe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN487@Create_MDe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN487@Create_MDe
	push	DWORD PTR _limit$1$[ebp]
	mov	eax, DWORD PTR [eax+380]
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN488@Create_MDe
$LN487@Create_MDe:
	xor	ecx, ecx
$LN488@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
	push	DWORD PTR _limit$1$[ebp]
	push	DWORD PTR _YUVplanes$1$[ebp]
	push	DWORD PTR _thSADC$1$[ebp]
	push	DWORD PTR _thSAD$1$[ebp]
	push	ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN491@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN491@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN492@Create_MDe
$LN491@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN492@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 65		; 00000041H
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN495@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN495@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN496@Create_MDe
$LN495@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN496@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T5[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 66		; 00000042H
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN499@Create_MDe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN499@Create_MDe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN500@Create_MDe
$LN499@Create_MDe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN500@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 64		; 00000040H
	call	??0MDegrainN@@QAE@VPClip@@00HHHHHHHH_N11HH1PAVIScriptEnvironment@@@Z ; MDegrainN::MDegrainN
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 759  : 	return new MDegrainN (

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN503@Create_MDe
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN503@Create_MDe
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN503@Create_MDe:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 67		; 00000043H
$LN524@Create_MDe:
	test	edx, edx
	je	SHORT $LN507@Create_MDe
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN507@Create_MDe
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN507@Create_MDe:
; File c:\github\mvtools\sources\interface.cpp

; 779  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN525@Create_MDe:
	DD	$LN4@Create_MDe
	DD	$LN5@Create_MDe
	DD	$LN6@Create_MDe
	DD	$LN7@Create_MDe
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$36:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	push	376					; 00000178H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 1
	je	$LN38@Create_MDe
	and	DWORD PTR $T40[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN38@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 2
	je	$LN40@Create_MDe
	and	DWORD PTR $T40[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN40@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 4
	je	$LN42@Create_MDe
	and	DWORD PTR $T40[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN42@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$6:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 8
	je	$LN44@Create_MDe
	and	DWORD PTR $T40[ebp], -9			; fffffff7H
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN44@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 16					; 00000010H
	je	$LN46@Create_MDe
	and	DWORD PTR $T40[ebp], -17		; ffffffefH
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN46@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 32					; 00000020H
	je	$LN48@Create_MDe
	and	DWORD PTR $T40[ebp], -33		; ffffffdfH
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN48@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 64					; 00000040H
	je	$LN50@Create_MDe
	and	DWORD PTR $T40[ebp], -65		; ffffffbfH
	lea	ecx, DWORD PTR $T13[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN50@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$10:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 128				; 00000080H
	je	$LN52@Create_MDe
	and	DWORD PTR $T40[ebp], -129		; ffffff7fH
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN52@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$11:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 256				; 00000100H
	je	$LN54@Create_MDe
	and	DWORD PTR $T40[ebp], -257		; fffffeffH
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN54@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$12:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 512				; 00000200H
	je	$LN56@Create_MDe
	and	DWORD PTR $T40[ebp], -513		; fffffdffH
	lea	ecx, DWORD PTR $T16[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN56@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$13:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 1024				; 00000400H
	je	$LN58@Create_MDe
	and	DWORD PTR $T40[ebp], -1025		; fffffbffH
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN58@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$14:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 2048				; 00000800H
	je	$LN60@Create_MDe
	and	DWORD PTR $T40[ebp], -2049		; fffff7ffH
	lea	ecx, DWORD PTR $T18[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN60@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$15:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 4096				; 00001000H
	je	$LN62@Create_MDe
	and	DWORD PTR $T40[ebp], -4097		; ffffefffH
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN62@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$16:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 8192				; 00002000H
	je	$LN64@Create_MDe
	and	DWORD PTR $T40[ebp], -8193		; ffffdfffH
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN64@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$17:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 16384				; 00004000H
	je	$LN66@Create_MDe
	and	DWORD PTR $T40[ebp], -16385		; ffffbfffH
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN66@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$18:
	mov	eax, DWORD PTR $T40[ebp]
	and	eax, 32768				; 00008000H
	je	$LN68@Create_MDe
	and	DWORD PTR $T40[ebp], -32769		; ffff7fffH
	lea	ecx, DWORD PTR $T22[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN68@Create_MDe:
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$19:
	mov	ecx, DWORD PTR $T35[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$20:
	mov	ecx, DWORD PTR $T34[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$21:
	mov	ecx, DWORD PTR $T32[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$22:
	mov	ecx, DWORD PTR $T30[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$23:
	mov	ecx, DWORD PTR $T28[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$24:
	mov	ecx, DWORD PTR $T26[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$25:
	mov	ecx, DWORD PTR $T24[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$26:
	mov	ecx, DWORD PTR $T36[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$27:
	mov	ecx, DWORD PTR $T37[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$28:
	mov	ecx, DWORD PTR $T38[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$29:
	mov	ecx, DWORD PTR $T39[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$37:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$38:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$39:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$40:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$41:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$42:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$43:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$44:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$45:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$46:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$47:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$48:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$49:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$50:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$51:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$52:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$53:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$32:
	push	3704					; 00000e78H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$33:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$34:
	mov	ecx, DWORD PTR $T5[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$54:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MDegrainN
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_blksize$1$ = -20					; size = 4
_blksizeV$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T4 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVRecalculate, COMDAT

; 782  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN15@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN15@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN16@Create_MVR
$LN15@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN16@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN19@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN19@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	8
	call	eax
	mov	edi, eax
	mov	DWORD PTR _blksize$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN20@Create_MVR
$LN19@Create_MVR:
	xor	edi, edi
	mov	DWORD PTR _blksize$1$[ebp], edi
$LN20@Create_MVR:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN23@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN23@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN24@Create_MVR
$LN23@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN24@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN27@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN27@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	edi
	call	eax
	mov	DWORD PTR _blksizeV$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN28@Create_MVR
$LN27@Create_MVR:
	mov	DWORD PTR _blksizeV$1$[ebp], 0
$LN28@Create_MVR:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN31@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN31@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN32@Create_MVR
$LN31@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN32@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN35@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN35@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ebx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN36@Create_MVR
$LN35@Create_MVR:
	xor	ebx, ebx
$LN36@Create_MVR:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN39@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN39@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN40@Create_MVR
$LN39@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN40@Create_MVR:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	$LN63@Create_MVR
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	$LN2@Create_MVR
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
; File c:\github\mvtools\sources\interface.cpp

; 792  : 	if (truemotion)

	test	al, al
	je	$LN208@Create_MVR
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN47@Create_MVR
	cmp	DWORD PTR [esi], 324			; 00000144H
	jbe	SHORT $LN47@Create_MVR
	mov	eax, DWORD PTR [esi+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN48@Create_MVR
$LN47@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN48@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	esi, esi
	je	SHORT $LN51@Create_MVR
	cmp	DWORD PTR [esi], 380			; 0000017cH
	jbe	SHORT $LN51@Create_MVR
; File c:\github\mvtools\sources\interface.cpp

; 794  : 		lambda = args[ 8].AsInt(1000*blksize*blksizeV/64);

	mov	eax, DWORD PTR _blksizeV$1$[ebp]
	imul	eax, edi
	imul	eax, eax, 1000
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
; File c:\github\mvtools\sources\include\avisynth.h

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	push	eax
	mov	eax, DWORD PTR [esi+380]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN52@Create_MVR
$LN51@Create_MVR:
	xor	edi, edi
$LN52@Create_MVR:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	esi, esi
	je	SHORT $LN55@Create_MVR
	cmp	DWORD PTR [esi], 324			; 00000144H
	jbe	SHORT $LN55@Create_MVR
	mov	eax, DWORD PTR [esi+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN56@Create_MVR
$LN55@Create_MVR:
	lea	eax, DWORD PTR _args$[ebp]
$LN56@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	esi, esi
	je	$LN75@Create_MVR
	cmp	DWORD PTR [esi], 380			; 0000017cH
	jbe	$LN75@Create_MVR
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+380]
	push	50					; 00000032H
	call	eax
	mov	esi, eax
	jmp	$LN76@Create_MVR
$LN208@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 797  : 	else // old versions 0.9.9.1 compatibility mode

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN2@Create_MVR:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN63@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN63@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN64@Create_MVR
$LN63@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN64@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN67@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN67@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN68@Create_MVR
$LN67@Create_MVR:
	xor	edi, edi
$LN68@Create_MVR:

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN71@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN71@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN72@Create_MVR
$LN71@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN72@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN75@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN75@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	esi, eax
	jmp	SHORT $LN76@Create_MVR
$LN75@Create_MVR:
	xor	esi, esi
$LN76@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	584					; 00000248H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN79@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN79@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	21					; 00000015H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN80@Create_MVR
$LN79@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN80@Create_MVR:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN83@Create_MVR
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN83@Create_MVR
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN84@Create_MVR
$LN83@Create_MVR:
	xor	ecx, ecx
$LN84@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN87@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN87@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	20					; 00000014H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN88@Create_MVR
$LN87@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN88@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN91@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN91@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN92@Create_MVR
$LN91@Create_MVR:
	xor	ecx, ecx
$LN92@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN95@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN95@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	19					; 00000013H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN96@Create_MVR
$LN95@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN96@Create_MVR:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN99@Create_MVR
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN99@Create_MVR
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN100@Create_MVR
$LN99@Create_MVR:
	xor	ecx, ecx
$LN100@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN103@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN103@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	18					; 00000012H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN104@Create_MVR
$LN103@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN104@Create_MVR:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN107@Create_MVR
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN107@Create_MVR
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN108@Create_MVR
$LN107@Create_MVR:
	xor	ecx, ecx
$LN108@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN111@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN111@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	17					; 00000011H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN112@Create_MVR
$LN111@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN112@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN115@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN115@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN115@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN119@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN119@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	16					; 00000010H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN120@Create_MVR
$LN119@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN120@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN123@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN123@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN124@Create_MVR
$LN123@Create_MVR:
	xor	ecx, ecx
$LN124@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN127@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN127@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	15					; 0000000fH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN128@Create_MVR
$LN127@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN128@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN131@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN131@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN132@Create_MVR
$LN131@Create_MVR:
	xor	ecx, ecx
$LN132@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN135@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN135@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	14					; 0000000eH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN136@Create_MVR
$LN135@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN136@Create_MVR:

; 1039 :   const char* AsString(const char* def) const AVS_BakedCode( return AVS_LinkCall(AsString2)(def) )

	test	eax, eax
	je	SHORT $LN139@Create_MVR
	cmp	DWORD PTR [eax], 392			; 00000188H
	jbe	SHORT $LN139@Create_MVR
	mov	eax, DWORD PTR [eax+392]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN140@Create_MVR
$LN139@Create_MVR:
	xor	ecx, ecx
$LN140@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN143@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN143@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN144@Create_MVR
$LN143@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN144@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN147@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN147@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN148@Create_MVR
$LN147@Create_MVR:
	xor	ecx, ecx
$LN148@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
	push	ebx
	push	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN151@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN151@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN152@Create_MVR
$LN151@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN152@Create_MVR:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN155@Create_MVR
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN155@Create_MVR
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN156@Create_MVR
$LN155@Create_MVR:
	xor	ecx, ecx
$LN156@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN159@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN159@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN160@Create_MVR
$LN159@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN160@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN163@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN163@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN164@Create_MVR
$LN163@Create_MVR:
	xor	ecx, ecx
$LN164@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN167@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN167@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN168@Create_MVR
$LN167@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN168@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN171@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN171@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN172@Create_MVR
$LN171@Create_MVR:
	xor	ecx, ecx
$LN172@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
	push	DWORD PTR _blksizeV$1$[ebp]
	push	DWORD PTR _blksize$1$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN175@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN175@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN176@Create_MVR
$LN175@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN176@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN179@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN179@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN180@Create_MVR
$LN179@Create_MVR:
	xor	ecx, ecx
$LN180@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN183@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN183@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN184@Create_MVR
$LN183@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN184@Create_MVR:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN187@Create_MVR
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN187@Create_MVR
	mov	eax, DWORD PTR [eax+380]
	push	200					; 000000c8H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN188@Create_MVR
$LN187@Create_MVR:
	xor	ecx, ecx
$LN188@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN191@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN191@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN192@Create_MVR
$LN191@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN192@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T4[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN195@Create_MVR
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN195@Create_MVR
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN196@Create_MVR
$LN195@Create_MVR:
	lea	ecx, DWORD PTR _args$[ebp]
$LN196@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0MVRecalculate@@QAE@VPClip@@0HHHHHHH_NHHHPBDHHH11H1PAVIScriptEnvironment@@@Z ; MVRecalculate::MVRecalculate
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 802  :    return new MVRecalculate (

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN199@Create_MVR
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN199@Create_MVR
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN199@Create_MVR:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN206@Create_MVR
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN206@Create_MVR
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN206@Create_MVR:
; File c:\github\mvtools\sources\interface.cpp

; 826  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	584					; 00000248H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVRecalculate
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
tv375 = -36						; size = 8
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T6 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVBlockFps, COMDAT

; 829  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR $T5[ebp], 0

; 830  : 	return new MVBlockFps(

	push	864					; 00000360H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN15@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN15@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	13					; 0000000dH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN16@Create_MVB
$LN15@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN16@Create_MVB:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN19@Create_MVB
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN19@Create_MVB
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN20@Create_MVB
$LN19@Create_MVB:
	xor	ecx, ecx
$LN20@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN23@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN23@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	12					; 0000000cH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN24@Create_MVB
$LN23@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN24@Create_MVB:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN27@Create_MVB
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN27@Create_MVB
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN28@Create_MVB
$LN27@Create_MVB:
	xor	ecx, ecx
$LN28@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN31@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN31@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN32@Create_MVB
$LN31@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN32@Create_MVB:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN35@Create_MVB
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN35@Create_MVB
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN36@Create_MVB
$LN35@Create_MVB:
	xor	ecx, ecx
$LN36@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN39@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN39@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN40@Create_MVB
$LN39@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN40@Create_MVB:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN43@Create_MVB
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN43@Create_MVB
	mov	eax, DWORD PTR [eax+380]
	push	130					; 00000082H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN44@Create_MVB
$LN43@Create_MVB:
	xor	ecx, ecx
$LN44@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN47@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN47@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN48@Create_MVB
$LN47@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN48@Create_MVB:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN51@Create_MVB
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN51@Create_MVB
	mov	eax, DWORD PTR [eax+380]
	push	400					; 00000190H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN52@Create_MVB
$LN51@Create_MVB:
	xor	ecx, ecx
$LN52@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN55@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN55@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN56@Create_MVB
$LN55@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN56@Create_MVB:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN59@Create_MVB
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN59@Create_MVB
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN60@Create_MVB
$LN59@Create_MVB:
	xor	ecx, ecx
$LN60@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN63@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN63@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN64@Create_MVB
$LN63@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN64@Create_MVB:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN67@Create_MVB
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN67@Create_MVB
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1120403456		; 42c80000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv375[ebp]
	movsd	xmm0, QWORD PTR tv375[ebp]
	jmp	SHORT $LN68@Create_MVB
$LN67@Create_MVB:
	xorps	xmm0, xmm0
$LN68@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN71@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN71@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN72@Create_MVB
$LN71@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN72@Create_MVB:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN75@Create_MVB
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN75@Create_MVB
	mov	eax, DWORD PTR [eax+380]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN76@Create_MVB
$LN75@Create_MVB:
	xor	ecx, ecx
$LN76@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN79@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN79@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN80@Create_MVB
$LN79@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN80@Create_MVB:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN83@Create_MVB
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN83@Create_MVB
	mov	eax, DWORD PTR [eax+380]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN84@Create_MVB
$LN83@Create_MVB:
	xor	ecx, ecx
$LN84@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN87@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN87@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN88@Create_MVB
$LN87@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN88@Create_MVB:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN91@Create_MVB
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN91@Create_MVB
	mov	eax, DWORD PTR [eax+380]
	push	25					; 00000019H
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN92@Create_MVB
$LN91@Create_MVB:
	xor	ecx, ecx
$LN92@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN95@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN95@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN96@Create_MVB
$LN95@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN96@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T6[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN99@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN99@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN100@Create_MVB
$LN99@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN100@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T3[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN103@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN103@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN104@Create_MVB
$LN103@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN104@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T2[ebp], esp
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN107@Create_MVB
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN107@Create_MVB
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN108@Create_MVB
$LN107@Create_MVB:
	lea	ecx, DWORD PTR _args$[ebp]
$LN108@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z ; MVBlockFps::MVBlockFps
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 830  : 	return new MVBlockFps(

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN111@Create_MVB
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN111@Create_MVB
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN111@Create_MVB:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	edx, edx
	je	SHORT $LN118@Create_MVB
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN118@Create_MVB
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN118@Create_MVB:
; File c:\github\mvtools\sources\interface.cpp

; 847  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	864					; 00000360H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVBlockFps
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T6 = 24						; size = 4
_env$ = 24						; size = 4
?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MVSuper, COMDAT

; 850  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T5[ebp], 0

; 851  :    return new MVSuper(

	push	160					; 000000a0H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN21@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN21@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN22@Create_MVS
$LN21@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN22@Create_MVS:

; 1017 :   bool Defined() const AVS_BakedCode( return AVS_LinkCall(Defined)() )

	test	eax, eax
	je	SHORT $LN33@Create_MVS
	cmp	DWORD PTR [eax], 328			; 00000148H
	jbe	SHORT $LN3@Create_MVS
	mov	eax, DWORD PTR [eax+328]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	test	al, al
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	je	SHORT $LN3@Create_MVS
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN29@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN29@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	8
	call	eax
	jmp	SHORT $LN30@Create_MVS
$LN29@Create_MVS:
	lea	eax, DWORD PTR _args$[ebp]
$LN30@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ebx, 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN146@Create_MVS
$LN3@Create_MVS:
; File c:\github\mvtools\sources\include\avisynth.h

; 938  :   PClip(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR2)(x) )

	test	eax, eax
	je	SHORT $LN33@Create_MVS
	cmp	DWORD PTR [eax], 236			; 000000ecH
	jbe	SHORT $LN33@Create_MVS
	mov	eax, DWORD PTR [eax+236]
	lea	ecx, DWORD PTR $T4[ebp]
	push	0
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN33@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	lea	esi, DWORD PTR $T4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ebx, 2
$LN146@Create_MVS:
	mov	DWORD PTR $T5[ebp], ebx
	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN37@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN37@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	11					; 0000000bH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN38@Create_MVS
$LN37@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN38@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN41@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN41@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN42@Create_MVS
$LN41@Create_MVS:
	xor	ecx, ecx
$LN42@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN45@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN45@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	10					; 0000000aH
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN46@Create_MVS
$LN45@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN46@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN49@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN49@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN50@Create_MVS
$LN49@Create_MVS:
	xor	ecx, ecx
$LN50@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN53@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN53@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	9
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN54@Create_MVS
$LN53@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN54@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN57@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN57@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN58@Create_MVS
$LN57@Create_MVS:
	xor	ecx, ecx
$LN58@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
	push	ecx
	mov	DWORD PTR $T6[ebp], esp
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN61@Create_MVS
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN61@Create_MVS
	mov	eax, DWORD PTR [eax+232]
	push	esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN61@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN65@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN65@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	7
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN66@Create_MVS
$LN65@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN66@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN69@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN69@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN70@Create_MVS
$LN69@Create_MVS:
	xor	ecx, ecx
$LN70@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN73@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN73@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	6
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN74@Create_MVS
$LN73@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN74@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN77@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN77@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN78@Create_MVS
$LN77@Create_MVS:
	xor	ecx, ecx
$LN78@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN81@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN81@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN82@Create_MVS
$LN81@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN82@Create_MVS:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN85@Create_MVS
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN85@Create_MVS
	mov	eax, DWORD PTR [eax+376]
	push	1
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN86@Create_MVS
$LN85@Create_MVS:
	xor	ecx, ecx
$LN86@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN89@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN89@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN90@Create_MVS
$LN89@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN90@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN93@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN93@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN94@Create_MVS
$LN93@Create_MVS:
	xor	ecx, ecx
$LN94@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN97@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN97@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN98@Create_MVS
$LN97@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN98@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN101@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN101@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN102@Create_MVS
$LN101@Create_MVS:
	xor	ecx, ecx
$LN102@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN105@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN105@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN106@Create_MVS
$LN105@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN106@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN109@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN109@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN110@Create_MVS
$LN109@Create_MVS:
	xor	ecx, ecx
$LN110@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN113@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN113@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN114@Create_MVS
$LN113@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN114@Create_MVS:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN117@Create_MVS
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN117@Create_MVS
	mov	eax, DWORD PTR [eax+380]
	push	8
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN118@Create_MVS
$LN117@Create_MVS:
	xor	ecx, ecx
$LN118@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN121@Create_MVS
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN121@Create_MVS
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN122@Create_MVS
$LN121@Create_MVS:
	lea	ecx, DWORD PTR _args$[ebp]
$LN122@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0MVSuper@@QAE@VPClip@@HHHH_NHH0111PAVIScriptEnvironment@@@Z ; MVSuper::MVSuper
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN125@Create_MVS
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN125@Create_MVS
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN125@Create_MVS:
	or	ebx, 4
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	test	bl, 2
	je	SHORT $LN129@Create_MVS
	and	ebx, -3					; fffffffdH
	mov	DWORD PTR $T5[ebp], ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 7
	test	edx, edx
	je	SHORT $LN129@Create_MVS
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN129@Create_MVS
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T4[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN129@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 851  :    return new MVSuper(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	bl, 1
	je	SHORT $LN134@Create_MVS
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	test	edx, edx
	je	SHORT $LN134@Create_MVS
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN134@Create_MVS
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR $T3[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN134@Create_MVS:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 9
	test	edx, edx
	je	SHORT $LN142@Create_MVS
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN142@Create_MVS
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN142@Create_MVS:
; File c:\github\mvtools\sources\interface.cpp

; 866  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	160					; 000000a0H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 1
	je	$LN10@Create_MVS
	and	DWORD PTR $T5[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN10@Create_MVS:
	ret	0
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	mov	eax, DWORD PTR $T5[ebp]
	and	eax, 2
	je	$LN12@Create_MVS
	and	DWORD PTR $T5[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
$LN12@Create_MVS:
	ret	0
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MVSuper
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_vect_arr$ = -32					; size = 12
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
$T3 = 24						; size = 1
$T4 = 24						; size = 4
_clip_ptr$5 = 24					; size = 4
_env_ptr$ = 24						; size = 4
?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MStoreVect, COMDAT

; 878  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN18@Create_MSt
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN18@Create_MSt
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN19@Create_MSt
$LN18@Create_MSt:
	lea	ecx, DWORD PTR _args$[ebp]
$LN19@Create_MSt:

; 1041 :   int ArraySize() const AVS_BakedCode( return AVS_LinkCall(ArraySize)() )

	mov	ebx, DWORD PTR _env_ptr$[ebp]
	test	eax, eax
	je	SHORT $LN22@Create_MSt
	cmp	DWORD PTR [eax], 396			; 0000018cH
	jbe	SHORT $LN22@Create_MSt
	mov	eax, DWORD PTR [eax+396]
	call	eax
	mov	edi, eax
; File c:\github\mvtools\sources\interface.cpp

; 880  : 	if (nbr_clips < 1)

	cmp	edi, 1
	jge	SHORT $LN5@Create_MSt
	jmp	SHORT $LN187@Create_MSt
$LN22@Create_MSt:
; File c:\github\mvtools\sources\include\avisynth.h

; 1041 :   int ArraySize() const AVS_BakedCode( return AVS_LinkCall(ArraySize)() )

	xor	edi, edi
$LN187@Create_MSt:
; File c:\github\mvtools\sources\interface.cpp

; 882  : 		env_ptr->ThrowError ("MStoreVect: you must specify at least one vector clip.");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0DH@CPPJDDLD@MStoreVect?3?5you?5must?5specify?5at?5@
	push	ebx
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN5@Create_MSt:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR _vect_arr$[ebp], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR _vect_arr$[ebp+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR _vect_arr$[ebp+8], 0
; File c:\github\mvtools\sources\interface.cpp

; 886  : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	xor	esi, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	test	edi, edi
	jle	$LN3@Create_MSt
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	npad	2
$LL4@Create_MSt:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN35@Create_MSt
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN35@Create_MSt
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN36@Create_MSt
$LN35@Create_MSt:
	lea	ecx, DWORD PTR _args$[ebp]
$LN36@Create_MSt:
	test	eax, eax
	je	SHORT $LN40@Create_MSt
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN40@Create_MSt
	mov	eax, DWORD PTR [eax+324]
	push	esi
	call	eax
	mov	ecx, eax
$LN40@Create_MSt:
; File c:\github\mvtools\sources\interface.cpp

; 888  : 		::PClip			clip_ptr = args [0] [clip_cnt].AsClip ();

	lea	eax, DWORD PTR _clip_ptr$5[ebp]
	push	eax
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip

; 889  : 		vect_arr.push_back (clip_ptr);

	lea	eax, DWORD PTR _clip_ptr$5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	eax
	lea	ecx, DWORD PTR _vect_arr$[ebp]
	call	?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z ; std::vector<PClip,std::allocator<PClip> >::push_back
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN43@Create_MSt
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN43@Create_MSt
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _clip_ptr$5[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN43@Create_MSt:
; File c:\github\mvtools\sources\interface.cpp

; 886  : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	inc	esi
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\interface.cpp

; 886  : 	for (int clip_cnt = 0; clip_cnt < nbr_clips; ++clip_cnt)

	cmp	esi, edi
	jl	$LL4@Create_MSt
$LN3@Create_MSt:

; 892  : 	return new MStoreVect (

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 892  : 	return new MStoreVect (

	push	ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN48@Create_MSt
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN48@Create_MSt
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN49@Create_MSt
$LN48@Create_MSt:
	lea	ecx, DWORD PTR _args$[ebp]
$LN49@Create_MSt:

; 1039 :   const char* AsString(const char* def) const AVS_BakedCode( return AVS_LinkCall(AsString2)(def) )

	test	eax, eax
	je	SHORT $LN52@Create_MSt
	cmp	DWORD PTR [eax], 392			; 00000188H
	jbe	SHORT $LN52@Create_MSt
	mov	eax, DWORD PTR [eax+392]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	call	eax
	jmp	SHORT $LN53@Create_MSt
$LN52@Create_MSt:
	xor	eax, eax
$LN53@Create_MSt:
; File c:\github\mvtools\sources\interface.cpp

; 892  : 	return new MStoreVect (

	push	eax
	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _vect_arr$[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z ; std::vector<PClip,std::allocator<PClip> >::vector<PClip,std::allocator<PClip> >
	mov	ecx, esi
	call	??0MStoreVect@@QAE@V?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@PBDAAVIScriptEnvironment@@@Z ; MStoreVect::MStoreVect
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 892  : 	return new MStoreVect (

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN56@Create_MSt
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN56@Create_MSt
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN56@Create_MSt:
; File c:\github\mvtools\sources\interface.cpp

; 892  : 	return new MStoreVect (

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ebx, DWORD PTR _vect_arr$[ebp]
	test	ebx, ebx
	je	SHORT $LN62@Create_MSt
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR _vect_arr$[ebp+4]
	push	ecx
	mov	ecx, ebx
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR _vect_arr$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	eax, ebx
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN139@Create_MSt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN190@Create_MSt:
$LN139@Create_MSt:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN140@Create_MSt

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	bl, 31					; 0000001fH
	je	SHORT $LN141@Create_MSt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN191@Create_MSt:
$LN141@Create_MSt:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ebx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ebx
	jb	SHORT $LN142@Create_MSt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN192@Create_MSt:
$LN142@Create_MSt:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ebx, eax
	cmp	ebx, 4
	jae	SHORT $LN143@Create_MSt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN193@Create_MSt:
$LN143@Create_MSt:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ebx, 35					; 00000023H
	jbe	SHORT $LN144@Create_MSt
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN194@Create_MSt:
$LN144@Create_MSt:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ebx, eax
$LN140@Create_MSt:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 4
$LN62@Create_MSt:
; File c:\github\mvtools\sources\include\avisynth.h

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	edx, edx
	je	SHORT $LN180@Create_MSt
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN180@Create_MSt
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN180@Create_MSt:
; File c:\github\mvtools\sources\interface.cpp

; 897  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN189@Create_MSt:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _vect_arr$[ebp]
	jmp	??1?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ; std::vector<PClip,std::allocator<PClip> >::~vector<PClip,std::allocator<PClip> >
__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _clip_ptr$5[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$3:
	push	80					; 00000050H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$40:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MStoreVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
_env_ptr$ = 24						; size = 4
?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MRestoreVect, COMDAT

; 900  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR $T3[ebp], 0

; 901  : 	return new MRestoreVect (

	push	168					; 000000a8H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	push	DWORD PTR _env_ptr$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN12@Create_MRe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN12@Create_MRe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN13@Create_MRe
$LN12@Create_MRe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN13@Create_MRe:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN16@Create_MRe
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN16@Create_MRe
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN17@Create_MRe
$LN16@Create_MRe:
	xor	ecx, ecx
$LN17@Create_MRe:
; File c:\github\mvtools\sources\interface.cpp

; 901  : 	return new MRestoreVect (

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN20@Create_MRe
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN20@Create_MRe
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN21@Create_MRe
$LN20@Create_MRe:
	lea	ecx, DWORD PTR _args$[ebp]
$LN21@Create_MRe:
; File c:\github\mvtools\sources\interface.cpp

; 901  : 	return new MRestoreVect (

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, esi
	call	??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z ; MRestoreVect::MRestoreVect
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 901  : 	return new MRestoreVect (

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN24@Create_MRe
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN24@Create_MRe
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN24@Create_MRe:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN31@Create_MRe
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN31@Create_MRe
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN31@Create_MRe:
; File c:\github\mvtools\sources\interface.cpp

; 906  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	168					; 000000a8H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MRestoreVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
tv217 = -36						; size = 8
tv205 = -36						; size = 8
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_scaleY$1$ = -24					; size = 4
$T4 = -20						; size = 1
_scaleX$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_args$ = 12						; size = 8
___formal$ = 20						; size = 4
_env$ = 24						; size = 4
?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z PROC ; Create_MScaleVect, COMDAT

; 909  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN14@Create_MSc
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN14@Create_MSc
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN15@Create_MSc
$LN14@Create_MSc:
	lea	ecx, DWORD PTR _args$[ebp]
$LN15@Create_MSc:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN18@Create_MSc
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN18@Create_MSc
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	mov	DWORD PTR [esp], 1073741824		; 40000000H
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	fstp	QWORD PTR tv205[ebp]
	movsd	xmm0, QWORD PTR tv205[ebp]
	jmp	SHORT $LN19@Create_MSc
$LN18@Create_MSc:
	xorps	xmm0, xmm0
$LN19@Create_MSc:
; File c:\github\mvtools\sources\interface.cpp

; 911  : 	float scaleX = float(args[SCALE].AsFloat(2.0));

	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _scaleX$1$[ebp], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN22@Create_MSc
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN22@Create_MSc
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	2
	call	eax
	movss	xmm0, DWORD PTR _scaleX$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN23@Create_MSc
$LN22@Create_MSc:
	lea	ecx, DWORD PTR _args$[ebp]
$LN23@Create_MSc:

; 1037 :   double AsFloat(float def) const AVS_BakedCode( return AVS_LinkCall(AsFloat2)(def) )

	test	eax, eax
	je	SHORT $LN26@Create_MSc
	cmp	DWORD PTR [eax], 388			; 00000184H
	jbe	SHORT $LN26@Create_MSc
	mov	eax, DWORD PTR [eax+388]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	eax
	fstp	QWORD PTR tv217[ebp]
	movsd	xmm0, QWORD PTR tv217[ebp]
	jmp	SHORT $LN27@Create_MSc
$LN26@Create_MSc:
	xorps	xmm0, xmm0
$LN27@Create_MSc:
; File c:\github\mvtools\sources\interface.cpp

; 912  : 	float scaleY = float(args[SCALEV].AsFloat(scaleX));

	cvtpd2ps xmm0, xmm0

; 913  : 	return new MScaleVect( args[CLIP].AsClip(), 

	push	184					; 000000b8H
	movss	DWORD PTR _scaleY$1$[ebp], xmm0
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	movss	xmm1, DWORD PTR _scaleX$1$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	jbe	SHORT $LN3@Create_MSc
	ucomiss	xmm1, DWORD PTR _scaleY$1$[ebp]
	mov	BYTE PTR $T4[ebp], 1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@Create_MSc
$LN3@Create_MSc:
	mov	BYTE PTR $T4[ebp], 0
$LN4@Create_MSc:
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\interface.cpp

; 913  : 	return new MScaleVect( args[CLIP].AsClip(), 

	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN30@Create_MSc
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN30@Create_MSc
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	5
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN31@Create_MSc
$LN30@Create_MSc:
	lea	ecx, DWORD PTR _args$[ebp]
$LN31@Create_MSc:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN34@Create_MSc
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN34@Create_MSc
	mov	eax, DWORD PTR [eax+376]
	push	0
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN35@Create_MSc
$LN34@Create_MSc:
	xor	ecx, ecx
$LN35@Create_MSc:
; File c:\github\mvtools\sources\interface.cpp

; 913  : 	return new MScaleVect( args[CLIP].AsClip(), 

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN38@Create_MSc
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN38@Create_MSc
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN39@Create_MSc
$LN38@Create_MSc:
	lea	ecx, DWORD PTR _args$[ebp]
$LN39@Create_MSc:

; 1034 :   bool AsBool(bool def) const AVS_BakedCode( return AVS_LinkCall(AsBool2)(def) )

	test	eax, eax
	je	SHORT $LN42@Create_MSc
	cmp	DWORD PTR [eax], 376			; 00000178H
	jbe	SHORT $LN42@Create_MSc
	push	DWORD PTR $T4[ebp]
	mov	eax, DWORD PTR [eax+376]
	call	eax
	movzx	ecx, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN43@Create_MSc
$LN42@Create_MSc:
	xor	ecx, ecx
$LN43@Create_MSc:
; File c:\github\mvtools\sources\interface.cpp

; 913  : 	return new MScaleVect( args[CLIP].AsClip(), 

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN46@Create_MSc
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN46@Create_MSc
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	3
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN47@Create_MSc
$LN46@Create_MSc:
	lea	ecx, DWORD PTR _args$[ebp]
$LN47@Create_MSc:

; 1035 :   int AsInt(int def) const AVS_BakedCode( return AVS_LinkCall(AsInt2)(def) )

	test	eax, eax
	je	SHORT $LN50@Create_MSc
	cmp	DWORD PTR [eax], 380			; 0000017cH
	jbe	SHORT $LN50@Create_MSc
	mov	eax, DWORD PTR [eax+380]
	push	0
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN51@Create_MSc
$LN50@Create_MSc:
	xor	ecx, ecx
$LN51@Create_MSc:
; File c:\github\mvtools\sources\interface.cpp

; 913  : 	return new MScaleVect( args[CLIP].AsClip(), 

	push	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 1043 :   const AVSValue& operator[](int index) const AVS_BakedCode( return AVS_LinkCallV(AVSValue_OPERATOR_INDEX)(index) )

	test	eax, eax
	je	SHORT $LN54@Create_MSc
	cmp	DWORD PTR [eax], 324			; 00000144H
	jbe	SHORT $LN54@Create_MSc
	mov	eax, DWORD PTR [eax+324]
	lea	ecx, DWORD PTR _args$[ebp]
	push	0
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN55@Create_MSc
$LN54@Create_MSc:
	lea	ecx, DWORD PTR _args$[ebp]
$LN55@Create_MSc:
; File c:\github\mvtools\sources\interface.cpp

; 913  : 	return new MScaleVect( args[CLIP].AsClip(), 

	push	ecx
	push	esp
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	movss	xmm2, DWORD PTR _scaleY$1$[ebp]
	mov	ecx, esi
	movss	xmm0, DWORD PTR _scaleX$1$[ebp]
	cvtps2pd xmm3, xmm2
	cvtps2pd xmm2, xmm0
	call	??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z ; MScaleVect::MScaleVect
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\interface.cpp

; 913  : 	return new MScaleVect( args[CLIP].AsClip(), 

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 999  :   AVSValue(IClip* c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR1)(c) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN58@Create_MSc
	cmp	DWORD PTR [edx], 280			; 00000118H
	jbe	SHORT $LN58@Create_MSc
	push	eax
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, esi
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN58@Create_MSc:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN65@Create_MSc
	cmp	DWORD PTR [edx], 316			; 0000013cH
	jbe	SHORT $LN65@Create_MSc
	mov	edx, DWORD PTR [edx+316]
	lea	ecx, DWORD PTR _args$[ebp]
	call	edx
$LN65@Create_MSc:
; File c:\github\mvtools\sources\interface.cpp

; 918  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _args$[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$1:
	push	184					; 000000b8H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ENDP ; Create_MScaleVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT _AvisynthPluginInit3@8
_TEXT	SEGMENT
_env$ = 8						; size = 4
_vectors$ = 12						; size = 4
_AvisynthPluginInit3@8 PROC				; COMDAT

; 932  : 
; 933  : 	/* New 2.6 requirment!!! */
; 934  : 	// Save the server pointers.
; 935  : 	AVS_linkage = vectors;

	mov	eax, DWORD PTR _vectors$[esp-4]
	push	esi

; 936  : #endif
; 937  : 	env->AddFunction("MShow",        "cc[scale]i[sil]i[tol]i[showsad]b[number]i[thSCD1]i[thSCD2]i[isse]b[planar]b", Create_MVShow, 0);

	mov	esi, DWORD PTR _env$[esp]
	push	0
	push	OFFSET ?Create_MVShow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVShow
	push	OFFSET ??_C@_0EM@NAKFNCAA@cc?$FLscale?$FNi?$FLsil?$FNi?$FLtol?$FNi?$FLshowsad?$FNb@
	mov	DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B, eax ; AVS_linkage
	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_05FPCPEODF@MShow?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 938  : 	env->AddFunction("MAnalyse",     "c[blksize]i[blksizeV]i[levels]i[search]i[searchparam]i[pelsearch]i[isb]b[lambda]i[chroma]b[delta]i[truemotion]b[lsad]i[plevel]i[global]b[pnew]i[pzero]i[pglobal]i[overlap]i[overlapV]i[outfile]s[dct]i[divide]i[sadx264]i[badSAD]i[badrange]i[isse]b[meander]b[temporal]b[trymany]b[multi]b[mt]b", Create_MVAnalyse, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVAnalyse@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVAnalyse
	push	OFFSET ??_C@_0BCB@KLDOCAHB@c?$FLblksize?$FNi?$FLblksizeV?$FNi?$FLlevels?$FNi?$FL@
	push	OFFSET ??_C@_08MPPFBKIE@MAnalyse?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 939  :   env->AddFunction("MMask",        "cc[ml]f[gamma]f[kind]i[time]f[Ysc]i[thSCD1]i[thSCD2]i[isse]b[planar]b", Create_MVMask, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVMask@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVMask
	push	OFFSET ??_C@_0EG@HAJCMFCN@cc?$FLml?$FNf?$FLgamma?$FNf?$FLkind?$FNi?$FLtime?$FNf?$FLYs@
	push	OFFSET ??_C@_05OLMCPBF@MMask?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 940  :   env->AddFunction("MCompensate",  "ccc[scbehavior]b[recursion]f[thSAD]i[fields]b[time]f[thSCD1]i[thSCD2]i[isse]b[planar]b[mt]b[tr]i[center]b[cclip]c[thSAD2]i", Create_MVCompensate, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVCompensate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVCompensate
	push	OFFSET ??_C@_0HL@HEAJFDF@ccc?$FLscbehavior?$FNb?$FLrecursion?$FNf?$FLthS@
	push	OFFSET ??_C@_0M@NJDGAAIB@MCompensate?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 941  :   env->AddFunction("MSCDetection", "cc[Yth]i[thSCD1]i[thSCD2]i[isse]b", Create_MVSCDetection, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVSCDetection@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVSCDetection
	push	OFFSET ??_C@_0CC@KMGONIIC@cc?$FLYth?$FNi?$FLthSCD1?$FNi?$FLthSCD2?$FNi?$FLisse?$FN@
	push	OFFSET ??_C@_0N@CLNGJOF@MSCDetection?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 942  : 	env->AddFunction("MDepan",       "cc[mask]c[zoom]b[rot]b[pixaspect]f[error]f[info]b[log]s[wrong]f[zerow]f[range]i[thSCD1]i[thSCD2]i[isse]b[planar]b", Create_MVDepan, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVDepan@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDepan
	push	OFFSET ??_C@_0HC@HLJFBMGH@cc?$FLmask?$FNc?$FLzoom?$FNb?$FLrot?$FNb?$FLpixaspect@
	push	OFFSET ??_C@_06FLAAMDNN@MDepan?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 943  : 	env->AddFunction("MFlow",        "ccc[time]f[mode]i[fields]b[thSCD1]i[thSCD2]i[isse]b[planar]b[tclip]c", Create_MVFlow, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVFlow@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlow
	push	OFFSET ??_C@_0EF@KDBNKAPJ@ccc?$FLtime?$FNf?$FLmode?$FNi?$FLfields?$FNb?$FLthSCD@
	push	OFFSET ??_C@_05HIENMBJA@MFlow?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 944  : 	env->AddFunction("MFlowInter",   "cccc[time]f[ml]f[blend]b[thSCD1]i[thSCD2]i[isse]b[planar]b[tclip]c", Create_MVFlowInter, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVFlowInter@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlowInter
	push	OFFSET ??_C@_0ED@CGOJKPH@cccc?$FLtime?$FNf?$FLml?$FNf?$FLblend?$FNb?$FLthSCD1?$FN@
	push	OFFSET ??_C@_0L@DJEOPEOC@MFlowInter?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 945  : 	env->AddFunction("MFlowFps",     "cccc[num]i[den]i[mask]i[ml]f[blend]b[thSCD1]i[thSCD2]i[isse]b[planar]b", Create_MVFlowFps, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVFlowFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlowFps
	push	OFFSET ??_C@_0EH@BLHGHBNC@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmask?$FNi?$FLml?$FNf?$FLble@
	push	OFFSET ??_C@_08MJADCGCO@MFlowFps?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 946  : 	env->AddFunction("MFlowBlur",    "cccc[blur]f[prec]i[thSCD1]i[thSCD2]i[isse]b[planar]b", Create_MVFlowBlur, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVFlowBlur@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVFlowBlur
	push	OFFSET ??_C@_0DF@DPJMOPHB@cccc?$FLblur?$FNf?$FLprec?$FNi?$FLthSCD1?$FNi?$FLthSC@
	push	OFFSET ??_C@_09CKNECHMI@MFlowBlur?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 947  : 	env->AddFunction("MDegrain1",    "cccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2]i[isse]b[planar]b[lsb]b[mt]b", Create_MVDegrainX, (void *)1);

	mov	eax, DWORD PTR [esi]
	push	1
	push	OFFSET ?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDegrainX
	push	OFFSET ??_C@_0FM@HNKAHCLO@cccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@
	push	OFFSET ??_C@_09CNHDOAA@MDegrain1?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 948  : 	env->AddFunction("MDegrain2",    "cccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2]i[isse]b[planar]b[lsb]b[mt]b", Create_MVDegrainX, (void *)2);

	mov	eax, DWORD PTR [esi]
	push	2
	push	OFFSET ?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDegrainX
	push	OFFSET ??_C@_0FO@HLKNGIOP@cccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FL@
	push	OFFSET ??_C@_09CJPKGNMD@MDegrain2?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 949  : 	env->AddFunction("MDegrain3",    "cccccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2]i[isse]b[planar]b[lsb]b[mt]b", Create_MVDegrainX, (void *)3);

	mov	eax, DWORD PTR [esi]
	push	3
	push	OFFSET ?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDegrainX
	push	OFFSET ??_C@_0GA@CFGPPLIN@cccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FN@
	push	OFFSET ??_C@_09DAOBFMIC@MDegrain3?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 950  :   env->AddFunction("MDegrain4",    "cccccccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2]i[isse]b[planar]b[lsb]b[mt]b", Create_MVDegrainX, (void *)4);

	mov	eax, DWORD PTR [esi]
	push	4
	push	OFFSET ?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDegrainX
	push	OFFSET ??_C@_0GC@BLKCGOJE@cccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplan@
	push	OFFSET ??_C@_09HPKAMKEF@MDegrain4?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 951  :   env->AddFunction("MDegrain5",    "cccccccccccc[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2]i[isse]b[planar]b[lsb]b[mt]b", Create_MVDegrainX, (void *)5);

	mov	eax, DWORD PTR [esi]
	push	5
	push	OFFSET ?Create_MVDegrainX@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVDegrainX
	push	OFFSET ??_C@_0GE@MHJOIK@cccccccccccc?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLpl@
	push	OFFSET ??_C@_09GGLLPLAE@MDegrain5?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 952  :   env->AddFunction("MDegrainN",    "ccci[thSAD]i[thSADC]i[plane]i[limit]i[limitC]i[thSCD1]i[thSCD2]i[isse]b[planar]b[lsb]b[thsad2]i[thsadc2]i[mt]b", Create_MDegrainN, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MDegrainN@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MDegrainN
	push	OFFSET ??_C@_0GP@OJFJMPLO@ccci?$FLthSAD?$FNi?$FLthSADC?$FNi?$FLplane?$FNi?$FLli@
	push	OFFSET ??_C@_09KKHAFLDJ@MDegrainN?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 953  : 	env->AddFunction("MRecalculate", "cc[thsad]i[smooth]i[blksize]i[blksizeV]i[search]i[searchparam]i[lambda]i[chroma]b[truemotion]b[pnew]i[overlap]i[overlapV]i[outfile]s[dct]i[divide]i[sadx264]i[isse]b[meander]b[tr]i[mt]b", Create_MVRecalculate, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVRecalculate@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVRecalculate
	push	OFFSET ??_C@_0LJ@LNPKOIAB@cc?$FLthsad?$FNi?$FLsmooth?$FNi?$FLblksize?$FNi?$FLbl@
	push	OFFSET ??_C@_0N@HIPOLGGP@MRecalculate?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 954  : 	env->AddFunction("MBlockFps",    "cccc[num]i[den]i[mode]i[ml]i[blend]b[thSCD1]i[thSCD2]i[isse]b[planar]b[mt]b", Create_MVBlockFps, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVBlockFps@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVBlockFps
	push	OFFSET ??_C@_0EM@FHHOOIJP@cccc?$FLnum?$FNi?$FLden?$FNi?$FLmode?$FNi?$FLml?$FNi?$FLble@
	push	OFFSET ??_C@_09PDPBMHMM@MBlockFps?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 955  :   env->AddFunction("MSuper",       "c[hpad]i[vpad]i[pel]i[levels]i[chroma]b[sharp]i[rfilter]i[pelclip]c[isse]b[planar]b[mt]b", Create_MVSuper, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MVSuper@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MVSuper
	push	OFFSET ??_C@_0FJ@KJGJJNIF@c?$FLhpad?$FNi?$FLvpad?$FNi?$FLpel?$FNi?$FLlevels?$FNi?$FLc@
	push	OFFSET ??_C@_06MEENJDPN@MSuper?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 956  : 	env->AddFunction("MStoreVect",   "c+[vccs]s", Create_MStoreVect, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MStoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MStoreVect
	push	OFFSET ??_C@_09OIPLNGMI@c?$CL?$FLvccs?$FNs?$AA@
	push	OFFSET ??_C@_0L@OGKEKMEE@MStoreVect?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 957  : 	env->AddFunction("MRestoreVect", "c[index]i", Create_MRestoreVect, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MRestoreVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MRestoreVect
	push	OFFSET ??_C@_09HOOICLHG@c?$FLindex?$FNi?$AA@
	push	OFFSET ??_C@_0N@NLLEADCO@MRestoreVect?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 958  : 	env->AddFunction("MScaleVect",   "c[scale]f[scaleV]f[mode]i[flip]b[adjustSubPel]b", Create_MScaleVect, 0);

	mov	eax, DWORD PTR [esi]
	push	0
	push	OFFSET ?Create_MScaleVect@@YA?AVAVSValue@@V1@PAXPAVIScriptEnvironment@@@Z ; Create_MScaleVect
	push	OFFSET ??_C@_0DA@IJJIFBPP@c?$FLscale?$FNf?$FLscaleV?$FNf?$FLmode?$FNi?$FLflip?$FNb@
	push	OFFSET ??_C@_0L@MGOHGFN@MScaleVect?$AA@
	push	esi
	call	DWORD PTR [eax+24]

; 959  : //	env->AddFunction("MVFinest",     "c[isse]b", Create_MVFinest, 0);
; 960  : 	return("MVTools : set of tools based on a motion estimation engine");

	mov	eax, OFFSET ??_C@_0DL@BMMDLPLH@MVTools?5?3?5set?5of?5tools?5based?5on?5@
	pop	esi

; 961  : }

	ret	8
_AvisynthPluginInit3@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Interface_dll_load@@YAXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
?Interface_dll_load@@YAXPAUHINSTANCE__@@@Z PROC		; Interface_dll_load, COMDAT
; _hinst$dead$ = ecx

; 967  : #if defined (_MSC_VER) && ! defined (NDEBUG) && defined (_DEBUG)
; 968  : 	{
; 969  : 		const int	mode =   (1 * _CRTDBG_MODE_DEBUG)
; 970  : 						       | (1 * _CRTDBG_MODE_WNDW);
; 971  : 		::_CrtSetReportMode (_CRT_WARN, mode);
; 972  : 		::_CrtSetReportMode (_CRT_ERROR, mode);
; 973  : 		::_CrtSetReportMode (_CRT_ASSERT, mode);
; 974  : 
; 975  : 		const int	old_flags = ::_CrtSetDbgFlag (_CRTDBG_REPORT_FLAG);
; 976  : 		::_CrtSetDbgFlag (  old_flags
; 977  : 		                  | (1 * _CRTDBG_LEAK_CHECK_DF)
; 978  : 		                  | (0 * _CRTDBG_CHECK_ALWAYS_DF));
; 979  : 		::_CrtSetBreakAlloc (-1);	// Specify here a memory bloc number
; 980  : 	}
; 981  : #endif	// _MSC_VER, NDEBUG
; 982  : }

	ret	0
?Interface_dll_load@@YAXPAUHINSTANCE__@@@Z ENDP		; Interface_dll_load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT ?Interface_dll_unload@@YAXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
?Interface_dll_unload@@YAXPAUHINSTANCE__@@@Z PROC	; Interface_dll_unload, COMDAT
; _hinst$dead$ = ecx

; 988  : #if defined (_MSC_VER) && ! defined (NDEBUG) && defined (_DEBUG)
; 989  : 	{
; 990  : 		const int	mode =   (1 * _CRTDBG_MODE_DEBUG)
; 991  : 						       | (0 * _CRTDBG_MODE_WNDW);
; 992  : 		::_CrtSetReportMode (_CRT_WARN, mode);
; 993  : 		::_CrtSetReportMode (_CRT_ERROR, mode);
; 994  : 		::_CrtSetReportMode (_CRT_ASSERT, mode);
; 995  : 
; 996  : 		::_CrtMemState	mem_state;
; 997  : 		::_CrtMemCheckpoint (&mem_state);
; 998  : 		::_CrtMemDumpStatistics (&mem_state);
; 999  : 	}
; 1000 : #endif	// _MSC_VER, NDEBUG
; 1001 : }

	ret	0
?Interface_dll_unload@@YAXPAUHINSTANCE__@@@Z ENDP	; Interface_dll_unload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interface.cpp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_hinst$ = 8						; size = 4
_reason$ = 12						; size = 4
_reserved_ptr$ = 16					; size = 4
_DllMain@12 PROC					; COMDAT

; 1007 : 	switch (reason)
; 1008 : 	{
; 1009 : 	case	DLL_PROCESS_ATTACH:
; 1010 : 		Interface_dll_load (hinst);
; 1011 : 		break;
; 1012 : 
; 1013 : 	case	DLL_PROCESS_DETACH:
; 1014 : 		Interface_dll_unload (hinst);
; 1015 : 		break;
; 1016 : 	}
; 1017 : 
; 1018 : 	return (TRUE);

	mov	eax, 1

; 1019 : }

	ret	12					; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z PROC ; std::vector<PClip,std::allocator<PClip> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	edi, eax
	jae	SHORT $LN2@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	ecx, edi
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	edi, ecx
	sar	edi, 2

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	push	ecx
	mov	ecx, esi
	call	?_Reserve@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z ; std::vector<PClip,std::allocator<PClip> >::_Reserve
$LN4@push_back:

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	lea	edx, DWORD PTR [eax+edi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN224@push_back
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN224@push_back
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN224@push_back
	push	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1287 : 		else

	jmp	SHORT $LN237@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	push	ecx
	mov	ecx, esi
	call	?_Reserve@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z ; std::vector<PClip,std::allocator<PClip> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	ecx, ecx
	je	SHORT $LN224@push_back
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN224@push_back
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN224@push_back
	push	edi
$LN237@push_back:
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN224@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 4

; 1295 : 			}
; 1296 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z$33:
	jmp	??3@YAXPAX0@Z				; operator delete
__unwindfunclet$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z$57:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAEXABVPClip@@@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
??1?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ PROC ; std::vector<PClip,std::allocator<PClip> >::~vector<PClip,std::allocator<PClip> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	pop	ecx
	ret	0
??1?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ENDP ; std::vector<PClip,std::allocator<PClip> >::~vector<PClip,std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<PClip,std::allocator<PClip> >::vector<PClip,std::allocator<PClip> >, COMDAT
; _this$ = ecx

; 748  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 658  : 		return (_Get_data()._Mylast);

	mov	ebx, DWORD PTR __Right$[ebp]

; 748  : 		{	// construct by copying _Right

	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+8], 0

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR [ebx+4]
	sub	edi, DWORD PTR [ebx]
	sar	edi, 2

; 1562 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1563 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1564 : 		this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0

; 1565 : 
; 1566 : 		if (_Capacity == 0)

	test	edi, edi
	je	SHORT $LN7@vector

; 1567 : 			return (false);
; 1568 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN58@vector

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN257@vector:
$LN58@vector:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z ; std::allocator<PClip>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]

; 749  : 		if (_Buy(_Right.size()))
; 750  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 793  : 	return {};

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [ebx+4]
	push	ecx
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebx]
	call	??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<PClip const *,PClip *,std::allocator<PClip> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

	mov	DWORD PTR [esi+4], eax
$LN7@vector:

; 756  : 			_CATCH_END
; 757  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z$0:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXXZ ; std::vector<PClip,std::allocator<PClip> >::_Tidy

; 755  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN258@vector:
$LN256@vector:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::vector<PClip,std::allocator<PClip> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ PROC ; std::vector<PClip,std::allocator<PClip> >::vector<PClip,std::allocator<PClip> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ENDP ; std::vector<PClip,std::allocator<PClip> >::vector<PClip,std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::select_on_container_copy_construction, COMDAT
; _this$dead$ = ecx

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 914  : 		}

	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAPAVPClip@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXPAVPClip@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXPAVPClip@@0@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1794 : 		}

	ret	8
?_Orphan_range@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXPAVPClip@@0@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
?_Tidy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXXZ PROC ; std::vector<PClip,std::allocator<PClip> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXXZ ENDP ; std::vector<PClip,std::allocator<PClip> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?_Reserve@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	esi
	mov	esi, ecx
	push	edi

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, 1
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	push	ebx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ebx, 1073741823				; 3fffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, ebx
	sub	eax, edx
	cmp	eax, 1
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN136@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	edx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edi, 2
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, edi
	shr	eax, 1
	sub	ebx, eax
	add	eax, edi
	cmp	ebx, edi
	cmovae	ecx, eax
	cmp	ecx, edx
	cmovae	edx, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, esi
	push	edx
	call	?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z ; std::vector<PClip,std::allocator<PClip> >::_Reallocate
	pop	ebx
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	ret	4
$LN135@Reserve:
?_Reserve@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBE_NPBVPClip@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBE_NPBVPClip@@@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Inside, COMDAT
; _this$ = ecx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN3@Inside
	cmp	DWORD PTR [ecx], eax
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	ret	4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	ret	4
?_Inside@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBE_NPBVPClip@@@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAE_NI@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, ecx
	push	edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1567 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1577 : 		}

	ret	4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@Buy

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN110@Buy:
$LN4@Buy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z ; std::allocator<PClip>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1577 : 		}

	ret	4
$LN109@Buy:
?_Buy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ PROC ; std::vector<PClip,std::allocator<PClip> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1181 : 		}

	ret	0
?size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ENDP ; std::vector<PClip,std::allocator<PClip> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ PROC ; std::vector<PClip,std::allocator<PClip> >::end, COMDAT
; _this$ = ecx

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1073 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1074 : 		}

	ret	4
?end@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ ENDP ; std::vector<PClip,std::allocator<PClip> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ PROC ; std::vector<PClip,std::allocator<PClip> >::begin, COMDAT
; _this$ = ecx

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1063 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1064 : 		}

	ret	4
?begin@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@2@XZ ENDP ; std::vector<PClip,std::allocator<PClip> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QAE@PAVPClip@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QAE@PAVPClip@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >, COMDAT
; _this$ = ecx

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	eax, ecx
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QAE@PAVPClip@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SA?AV?$allocator@VPClip@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SA?AV?$allocator@VPClip@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<PClip> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 875  : 		return (_Al);

	mov	eax, ecx

; 876  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SA?AV?$allocator@VPClip@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<PClip> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEPAVPClip@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEPAVPClip@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z ; std::allocator<PClip>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEPAVPClip@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXXZ PROC ; std::vector<PClip,std::allocator<PClip> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEXXZ ENDP ; std::vector<PClip,std::allocator<PClip> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
$T2 = -20						; size = 1
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Count$[ebp]
	call	?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z ; std::allocator<PClip>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1604 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [esi+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	DWORD PTR __Ptr$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<PClip *,PClip *,std::allocator<PClip> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi]
	mov	ebx, edx
	sub	ebx, ecx
	sar	ebx, 2

; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T3[ebp]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]

; 1621 : 		this->_Mylast() = _Ptr + _Size;
; 1622 : 		this->_Myfirst() = _Ptr;
; 1623 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+8], eax
	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1608 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN194@Reallocate:
$LN193@Reallocate:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXI@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Reallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEII@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 1073741823				; 3fffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	esi, DWORD PTR [ecx]
	sar	esi, 2

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IBEII@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXPAVPClip@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXPAVPClip@@0@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Destroy, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp-4]
	mov	edx, DWORD PTR __Last$[esp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1582 : 		}

	ret	8
?_Destroy@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEXPAVPClip@@0@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ PROC ; std::vector<PClip,std::allocator<PClip> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ENDP ; std::vector<PClip,std::allocator<PClip> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ PROC ; std::vector<PClip,std::allocator<PClip> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ENDP ; std::vector<PClip,std::allocator<PClip> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QBEABQAVPClip@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ PROC ; std::vector<PClip,std::allocator<PClip> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1044 : 		}

	ret	0
?capacity@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@QBEIXZ ENDP ; std::vector<PClip,std::allocator<PClip> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z PROC ; std::allocator<PClip>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@VPClip@@@std@@QAEPAVPClip@@I@Z ENDP ; std::allocator<PClip>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VPClip@@@std@@QAEXPAVPClip@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VPClip@@@std@@QAEXPAVPClip@@I@Z PROC ; std::allocator<PClip>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@VPClip@@@std@@QAEXPAVPClip@@I@Z ENDP ; std::allocator<PClip>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VPClip@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$allocator@VPClip@@@std@@QAE@ABV01@@Z PROC		; std::allocator<PClip>::allocator<PClip>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@VPClip@@@std@@QAE@ABV01@@Z ENDP		; std::allocator<PClip>::allocator<PClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAIABV?$allocator@VPClip@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAIABV?$allocator@VPClip@@@2@@Z PROC ; std::allocator_traits<std::allocator<PClip> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAIABV?$allocator@VPClip@@@2@@Z ENDP ; std::allocator_traits<std::allocator<PClip> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VPClip@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VPClip@@@std@@QBEIXZ PROC		; std::allocator<PClip>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@VPClip@@@std@@QBEIXZ ENDP		; std::allocator<PClip>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBVPClip@@@std@@YAPBVPClip@@ABV1@@Z
_TEXT	SEGMENT
??$addressof@$$CBVPClip@@@std@@YAPBVPClip@@ABV1@@Z PROC	; std::addressof<PClip const >, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@$$CBVPClip@@@std@@YAPBVPClip@@ABV1@@Z ENDP	; std::addressof<PClip const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VPClip@@@std@@YAPAVPClip@@PAV1@@Z
_TEXT	SEGMENT
??$_Unfancy@VPClip@@@std@@YAPAVPClip@@PAV1@@Z PROC	; std::_Unfancy<PClip>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@VPClip@@@std@@YAPAVPClip@@PAV1@@Z ENDP	; std::_Unfancy<PClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip &>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	-1
	push	__ehhandler$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN23@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN23@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN23@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN23@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z$2:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@AAV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@AAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip const &>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	-1
	push	__ehhandler$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN23@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN23@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN23@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN23@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z$2:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@ABV1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@ABV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip const &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > ><std::_Wrap_alloc<std::allocator<PClip> >,void>, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 529  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 529  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@VPClip@@V?$allocator@VPClip@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > >::_Vector_alloc<std::_Vec_base_types<PClip,std::allocator<PClip> > ><std::_Wrap_alloc<std::allocator<PClip> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@1@0PAV2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@1@0PAV2@@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > > >, COMDAT
; _this$dead$ = ecx

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 793  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Ptr$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<PClip const *,PClip *,std::allocator<PClip> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1654 : 		}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@1@0PAV2@@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@VPClip@@@std@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAV?$allocator@VPClip@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0V?$allocator@VPClip@@@std@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAV?$allocator@VPClip@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> ><std::allocator<PClip> >, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@VPClip@@@std@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAV?$allocator@VPClip@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> ><std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAVPClip@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@PAV2@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVPClip@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@PAV2@00@Z PROC ; std::vector<PClip,std::allocator<PClip> >::_Umove<PClip *>, COMDAT
; _this$dead$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Ptr$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<PClip *,PClip *,std::allocator<PClip> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
??$_Umove@PAVPClip@@@?$vector@VPClip@@V?$allocator@VPClip@@@std@@@std@@IAEPAVPClip@@PAV2@00@Z ENDP ; std::vector<PClip,std::allocator<PClip> >::_Umove<PClip *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<PClip>,PClip *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	ecx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Destroy_range@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<PClip>,PClip *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PClip> >::_Vector_val<std::_Simple_types<PClip> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PClip> >::_Vector_val<std::_Simple_types<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VPClip@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VPClip@@@std@@QAE@XZ PROC		; std::allocator<PClip>::allocator<PClip>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@VPClip@@@std@@QAE@XZ ENDP		; std::allocator<PClip>::allocator<PClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAVPClip@@@std@@YAAAVPClip@@AAV1@@Z
_TEXT	SEGMENT
??$forward@AAVPClip@@@std@@YAAAVPClip@@AAV1@@Z PROC	; std::forward<PClip &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAVPClip@@@std@@YAAAVPClip@@AAV1@@Z ENDP	; std::forward<PClip &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 4
??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z PROC ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edx, edx
	je	SHORT $LN18@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN18@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN18@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, edx
	call	eax
$LN18@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z$1:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@AAV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@AAV3@@Z ENDP ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABVPClip@@@std@@YAABVPClip@@ABV1@@Z
_TEXT	SEGMENT
??$forward@ABVPClip@@@std@@YAABVPClip@@ABV1@@Z PROC	; std::forward<PClip const &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@ABVPClip@@@std@@YAABVPClip@@ABV1@@Z ENDP	; std::forward<PClip const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 4
??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z PROC ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edx, edx
	je	SHORT $LN18@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN18@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN18@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, edx
	call	eax
$LN18@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z$1:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@ABV1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@ABV3@@Z ENDP ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip const &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<PClip> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<PClip> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1><std::_Wrap_alloc<std::allocator<PClip> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PClip> >,std::_Vector_val<std::_Simple_types<PClip> >,1><std::_Wrap_alloc<std::allocator<PClip> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@PAVPClip@@V?$allocator@VPClip@@@2@@std@@YAPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@PAVPClip@@V?$allocator@VPClip@@@2@@std@@YAPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >,PClip *,std::allocator<PClip> >, COMDAT
; __Dest$ = ecx
; __Al$dead$ = edx

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	sub	esp, 8

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 793  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<PClip const *,PClip *,std::allocator<PClip> >

; 260  : 		// note: only called internally from elsewhere in the STL, debug checks
; 261  : 		// and deprecation warnings omitted
; 262  : 	return (_Rechecked(_Dest,
; 263  : 		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 264  : 			_Unchecked(_Dest), _Al)));
; 265  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@PAVPClip@@V?$allocator@VPClip@@@2@@std@@YAPAVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >,PClip *,std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@VPClip@@@std@@@std@@YA$$QAV?$allocator@VPClip@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@VPClip@@@std@@@std@@YA$$QAV?$allocator@VPClip@@@0@AAV10@@Z PROC ; std::forward<std::allocator<PClip> >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$allocator@VPClip@@@std@@@std@@YA$$QAV?$allocator@VPClip@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z PROC ; std::_Uninitialized_move<PClip *,PClip *,std::allocator<PClip> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<PClip *,PClip *,std::allocator<PClip> >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<PClip *,PClip *,std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<PClip>,PClip *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $LN3@Destroy_ra
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	npad	9
$LL4@Destroy_ra:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN20@Destroy_ra
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN20@Destroy_ra
	mov	eax, DWORD PTR [eax+248]
	mov	ecx, esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN20@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	add	esi, 4
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	jne	SHORT $LL4@Destroy_ra
$LN3@Destroy_ra:

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::_Wrap_alloc<std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z PROC ; std::allocator<PClip>::construct<PClip,PClip &>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	-1
	push	__ehhandler$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN13@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN13@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@AAV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@AAV2@@Z ENDP ; std::allocator<PClip>::construct<PClip,PClip &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z PROC ; std::allocator<PClip>::construct<PClip,PClip const &>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	-1
	push	__ehhandler$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN13@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN13@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@ABV1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@ABV2@@Z ENDP ; std::allocator<PClip>::construct<PClip,PClip const &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@YAPBVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@YAPBVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PClip> > >, COMDAT

; 272  : 	return (_Iter._Unchecked());

	mov	eax, DWORD PTR __Iter$[esp-4]

; 273  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@YAPBVPClip@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PClip> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAVPClip@@@std@@YAPAVPClip@@PAV1@@Z
_TEXT	SEGMENT
??$_Unchecked@PAVPClip@@@std@@YAPAVPClip@@PAV1@@Z PROC	; std::_Unchecked<PClip *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAVPClip@@@std@@YAPAVPClip@@PAV1@@Z ENDP	; std::_Unchecked<PClip *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy_al_unchecked@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<PClip const *,PClip *,std::allocator<PClip> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	sub	esp, 8

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 793  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<PClip const *,PClip *,std::allocator<PClip> >

; 250  : 		_Ptr_copy_cat(_First, _Dest),
; 251  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
; 252  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_copy_al_unchecked@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<PClip const *,PClip *,std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAVPClip@@PAV1@@std@@YAAAPAVPClip@@AAPAV1@PAV1@@Z
_TEXT	SEGMENT
??$_Rechecked@PAVPClip@@PAV1@@std@@YAAAPAVPClip@@AAPAV1@PAV1@@Z PROC ; std::_Rechecked<PClip *,PClip *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAVPClip@@PAV1@@std@@YAAAPAVPClip@@AAPAV1@PAV1@@Z ENDP ; std::_Rechecked<PClip *,PClip *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<PClip *,PClip *,std::allocator<PClip> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<PClip *,PClip *,std::allocator<PClip> >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move_al_unchecked@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<PClip *,PClip *,std::allocator<PClip> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::destroy<PClip>, COMDAT
; _this$dead$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN13@destroy
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN13@destroy
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN13@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$destroy@VPClip@@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::destroy<PClip>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$move@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<PClip> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<PClip> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QBEPBVPClip@@XZ
_TEXT	SEGMENT
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QBEPBVPClip@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >::_Unchecked, COMDAT
; _this$ = ecx

; 61   : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 62   : 		}

	ret	0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VPClip@@@std@@@std@@@std@@QBEPBVPClip@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PClip> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBVPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBVPClip@@ABQAV2@@Z
_TEXT	SEGMENT
??$_Ptr_copy_cat@$$CBVPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBVPClip@@ABQAV2@@Z PROC ; std::_Ptr_copy_cat<PClip const ,PClip>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 793  : 	return {};

	xor	al, al

; 794  : 	}

	ret	0
??$_Ptr_copy_cat@$$CBVPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBVPClip@@ABQAV2@@Z ENDP ; std::_Ptr_copy_cat<PClip const ,PClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<PClip const *,PClip *,std::allocator<PClip> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 220  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 221  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	mov	ebx, edx
	push	edi

; 222  : 
; 223  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	edi, ecx
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
$LL4@Uninitiali:

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	edi, ebx
	je	SHORT $LN3@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN35@Uninitiali
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN35@Uninitiali
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN35@Uninitiali
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, esi
	push	edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN35@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 4
	jmp	SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Next$[ebp]
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 228  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN44@Uninitiali:
$LN3@Uninitiali:

; 229  : 	_CATCH_END
; 230  : 
; 231  : 	return (_Dest);
; 232  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$4:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked1@PBVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PBV1@0PAV1@AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<PClip const *,PClip *,std::allocator<PClip> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	eax, ecx
	ret	4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@VPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVPClip@@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@VPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVPClip@@0@Z PROC ; std::_Ptr_move_cat<PClip,PClip>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	xor	al, al

; 811  : 	}

	ret	0
??$_Ptr_move_cat@VPClip@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVPClip@@0@Z ENDP ; std::_Ptr_move_cat<PClip,PClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<PClip *,PClip *,std::allocator<PClip> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 274  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	mov	ebx, edx
	push	edi

; 275  : 
; 276  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	edi, ecx
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
$LL4@Uninitiali:

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	edi, ebx
	je	SHORT $LN3@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 1
	test	esi, esi
	je	SHORT $LN38@Uninitiali
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN38@Uninitiali
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN38@Uninitiali
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, esi
	push	edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN38@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 4
	jmp	SHORT $LL4@Uninitiali
__catch$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Next$[ebp]
	call	??$_Destroy_range1@V?$allocator@VPClip@@@std@@PAVPClip@@@std@@YAXPAVPClip@@0AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<PClip>,PClip *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 281  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN47@Uninitiali:
$LN3@Uninitiali:

; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);
; 285  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@Uninitiali:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$5:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move_al_unchecked1@PAVPClip@@PAV1@V?$allocator@VPClip@@@std@@@std@@YAPAVPClip@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<PClip *,PClip *,std::allocator<PClip> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z PROC ; std::allocator_traits<std::allocator<PClip> >::destroy<PClip>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 863  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN11@destroy
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN11@destroy
	mov	eax, DWORD PTR [eax+248]
	mov	ecx, edx
	call	eax
$LN11@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$destroy@VPClip@@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@@Z ENDP ; std::allocator_traits<std::allocator<PClip> >::destroy<PClip>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAVPClip@@@std@@YA$$QAVPClip@@AAV1@@Z
_TEXT	SEGMENT
??$move@AAVPClip@@@std@@YA$$QAVPClip@@AAV1@@Z PROC	; std::move<PClip &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAVPClip@@@std@@YA$$QAVPClip@@AAV1@@Z ENDP	; std::move<PClip &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	-1
	push	__ehhandler$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN23@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN23@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN23@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN23@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z$2:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@V1@@?$_Wrap_alloc@V?$allocator@VPClip@@@std@@@std@@QAEXPAVPClip@@$$QAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PClip> >::construct<PClip,PClip>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z PROC ; std::allocator<PClip>::destroy<PClip>, COMDAT
; _this$dead$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN9@destroy
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN9@destroy
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN9@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$destroy@VPClip@@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@@Z ENDP ; std::allocator<PClip>::destroy<PClip>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??_GPClip@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$dead$ = 8					; size = 4
??_GPClip@@QAEPAXI@Z PROC				; PClip::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_GPClip@@QAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN9@scalar
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN9@scalar
	mov	eax, DWORD PTR [eax+248]
	call	eax
$LN9@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GPClip@@QAEPAXI@Z$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_GPClip@@QAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GPClip@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GPClip@@QAEPAXI@Z ENDP				; PClip::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@VPClip@@@std@@YA$$QAVPClip@@AAV1@@Z
_TEXT	SEGMENT
??$forward@VPClip@@@std@@YA$$QAVPClip@@AAV1@@Z PROC	; std::forward<PClip>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@VPClip@@@std@@YA$$QAVPClip@@AAV1@@Z ENDP	; std::forward<PClip>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 4
??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z PROC ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edx, edx
	je	SHORT $LN18@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN18@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN18@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	mov	ecx, edx
	call	eax
$LN18@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z$1:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@V1@@?$allocator_traits@V?$allocator@VPClip@@@std@@@std@@SAXAAV?$allocator@VPClip@@@1@PAVPClip@@$$QAV3@@Z ENDP ; std::allocator_traits<std::allocator<PClip> >::construct<PClip,PClip>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z PROC ; std::allocator<PClip>::construct<PClip,PClip>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	-1
	push	__ehhandler$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN13@construct
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN13@construct
	push	DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax+232]
	call	eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VPClip@@V1@@?$allocator@VPClip@@@std@@QAEXPAVPClip@@$$QAV2@@Z ENDP ; std::allocator<PClip>::construct<PClip,PClip>
END
