; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\interpolation.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	_RB2CubicVerticalLine_SSE:PROC
EXTRN	_RB2BilinearFilteredHorizontalInplaceLine_SSE:PROC
EXTRN	_RB2F_iSSE:PROC
EXTRN	_RB2CubicHorizontalInplaceLine_SSE:PROC
EXTRN	_RB2QuadraticVerticalLine_SSE:PROC
EXTRN	_RB2FilteredHorizontalInplaceLine_SSE:PROC
EXTRN	_RB2BilinearFilteredVerticalLine_SSE:PROC
EXTRN	_RB2QuadraticHorizontalInplaceLine_SSE:PROC
EXTRN	_RB2FilteredVerticalLine_SSE:PROC
PUBLIC	??$RB2CubicHorizontalInplace@G@@YAXPAEHHHHH_N@Z	; RB2CubicHorizontalInplace<unsigned short>
PUBLIC	??$RB2CubicVertical@G@@YAXPAEPBEHHHHHH_N@Z	; RB2CubicVertical<unsigned short>
PUBLIC	??$RB2CubicHorizontalInplace@E@@YAXPAEHHHHH_N@Z	; RB2CubicHorizontalInplace<unsigned char>
PUBLIC	??$RB2CubicVertical@E@@YAXPAEPBEHHHHHH_N@Z	; RB2CubicVertical<unsigned char>
PUBLIC	??$RB2QuadraticHorizontalInplace@G@@YAXPAEHHHHHH@Z ; RB2QuadraticHorizontalInplace<unsigned short>
PUBLIC	??$RB2QuadraticVertical@G@@YAXPAEPBEHHHHHH_N@Z	; RB2QuadraticVertical<unsigned short>
PUBLIC	??$RB2QuadraticHorizontalInplace@E@@YAXPAEHHHHHH@Z ; RB2QuadraticHorizontalInplace<unsigned char>
PUBLIC	??$RB2QuadraticVertical@E@@YAXPAEPBEHHHHHH_N@Z	; RB2QuadraticVertical<unsigned char>
PUBLIC	??$RB2BilinearFilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z ; RB2BilinearFilteredHorizontalInplace<unsigned short>
PUBLIC	??$RB2BilinearFilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFilteredVertical<unsigned short>
PUBLIC	??$RB2BilinearFilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z ; RB2BilinearFilteredHorizontalInplace<unsigned char>
PUBLIC	??$RB2BilinearFilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFilteredVertical<unsigned char>
PUBLIC	??$RB2FilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z ; RB2FilteredHorizontalInplace<unsigned short>
PUBLIC	??$RB2FilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z	; RB2FilteredVertical<unsigned short>
PUBLIC	??$RB2FilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z ; RB2FilteredHorizontalInplace<unsigned char>
PUBLIC	??$RB2FilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z	; RB2FilteredVertical<unsigned char>
PUBLIC	??$RB2F_C@G@@YAXPAGPBGHHHHHH@Z			; RB2F_C<unsigned short>
PUBLIC	??$RB2F_C@E@@YAXPAEPBEHHHHHH@Z			; RB2F_C<unsigned char>
PUBLIC	??$Average2@G@@YAXPAEPBE1HHH@Z			; Average2<unsigned short>
PUBLIC	??$Average2@E@@YAXPAEPBE1HHH@Z			; Average2<unsigned char>
PUBLIC	??$HorizontalBicubic@G@@YAXPAEPBEHHHHH@Z	; HorizontalBicubic<unsigned short>
PUBLIC	??$HorizontalBicubic@E@@YAXPAEPBEHHHHH@Z	; HorizontalBicubic<unsigned char>
PUBLIC	??$VerticalBicubic@G@@YAXPAEPBEHHHHH@Z		; VerticalBicubic<unsigned short>
PUBLIC	??$VerticalBicubic@E@@YAXPAEPBEHHHHH@Z		; VerticalBicubic<unsigned char>
PUBLIC	??$HorizontalWiener@G@@YAXPAEPBEHHHHH@Z		; HorizontalWiener<unsigned short>
PUBLIC	??$HorizontalWiener@E@@YAXPAEPBEHHHHH@Z		; HorizontalWiener<unsigned char>
PUBLIC	??$VerticalWiener@G@@YAXPAEPBEHHHHH@Z		; VerticalWiener<unsigned short>
PUBLIC	??$VerticalWiener@E@@YAXPAEPBEHHHHH@Z		; VerticalWiener<unsigned char>
PUBLIC	??$RB2Cubic@G@@YAXPAEPBEHHHHHH_N@Z		; RB2Cubic<unsigned short>
PUBLIC	??$RB2Cubic@E@@YAXPAEPBEHHHHHH_N@Z		; RB2Cubic<unsigned char>
PUBLIC	??$RB2Quadratic@G@@YAXPAEPBEHHHHHH_N@Z		; RB2Quadratic<unsigned short>
PUBLIC	??$RB2Quadratic@E@@YAXPAEPBEHHHHHH_N@Z		; RB2Quadratic<unsigned char>
PUBLIC	??$RB2BilinearFiltered@G@@YAXPAEPBEHHHHHH_N@Z	; RB2BilinearFiltered<unsigned short>
PUBLIC	??$RB2BilinearFiltered@E@@YAXPAEPBEHHHHHH_N@Z	; RB2BilinearFiltered<unsigned char>
PUBLIC	??$RB2Filtered@G@@YAXPAEPBEHHHHHH_N@Z		; RB2Filtered<unsigned short>
PUBLIC	??$RB2Filtered@E@@YAXPAEPBEHHHHHH_N@Z		; RB2Filtered<unsigned char>
PUBLIC	??$RB2F@G@@YAXPAEPBEHHHHHH_N@Z			; RB2F<unsigned short>
PUBLIC	??$RB2F@E@@YAXPAEPBEHHHHHH_N@Z			; RB2F<unsigned char>
PUBLIC	??$DiagonalBilin@G@@YAXPAEPBEHHHHH@Z		; DiagonalBilin<unsigned short>
PUBLIC	??$DiagonalBilin@E@@YAXPAEPBEHHHHH@Z		; DiagonalBilin<unsigned char>
PUBLIC	??$HorizontalBilin@G@@YAXPAEPBEHHHHH@Z		; HorizontalBilin<unsigned short>
PUBLIC	??$HorizontalBilin@E@@YAXPAEPBEHHHHH@Z		; HorizontalBilin<unsigned char>
PUBLIC	??$VerticalBilin@G@@YAXPAEPBEHHHHH@Z		; VerticalBilin<unsigned short>
PUBLIC	??$VerticalBilin@E@@YAXPAEPBEHHHHH@Z		; VerticalBilin<unsigned char>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$VerticalBilin@E@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
_pDst8$ = 8						; size = 4
tv346 = 12						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
tv353 = 28						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$VerticalBilin@E@@YAXPAEPBEHHHHH@Z PROC		; VerticalBilin<unsigned char>, COMDAT

; 792  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 793  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 794  : 
; 795  :   nSrcPitch /= sizeof(pixel_t);
; 796  :   nDstPitch /= sizeof(pixel_t);
; 797  : 
; 798  :   for (int j = 0; j < nHeight - 1; j++)

	mov	ecx, DWORD PTR _nHeight$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _nWidth$[esp]
	dec	ecx
	push	esi
	mov	esi, DWORD PTR _pDst8$[esp+4]
	push	edi
	mov	edi, DWORD PTR _pSrc8$[esp+8]
	mov	DWORD PTR tv346[esp+8], ecx
	test	ecx, ecx
	jle	SHORT $LN3@VerticalBi
	mov	eax, DWORD PTR _nSrcPitch$[esp+8]
	push	ebp
$LL4@VerticalBi:

; 799  :   {
; 800  :     for (int i = 0; i < nWidth; i++)

	test	ebx, ebx
	jle	SHORT $LN6@VerticalBi
	mov	ebp, esi
	mov	DWORD PTR tv353[esp+12], ebx
	mov	esi, DWORD PTR _nSrcPitch$[esp+12]
	mov	eax, edi
	sub	ebp, edi
$LL7@VerticalBi:

; 801  :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+esi-1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+ebp-1], cl
	sub	ebx, 1
	jne	SHORT $LL7@VerticalBi
	mov	esi, DWORD PTR _pDst8$[esp+12]
	mov	ebx, DWORD PTR _nWidth$[esp+12]
	mov	eax, DWORD PTR _nSrcPitch$[esp+12]
	mov	ecx, DWORD PTR tv346[esp+12]
$LN6@VerticalBi:

; 802  :     pDst += nDstPitch;

	add	esi, DWORD PTR _nDstPitch$[esp+12]

; 803  :     pSrc += nSrcPitch;

	add	edi, eax
	sub	ecx, 1
	mov	DWORD PTR _pDst8$[esp+12], esi
	mov	DWORD PTR tv346[esp+12], ecx
	jne	SHORT $LL4@VerticalBi
	pop	ebp
$LN3@VerticalBi:

; 804  :   }
; 805  :   // last row
; 806  :   for (int i = 0; i < nWidth; i++)

	test	ebx, ebx
	jle	SHORT $LN9@VerticalBi
	sub	edi, esi
$LL18@VerticalBi:

; 807  :     pDst[i] = pSrc[i];

	mov	al, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [esi-1], al
	sub	ebx, 1
	jne	SHORT $LL18@VerticalBi
$LN9@VerticalBi:
	pop	edi
	pop	esi
	pop	ebx

; 808  : }

	ret	0
??$VerticalBilin@E@@YAXPAEPBEHHHHH@Z ENDP		; VerticalBilin<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$VerticalBilin@G@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
tv417 = 8						; size = 4
_pDst8$ = 8						; size = 4
_pSrc8$ = 12						; size = 4
tv423 = 16						; size = 4
_nDstPitch$ = 16					; size = 4
tv420 = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
tv425 = 28						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$VerticalBilin@G@@YAXPAEPBEHHHHH@Z PROC		; VerticalBilin<unsigned short>, COMDAT

; 792  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 793  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 794  : 
; 795  :   nSrcPitch /= sizeof(pixel_t);
; 796  :   nDstPitch /= sizeof(pixel_t);
; 797  : 
; 798  :   for (int j = 0; j < nHeight - 1; j++)

	mov	ecx, DWORD PTR _nHeight$[esp-4]
	mov	edx, DWORD PTR _nSrcPitch$[esp-4]
	dec	ecx
	mov	eax, DWORD PTR _pDst8$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR _nWidth$[esp]
	push	esi
	mov	esi, DWORD PTR _nDstPitch$[esp+4]
	shr	edx, 1
	shr	esi, 1
	mov	DWORD PTR tv417[esp+4], ecx
	push	edi
	mov	edi, DWORD PTR _pSrc8$[esp+8]
	test	ecx, ecx
	jle	SHORT $LN3@VerticalBi
	push	ebx
	lea	ebx, DWORD PTR [esi+esi]
	add	edx, edx
	mov	DWORD PTR tv425[esp+12], ebx
	mov	DWORD PTR tv423[esp+12], edx
$LL4@VerticalBi:

; 799  :   {
; 800  :     for (int i = 0; i < nWidth; i++)

	test	ebp, ebp
	jle	SHORT $LN6@VerticalBi
	lea	ebx, DWORD PTR [edx+edi]
	mov	esi, eax
	sub	edi, eax
	mov	DWORD PTR tv420[esp+12], edi
	mov	edi, ebp
	mov	ebp, DWORD PTR tv420[esp+12]
	npad	5
$LL7@VerticalBi:

; 801  :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	ecx, WORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, WORD PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [esi-2], cx
	sub	edi, 1
	jne	SHORT $LL7@VerticalBi
	mov	edi, DWORD PTR _pSrc8$[esp+12]
	mov	ebp, DWORD PTR _nWidth$[esp+12]
	mov	ecx, DWORD PTR tv417[esp+12]
	mov	edx, DWORD PTR tv423[esp+12]
	mov	ebx, DWORD PTR tv425[esp+12]
$LN6@VerticalBi:

; 802  :     pDst += nDstPitch;
; 803  :     pSrc += nSrcPitch;

	add	edi, edx
	add	eax, ebx
	sub	ecx, 1
	mov	DWORD PTR _pSrc8$[esp+12], edi
	mov	DWORD PTR tv417[esp+12], ecx
	jne	SHORT $LL4@VerticalBi
	pop	ebx
$LN3@VerticalBi:

; 804  :   }
; 805  :   // last row
; 806  :   for (int i = 0; i < nWidth; i++)

	test	ebp, ebp
	jle	SHORT $LN9@VerticalBi
	sub	edi, eax
	npad	9
$LL18@VerticalBi:

; 807  :     pDst[i] = pSrc[i];

	mov	cx, WORD PTR [eax+edi]
	lea	eax, DWORD PTR [eax+2]
	mov	WORD PTR [eax-2], cx
	sub	ebp, 1
	jne	SHORT $LL18@VerticalBi
$LN9@VerticalBi:
	pop	edi
	pop	esi
	pop	ebp

; 808  : }

	ret	0
??$VerticalBilin@G@@YAXPAEPBEHHHHH@Z ENDP		; VerticalBilin<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$HorizontalBilin@E@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
tv338 = -4						; size = 4
_pDst8$ = 8						; size = 4
tv334 = 12						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$HorizontalBilin@E@@YAXPAEPBEHHHHH@Z PROC		; HorizontalBilin<unsigned char>, COMDAT

; 813  : {

	push	ecx

; 814  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 815  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 816  : 
; 817  :   nSrcPitch /= sizeof(pixel_t);
; 818  :   nDstPitch /= sizeof(pixel_t);
; 819  : 
; 820  :   for (int j = 0; j < nHeight; j++)

	cmp	DWORD PTR _nHeight$[esp], 0
	push	edi
	mov	edi, DWORD PTR _pSrc8$[esp+4]
	jle	SHORT $LN3@Horizontal
	mov	ecx, DWORD PTR _pDst8$[esp+4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nWidth$[esp+12]
	dec	ebp
	push	esi
	mov	DWORD PTR tv338[esp+20], ebp
	npad	3
$LL4@Horizontal:

; 821  :   {
; 822  :     for (int i = 0; i < nWidth - 1; i++)

	test	ebp, ebp
	jle	SHORT $LN6@Horizontal
	mov	ebx, ecx
	mov	DWORD PTR tv334[esp+16], ebp
	mov	eax, edi
	sub	ebx, edi
	npad	2
$LL7@Horizontal:

; 823  :       pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [ebx+eax-1], cl
	sub	ebp, 1
	jne	SHORT $LL7@Horizontal
	mov	ebp, DWORD PTR tv338[esp+20]
	mov	ecx, DWORD PTR _pDst8$[esp+16]
$LN6@Horizontal:

; 824  : 
; 825  :     pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	al, BYTE PTR [edi+ebp]

; 826  :     pDst += nDstPitch;
; 827  :     pSrc += nSrcPitch;

	add	edi, DWORD PTR _nSrcPitch$[esp+16]
	mov	BYTE PTR [ecx+ebp], al
	add	ecx, DWORD PTR _nDstPitch$[esp+16]
	sub	DWORD PTR _nHeight$[esp+16], 1
	mov	DWORD PTR _pDst8$[esp+16], ecx
	jne	SHORT $LL4@Horizontal
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Horizontal:
	pop	edi

; 828  :   }
; 829  : }

	pop	ecx
	ret	0
??$HorizontalBilin@E@@YAXPAEPBEHHHHH@Z ENDP		; HorizontalBilin<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$HorizontalBilin@G@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
tv326 = -4						; size = 4
_pDst8$ = 8						; size = 4
tv328 = 12						; size = 4
_pSrc8$ = 12						; size = 4
tv327 = 16						; size = 4
_nDstPitch$ = 16					; size = 4
tv325 = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$HorizontalBilin@G@@YAXPAEPBEHHHHH@Z PROC		; HorizontalBilin<unsigned short>, COMDAT

; 813  : {

	push	ecx

; 814  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 815  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 816  : 
; 817  :   nSrcPitch /= sizeof(pixel_t);

	mov	ecx, DWORD PTR _nSrcPitch$[esp]
	push	esi

; 818  :   nDstPitch /= sizeof(pixel_t);

	mov	esi, DWORD PTR _nDstPitch$[esp+4]
	shr	ecx, 1
	shr	esi, 1

; 819  : 
; 820  :   for (int j = 0; j < nHeight; j++)

	cmp	DWORD PTR _nHeight$[esp+4], 0
	push	edi
	mov	edi, DWORD PTR _pSrc8$[esp+8]
	jle	SHORT $LN3@Horizontal
	mov	eax, DWORD PTR _nWidth$[esp+8]
	add	esi, esi
	push	ebx
	add	ecx, ecx
	mov	DWORD PTR tv326[esp+16], ecx
	mov	ecx, DWORD PTR _pDst8$[esp+12]
	lea	edx, DWORD PTR [eax-1]
	lea	ebx, DWORD PTR [eax*2-2]
	mov	DWORD PTR tv328[esp+12], edx
	push	ebp
	mov	DWORD PTR tv325[esp+16], ebx
	npad	2
$LL4@Horizontal:

; 821  :   {
; 822  :     for (int i = 0; i < nWidth - 1; i++)

	test	edx, edx
	jle	SHORT $LN6@Horizontal
	mov	ebx, ecx
	mov	eax, edi
	sub	ebx, edi
	mov	ebp, edx
	npad	4
$LL7@Horizontal:

; 823  :       pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	ecx, WORD PTR [eax]
	lea	eax, DWORD PTR [eax+2]
	movzx	edx, WORD PTR [eax]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [ebx+eax-2], cx
	sub	ebp, 1
	jne	SHORT $LL7@Horizontal
	mov	ecx, DWORD PTR _pDst8$[esp+16]
	mov	edx, DWORD PTR tv328[esp+16]
	mov	ebx, DWORD PTR tv325[esp+16]
$LN6@Horizontal:

; 824  : 
; 825  :     pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	ax, WORD PTR [ebx+edi]

; 826  :     pDst += nDstPitch;
; 827  :     pSrc += nSrcPitch;

	add	edi, DWORD PTR tv326[esp+20]
	mov	WORD PTR [ebx+ecx], ax
	add	ecx, esi
	sub	DWORD PTR _nHeight$[esp+16], 1
	mov	DWORD PTR _pDst8$[esp+16], ecx
	jne	SHORT $LL4@Horizontal
	pop	ebp
	pop	ebx
$LN3@Horizontal:
	pop	edi
	pop	esi

; 828  :   }
; 829  : }

	pop	ecx
	ret	0
??$HorizontalBilin@G@@YAXPAEPBEHHHHH@Z ENDP		; HorizontalBilin<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$DiagonalBilin@E@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
tv635 = -12						; size = 4
tv641 = -8						; size = 4
tv647 = -4						; size = 4
_pDst8$ = 8						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
tv633 = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
tv640 = 28						; size = 4
tv639 = 28						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$DiagonalBilin@E@@YAXPAEPBEHHHHH@Z PROC		; DiagonalBilin<unsigned char>, COMDAT

; 834  : {

	sub	esp, 12					; 0000000cH

; 835  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 836  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 837  : 
; 838  :   nSrcPitch /= sizeof(pixel_t);
; 839  :   nDstPitch /= sizeof(pixel_t);
; 840  : 
; 841  :   for (int j = 0; j < nHeight - 1; j++)

	mov	eax, DWORD PTR _nHeight$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _pSrc8$[esp+12]
	dec	eax
	mov	DWORD PTR tv635[esp+16], eax
	push	ebp
	mov	ebp, DWORD PTR _pDst8$[esp+16]
	push	esi
	push	edi
	test	eax, eax
	jle	$LN3@DiagonalBi
	mov	esi, DWORD PTR _nWidth$[esp+24]
	mov	edi, DWORD PTR _nSrcPitch$[esp+24]
	dec	esi
	mov	DWORD PTR tv647[esp+28], esi
	npad	3
$LL4@DiagonalBi:

; 842  :   {
; 843  :     for (int i = 0; i < nWidth - 1; i++)

	test	esi, esi
	jle	SHORT $LN6@DiagonalBi
	mov	edx, DWORD PTR _nSrcPitch$[esp+24]
	mov	ecx, 1
	sub	ecx, edx
	mov	DWORD PTR tv640[esp+24], ebx
	mov	eax, ebp
	mov	DWORD PTR tv639[esp+24], esi
	lea	edi, DWORD PTR [ebx+edx]
	sub	ebx, ebp
	mov	ebp, ecx
$LL7@DiagonalBi:

; 844  :       pDst[i] = (pSrc[i] + pSrc[i + 1] + pSrc[i + nSrcPitch] + pSrc[i + nSrcPitch + 1] + 2) >> 2;

	movzx	ecx, BYTE PTR [ebx+eax]
	lea	edi, DWORD PTR [edi+1]
	movzx	edx, BYTE PTR [edi+ebp-1]
	lea	eax, DWORD PTR [eax+1]
	add	edx, ecx
	movzx	ecx, BYTE PTR [edi-1]
	add	edx, ecx
	movzx	ecx, BYTE PTR [edi]
	add	ecx, 2
	add	ecx, edx
	shr	ecx, 2
	sub	DWORD PTR tv639[esp+24], 1
	mov	BYTE PTR [eax-1], cl
	jne	SHORT $LL7@DiagonalBi
	mov	ebx, DWORD PTR _pSrc8$[esp+24]
	mov	ebp, DWORD PTR _pDst8$[esp+24]
	mov	esi, DWORD PTR tv647[esp+28]
	mov	edi, DWORD PTR _nSrcPitch$[esp+24]
$LN6@DiagonalBi:

; 845  : 
; 846  :     pDst[nWidth - 1] = (pSrc[nWidth - 1] + pSrc[nWidth + nSrcPitch - 1] + 1) >> 1;

	movzx	eax, BYTE PTR [esi+ebx]
	lea	edx, DWORD PTR [ebx+edi]
	movzx	ecx, BYTE PTR [edx+esi]
	inc	eax
	add	eax, ecx

; 847  :     pDst += nDstPitch;
; 848  :     pSrc += nSrcPitch;

	mov	ebx, edx
	shr	eax, 1
	mov	BYTE PTR [esi+ebp], al
	add	ebp, DWORD PTR _nDstPitch$[esp+24]
	sub	DWORD PTR tv635[esp+28], 1
	mov	DWORD PTR _pDst8$[esp+24], ebp
	mov	DWORD PTR _pSrc8$[esp+24], ebx
	jne	$LL4@DiagonalBi
$LN3@DiagonalBi:

; 849  :   }
; 850  :   for (int i = 0; i < nWidth - 1; i++)

	mov	ecx, DWORD PTR _nWidth$[esp+24]
	lea	edi, DWORD PTR [ecx-1]
	test	edi, edi
	jle	SHORT $LN24@DiagonalBi
	sub	ebp, ebx
	mov	esi, ebx
	mov	DWORD PTR tv633[esp+24], ebp
	npad	5
$LL10@DiagonalBi:

; 851  :     pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	eax, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [esi+ebp-1], al
	sub	edi, 1
	jne	SHORT $LL10@DiagonalBi

; 852  :   pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	ecx, DWORD PTR _nWidth$[esp+24]
	mov	ebp, DWORD PTR _pDst8$[esp+24]
$LN24@DiagonalBi:
	mov	al, BYTE PTR [ebx+ecx-1]
	pop	edi
	pop	esi
	mov	BYTE PTR [ecx+ebp-1], al
	pop	ebp
	pop	ebx

; 853  : }

	add	esp, 12					; 0000000cH
	ret	0
??$DiagonalBilin@E@@YAXPAEPBEHHHHH@Z ENDP		; DiagonalBilin<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$DiagonalBilin@G@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
tv744 = -16						; size = 4
tv739 = -12						; size = 4
tv741 = -8						; size = 4
tv740 = -4						; size = 4
_pDst8$ = 8						; size = 4
tv732 = 12						; size = 4
_pSrc8$ = 12						; size = 4
tv730 = 16						; size = 4
_nDstPitch$ = 16					; size = 4
tv731 = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
tv735 = 28						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$DiagonalBilin@G@@YAXPAEPBEHHHHH@Z PROC		; DiagonalBilin<unsigned short>, COMDAT

; 834  : {

	sub	esp, 16					; 00000010H

; 835  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 836  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 837  : 
; 838  :   nSrcPitch /= sizeof(pixel_t);

	mov	edx, DWORD PTR _nSrcPitch$[esp+12]
	mov	eax, DWORD PTR _pSrc8$[esp+12]
	push	ebx
	mov	ebx, DWORD PTR _pDst8$[esp+16]
	push	ebp

; 839  :   nDstPitch /= sizeof(pixel_t);
; 840  : 
; 841  :   for (int j = 0; j < nHeight - 1; j++)

	mov	ebp, DWORD PTR _nHeight$[esp+20]
	push	esi
	push	edi
	mov	edi, DWORD PTR _nDstPitch$[esp+28]
	dec	ebp
	shr	edx, 1
	shr	edi, 1
	mov	DWORD PTR tv730[esp+28], ebp
	test	ebp, ebp
	jle	$LN24@DiagonalBi
	mov	ecx, DWORD PTR _nWidth$[esp+28]
	lea	esi, DWORD PTR [ecx-1]
	add	ecx, edx
	mov	DWORD PTR tv744[esp+32], esi
	lea	ecx, DWORD PTR [ecx*2-2]
	mov	DWORD PTR tv739[esp+32], ecx
	lea	ecx, DWORD PTR [edi+edi]
	mov	edi, DWORD PTR _nWidth$[esp+28]
	mov	DWORD PTR tv741[esp+32], ecx
	lea	ecx, DWORD PTR [edx+edx]
	mov	DWORD PTR tv740[esp+32], ecx
$LL4@DiagonalBi:

; 842  :   {
; 843  :     for (int i = 0; i < nWidth - 1; i++)

	test	esi, esi
	jle	SHORT $LN6@DiagonalBi
	mov	ebp, DWORD PTR _pDst8$[esp+28]
	add	ecx, eax
	mov	ebx, eax
	mov	DWORD PTR tv735[esp+28], ecx
	sub	ebp, eax
	mov	DWORD PTR tv731[esp+28], esi
	mov	eax, ecx
	npad	2
$LL7@DiagonalBi:

; 844  :       pDst[i] = (pSrc[i] + pSrc[i + 1] + pSrc[i + nSrcPitch] + pSrc[i + nSrcPitch + 1] + 2) >> 2;

	movzx	ecx, WORD PTR [ebx]
	lea	eax, DWORD PTR [eax+2]
	movzx	edx, WORD PTR [ebx+2]
	lea	ebx, DWORD PTR [ebx+2]
	add	edx, ecx
	movzx	ecx, WORD PTR [eax]
	add	edx, ecx
	movzx	ecx, WORD PTR [eax-2]
	add	ecx, 2
	add	ecx, edx
	shr	ecx, 2
	sub	DWORD PTR tv731[esp+28], 1
	mov	WORD PTR [ebx+ebp-2], cx
	jne	SHORT $LL7@DiagonalBi
	mov	eax, DWORD PTR _pSrc8$[esp+28]
	mov	ebx, DWORD PTR _pDst8$[esp+28]
	mov	esi, DWORD PTR tv744[esp+32]
	mov	ebp, DWORD PTR tv730[esp+28]
	mov	edi, DWORD PTR _nWidth$[esp+28]
$LN6@DiagonalBi:

; 845  : 
; 846  :     pDst[nWidth - 1] = (pSrc[nWidth - 1] + pSrc[nWidth + nSrcPitch - 1] + 1) >> 1;

	mov	ecx, DWORD PTR tv739[esp+32]
	movzx	edx, WORD PTR [eax+edi*2-2]
	movzx	ecx, WORD PTR [ecx+eax]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [ebx+edi*2-2], cx

; 847  :     pDst += nDstPitch;

	add	ebx, DWORD PTR tv741[esp+32]

; 848  :     pSrc += nSrcPitch;

	mov	ecx, DWORD PTR tv740[esp+32]
	add	eax, ecx
	sub	ebp, 1
	mov	DWORD PTR _pDst8$[esp+28], ebx
	mov	DWORD PTR _pSrc8$[esp+28], eax
	mov	DWORD PTR tv730[esp+28], ebp
	jne	$LL4@DiagonalBi
	jmp	SHORT $LN3@DiagonalBi
$LN24@DiagonalBi:
	mov	edi, DWORD PTR _nWidth$[esp+28]
$LN3@DiagonalBi:

; 849  :   }
; 850  :   for (int i = 0; i < nWidth - 1; i++)

	lea	ebp, DWORD PTR [edi-1]
	test	ebp, ebp
	jle	SHORT $LN9@DiagonalBi
	sub	ebx, eax
	mov	edi, eax
	mov	DWORD PTR tv732[esp+28], ebx
	npad	5
$LL10@DiagonalBi:

; 851  :     pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	ecx, WORD PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, WORD PTR [edi]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [edi+ebx-2], cx
	sub	ebp, 1
	jne	SHORT $LL10@DiagonalBi
	mov	ebx, DWORD PTR _pDst8$[esp+28]
	mov	edi, DWORD PTR _nWidth$[esp+28]
$LN9@DiagonalBi:

; 852  :   pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	ax, WORD PTR [eax+edi*2-2]
	mov	WORD PTR [ebx+edi*2-2], ax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 853  : }

	add	esp, 16					; 00000010H
	ret	0
??$DiagonalBilin@G@@YAXPAEPBEHHHHH@Z ENDP		; DiagonalBilin<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2F@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst8$ = 8						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2F@E@@YAXPAEPBEHHHHHH_N@Z PROC			; RB2F<unsigned char>, COMDAT

; 84   :   assert(y_beg >= 0);
; 85   :   assert(y_end <= nHeight);
; 86   : 
; 87   :   pixel_t *    pDst = reinterpret_cast<pixel_t *>(pDst8);
; 88   :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 89   : 
; 90   :   if (isse2 && (sizeof(pixel_t) == 1))

	cmp	BYTE PTR _isse2$[esp-4], 0
	je	SHORT $LN2@RB2F

; 91   :   {
; 92   :     int				y = 0;
; 93   : 
; 94   :     RB2_jump(y_beg, y, pDst, pSrc, nDstPitch, nSrcPitch);
; 95   :     RB2F_iSSE((uint8_t *)pDst, (uint8_t *)pSrc, nDstPitch, nSrcPitch, nWidth, y_end - y_beg);

	mov	eax, DWORD PTR _y_end$[esp-4]
	mov	ecx, DWORD PTR _nSrcPitch$[esp-4]
	mov	edx, DWORD PTR _nDstPitch$[esp-4]
	push	esi
	mov	esi, DWORD PTR _y_beg$[esp]
	sub	eax, esi
	push	eax
	push	DWORD PTR _nWidth$[esp+4]
	mov	eax, DWORD PTR _pSrc8$[esp+8]
	push	ecx
	imul	ecx, esi
	push	edx
	imul	edx, esi
	add	edx, DWORD PTR _pDst8$[esp+16]
	lea	eax, DWORD PTR [eax+ecx*2]
	push	eax
	push	edx
	call	_RB2F_iSSE
	add	esp, 24					; 00000018H
	pop	esi

; 100  :   }
; 101  : }

	ret	0
$LN2@RB2F:

; 96   :   }
; 97   :   else
; 98   :   {
; 99   :     RB2F_C<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth, nHeight, y_beg, y_end);

	push	DWORD PTR _y_end$[esp-4]
	mov	edx, DWORD PTR _pSrc8$[esp]
	push	DWORD PTR _y_beg$[esp]
	push	ecx
	push	DWORD PTR _nWidth$[esp+8]
	mov	ecx, DWORD PTR _pDst8$[esp+12]
	push	DWORD PTR _nSrcPitch$[esp+12]
	push	DWORD PTR _nDstPitch$[esp+16]
	call	??$RB2F_C@E@@YAXPAEPBEHHHHHH@Z		; RB2F_C<unsigned char>
	add	esp, 24					; 00000018H

; 100  :   }
; 101  : }

	ret	0
??$RB2F@E@@YAXPAEPBEHHHHHH_N@Z ENDP			; RB2F<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2F@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst8$ = 8						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2F@G@@YAXPAEPBEHHHHHH_N@Z PROC			; RB2F<unsigned short>, COMDAT

; 84   :   assert(y_beg >= 0);
; 85   :   assert(y_end <= nHeight);
; 86   : 
; 87   :   pixel_t *    pDst = reinterpret_cast<pixel_t *>(pDst8);
; 88   :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 89   : 
; 90   :   if (isse2 && (sizeof(pixel_t) == 1))
; 91   :   {
; 92   :     int				y = 0;
; 93   : 
; 94   :     RB2_jump(y_beg, y, pDst, pSrc, nDstPitch, nSrcPitch);
; 95   :     RB2F_iSSE((uint8_t *)pDst, (uint8_t *)pSrc, nDstPitch, nSrcPitch, nWidth, y_end - y_beg);
; 96   :   }
; 97   :   else
; 98   :   {
; 99   :     RB2F_C<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth, nHeight, y_beg, y_end);

	push	DWORD PTR _y_end$[esp-4]
	mov	edx, DWORD PTR _pSrc8$[esp]
	push	DWORD PTR _y_beg$[esp]
	push	ecx
	push	DWORD PTR _nWidth$[esp+8]
	mov	ecx, DWORD PTR _pDst8$[esp+12]
	push	DWORD PTR _nSrcPitch$[esp+12]
	push	DWORD PTR _nDstPitch$[esp+16]
	call	??$RB2F_C@G@@YAXPAGPBGHHHHHH@Z		; RB2F_C<unsigned short>
	add	esp, 24					; 00000018H

; 100  :   }
; 101  : }

	ret	0
??$RB2F@G@@YAXPAEPBEHHHHHH_N@Z ENDP			; RB2F<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2Filtered@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2Filtered@E@@YAXPAEPBEHHHHHH_N@Z PROC		; RB2Filtered<unsigned char>, COMDAT

; 358  :   RB2FilteredVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	push	DWORD PTR _isse2$[esp]
	mov	ebx, DWORD PTR _nWidth$[esp+4]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2FilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z ; RB2FilteredVertical<unsigned char>

; 359  :   RB2FilteredHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	edx, DWORD PTR _nDstPitch$[esp+28]
	add	esp, 28					; 0000001cH
	push	DWORD PTR _isse2$[esp]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2FilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z ; RB2FilteredHorizontalInplace<unsigned char>
	add	esp, 20					; 00000014H
	pop	ebx

; 360  : }

	ret	0
??$RB2Filtered@E@@YAXPAEPBEHHHHHH_N@Z ENDP		; RB2Filtered<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2Filtered@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2Filtered@G@@YAXPAEPBEHHHHHH_N@Z PROC		; RB2Filtered<unsigned short>, COMDAT

; 358  :   RB2FilteredVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _nWidth$[esp]
	push	ecx
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2FilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z ; RB2FilteredVertical<unsigned short>

; 359  :   RB2FilteredHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	edx, DWORD PTR _nDstPitch$[esp+28]
	add	esp, 24					; 00000018H
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2FilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z ; RB2FilteredHorizontalInplace<unsigned short>
	add	esp, 20					; 00000014H
	pop	ebx

; 360  : }

	ret	0
??$RB2Filtered@G@@YAXPAEPBEHHHHHH_N@Z ENDP		; RB2Filtered<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2BilinearFiltered@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2BilinearFiltered@E@@YAXPAEPBEHHHHHH_N@Z PROC	; RB2BilinearFiltered<unsigned char>, COMDAT

; 492  :   RB2BilinearFilteredVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	mov	ecx, DWORD PTR _pDst$[esp-4]
	push	ebx
	push	DWORD PTR _isse2$[esp]
	mov	ebx, DWORD PTR _nWidth$[esp+4]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	DWORD PTR _nHeight$[esp+12]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2BilinearFilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFilteredVertical<unsigned char>

; 493  :   RB2BilinearFilteredHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	edx, DWORD PTR _nDstPitch$[esp+28]
	add	esp, 28					; 0000001cH
	push	DWORD PTR _isse2$[esp]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2BilinearFilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z ; RB2BilinearFilteredHorizontalInplace<unsigned char>
	add	esp, 20					; 00000014H
	pop	ebx

; 494  : }

	ret	0
??$RB2BilinearFiltered@E@@YAXPAEPBEHHHHHH_N@Z ENDP	; RB2BilinearFiltered<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2BilinearFiltered@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2BilinearFiltered@G@@YAXPAEPBEHHHHHH_N@Z PROC	; RB2BilinearFiltered<unsigned short>, COMDAT

; 492  :   RB2BilinearFilteredVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _nWidth$[esp]
	push	ecx
	push	DWORD PTR _y_end$[esp+4]
	mov	ecx, DWORD PTR _pDst$[esp+8]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	DWORD PTR _nHeight$[esp+12]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2BilinearFilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFilteredVertical<unsigned short>

; 493  :   RB2BilinearFilteredHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	edx, DWORD PTR _nDstPitch$[esp+28]
	add	esp, 24					; 00000018H
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2BilinearFilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z ; RB2BilinearFilteredHorizontalInplace<unsigned short>
	add	esp, 20					; 00000014H
	pop	ebx

; 494  : }

	ret	0
??$RB2BilinearFiltered@G@@YAXPAEPBEHHHHHH_N@Z ENDP	; RB2BilinearFiltered<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2Quadratic@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2Quadratic@E@@YAXPAEPBEHHHHHH_N@Z PROC		; RB2Quadratic<unsigned char>, COMDAT

; 632  :   RB2QuadraticVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	mov	ecx, DWORD PTR _pDst$[esp-4]
	push	ebx
	push	DWORD PTR _isse2$[esp]
	mov	ebx, DWORD PTR _nWidth$[esp+4]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	DWORD PTR _nHeight$[esp+12]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2QuadraticVertical@E@@YAXPAEPBEHHHHHH_N@Z ; RB2QuadraticVertical<unsigned char>

; 633  :   RB2QuadraticHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	eax, DWORD PTR _isse2$[esp+28]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _nDstPitch$[esp]
	movzx	eax, al
	push	eax
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2QuadraticHorizontalInplace@E@@YAXPAEHHHHHH@Z ; RB2QuadraticHorizontalInplace<unsigned char>
	add	esp, 20					; 00000014H
	pop	ebx

; 634  : }

	ret	0
??$RB2Quadratic@E@@YAXPAEPBEHHHHHH_N@Z ENDP		; RB2Quadratic<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2Quadratic@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2Quadratic@G@@YAXPAEPBEHHHHHH_N@Z PROC		; RB2Quadratic<unsigned short>, COMDAT

; 632  :   RB2QuadraticVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _nWidth$[esp]
	push	ecx
	push	DWORD PTR _y_end$[esp+4]
	mov	ecx, DWORD PTR _pDst$[esp+8]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	DWORD PTR _nHeight$[esp+12]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2QuadraticVertical@G@@YAXPAEPBEHHHHHH_N@Z ; RB2QuadraticVertical<unsigned short>

; 633  :   RB2QuadraticHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	edx, DWORD PTR _nDstPitch$[esp+28]
	add	esp, 24					; 00000018H
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2QuadraticHorizontalInplace@G@@YAXPAEHHHHHH@Z ; RB2QuadraticHorizontalInplace<unsigned short>
	add	esp, 20					; 00000014H
	pop	ebx

; 634  : }

	ret	0
??$RB2Quadratic@G@@YAXPAEPBEHHHHHH_N@Z ENDP		; RB2Quadratic<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2Cubic@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2Cubic@E@@YAXPAEPBEHHHHHH_N@Z PROC			; RB2Cubic<unsigned char>, COMDAT

; 778  :   RB2CubicVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	mov	ecx, DWORD PTR _pDst$[esp-4]
	push	ebx
	push	DWORD PTR _isse2$[esp]
	mov	ebx, DWORD PTR _nWidth$[esp+4]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	DWORD PTR _nHeight$[esp+12]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2CubicVertical@E@@YAXPAEPBEHHHHHH_N@Z ; RB2CubicVertical<unsigned char>

; 779  :   RB2CubicHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	edx, DWORD PTR _nDstPitch$[esp+28]
	add	esp, 28					; 0000001cH
	push	DWORD PTR _isse2$[esp]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2CubicHorizontalInplace@E@@YAXPAEHHHHH_N@Z ; RB2CubicHorizontalInplace<unsigned char>
	add	esp, 20					; 00000014H
	pop	ebx

; 780  : }

	ret	0
??$RB2Cubic@E@@YAXPAEPBEHHHHHH_N@Z ENDP			; RB2Cubic<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2Cubic@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_y_beg$ = 32						; size = 4
_y_end$ = 36						; size = 4
_isse2$ = 40						; size = 1
??$RB2Cubic@G@@YAXPAEPBEHHHHHH_N@Z PROC			; RB2Cubic<unsigned short>, COMDAT

; 778  :   RB2CubicVertical<pixel_t>(pDst, pSrc, nDstPitch, nSrcPitch, nWidth * 2, nHeight, y_beg, y_end, isse2); // intermediate half height

	mov	edx, DWORD PTR _pSrc$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _nWidth$[esp]
	push	ecx
	push	DWORD PTR _y_end$[esp+4]
	mov	ecx, DWORD PTR _pDst$[esp+8]
	push	DWORD PTR _y_beg$[esp+8]
	lea	eax, DWORD PTR [ebx+ebx]
	push	DWORD PTR _nHeight$[esp+12]
	push	eax
	push	DWORD PTR _nSrcPitch$[esp+20]
	push	DWORD PTR _nDstPitch$[esp+24]
	call	??$RB2CubicVertical@G@@YAXPAEPBEHHHHHH_N@Z ; RB2CubicVertical<unsigned short>

; 779  :   RB2CubicHorizontalInplace<pixel_t>(pDst, nDstPitch, nWidth, nHeight, y_beg, y_end, isse2); // inpace width reduction

	mov	edx, DWORD PTR _nDstPitch$[esp+28]
	add	esp, 28					; 0000001cH
	push	DWORD PTR _isse2$[esp]
	push	DWORD PTR _y_end$[esp+4]
	push	DWORD PTR _y_beg$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[esp+16]
	push	ebx
	call	??$RB2CubicHorizontalInplace@G@@YAXPAEHHHHH_N@Z ; RB2CubicHorizontalInplace<unsigned short>
	add	esp, 20					; 00000014H
	pop	ebx

; 780  : }

	ret	0
??$RB2Cubic@G@@YAXPAEPBEHHHHHH_N@Z ENDP			; RB2Cubic<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$VerticalWiener@E@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
tv1038 = -36						; size = 4
tv1033 = -36						; size = 4
tv1034 = -32						; size = 4
_i$1$ = -28						; size = 4
$T1 = -28						; size = 4
tv1043 = -24						; size = 4
tv1041 = -20						; size = 4
$T2 = -16						; size = 4
tv1037 = -12						; size = 4
_j$1$ = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
_pDst8$ = 8						; size = 4
tv1047 = 12						; size = 4
tv1028 = 12						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
tv1048 = 20						; size = 4
tv1036 = 20						; size = 4
tv1035 = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
tv1031 = 28						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$VerticalWiener@E@@YAXPAEPBEHHHHH@Z PROC		; VerticalWiener<unsigned char>, COMDAT

; 860  : {

	sub	esp, 36					; 00000024H

; 861  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);

	mov	ecx, DWORD PTR _nDstPitch$[esp+32]
	mov	eax, 2
	push	ebx
	mov	ebx, DWORD PTR _nSrcPitch$[esp+36]
	push	ebp
	mov	ebp, DWORD PTR _nWidth$[esp+40]
	push	esi

; 862  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);

	mov	esi, DWORD PTR _pSrc8$[esp+44]
	push	edi
	mov	edi, DWORD PTR _pDst8$[esp+48]

; 863  : 
; 864  :   nSrcPitch /= sizeof(pixel_t);
; 865  :   nDstPitch /= sizeof(pixel_t);
; 866  : 
; 867  :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;

	mov	DWORD PTR _max_pixel_value$[esp+52], 255 ; 000000ffH
	mov	DWORD PTR tv1047[esp+48], eax
	npad	4
$LL4@VerticalWi:

; 868  : 
; 869  :   for (int j = 0; j < 2; j++)
; 870  :   {
; 871  :     for (int i = 0; i < nWidth; i++)

	test	ebp, ebp
	jle	SHORT $LN6@VerticalWi
	sub	edi, esi
	mov	DWORD PTR tv1048[esp+48], ebp
	mov	edx, esi
	mov	DWORD PTR tv1038[esp+52], edi
$LL7@VerticalWi:

; 872  :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	eax, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	movzx	ecx, BYTE PTR [edx+ebx-1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edi+edx-1], al
	sub	ebp, 1
	jne	SHORT $LL7@VerticalWi
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ebp, DWORD PTR _nWidth$[esp+48]
	mov	eax, DWORD PTR tv1047[esp+48]
	mov	ecx, DWORD PTR _nDstPitch$[esp+48]
$LN6@VerticalWi:

; 873  :     pDst += nDstPitch;

	add	edi, ecx

; 874  :     pSrc += nSrcPitch;

	add	esi, ebx
	sub	eax, 1
	mov	DWORD PTR _pDst8$[esp+48], edi
	mov	DWORD PTR tv1047[esp+48], eax
	jne	SHORT $LL4@VerticalWi

; 875  :   }
; 876  :   for (int j = 2; j < nHeight - 4; j++)

	mov	eax, DWORD PTR _nHeight$[esp+48]
	mov	DWORD PTR _pSrc8$[esp+48], esi
	lea	edx, DWORD PTR [eax-4]
	mov	DWORD PTR _j$1$[esp+52], edx
	cmp	edx, 2
	jle	$LN9@VerticalWi
	lea	eax, DWORD PTR [edx-2]
	mov	DWORD PTR tv1033[esp+52], eax
	npad	7
$LL10@VerticalWi:

; 877  :   {
; 878  :     for (int i = 0; i < nWidth; i++)

	mov	DWORD PTR _i$1$[esp+52], 0
	test	ebp, ebp
	jle	$LN12@VerticalWi
	lea	eax, DWORD PTR [ebx+ebx]
	mov	DWORD PTR tv1035[esp+48], esi
	mov	ecx, esi

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T2[esp+52], 0
	sub	ecx, eax
	sub	edi, esi
	add	eax, esi
	mov	DWORD PTR tv1037[esp+52], edi
	mov	DWORD PTR tv1043[esp+52], eax
	mov	edx, esi
	lea	eax, DWORD PTR [esi+ebx*2]
	mov	DWORD PTR tv1034[esp+52], ecx
	mov	esi, DWORD PTR _i$1$[esp+52]
	add	eax, ebx
	mov	DWORD PTR tv1041[esp+52], eax
	mov	edi, ecx
$LL13@VerticalWi:
	movzx	eax, BYTE PTR [edx]
	lea	edi, DWORD PTR [edi+1]
	movzx	ecx, BYTE PTR [edx+ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T1[esp+52]
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	add	ecx, eax
	movzx	eax, BYTE PTR [edi+ebx-1]
	shl	ecx, 2
	sub	ecx, eax
	mov	eax, DWORD PTR tv1043[esp+52]
	movzx	eax, BYTE PTR [eax+esi]
	sub	ecx, eax
	mov	eax, DWORD PTR tv1041[esp+52]
	movzx	eax, BYTE PTR [eax+esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	movzx	eax, BYTE PTR [edi-1]
	add	ecx, 16					; 00000010H
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ecx, DWORD PTR $T2[esp+52]
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	sar	eax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T1[esp+52], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	edx, ecx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, 255				; 000000ffH
	cmp	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [edx]
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	edx, DWORD PTR tv1035[esp+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	eax, DWORD PTR tv1037[esp+52]
	inc	esi
	mov	BYTE PTR [edx+eax], cl
	inc	edx
	mov	DWORD PTR tv1035[esp+48], edx
	cmp	esi, ebp
	jl	SHORT $LL13@VerticalWi
	mov	esi, DWORD PTR _pSrc8$[esp+48]
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ecx, DWORD PTR _nDstPitch$[esp+48]
	mov	eax, DWORD PTR tv1033[esp+52]
$LN12@VerticalWi:

; 881  :         ((pSrc[i - nSrcPitch * 2])
; 882  :           + (-(pSrc[i - nSrcPitch]) + (pSrc[i] << 2) + (pSrc[i + nSrcPitch] << 2) - (pSrc[i + nSrcPitch * 2])) * 5
; 883  :           + (pSrc[i + nSrcPitch * 3]) + 16) >> 5));
; 884  :     }
; 885  :     pDst += nDstPitch;

	add	edi, ecx

; 886  :     pSrc += nSrcPitch;

	add	esi, ebx
	sub	eax, 1
	mov	DWORD PTR _pDst8$[esp+48], edi
	mov	DWORD PTR _pSrc8$[esp+48], esi
	mov	DWORD PTR tv1033[esp+52], eax
	jne	$LL10@VerticalWi
	mov	edx, DWORD PTR _j$1$[esp+52]
	mov	eax, DWORD PTR _nHeight$[esp+48]
$LN9@VerticalWi:

; 887  :   }
; 888  :   for (int j = nHeight - 4; j < nHeight - 1; j++)

	dec	eax
	cmp	edx, eax
	jge	SHORT $LN15@VerticalWi
	sub	eax, edx
	mov	DWORD PTR tv1028[esp+48], eax
	npad	4
$LL16@VerticalWi:

; 889  :   {
; 890  :     for (int i = 0; i < nWidth; i++)

	test	ebp, ebp
	jle	SHORT $LN18@VerticalWi
	sub	edi, esi
	mov	DWORD PTR tv1031[esp+48], ebp
	mov	eax, esi
	mov	DWORD PTR tv1036[esp+48], edi
$LL19@VerticalWi:

; 891  :     {
; 892  :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+ebx-1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+edi-1], cl
	sub	ebp, 1
	jne	SHORT $LL19@VerticalWi
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ebp, DWORD PTR _nWidth$[esp+48]
	mov	eax, DWORD PTR tv1028[esp+48]
	mov	ecx, DWORD PTR _nDstPitch$[esp+48]
$LN18@VerticalWi:

; 893  :     }
; 894  : 
; 895  :     pDst += nDstPitch;

	add	edi, ecx

; 896  :     pSrc += nSrcPitch;

	add	esi, ebx
	sub	eax, 1
	mov	DWORD PTR _pDst8$[esp+48], edi
	mov	DWORD PTR tv1028[esp+48], eax
	jne	SHORT $LL16@VerticalWi
$LN15@VerticalWi:

; 897  :   }
; 898  :   // last row
; 899  :   for (int i = 0; i < nWidth; i++)

	test	ebp, ebp
	jle	SHORT $LN21@VerticalWi
	sub	esi, edi
$LL46@VerticalWi:

; 900  :     pDst[i] = pSrc[i];

	mov	al, BYTE PTR [esi+edi]
	lea	edi, DWORD PTR [edi+1]
	mov	BYTE PTR [edi-1], al
	sub	ebp, 1
	jne	SHORT $LL46@VerticalWi
$LN21@VerticalWi:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 901  : }

	add	esp, 36					; 00000024H
	ret	0
??$VerticalWiener@E@@YAXPAEPBEHHHHH@Z ENDP		; VerticalWiener<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$VerticalWiener@G@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
_max_pixel_value$1$ = -48				; size = 4
tv1426 = -44						; size = 4
tv1427 = -40						; size = 4
tv1425 = -36						; size = 4
tv1437 = -32						; size = 4
tv1432 = -32						; size = 4
tv1428 = -28						; size = 4
tv1433 = -24						; size = 4
tv1430 = -20						; size = 4
$T1 = -20						; size = 4
tv1436 = -16						; size = 4
$T2 = -12						; size = 4
_j$1$ = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
tv1445 = 8						; size = 4
tv1419 = 8						; size = 4
_pDst8$ = 8						; size = 4
_pSrc8$ = 12						; size = 4
tv1443 = 16						; size = 4
_nDstPitch$ = 16					; size = 4
tv1435 = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
tv1442 = 32						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$VerticalWiener@G@@YAXPAEPBEHHHHH@Z PROC		; VerticalWiener<unsigned short>, COMDAT

; 860  : {

	sub	esp, 48					; 00000030H

; 861  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 862  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 863  : 
; 864  :   nSrcPitch /= sizeof(pixel_t);
; 865  :   nDstPitch /= sizeof(pixel_t);

	mov	edx, DWORD PTR _nDstPitch$[esp+44]

; 866  : 
; 867  :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;

	mov	ecx, DWORD PTR _bits_per_pixel$[esp+44]
	mov	eax, DWORD PTR _pDst8$[esp+44]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _nSrcPitch$[esp+56]
	mov	ebx, 1
	shr	edx, 1
	shl	ebx, cl
	shr	esi, 1
	dec	ebx
	mov	DWORD PTR _max_pixel_value$1$[esp+60], ebx
	lea	ecx, DWORD PTR [edx+edx]
	mov	DWORD PTR _max_pixel_value$[esp+60], ebx
	mov	edx, DWORD PTR _nWidth$[esp+56]
	mov	DWORD PTR tv1443[esp+56], ecx
	lea	ebx, DWORD PTR [esi+esi]
	mov	ebp, DWORD PTR tv1443[esp+56]
	mov	ecx, 2
	push	edi
	mov	edi, DWORD PTR _pSrc8$[esp+60]
	mov	DWORD PTR _nSrcPitch$[esp+60], esi
	mov	DWORD PTR tv1442[esp+60], ebx
	mov	DWORD PTR tv1445[esp+60], ecx
$LL4@VerticalWi:

; 868  : 
; 869  :   for (int j = 0; j < 2; j++)
; 870  :   {
; 871  :     for (int i = 0; i < nWidth; i++)

	test	edx, edx
	jle	SHORT $LN6@VerticalWi
	add	ebx, edi
	mov	DWORD PTR tv1437[esp+64], edi
	mov	esi, eax
	sub	edi, eax
	mov	ebp, edx
$LL7@VerticalWi:

; 872  :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	ecx, WORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, WORD PTR [edi+esi]
	lea	esi, DWORD PTR [esi+2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [esi-2], cx
	sub	ebp, 1
	jne	SHORT $LL7@VerticalWi
	mov	edi, DWORD PTR _pSrc8$[esp+60]
	mov	edx, DWORD PTR _nWidth$[esp+60]
	mov	ebx, DWORD PTR tv1442[esp+60]
	mov	ecx, DWORD PTR tv1445[esp+60]
	mov	ebp, DWORD PTR tv1443[esp+60]
$LN6@VerticalWi:

; 873  :     pDst += nDstPitch;
; 874  :     pSrc += nSrcPitch;

	add	edi, ebx
	add	eax, ebp
	sub	ecx, 1
	mov	DWORD PTR _pSrc8$[esp+60], edi
	mov	DWORD PTR tv1445[esp+60], ecx
	jne	SHORT $LL4@VerticalWi

; 875  :   }
; 876  :   for (int j = 2; j < nHeight - 4; j++)

	mov	ecx, DWORD PTR _nHeight$[esp+60]
	mov	DWORD PTR _pDst8$[esp+60], eax
	lea	esi, DWORD PTR [ecx-4]
	mov	DWORD PTR _j$1$[esp+64], esi
	cmp	esi, 2
	jle	$LN9@VerticalWi
	mov	ecx, DWORD PTR tv1443[esp+60]
	lea	ebp, DWORD PTR [esi-2]
	mov	DWORD PTR tv1432[esp+64], ebp
$LL10@VerticalWi:

; 878  :     for (int i = 0; i < nWidth; i++)

	test	edx, edx
	jle	$LN12@VerticalWi
	mov	esi, DWORD PTR _nSrcPitch$[esp+60]
	mov	ebp, edi
	mov	DWORD PTR tv1433[esp+64], eax

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T2[esp+64], 0
	mov	DWORD PTR tv1425[esp+64], edx
	lea	ecx, DWORD PTR [esi+esi*2]
	lea	ecx, DWORD PTR [edi+ecx*2]
	mov	DWORD PTR tv1430[esp+64], ecx
	lea	ecx, DWORD PTR [esi*4]
	mov	esi, edi
	sub	ebp, ecx
	sub	esi, ebx
	mov	DWORD PTR tv1428[esp+64], esi
	lea	esi, DWORD PTR [ecx+edi]
	lea	ecx, DWORD PTR [ebx+edi]
	mov	DWORD PTR tv1427[esp+64], esi
	mov	ebx, edi
	mov	DWORD PTR tv1426[esp+64], ecx
	sub	ebx, eax
	mov	edi, eax
	mov	eax, DWORD PTR tv1430[esp+64]
	mov	DWORD PTR tv1436[esp+64], ebx
	mov	ebx, DWORD PTR tv1428[esp+64]
	npad	2
$LL13@VerticalWi:
	movzx	ecx, WORD PTR [ecx]
	lea	ebx, DWORD PTR [ebx+2]
	mov	edx, DWORD PTR tv1436[esp+64]
	lea	ebp, DWORD PTR [ebp+2]
	lea	eax, DWORD PTR [eax+2]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, WORD PTR [edi+edx-2]
	add	edx, ecx
	movzx	ecx, WORD PTR [esi]
	shl	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	esi, DWORD PTR $T1[esp+64]
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	sub	edx, ecx
	movzx	ecx, WORD PTR [ebx-2]
	sub	edx, ecx
	movzx	ecx, WORD PTR [ebp-2]
	lea	edx, DWORD PTR [edx+edx*4]
	add	edx, ecx
	movzx	ecx, WORD PTR [eax-2]
	add	edx, 16					; 00000010H
	add	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T2[esp+64]
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	sar	ecx, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	ecx, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T1[esp+64], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, DWORD PTR _max_pixel_value$1$[esp+64]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	esi, edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	edx, cx
	cmp	DWORD PTR [esi], ecx
	movzx	ecx, WORD PTR [esi]
; File c:\github\mvtools\sources\interpolation.cpp

; 878  :     for (int i = 0; i < nWidth; i++)

	mov	esi, DWORD PTR tv1427[esp+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	edx, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 878  :     for (int i = 0; i < nWidth; i++)

	mov	ecx, DWORD PTR tv1426[esp+64]
	add	esi, 2
	add	ecx, 2

; 880  :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	WORD PTR [edi-2], dx
	sub	DWORD PTR tv1425[esp+64], 1
	mov	DWORD PTR tv1426[esp+64], ecx
	mov	DWORD PTR tv1427[esp+64], esi
	jne	SHORT $LL13@VerticalWi
	mov	eax, DWORD PTR _pDst8$[esp+60]
	mov	edi, DWORD PTR _pSrc8$[esp+60]
	mov	edx, DWORD PTR _nWidth$[esp+60]
	mov	ebx, DWORD PTR tv1442[esp+60]
	mov	ecx, DWORD PTR tv1443[esp+60]
	mov	ebp, DWORD PTR tv1432[esp+64]
$LN12@VerticalWi:

; 881  :         ((pSrc[i - nSrcPitch * 2])
; 882  :           + (-(pSrc[i - nSrcPitch]) + (pSrc[i] << 2) + (pSrc[i + nSrcPitch] << 2) - (pSrc[i + nSrcPitch * 2])) * 5
; 883  :           + (pSrc[i + nSrcPitch * 3]) + 16) >> 5));
; 884  :     }
; 885  :     pDst += nDstPitch;

	add	eax, ecx

; 886  :     pSrc += nSrcPitch;

	add	edi, ebx
	sub	ebp, 1
	mov	DWORD PTR _pDst8$[esp+60], eax
	mov	DWORD PTR _pSrc8$[esp+60], edi
	mov	DWORD PTR tv1432[esp+64], ebp
	jne	$LL10@VerticalWi
	mov	ebp, DWORD PTR tv1443[esp+60]
	mov	esi, DWORD PTR _j$1$[esp+64]
	mov	ecx, DWORD PTR _nHeight$[esp+60]
$LN9@VerticalWi:

; 887  :   }
; 888  :   for (int j = nHeight - 4; j < nHeight - 1; j++)

	dec	ecx
	cmp	esi, ecx
	jge	SHORT $LN15@VerticalWi
	sub	ecx, esi
	mov	DWORD PTR tv1419[esp+60], ecx
$LL16@VerticalWi:

; 889  :   {
; 890  :     for (int i = 0; i < nWidth; i++)

	test	edx, edx
	jle	SHORT $LN18@VerticalWi
	add	ebx, edi
	mov	DWORD PTR tv1435[esp+60], edi
	mov	esi, eax
	sub	edi, eax
	mov	ebp, edx
$LL19@VerticalWi:

; 891  :     {
; 892  :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	ecx, WORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, WORD PTR [edi+esi]
	lea	esi, DWORD PTR [esi+2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [esi-2], cx
	sub	ebp, 1
	jne	SHORT $LL19@VerticalWi
	mov	edi, DWORD PTR _pSrc8$[esp+60]
	mov	edx, DWORD PTR _nWidth$[esp+60]
	mov	ebx, DWORD PTR tv1442[esp+60]
	mov	ecx, DWORD PTR tv1419[esp+60]
	mov	ebp, DWORD PTR tv1443[esp+60]
$LN18@VerticalWi:

; 893  :     }
; 894  : 
; 895  :     pDst += nDstPitch;
; 896  :     pSrc += nSrcPitch;

	add	edi, ebx
	add	eax, ebp
	sub	ecx, 1
	mov	DWORD PTR _pSrc8$[esp+60], edi
	mov	DWORD PTR tv1419[esp+60], ecx
	jne	SHORT $LL16@VerticalWi
$LN15@VerticalWi:

; 897  :   }
; 898  :   // last row
; 899  :   for (int i = 0; i < nWidth; i++)

	test	edx, edx
	jle	SHORT $LN21@VerticalWi
	sub	edi, eax
	npad	4
$LL46@VerticalWi:

; 900  :     pDst[i] = pSrc[i];

	mov	cx, WORD PTR [edi+eax]
	lea	eax, DWORD PTR [eax+2]
	mov	WORD PTR [eax-2], cx
	sub	edx, 1
	jne	SHORT $LL46@VerticalWi
$LN21@VerticalWi:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 901  : }

	add	esp, 48					; 00000030H
	ret	0
??$VerticalWiener@G@@YAXPAEPBEHHHHH@Z ENDP		; VerticalWiener<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$HorizontalWiener@E@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
_i$1$ = -28						; size = 4
tv945 = -24						; size = 4
tv939 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
tv938 = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
_pDst8$ = 8						; size = 4
tv949 = 12						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$HorizontalWiener@E@@YAXPAEPBEHHHHH@Z PROC		; HorizontalWiener<unsigned char>, COMDAT

; 906  : {

	sub	esp, 28					; 0000001cH

; 907  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 908  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 909  : 
; 910  :   nSrcPitch /= sizeof(pixel_t);
; 911  :   nDstPitch /= sizeof(pixel_t);
; 912  : 
; 913  :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;
; 914  : 
; 915  :   for (int j = 0; j < nHeight; j++)

	cmp	DWORD PTR _nHeight$[esp+24], 0
	mov	DWORD PTR _max_pixel_value$[esp+28], 255 ; 000000ffH
	jle	$LN3@Horizontal
	mov	ecx, DWORD PTR _nWidth$[esp+24]
	mov	eax, 2
	mov	edx, DWORD PTR _pDst8$[esp+24]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _pSrc8$[esp+32]
	lea	ebx, DWORD PTR [ecx-1]
	add	ebp, 2
	mov	DWORD PTR tv949[esp+32], ebx
	sub	eax, ecx
	push	esi
	mov	DWORD PTR tv939[esp+40], eax
	lea	esi, DWORD PTR [ecx-4]
	lea	eax, DWORD PTR [ecx-3]
	mov	DWORD PTR _i$1$[esp+40], esi
	push	edi
	mov	DWORD PTR tv938[esp+44], eax
	npad	7
$LL4@Horizontal:

; 916  :   {
; 917  :     pDst[0] = (pSrc[0] + pSrc[1] + 1) >> 1;

	movzx	ecx, BYTE PTR [ebp-1]
	lea	edi, DWORD PTR [ebp-2]
	movzx	eax, BYTE PTR [edi]
	inc	ecx

; 918  :     pDst[1] = (pSrc[1] + pSrc[2] + 1) >> 1;

	mov	esi, DWORD PTR tv939[esp+44]
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edx], al
	movzx	ecx, BYTE PTR [ebp-1]
	movzx	eax, BYTE PTR [ebp]
	inc	ecx
	add	eax, ecx
	lea	ecx, DWORD PTR [ebx+edx]
	shr	eax, 1
	mov	BYTE PTR [esi+ecx], al

; 919  :     for (int i = 2; i < nWidth - 4; i++)

	mov	esi, DWORD PTR _i$1$[esp+44]
	cmp	esi, 2
	jle	$LN6@Horizontal
	mov	ebx, edx

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	mov	DWORD PTR $T2[esp+44], 0
	lea	eax, DWORD PTR [ebp-2]
	mov	edi, ebp
	sub	ebx, eax
	add	esi, -2					; fffffffeH
	mov	DWORD PTR tv945[esp+44], esi
	npad	3
$LL7@Horizontal:
	movzx	eax, BYTE PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T1[esp+44]
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	movzx	ecx, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	add	ecx, eax
	movzx	eax, BYTE PTR [edi+1]
	shl	ecx, 2
	sub	ecx, eax
	movzx	eax, BYTE PTR [edi-2]
	sub	ecx, eax
	movzx	eax, BYTE PTR [edi+2]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	movzx	eax, BYTE PTR [edi-3]
	add	ecx, 16					; 00000010H
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ecx, DWORD PTR $T2[esp+44]
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	sar	eax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	mov	DWORD PTR $T1[esp+44], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	edx, ecx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, 255				; 000000ffH
	cmp	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [edx]
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 919  :     for (int i = 2; i < nWidth - 4; i++)

	sub	DWORD PTR tv945[esp+44], 1

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	mov	BYTE PTR [ebx+edi-1], cl
	jne	SHORT $LL7@Horizontal
	mov	edx, DWORD PTR _pDst8$[esp+40]
	lea	edi, DWORD PTR [ebp-2]
	mov	esi, DWORD PTR _i$1$[esp+44]
	mov	ebx, DWORD PTR tv949[esp+40]
$LN6@Horizontal:

; 922  :         + (pSrc[i + 1] << 2) - (pSrc[i + 2])) * 5 + (pSrc[i + 3]) + 16) >> 5));
; 923  :     }
; 924  :     for (int i = nWidth - 4; i < nWidth - 1; i++)

	cmp	esi, ebx
	jge	SHORT $LN9@Horizontal
	mov	ebx, edx
	lea	eax, DWORD PTR [edi+esi]
	sub	ebx, edi
	mov	edi, DWORD PTR tv949[esp+40]
	sub	edi, esi
	npad	7
$LL10@Horizontal:

; 925  :       pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [ebx+eax-1], cl
	sub	edi, 1
	jne	SHORT $LL10@Horizontal
	mov	edx, DWORD PTR _pDst8$[esp+40]
	mov	ebx, DWORD PTR tv949[esp+40]
$LN9@Horizontal:

; 926  : 
; 927  :     pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	eax, DWORD PTR tv938[esp+44]
	mov	al, BYTE PTR [eax+ebp]

; 928  :     pDst += nDstPitch;
; 929  :     pSrc += nSrcPitch;

	add	ebp, DWORD PTR _nSrcPitch$[esp+40]
	mov	BYTE PTR [ebx+edx], al
	add	edx, DWORD PTR _nDstPitch$[esp+40]
	sub	DWORD PTR _nHeight$[esp+40], 1
	mov	DWORD PTR _pDst8$[esp+40], edx
	jne	$LL4@Horizontal
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Horizontal:

; 930  :   }
; 931  : }

	add	esp, 28					; 0000001cH
	ret	0
??$HorizontalWiener@E@@YAXPAEPBEHHHHH@Z ENDP		; HorizontalWiener<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$HorizontalWiener@G@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
tv913 = -20						; size = 4
tv910 = -16						; size = 4
tv912 = -12						; size = 4
tv911 = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
_pDst8$ = 8						; size = 4
tv906 = 12						; size = 4
_pSrc8$ = 12						; size = 4
_max_pixel_value$1$ = 16				; size = 4
_nDstPitch$ = 16					; size = 4
_i$1$ = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
$T2 = 32						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$HorizontalWiener@G@@YAXPAEPBEHHHHH@Z PROC		; HorizontalWiener<unsigned short>, COMDAT

; 906  : {

	sub	esp, 24					; 00000018H

; 907  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 908  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 909  : 
; 910  :   nSrcPitch /= sizeof(pixel_t);
; 911  :   nDstPitch /= sizeof(pixel_t);
; 912  : 
; 913  :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;

	mov	ecx, DWORD PTR _bits_per_pixel$[esp+20]
	mov	eax, 1
	push	ebx
	mov	ebx, DWORD PTR _pDst8$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR _pSrc8$[esp+28]
	push	esi
	mov	esi, DWORD PTR _nSrcPitch$[esp+32]
	push	edi
	mov	edi, DWORD PTR _nDstPitch$[esp+36]
	shl	eax, cl
	dec	eax
	shr	esi, 1
	shr	edi, 1

; 914  : 
; 915  :   for (int j = 0; j < nHeight; j++)

	cmp	DWORD PTR _nHeight$[esp+36], 0
	mov	DWORD PTR _max_pixel_value$1$[esp+36], eax
	mov	DWORD PTR _max_pixel_value$[esp+40], eax
	jle	$LN3@Horizontal
	mov	eax, DWORD PTR _nWidth$[esp+36]
	lea	edx, DWORD PTR [eax-4]
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR _i$1$[esp+36], edx
	lea	eax, DWORD PTR [eax*2-2]
	mov	DWORD PTR tv913[esp+40], ecx
	mov	DWORD PTR tv910[esp+40], eax
	lea	eax, DWORD PTR [edi+edi]
	mov	DWORD PTR tv912[esp+40], eax
	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR tv911[esp+40], eax
$LL4@Horizontal:

; 916  :   {
; 917  :     pDst[0] = (pSrc[0] + pSrc[1] + 1) >> 1;

	movzx	ecx, WORD PTR [ebp+2]
	lea	esi, DWORD PTR [ebp+2]
	movzx	eax, WORD PTR [ebp]
	inc	ecx
	add	eax, ecx

; 918  :     pDst[1] = (pSrc[1] + pSrc[2] + 1) >> 1;
; 919  :     for (int i = 2; i < nWidth - 4; i++)

	mov	edi, 2
	shr	eax, 1
	mov	WORD PTR [ebx], ax
	movzx	eax, WORD PTR [esi]
	movzx	ecx, WORD PTR [ebp+4]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	WORD PTR [ebx+2], ax
	cmp	edx, edi
	jle	SHORT $LN6@Horizontal

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	mov	ebp, DWORD PTR _i$1$[esp+36]
	mov	DWORD PTR $T1[esp+40], 0
	npad	3
$LL7@Horizontal:
	movzx	eax, WORD PTR [esi+2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T2[esp+36]
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	movzx	ecx, WORD PTR [esi+4]
	lea	esi, DWORD PTR [esi+2]
	add	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ebx, DWORD PTR _max_pixel_value$1$[esp+36]
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	movzx	eax, WORD PTR [esi+4]
	shl	ecx, 2
	sub	ecx, eax
	movzx	eax, WORD PTR [esi-2]
	sub	ecx, eax
	movzx	eax, WORD PTR [esi+6]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	movzx	eax, WORD PTR [esi-4]
	add	ecx, 16					; 00000010H
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ecx, DWORD PTR $T1[esp+40]
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	sar	eax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	mov	DWORD PTR $T2[esp+36], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR _max_pixel_value$1$[esp+36]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	edx, ecx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	ecx, ax
	cmp	DWORD PTR [edx], ebx
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	mov	ebx, DWORD PTR _pDst8$[esp+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	eax, WORD PTR [edx]
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 921  :       pDst[i] = std::min(max_pixel_value, std::max(0, ((pSrc[i - 2]) + (-(pSrc[i - 1]) + (pSrc[i] << 2)

	mov	WORD PTR [ebx+edi*2], cx
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL7@Horizontal
	mov	ebp, DWORD PTR _pSrc8$[esp+36]
	mov	edx, DWORD PTR _i$1$[esp+36]
$LN6@Horizontal:

; 922  :         + (pSrc[i + 1] << 2) - (pSrc[i + 2])) * 5 + (pSrc[i + 3]) + 16) >> 5));
; 923  :     }
; 924  :     for (int i = nWidth - 4; i < nWidth - 1; i++)

	mov	esi, DWORD PTR tv913[esp+40]
	cmp	edx, esi
	jge	SHORT $LN9@Horizontal
	lea	eax, DWORD PTR [edx*2]
	sub	ebx, ebp
	mov	edi, esi
	mov	DWORD PTR tv906[esp+36], ebx
	add	eax, ebp
	sub	edi, edx
$LL10@Horizontal:

; 925  :       pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	ecx, WORD PTR [eax+2]
	lea	eax, DWORD PTR [eax+2]
	movzx	edx, WORD PTR [eax-2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [ebx+eax-2], cx
	sub	edi, 1
	jne	SHORT $LL10@Horizontal
	mov	ebx, DWORD PTR _pDst8$[esp+36]
	mov	edx, DWORD PTR _i$1$[esp+36]
$LN9@Horizontal:

; 926  : 
; 927  :     pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	ecx, DWORD PTR tv910[esp+40]
	mov	ax, WORD PTR [ecx+ebp]

; 928  :     pDst += nDstPitch;
; 929  :     pSrc += nSrcPitch;

	add	ebp, DWORD PTR tv911[esp+40]
	mov	WORD PTR [ecx+ebx], ax
	add	ebx, DWORD PTR tv912[esp+40]
	sub	DWORD PTR _nHeight$[esp+36], 1
	mov	DWORD PTR _pDst8$[esp+36], ebx
	mov	DWORD PTR _pSrc8$[esp+36], ebp
	jne	$LL4@Horizontal
$LN3@Horizontal:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 930  :   }
; 931  : }

	add	esp, 24					; 00000018H
	ret	0
??$HorizontalWiener@G@@YAXPAEPBEHHHHH@Z ENDP		; HorizontalWiener<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$VerticalBicubic@E@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
_pSrc$1$ = -32						; size = 4
tv904 = -28						; size = 4
_i$1$ = -24						; size = 4
tv905 = -20						; size = 4
$T1 = -20						; size = 4
tv912 = -16						; size = 4
$T2 = -12						; size = 4
tv909 = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
_pDst$1$ = 8						; size = 4
_pDst8$ = 8						; size = 4
tv908 = 12						; size = 4
tv903 = 12						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
tv900 = 28						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$VerticalBicubic@E@@YAXPAEPBEHHHHH@Z PROC		; VerticalBicubic<unsigned char>, COMDAT

; 992  : {

	sub	esp, 32					; 00000020H
	push	ebx

; 993  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 994  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 995  : 
; 996  :   nSrcPitch /= sizeof(pixel_t);
; 997  :   nDstPitch /= sizeof(pixel_t);
; 998  : 
; 999  :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;
; 1000 : 
; 1001 :   for (int j = 0; j < 1; j++)
; 1002 :   {
; 1003 :     for (int i = 0; i < nWidth; i++)

	mov	ebx, DWORD PTR _nSrcPitch$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR _nWidth$[esp+36]
	mov	DWORD PTR _max_pixel_value$[esp+40], 255 ; 000000ffH
	push	esi
	push	edi
	test	ebp, ebp
	jle	SHORT $LN6@VerticalBi
	mov	edi, DWORD PTR _pDst8$[esp+44]
	mov	esi, ebp
	mov	edx, DWORD PTR _pSrc8$[esp+44]
	sub	edi, edx
	npad	9
$LL7@VerticalBi:

; 1004 :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	eax, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	movzx	ecx, BYTE PTR [edx+ebx-1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edi+edx-1], al
	sub	esi, 1
	jne	SHORT $LL7@VerticalBi
$LN6@VerticalBi:

; 1005 :     pDst += nDstPitch;

	mov	esi, DWORD PTR _pDst8$[esp+44]

; 1006 :     pSrc += nSrcPitch;
; 1007 :   }
; 1008 :   for (int j = 1; j < nHeight - 3; j++)

	mov	eax, DWORD PTR _nHeight$[esp+44]
	mov	edi, DWORD PTR _pSrc8$[esp+44]
	add	eax, -3					; fffffffdH
	add	esi, DWORD PTR _nDstPitch$[esp+44]
	add	edi, ebx
	mov	ecx, DWORD PTR _nDstPitch$[esp+44]
	mov	DWORD PTR _pDst$1$[esp+44], esi
	mov	DWORD PTR _pSrc$1$[esp+48], edi
	cmp	eax, 1
	jle	$LN9@VerticalBi
	mov	edx, edi
	sub	edx, ebx
	dec	eax
	mov	DWORD PTR tv903[esp+44], edx
	mov	DWORD PTR tv904[esp+48], eax
$LL10@VerticalBi:

; 1010 :     for (int i = 0; i < nWidth; i++)

	mov	DWORD PTR _i$1$[esp+48], 0
	test	ebp, ebp
	jle	$LN12@VerticalBi
	sub	esi, edi

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T2[esp+48], 0
	lea	eax, DWORD PTR [edi+ebx*2]
	mov	DWORD PTR tv909[esp+48], esi
	mov	esi, DWORD PTR _i$1$[esp+48]
	mov	DWORD PTR tv905[esp+48], edi
	mov	DWORD PTR tv912[esp+48], eax
	npad	3
$LL13@VerticalBi:
	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	movzx	ecx, BYTE PTR [edi+ebx-1]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T1[esp+48]
; File c:\github\mvtools\sources\interpolation.cpp

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	lea	ecx, DWORD PTR [ecx+ecx*8]
	sub	ecx, eax
	mov	eax, DWORD PTR tv912[esp+48]
	movzx	eax, BYTE PTR [eax+esi]
	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T2[esp+48]
; File c:\github\mvtools\sources\interpolation.cpp

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	add	ecx, 8
	sar	ecx, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	ecx, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T1[esp+48], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, 255				; 000000ffH

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	edx, eax

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [edx]
; File c:\github\mvtools\sources\interpolation.cpp

; 1010 :     for (int i = 0; i < nWidth; i++)

	mov	edx, DWORD PTR tv903[esp+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	eax, DWORD PTR tv909[esp+48]
	inc	esi
	mov	BYTE PTR [edi+eax-1], cl
	cmp	esi, ebp
	jl	SHORT $LL13@VerticalBi
	mov	esi, DWORD PTR _pDst$1$[esp+44]
	mov	edi, DWORD PTR _pSrc$1$[esp+48]
	mov	eax, DWORD PTR tv904[esp+48]
	mov	ecx, DWORD PTR _nDstPitch$[esp+44]
$LN12@VerticalBi:

; 1013 :         (-pSrc[i - nSrcPitch] - pSrc[i + nSrcPitch * 2] + (pSrc[i] + pSrc[i + nSrcPitch]) * 9 + 8) >> 4));
; 1014 :     }
; 1015 :     pDst += nDstPitch;

	add	esi, ecx

; 1016 :     pSrc += nSrcPitch;

	add	edi, ebx
	add	edx, ebx
	mov	DWORD PTR _pDst$1$[esp+44], esi
	sub	eax, 1
	mov	DWORD PTR _pSrc$1$[esp+48], edi
	mov	DWORD PTR tv903[esp+44], edx
	mov	DWORD PTR tv904[esp+48], eax
	jne	$LL10@VerticalBi
$LN9@VerticalBi:

; 1017 :   }
; 1018 :   for (int j = nHeight - 3; j < nHeight - 1; j++)

	mov	eax, DWORD PTR _nHeight$[esp+44]
	mov	edx, DWORD PTR _nHeight$[esp+44]
	dec	eax
	add	edx, -3					; fffffffdH
	cmp	edx, eax
	jge	SHORT $LN15@VerticalBi
	sub	eax, edx
	mov	DWORD PTR tv900[esp+44], eax
	npad	6
$LL16@VerticalBi:

; 1019 :   {
; 1020 :     for (int i = 0; i < nWidth; i++)

	test	ebp, ebp
	jle	SHORT $LN18@VerticalBi
	sub	esi, edi
	mov	eax, edi
	mov	DWORD PTR tv908[esp+44], esi
	npad	4
$LL19@VerticalBi:

; 1021 :     {
; 1022 :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+ebx-1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+esi-1], cl
	sub	ebp, 1
	jne	SHORT $LL19@VerticalBi
	mov	esi, DWORD PTR _pDst$1$[esp+44]
	mov	ebp, DWORD PTR _nWidth$[esp+44]
	mov	eax, DWORD PTR tv900[esp+44]
	mov	ecx, DWORD PTR _nDstPitch$[esp+44]
$LN18@VerticalBi:

; 1023 :     }
; 1024 : 
; 1025 :     pDst += nDstPitch;

	add	esi, ecx

; 1026 :     pSrc += nSrcPitch;

	add	edi, ebx
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+44], esi
	mov	DWORD PTR tv900[esp+44], eax
	jne	SHORT $LL16@VerticalBi
$LN15@VerticalBi:

; 1027 :   }
; 1028 :   // last row
; 1029 :   for (int i = 0; i < nWidth; i++)

	test	ebp, ebp
	jle	SHORT $LN21@VerticalBi
	sub	edi, esi
$LL46@VerticalBi:

; 1030 :     pDst[i] = pSrc[i];

	mov	al, BYTE PTR [edi+esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [esi-1], al
	sub	ebp, 1
	jne	SHORT $LL46@VerticalBi
$LN21@VerticalBi:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1031 : }

	add	esp, 32					; 00000020H
	ret	0
??$VerticalBicubic@E@@YAXPAEPBEHHHHH@Z ENDP		; VerticalBicubic<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$VerticalBicubic@G@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
_pDst$1$ = -40						; size = 4
tv1136 = -36						; size = 4
tv1151 = -32						; size = 4
tv1141 = -28						; size = 4
tv1139 = -24						; size = 4
tv1138 = -20						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv1145 = -12						; size = 4
_j$1$ = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
_pSrc$1$ = 8						; size = 4
_pDst8$ = 8						; size = 4
tv1144 = 12						; size = 4
tv1137 = 12						; size = 4
_pSrc8$ = 12						; size = 4
tv1152 = 16						; size = 4
_nDstPitch$ = 16					; size = 4
tv1132 = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_max_pixel_value$1$ = 32				; size = 4
_bits_per_pixel$ = 32					; size = 4
??$VerticalBicubic@G@@YAXPAEPBEHHHHH@Z PROC		; VerticalBicubic<unsigned short>, COMDAT

; 992  : {

	sub	esp, 40					; 00000028H

; 993  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 994  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 995  : 
; 996  :   nSrcPitch /= sizeof(pixel_t);
; 997  :   nDstPitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _nDstPitch$[esp+36]

; 998  : 
; 999  :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;

	mov	edx, 1
	mov	ecx, DWORD PTR _bits_per_pixel$[esp+36]
	push	ebx
	mov	ebx, DWORD PTR _nSrcPitch$[esp+40]
	shr	ebx, 1
	push	ebp
	shl	edx, cl

; 1000 : 
; 1001 :   for (int j = 0; j < 1; j++)
; 1002 :   {
; 1003 :     for (int i = 0; i < nWidth; i++)

	mov	ecx, DWORD PTR _nWidth$[esp+44]
	dec	edx
	shr	eax, 1
	lea	ebp, DWORD PTR [ebx+ebx]
	add	eax, eax
	mov	DWORD PTR _nSrcPitch$[esp+44], ebx
	mov	DWORD PTR _max_pixel_value$1$[esp+44], edx
	mov	DWORD PTR _max_pixel_value$[esp+48], edx
	mov	DWORD PTR tv1151[esp+48], ebp
	mov	DWORD PTR tv1152[esp+44], eax
	push	esi
	push	edi
	test	ecx, ecx
	jle	SHORT $LN6@VerticalBi
	mov	eax, DWORD PTR _pSrc8$[esp+52]
	mov	edi, ecx
	mov	edx, DWORD PTR _pDst8$[esp+52]
	mov	ebx, eax
	sub	ebx, edx
	lea	esi, DWORD PTR [eax+ebp]
$LL7@VerticalBi:

; 1004 :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	ecx, WORD PTR [ebx+edx]
	lea	edx, DWORD PTR [edx+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	WORD PTR [edx-2], ax
	sub	edi, 1
	jne	SHORT $LL7@VerticalBi
	mov	ecx, DWORD PTR _nWidth$[esp+52]
	mov	eax, DWORD PTR tv1152[esp+52]
$LN6@VerticalBi:

; 1005 :     pDst += nDstPitch;

	mov	esi, DWORD PTR _pDst8$[esp+52]

; 1006 :     pSrc += nSrcPitch;

	mov	ebx, DWORD PTR _pSrc8$[esp+52]
	add	esi, eax

; 1007 :   }
; 1008 :   for (int j = 1; j < nHeight - 3; j++)

	mov	eax, DWORD PTR _nHeight$[esp+52]
	add	ebx, ebp
	mov	edx, DWORD PTR tv1152[esp+52]
	mov	DWORD PTR _pDst$1$[esp+56], esi
	mov	DWORD PTR _pSrc$1$[esp+52], ebx
	lea	edi, DWORD PTR [eax-3]
	mov	DWORD PTR _j$1$[esp+56], edi
	cmp	edi, 1
	jle	$LN9@VerticalBi
	lea	eax, DWORD PTR [edi-1]
	mov	DWORD PTR tv1136[esp+56], eax
$LL10@VerticalBi:

; 1010 :     for (int i = 0; i < nWidth; i++)

	test	ecx, ecx
	jle	$LN12@VerticalBi
	mov	eax, DWORD PTR _nSrcPitch$[esp+52]
	mov	edi, ebx
	sub	edi, ebp
	mov	DWORD PTR tv1141[esp+56], esi

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T2[esp+56], 0
	mov	DWORD PTR tv1137[esp+52], ecx
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv1139[esp+56], eax
	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR tv1138[esp+56], eax
	mov	ebp, esi
	mov	eax, ebx
	mov	ebx, DWORD PTR tv1139[esp+56]
	sub	eax, esi
	mov	esi, DWORD PTR tv1138[esp+56]
	mov	DWORD PTR tv1145[esp+56], eax
	npad	9
$LL13@VerticalBi:
	movzx	ecx, WORD PTR [eax+ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T1[esp+56]
; File c:\github\mvtools\sources\interpolation.cpp

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	add	ecx, eax
	lea	ebx, DWORD PTR [ebx+2]
	movzx	eax, WORD PTR [ebx-2]
	lea	edi, DWORD PTR [edi+2]
	lea	ebp, DWORD PTR [ebp+2]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	sub	ecx, eax
	movzx	eax, WORD PTR [edi-2]
	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T2[esp+56]
; File c:\github\mvtools\sources\interpolation.cpp

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	add	ecx, 8
	sar	ecx, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	ecx, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T1[esp+56], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	edx, eax

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR _max_pixel_value$1$[esp+52]
	movzx	ecx, ax
	cmp	DWORD PTR [edx], eax
	movzx	eax, WORD PTR [edx]
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 1010 :     for (int i = 0; i < nWidth; i++)

	sub	DWORD PTR tv1137[esp+52], 1
	mov	eax, DWORD PTR tv1145[esp+56]

; 1012 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	WORD PTR [ebp-2], cx
	jne	SHORT $LL13@VerticalBi
	mov	esi, DWORD PTR _pDst$1$[esp+56]
	mov	ebx, DWORD PTR _pSrc$1$[esp+52]
	mov	ecx, DWORD PTR _nWidth$[esp+52]
	mov	ebp, DWORD PTR tv1151[esp+56]
	mov	eax, DWORD PTR tv1136[esp+56]
	mov	edx, DWORD PTR tv1152[esp+52]
$LN12@VerticalBi:

; 1013 :         (-pSrc[i - nSrcPitch] - pSrc[i + nSrcPitch * 2] + (pSrc[i] + pSrc[i + nSrcPitch]) * 9 + 8) >> 4));
; 1014 :     }
; 1015 :     pDst += nDstPitch;

	add	esi, edx

; 1016 :     pSrc += nSrcPitch;

	add	ebx, ebp
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+56], esi
	mov	DWORD PTR _pSrc$1$[esp+52], ebx
	mov	DWORD PTR tv1136[esp+56], eax
	jne	$LL10@VerticalBi
	mov	edi, DWORD PTR _j$1$[esp+56]
	mov	eax, DWORD PTR _nHeight$[esp+52]
$LN9@VerticalBi:

; 1017 :   }
; 1018 :   for (int j = nHeight - 3; j < nHeight - 1; j++)

	dec	eax
	cmp	edi, eax
	jge	SHORT $LN15@VerticalBi
	sub	eax, edi
	mov	DWORD PTR tv1132[esp+52], eax
	npad	3
$LL16@VerticalBi:

; 1019 :   {
; 1020 :     for (int i = 0; i < nWidth; i++)

	test	ecx, ecx
	jle	SHORT $LN18@VerticalBi
	lea	edi, DWORD PTR [ebx+ebp]
	mov	DWORD PTR tv1144[esp+52], ebx
	mov	eax, esi
	sub	ebx, esi
	mov	ebp, ecx
$LL19@VerticalBi:

; 1021 :     {
; 1022 :       pDst[i] = (pSrc[i] + pSrc[i + nSrcPitch] + 1) >> 1;

	movzx	ecx, WORD PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, WORD PTR [ebx+eax]
	lea	eax, DWORD PTR [eax+2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [eax-2], cx
	sub	ebp, 1
	jne	SHORT $LL19@VerticalBi
	mov	ebx, DWORD PTR _pSrc$1$[esp+52]
	mov	ecx, DWORD PTR _nWidth$[esp+52]
	mov	ebp, DWORD PTR tv1151[esp+56]
	mov	eax, DWORD PTR tv1132[esp+52]
	mov	edx, DWORD PTR tv1152[esp+52]
$LN18@VerticalBi:

; 1023 :     }
; 1024 : 
; 1025 :     pDst += nDstPitch;
; 1026 :     pSrc += nSrcPitch;

	add	ebx, ebp
	add	esi, edx
	sub	eax, 1
	mov	DWORD PTR _pSrc$1$[esp+52], ebx
	mov	DWORD PTR tv1132[esp+52], eax
	jne	SHORT $LL16@VerticalBi
$LN15@VerticalBi:

; 1027 :   }
; 1028 :   // last row
; 1029 :   for (int i = 0; i < nWidth; i++)

	test	ecx, ecx
	jle	SHORT $LN21@VerticalBi
	sub	ebx, esi
	npad	9
$LL46@VerticalBi:

; 1030 :     pDst[i] = pSrc[i];

	mov	ax, WORD PTR [ebx+esi]
	lea	esi, DWORD PTR [esi+2]
	mov	WORD PTR [esi-2], ax
	sub	ecx, 1
	jne	SHORT $LL46@VerticalBi
$LN21@VerticalBi:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1031 : }

	add	esp, 40					; 00000028H
	ret	0
??$VerticalBicubic@G@@YAXPAEPBEHHHHH@Z ENDP		; VerticalBicubic<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$HorizontalBicubic@E@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
_i$1$ = -24						; size = 4
tv714 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
tv705 = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
_pDst8$ = 8						; size = 4
_pSrc8$ = 12						; size = 4
_nDstPitch$ = 16					; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$HorizontalBicubic@E@@YAXPAEPBEHHHHH@Z PROC		; HorizontalBicubic<unsigned char>, COMDAT

; 1036 : {

	sub	esp, 24					; 00000018H

; 1037 :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 1038 :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 1039 : 
; 1040 :   nSrcPitch /= sizeof(pixel_t);
; 1041 :   nDstPitch /= sizeof(pixel_t);
; 1042 : 
; 1043 :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;
; 1044 : 
; 1045 :   for (int j = 0; j < nHeight; j++)

	cmp	DWORD PTR _nHeight$[esp+20], 0
	push	ebx
	mov	ebx, DWORD PTR _pSrc8$[esp+24]
	mov	DWORD PTR _max_pixel_value$[esp+28], 255 ; 000000ffH
	jle	$LN3@Horizontal
	mov	eax, DWORD PTR _nWidth$[esp+24]
	mov	edx, DWORD PTR _pDst8$[esp+24]
	push	ebp
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax-3]
	lea	ecx, DWORD PTR [eax-2]
	mov	DWORD PTR _i$1$[esp+40], esi
	lea	edi, DWORD PTR [eax-1]
	mov	DWORD PTR tv705[esp+40], ecx
	mov	DWORD PTR tv714[esp+40], edi
	npad	5
$LL4@Horizontal:

; 1046 :   {
; 1047 :     pDst[0] = (pSrc[0] + pSrc[1] + 1) >> 1;

	movzx	eax, BYTE PTR [ebx]
	movzx	ecx, BYTE PTR [ebx+1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edx], al

; 1048 :     for (int i = 1; i < nWidth - 3; i++)

	cmp	esi, 1
	jle	SHORT $LN6@Horizontal
	mov	ebp, edx

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T2[esp+40], 0
	lea	edi, DWORD PTR [ebx+1]
	sub	ebp, ebx
	lea	ebx, DWORD PTR [esi-1]
$LL7@Horizontal:
	movzx	eax, BYTE PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T1[esp+40]
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	movzx	ecx, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	add	ecx, eax
	movzx	eax, BYTE PTR [edi+1]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	sub	ecx, eax
	movzx	eax, BYTE PTR [edi-2]
	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T2[esp+40]
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	add	ecx, 8
	sar	ecx, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	ecx, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T1[esp+40], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, 255				; 000000ffH

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	edx, eax

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [edx]
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	BYTE PTR [edi+ebp-1], cl
	sub	ebx, 1
	jne	SHORT $LL7@Horizontal
	mov	ebx, DWORD PTR _pSrc8$[esp+36]
	mov	edx, DWORD PTR _pDst8$[esp+36]
	mov	esi, DWORD PTR _i$1$[esp+40]
	mov	edi, DWORD PTR tv714[esp+40]
$LN6@Horizontal:

; 1051 :         (-(pSrc[i - 1] + pSrc[i + 2]) + (pSrc[i] + pSrc[i + 1]) * 9 + 8) >> 4));
; 1052 :     }
; 1053 :     for (int i = nWidth - 3; i < nWidth - 1; i++)

	cmp	esi, edi
	jge	SHORT $LN9@Horizontal
	mov	ebp, edx
	lea	eax, DWORD PTR [esi+ebx]
	sub	ebp, ebx
	sub	edi, esi
	npad	6
$LL10@Horizontal:

; 1054 :       pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+ebp-1], cl
	sub	edi, 1
	jne	SHORT $LL10@Horizontal
	mov	edx, DWORD PTR _pDst8$[esp+36]
	mov	esi, DWORD PTR _i$1$[esp+40]
	mov	edi, DWORD PTR tv714[esp+40]
$LN9@Horizontal:

; 1055 : 
; 1056 :     pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	eax, DWORD PTR tv705[esp+40]
	mov	al, BYTE PTR [eax+ebx+1]

; 1057 :     pDst += nDstPitch;
; 1058 :     pSrc += nSrcPitch;

	add	ebx, DWORD PTR _nSrcPitch$[esp+36]
	mov	BYTE PTR [edi+edx], al
	add	edx, DWORD PTR _nDstPitch$[esp+36]
	sub	DWORD PTR _nHeight$[esp+36], 1
	mov	DWORD PTR _pDst8$[esp+36], edx
	mov	DWORD PTR _pSrc8$[esp+36], ebx
	jne	$LL4@Horizontal
	pop	edi
	pop	esi
	pop	ebp
$LN3@Horizontal:
	pop	ebx

; 1059 :   }
; 1060 : }

	add	esp, 24					; 00000018H
	ret	0
??$HorizontalBicubic@E@@YAXPAEPBEHHHHH@Z ENDP		; HorizontalBicubic<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$HorizontalBicubic@G@@YAXPAEPBEHHHHH@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
tv701 = -20						; size = 4
tv698 = -16						; size = 4
tv700 = -12						; size = 4
tv699 = -8						; size = 4
_max_pixel_value$ = -4					; size = 4
_pDst8$ = 8						; size = 4
tv694 = 12						; size = 4
_pSrc8$ = 12						; size = 4
_max_pixel_value$1$ = 16				; size = 4
_nDstPitch$ = 16					; size = 4
_i$1$ = 20						; size = 4
_nSrcPitch$ = 20					; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
$T2 = 32						; size = 4
_bits_per_pixel$ = 32					; size = 4
??$HorizontalBicubic@G@@YAXPAEPBEHHHHH@Z PROC		; HorizontalBicubic<unsigned short>, COMDAT

; 1036 : {

	sub	esp, 24					; 00000018H

; 1037 :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 1038 :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 1039 : 
; 1040 :   nSrcPitch /= sizeof(pixel_t);
; 1041 :   nDstPitch /= sizeof(pixel_t);
; 1042 : 
; 1043 :   const int max_pixel_value = sizeof(pixel_t) == 1 ? 255 : (1 << bits_per_pixel) - 1;

	mov	ecx, DWORD PTR _bits_per_pixel$[esp+20]
	mov	eax, 1
	push	ebx
	mov	ebx, DWORD PTR _pSrc8$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR _pDst8$[esp+28]
	push	esi
	mov	esi, DWORD PTR _nSrcPitch$[esp+32]
	push	edi
	mov	edi, DWORD PTR _nDstPitch$[esp+36]
	shl	eax, cl
	dec	eax
	shr	esi, 1
	shr	edi, 1

; 1044 : 
; 1045 :   for (int j = 0; j < nHeight; j++)

	cmp	DWORD PTR _nHeight$[esp+36], 0
	mov	DWORD PTR _max_pixel_value$1$[esp+36], eax
	mov	DWORD PTR _max_pixel_value$[esp+40], eax
	jle	$LN3@Horizontal
	mov	eax, DWORD PTR _nWidth$[esp+36]
	lea	edx, DWORD PTR [eax-3]
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR _i$1$[esp+36], edx
	lea	eax, DWORD PTR [eax*2-2]
	mov	DWORD PTR tv701[esp+40], ecx
	mov	DWORD PTR tv698[esp+40], eax
	lea	eax, DWORD PTR [edi+edi]
	mov	DWORD PTR tv700[esp+40], eax
	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR tv699[esp+40], eax
	npad	11
$LL4@Horizontal:

; 1046 :   {
; 1047 :     pDst[0] = (pSrc[0] + pSrc[1] + 1) >> 1;

	movzx	eax, WORD PTR [ebx]

; 1048 :     for (int i = 1; i < nWidth - 3; i++)

	mov	edi, 1
	movzx	ecx, WORD PTR [ebx+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	WORD PTR [ebp], ax
	cmp	edx, edi
	jle	SHORT $LN6@Horizontal

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	esi, ebx
	mov	DWORD PTR $T1[esp+40], 0
	mov	ebx, DWORD PTR _i$1$[esp+36]
	npad	9
$LL7@Horizontal:
	movzx	eax, WORD PTR [esi+2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T2[esp+36]
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	movzx	ecx, WORD PTR [esi+4]
	lea	esi, DWORD PTR [esi+2]
	add	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ebp, DWORD PTR _max_pixel_value$1$[esp+36]
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	movzx	eax, WORD PTR [esi+4]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	sub	ecx, eax
	movzx	eax, WORD PTR [esi-2]
	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T1[esp+40]
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	add	ecx, 8
	sar	ecx, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	ecx, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	DWORD PTR $T2[esp+36], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovle	edx, eax

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR _max_pixel_value$1$[esp+36]
	movzx	ecx, ax
	cmp	DWORD PTR [edx], ebp
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	ebp, DWORD PTR _pDst8$[esp+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	eax, WORD PTR [edx]
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 1050 :       pDst[i] = std::min(max_pixel_value, std::max(0,

	mov	WORD PTR [ebp+edi*2], cx
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL7@Horizontal
	mov	ebx, DWORD PTR _pSrc8$[esp+36]
	mov	edx, DWORD PTR _i$1$[esp+36]
$LN6@Horizontal:

; 1051 :         (-(pSrc[i - 1] + pSrc[i + 2]) + (pSrc[i] + pSrc[i + 1]) * 9 + 8) >> 4));
; 1052 :     }
; 1053 :     for (int i = nWidth - 3; i < nWidth - 1; i++)

	mov	esi, DWORD PTR tv701[esp+40]
	cmp	edx, esi
	jge	SHORT $LN9@Horizontal
	sub	ebp, ebx
	lea	eax, DWORD PTR [ebx+edx*2]
	mov	edi, esi
	mov	DWORD PTR tv694[esp+36], ebp
	sub	edi, edx
$LL10@Horizontal:

; 1054 :       pDst[i] = (pSrc[i] + pSrc[i + 1] + 1) >> 1;

	movzx	ecx, WORD PTR [eax+2]
	lea	eax, DWORD PTR [eax+2]
	movzx	edx, WORD PTR [eax-2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [eax+ebp-2], cx
	sub	edi, 1
	jne	SHORT $LL10@Horizontal
	mov	ebp, DWORD PTR _pDst8$[esp+36]
	mov	edx, DWORD PTR _i$1$[esp+36]
$LN9@Horizontal:

; 1055 : 
; 1056 :     pDst[nWidth - 1] = pSrc[nWidth - 1];

	mov	ecx, DWORD PTR tv698[esp+40]
	mov	ax, WORD PTR [ecx+ebx]

; 1057 :     pDst += nDstPitch;
; 1058 :     pSrc += nSrcPitch;

	add	ebx, DWORD PTR tv699[esp+40]
	mov	WORD PTR [ecx+ebp], ax
	add	ebp, DWORD PTR tv700[esp+40]
	sub	DWORD PTR _nHeight$[esp+36], 1
	mov	DWORD PTR _pDst8$[esp+36], ebp
	mov	DWORD PTR _pSrc8$[esp+36], ebx
	jne	$LL4@Horizontal
$LN3@Horizontal:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1059 :   }
; 1060 : }

	add	esp, 24					; 00000018H
	ret	0
??$HorizontalBicubic@G@@YAXPAEPBEHHHHH@Z ENDP		; HorizontalBicubic<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$Average2@E@@YAXPAEPBE1HHH@Z
_TEXT	SEGMENT
_pDst8$ = 8						; size = 4
_pSrc1_8$ = 12						; size = 4
_pSrc2_8$ = 16						; size = 4
_nPitch$ = 20						; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
??$Average2@E@@YAXPAEPBE1HHH@Z PROC			; Average2<unsigned char>, COMDAT

; 1118 : { // assume all pitches equal

	push	ebp

; 1119 : 
; 1120 :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 1121 :   const pixel_t *pSrc1 = reinterpret_cast<const pixel_t *>(pSrc1_8);
; 1122 :   const pixel_t *pSrc2 = reinterpret_cast<const pixel_t *>(pSrc2_8);
; 1123 : 
; 1124 :   nPitch /= sizeof(pixel_t);
; 1125 : 
; 1126 :   for (int j = 0; j < nHeight; j++)

	mov	ebp, DWORD PTR _nHeight$[esp]
	push	esi
	mov	esi, DWORD PTR _pSrc1_8$[esp+4]
	test	ebp, ebp
	jle	SHORT $LN3@Average2
	mov	ecx, DWORD PTR _pDst8$[esp+4]
	mov	edx, DWORD PTR _nWidth$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR _pSrc2_8$[esp+8]
	sub	ebx, ecx
	sub	ecx, esi
	push	edi
	mov	DWORD PTR _pSrc2_8$[esp+12], ebx
	mov	DWORD PTR _pDst8$[esp+12], ecx
$LL4@Average2:

; 1127 :   {
; 1128 :     for (int i = 0; i < nWidth; i++)

	test	edx, edx
	jle	SHORT $LN6@Average2
	mov	ebp, ebx
	lea	edi, DWORD PTR [ecx+esi]
	sub	ebp, esi
	mov	eax, esi
	add	ebp, edi
	mov	ebx, edx
	sub	edi, esi
	npad	5
$LL7@Average2:

; 1129 :       pDst[i] = (pSrc1[i] + pSrc2[i] + 1) >> 1;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+ebp-1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [edi+eax-1], cl
	sub	ebx, 1
	jne	SHORT $LL7@Average2
	mov	ebp, DWORD PTR _nHeight$[esp+12]
	mov	edx, DWORD PTR _nWidth$[esp+12]
	mov	ecx, DWORD PTR _pDst8$[esp+12]
	mov	ebx, DWORD PTR _pSrc2_8$[esp+12]
$LN6@Average2:

; 1130 : 
; 1131 :     pDst += nPitch;
; 1132 :     pSrc1 += nPitch;

	add	esi, DWORD PTR _nPitch$[esp+12]
	sub	ebp, 1
	mov	DWORD PTR _nHeight$[esp+12], ebp
	jne	SHORT $LL4@Average2
	pop	edi
	pop	ebx
$LN3@Average2:
	pop	esi
	pop	ebp

; 1133 :     pSrc2 += nPitch;
; 1134 :   }
; 1135 : }

	ret	0
??$Average2@E@@YAXPAEPBE1HHH@Z ENDP			; Average2<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$Average2@G@@YAXPAEPBE1HHH@Z
_TEXT	SEGMENT
_pDst8$ = 8						; size = 4
tv339 = 12						; size = 4
_pSrc1_8$ = 12						; size = 4
_pSrc2_8$ = 16						; size = 4
_nPitch$ = 20						; size = 4
_nWidth$ = 24						; size = 4
_nHeight$ = 28						; size = 4
??$Average2@G@@YAXPAEPBE1HHH@Z PROC			; Average2<unsigned short>, COMDAT

; 1119 : 
; 1120 :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 1121 :   const pixel_t *pSrc1 = reinterpret_cast<const pixel_t *>(pSrc1_8);
; 1122 :   const pixel_t *pSrc2 = reinterpret_cast<const pixel_t *>(pSrc2_8);
; 1123 : 
; 1124 :   nPitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _nPitch$[esp-4]
	push	ebx

; 1125 : 
; 1126 :   for (int j = 0; j < nHeight; j++)

	mov	ebx, DWORD PTR _nHeight$[esp]
	shr	eax, 1
	push	edi
	mov	edi, DWORD PTR _pSrc1_8$[esp+4]
	test	ebx, ebx
	jle	SHORT $LN3@Average2
	mov	ecx, DWORD PTR _nWidth$[esp+4]
	add	eax, eax
	push	ebp
	mov	ebp, DWORD PTR _pSrc2_8$[esp+8]
	sub	ebp, edi
	mov	DWORD PTR tv339[esp+8], eax
	sub	DWORD PTR _pDst8$[esp+8], edi
	push	esi
	npad	6
$LL4@Average2:

; 1127 :   {
; 1128 :     for (int i = 0; i < nWidth; i++)

	test	ecx, ecx
	jle	SHORT $LN6@Average2
	mov	ebx, DWORD PTR _pDst8$[esp+12]
	mov	eax, edi
	mov	esi, ecx
	npad	4
$LL7@Average2:

; 1129 :       pDst[i] = (pSrc1[i] + pSrc2[i] + 1) >> 1;

	movzx	ecx, WORD PTR [eax]
	lea	eax, DWORD PTR [eax+2]
	movzx	edx, WORD PTR [eax+ebp-2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [ebx+eax-2], cx
	sub	esi, 1
	jne	SHORT $LL7@Average2
	mov	ebx, DWORD PTR _nHeight$[esp+12]
	mov	ecx, DWORD PTR _nWidth$[esp+12]
	mov	eax, DWORD PTR tv339[esp+12]
$LN6@Average2:

; 1130 : 
; 1131 :     pDst += nPitch;
; 1132 :     pSrc1 += nPitch;

	add	edi, eax
	sub	ebx, 1
	mov	DWORD PTR _nHeight$[esp+12], ebx
	jne	SHORT $LL4@Average2
	pop	esi
	pop	ebp
$LN3@Average2:
	pop	edi
	pop	ebx

; 1133 :     pSrc2 += nPitch;
; 1134 :   }
; 1135 : }

	ret	0
??$Average2@G@@YAXPAEPBE1HHH@Z ENDP			; Average2<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2F_C@E@@YAXPAEPBEHHHHHH@Z
_TEXT	SEGMENT
_nDstPitch$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$dead$ = 20					; size = 4
_y_beg$ = 24						; size = 4
_y_end$ = 28						; size = 4
??$RB2F_C@E@@YAXPAEPBEHHHHHH@Z PROC			; RB2F_C<unsigned char>, COMDAT
; _pDst$ = ecx
; _pSrc$ = edx

; 62   :   assert(y_beg >= 0);
; 63   :   assert(y_end <= nHeight);
; 64   : 
; 65   :   int				y = 0;
; 66   :   RB2_jump(y_beg, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	eax, DWORD PTR _nDstPitch$[esp-4]
	push	ebx
	mov	ebx, ecx
	mov	ecx, DWORD PTR _y_beg$[esp]
	imul	eax, ecx
	push	esi
	mov	esi, DWORD PTR _nSrcPitch$[esp+4]
	push	edi
	add	ebx, eax
	mov	eax, esi
	imul	eax, ecx
	lea	edi, DWORD PTR [edx+eax*2]

; 67   :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+8]
	cmp	ecx, edx
	jge	SHORT $LN3@RB2F_C

; 62   :   assert(y_beg >= 0);
; 63   :   assert(y_end <= nHeight);
; 64   : 
; 65   :   int				y = 0;
; 66   :   RB2_jump(y_beg, y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	edx, ecx
	mov	ecx, DWORD PTR _nWidth$[esp+8]
	mov	DWORD PTR _y_end$[esp+8], edx
	push	ebp
$LL4@RB2F_C:

; 68   :   {
; 69   :     for (int x = 0; x < nWidth; x++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN6@RB2F_C
	mov	ebp, 1
	add	esi, edi
	sub	ebp, DWORD PTR _nSrcPitch$[esp+12]
$LL7@RB2F_C:

; 70   :     {
; 71   :       pDst[x] = (pSrc[x * 2] + pSrc[x * 2 + 1]

	movzx	ecx, BYTE PTR [esi+ebp]
	lea	esi, DWORD PTR [esi+2]
	movzx	edx, BYTE PTR [edi+eax*2]
	add	edx, ecx
	movzx	ecx, BYTE PTR [esi-1]
	add	edx, ecx
	movzx	ecx, BYTE PTR [esi-2]
	add	ecx, 2
	add	ecx, edx
	shr	ecx, 2
	mov	BYTE PTR [eax+ebx], cl
	inc	eax
	mov	ecx, DWORD PTR _nWidth$[esp+12]
	cmp	eax, ecx
	jl	SHORT $LL7@RB2F_C
	mov	edx, DWORD PTR _y_end$[esp+12]
	mov	esi, DWORD PTR _nSrcPitch$[esp+12]
$LN6@RB2F_C:

; 72   :         + pSrc[x * 2 + nSrcPitch / sizeof(pixel_t)] + pSrc[x * 2 + nSrcPitch / sizeof(pixel_t) + 1] + 2) / 4;
; 73   :     }
; 74   :     pDst += nDstPitch / sizeof(pixel_t);

	add	ebx, DWORD PTR _nDstPitch$[esp+12]

; 75   :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	lea	edi, DWORD PTR [edi+esi*2]
	sub	edx, 1
	mov	DWORD PTR _y_end$[esp+12], edx
	jne	SHORT $LL4@RB2F_C
	pop	ebp
$LN3@RB2F_C:
	pop	edi
	pop	esi
	pop	ebx

; 76   :   }
; 77   : }

	ret	0
??$RB2F_C@E@@YAXPAEPBEHHHHHH@Z ENDP			; RB2F_C<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2F_C@G@@YAXPAGPBGHHHHHH@Z
_TEXT	SEGMENT
tv613 = 8						; size = 4
_nDstPitch$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$dead$ = 20					; size = 4
_y_beg$ = 24						; size = 4
_y_end$ = 28						; size = 4
??$RB2F_C@G@@YAXPAGPBGHHHHHH@Z PROC			; RB2F_C<unsigned short>, COMDAT
; _pDst$ = ecx
; _pSrc$ = edx

; 61   : {

	push	ebx
	push	ebp

; 62   :   assert(y_beg >= 0);
; 63   :   assert(y_end <= nHeight);
; 64   : 
; 65   :   int				y = 0;
; 66   :   RB2_jump(y_beg, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ebp, DWORD PTR _y_beg$[esp+4]
	push	esi
	mov	esi, DWORD PTR _nDstPitch$[esp+8]
	shr	esi, 1
	mov	eax, esi
	imul	eax, ebp
	push	edi
	lea	ebx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _nSrcPitch$[esp+12]

; 67   :   for (; y < y_end; ++y)

	mov	ecx, DWORD PTR _y_end$[esp+12]
	shr	eax, 1
	mov	DWORD PTR _nSrcPitch$[esp+12], eax
	imul	eax, ebp
	lea	edi, DWORD PTR [edx+eax*4]
	cmp	ebp, ecx
	jge	SHORT $LN3@RB2F_C

; 62   :   assert(y_beg >= 0);
; 63   :   assert(y_end <= nHeight);
; 64   : 
; 65   :   int				y = 0;
; 66   :   RB2_jump(y_beg, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	edx, DWORD PTR _nSrcPitch$[esp+12]
	lea	eax, DWORD PTR [esi+esi]
	sub	ecx, ebp
	mov	DWORD PTR tv613[esp+12], eax
	mov	ebp, DWORD PTR _nWidth$[esp+12]
	mov	DWORD PTR _y_end$[esp+12], ecx
$LL4@RB2F_C:

; 68   :   {
; 69   :     for (int x = 0; x < nWidth; x++)

	xor	eax, eax
	test	ebp, ebp
	jle	SHORT $LN6@RB2F_C
	lea	esi, DWORD PTR [edi+edx*2]
	npad	4
$LL7@RB2F_C:

; 70   :     {
; 71   :       pDst[x] = (pSrc[x * 2] + pSrc[x * 2 + 1]

	movzx	ecx, WORD PTR [edi+eax*4]
	lea	esi, DWORD PTR [esi+4]
	movzx	edx, WORD PTR [edi+eax*4+2]
	add	edx, ecx
	movzx	ecx, WORD PTR [esi-2]
	add	edx, ecx
	movzx	ecx, WORD PTR [esi-4]
	add	ecx, 2
	add	ecx, edx
	shr	ecx, 2
	mov	WORD PTR [ebx+eax*2], cx
	inc	eax
	cmp	eax, ebp
	jl	SHORT $LL7@RB2F_C
	mov	ecx, DWORD PTR _y_end$[esp+12]
	mov	edx, DWORD PTR _nSrcPitch$[esp+12]
$LN6@RB2F_C:

; 72   :         + pSrc[x * 2 + nSrcPitch / sizeof(pixel_t)] + pSrc[x * 2 + nSrcPitch / sizeof(pixel_t) + 1] + 2) / 4;
; 73   :     }
; 74   :     pDst += nDstPitch / sizeof(pixel_t);

	add	ebx, DWORD PTR tv613[esp+12]

; 75   :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	lea	eax, DWORD PTR [edx*4]
	add	edi, eax
	sub	ecx, 1
	mov	DWORD PTR _y_end$[esp+12], ecx
	jne	SHORT $LL4@RB2F_C
$LN3@RB2F_C:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 76   :   }
; 77   : }

	ret	0
??$RB2F_C@G@@YAXPAGPBGHHHHHH@Z ENDP			; RB2F_C<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2FilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_nWidthMMX$1$ = -16					; size = 4
tv935 = -12						; size = 4
tv934 = -12						; size = 4
_pDst8$1$ = -12						; size = 4
tv937 = -8						; size = 4
tv936 = -8						; size = 4
_pSrc8$1$ = -8						; size = 4
$T1 = -4						; size = 4
_nDstPitch$ = 8						; size = 4
_pSrc$1$ = 12						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$dead$ = 20					; size = 4
_dif$1$ = 24						; size = 4
_pDst$1$ = 24						; size = 4
_y_beg$ = 24						; size = 4
_y_end$ = 28						; size = 4
_y_end$2$ = 32						; size = 4
_y_end$1$ = 32						; size = 4
_isse2$ = 32						; size = 1
??$RB2FilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z PROC	; RB2FilteredVertical<unsigned char>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 259  : {

	sub	esp, 16					; 00000010H

; 260  : 
; 261  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 262  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 263  : 
; 264  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	eax, DWORD PTR _nWidth$[esp+12]
	push	ebx

; 268  :   if (y_beg < y_loop_b)

	mov	ebx, DWORD PTR _nSrcPitch$[esp+16]
	push	ebp
	mov	ebp, edx
	mov	DWORD PTR $T1[esp+24], 1
	cdq
	and	edx, 3
	mov	DWORD PTR _pSrc8$1$[esp+24], ebp
	push	esi
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	push	edi
; File c:\github\mvtools\sources\interpolation.cpp

; 259  : {

	mov	edi, ecx

; 260  : 
; 261  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 262  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 263  : 
; 264  :   int				nWidthMMX = (nWidth / 4) * 4;

	and	edx, -4					; fffffffcH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR _y_beg$[esp+28]
	mov	esi, ecx
	cmp	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 259  : {

	mov	DWORD PTR _pDst8$1$[esp+32], edi

; 260  : 
; 261  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 262  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 263  : 
; 264  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	DWORD PTR _nWidthMMX$1$[esp+32], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	esi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 268  :   if (y_beg < y_loop_b)

	cmp	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _dif$1$[esp+28], esi
; File c:\github\mvtools\sources\interpolation.cpp

; 270  :     for (int x = 0; x < nWidth; x++)

	mov	ecx, DWORD PTR _nWidth$[esp+28]
	jge	SHORT $LN3@RB2Filtere
	test	ecx, ecx
	jle	SHORT $LN3@RB2Filtere
	mov	edx, ebp
	sub	edi, ebp
	mov	esi, ecx
	npad	10
$LL4@RB2Filtere:

; 271  :     {
; 272  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	movzx	ecx, BYTE PTR [edx+ebx-1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edi+edx-1], al
	sub	esi, 1
	jne	SHORT $LL4@RB2Filtere
	mov	ecx, DWORD PTR _nWidth$[esp+28]
	mov	edx, DWORD PTR _nWidthMMX$1$[esp+32]
	mov	esi, DWORD PTR _dif$1$[esp+28]
	mov	edi, DWORD PTR _pDst8$1$[esp+32]
$LN3@RB2Filtere:

; 273  :     }
; 274  :   }
; 275  : 
; 276  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ebp, esi
	mov	eax, esi
	imul	ebp, DWORD PTR _nDstPitch$[esp+28]
	imul	eax, ebx
	add	ebp, edi

; 277  : 
; 278  :   if ((sizeof(pixel_t) == 1) && isse2 && nWidthMMX >= 4)

	cmp	BYTE PTR _isse2$[esp+28], 0
	mov	edi, DWORD PTR _pSrc8$1$[esp+32]
	mov	DWORD PTR _pDst$1$[esp+28], ebp
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR _pSrc$1$[esp+28], edi
	je	$LN18@RB2Filtere
	cmp	edx, 4
	jl	$LN18@RB2Filtere

; 279  :   {
; 280  :     for (; y < y_end; ++y)

	mov	eax, DWORD PTR _y_end$[esp+28]
	cmp	esi, eax
	jge	$LN6@RB2Filtere
	sub	eax, esi
	mov	DWORD PTR _y_end$1$[esp+28], eax
	npad	4
$LL7@RB2Filtere:

; 281  :     {
; 282  :       RB2FilteredVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);

	push	edx
	push	ebx
	push	edi
	push	ebp
	call	_RB2FilteredVerticalLine_SSE

; 283  : 
; 284  :       for (int x = nWidthMMX; x < nWidth; x++)

	mov	edx, DWORD PTR _nWidthMMX$1$[esp+48]
	add	esp, 16					; 00000010H
	mov	esi, edx
	cmp	edx, DWORD PTR _nWidth$[esp+28]
	jge	SHORT $LN9@RB2Filtere
	mov	eax, edi
	add	edx, edi
	sub	eax, ebx
	sub	ebp, edi
	mov	DWORD PTR tv935[esp+32], ebp
	mov	ebp, eax
	mov	edi, DWORD PTR tv935[esp+32]
	mov	DWORD PTR tv937[esp+32], eax
	npad	2
$LL10@RB2Filtere:

; 285  :       {
; 286  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)] + pSrc[x] * 2 + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 2) / 4;

	movzx	eax, BYTE PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+1]
	movzx	ecx, BYTE PTR [esi+ebp]
	inc	esi
	add	ecx, eax
	movzx	eax, BYTE PTR [edx-1]
	inc	eax
	lea	eax, DWORD PTR [ecx+eax*2]
	shr	eax, 2
	mov	BYTE PTR [edi+edx-1], al
	cmp	esi, DWORD PTR _nWidth$[esp+28]
	jl	SHORT $LL10@RB2Filtere
	mov	edi, DWORD PTR _pSrc$1$[esp+28]
	mov	ebp, DWORD PTR _pDst$1$[esp+28]
	mov	edx, DWORD PTR _nWidthMMX$1$[esp+32]
$LN9@RB2Filtere:

; 287  :       }
; 288  : 
; 289  :       pDst += nDstPitch / sizeof(pixel_t);

	add	ebp, DWORD PTR _nDstPitch$[esp+28]

; 290  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	lea	edi, DWORD PTR [edi+ebx*2]
	sub	DWORD PTR _y_end$1$[esp+28], 1
	mov	DWORD PTR _pDst$1$[esp+28], ebp
	mov	DWORD PTR _pSrc$1$[esp+28], edi
	jne	SHORT $LL7@RB2Filtere
$LN6@RB2Filtere:

; 291  :     }
; 292  : #ifndef _M_X64
; 293  :     _mm_empty();

	emms
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 307  :     }
; 308  :   }
; 309  : }

	add	esp, 16					; 00000010H
	ret	0
$LN18@RB2Filtere:

; 294  : #endif
; 295  :   }
; 296  :   else
; 297  :   {
; 298  :     for (; y < y_end; ++y)

	mov	eax, DWORD PTR _y_end$[esp+28]
	cmp	esi, eax
	jge	SHORT $LN12@RB2Filtere
	sub	eax, esi
	lea	edx, DWORD PTR [ebx+ebx]
	mov	DWORD PTR _y_end$2$[esp+28], eax
$LL13@RB2Filtere:

; 299  :     {
; 300  :       for (int x = 0; x < nWidth; x++)

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN15@RB2Filtere
	mov	ecx, edi
	mov	eax, edi
	sub	ecx, ebx
	sub	ebp, edi
	mov	DWORD PTR tv934[esp+32], ebp
	mov	ebp, ecx
	mov	edi, DWORD PTR tv934[esp+32]
	mov	DWORD PTR tv936[esp+32], ecx
	npad	4
$LL16@RB2Filtere:

; 301  :       {
; 302  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)] + pSrc[x] * 2 + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 2) / 4;

	movzx	ecx, BYTE PTR [esi+ebp]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+ebx-1]
	inc	esi
	add	edx, ecx
	movzx	ecx, BYTE PTR [eax-1]
	inc	ecx
	lea	ecx, DWORD PTR [edx+ecx*2]
	shr	ecx, 2
	mov	BYTE PTR [eax+edi-1], cl
	mov	ecx, DWORD PTR _nWidth$[esp+28]
	cmp	esi, ecx
	jl	SHORT $LL16@RB2Filtere
	mov	edi, DWORD PTR _pSrc$1$[esp+28]
	lea	edx, DWORD PTR [ebx+ebx]
	mov	ebp, DWORD PTR _pDst$1$[esp+28]
	mov	eax, DWORD PTR _y_end$2$[esp+28]
$LN15@RB2Filtere:

; 303  :       }
; 304  : 
; 305  :       pDst += nDstPitch / sizeof(pixel_t);

	add	ebp, DWORD PTR _nDstPitch$[esp+28]

; 306  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	edi, edx
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+28], ebp
	mov	DWORD PTR _pSrc$1$[esp+28], edi
	mov	DWORD PTR _y_end$2$[esp+28], eax
	jne	SHORT $LL13@RB2Filtere
$LN12@RB2Filtere:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 307  :     }
; 308  :   }
; 309  : }

	add	esp, 16					; 00000010H
	ret	0
??$RB2FilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z ENDP	; RB2FilteredVertical<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2FilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z
_TEXT	SEGMENT
_nSrcPitch$1$ = -4					; size = 4
_pSrc0$1$ = 8						; size = 4
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
_y_beg$ = 16						; size = 4
_y_end$ = 20						; size = 4
_isse2$ = 24						; size = 1
??$RB2FilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z PROC	; RB2FilteredHorizontalInplace<unsigned char>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 317  : {

	push	ecx
	push	ebx

; 318  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;

	mov	ebx, DWORD PTR _nWidth$[esp+4]
	push	ebp
	push	esi
	mov	esi, edx
	lea	eax, DWORD PTR [ebx-2]
	mov	DWORD PTR _nSrcPitch$1$[esp+16], esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	push	edi

; 319  :   int				y = 0;
; 320  : 
; 321  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 322  : 
; 323  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);
; 324  : 
; 325  :   for (; y < y_end; ++y)

	mov	edi, DWORD PTR _y_end$[esp+16]
	lea	ebp, DWORD PTR [eax*4+1]
	mov	eax, DWORD PTR _y_beg$[esp+16]
	imul	esi, eax
	add	esi, ecx
	cmp	eax, edi
	jge	$LN3@RB2Filtere

; 318  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;

	sub	edi, eax
	mov	DWORD PTR _y_end$[esp+16], edi
	npad	3
$LL4@RB2Filtere:

; 326  :   {
; 327  :     const int x = 0;
; 328  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	eax, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [esi+1]
	inc	eax
	add	eax, ecx
	shr	eax, 1

; 329  : 
; 330  :     if (sizeof(pixel_t) == 1 && isse2)

	cmp	BYTE PTR _isse2$[esp+16], 0
	mov	DWORD PTR _pSrc0$1$[esp+16], eax
	je	SHORT $LN11@RB2Filtere

; 331  :     {
; 332  :       RB2FilteredHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX); // very first is skipped

	push	ebp
	push	esi
	call	_RB2FilteredHorizontalInplaceLine_SSE
	add	esp, 8

; 333  :       for (int x = nWidthMMX; x < nWidth; x++)

	mov	edi, ebp
	cmp	ebp, ebx
	jge	SHORT $LN26@RB2Filtere

; 331  :     {
; 332  :       RB2FilteredHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX); // very first is skipped

	lea	edx, DWORD PTR [ebp*2+1]
	add	edx, esi
$LL7@RB2Filtere:

; 334  :       {
; 335  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 2 + pSrc[x * 2 + 1] + 2) / 4;

	movzx	eax, BYTE PTR [edx-2]
	lea	edx, DWORD PTR [edx+2]
	movzx	ecx, BYTE PTR [edx-3]
	add	eax, 2
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR [edx-2]
	add	ecx, eax
	shr	ecx, 2
	mov	BYTE PTR [edi+esi], cl
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL7@RB2Filtere

; 336  :       }
; 337  :     }
; 338  :     else

	jmp	SHORT $LN26@RB2Filtere
$LN11@RB2Filtere:

; 339  :     {
; 340  :       for (int x = 1; x < nWidth; x++)

	mov	edi, 1
	cmp	ebx, edi
	jle	SHORT $LN9@RB2Filtere

; 319  :   int				y = 0;
; 320  : 
; 321  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 322  : 
; 323  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);
; 324  : 
; 325  :   for (; y < y_end; ++y)

	lea	eax, DWORD PTR [esi+3]
$LL10@RB2Filtere:

; 341  :       {
; 342  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 2 + pSrc[x * 2 + 1] + 2) / 4;

	movzx	ecx, BYTE PTR [eax-2]
	lea	eax, DWORD PTR [eax+2]
	movzx	edx, BYTE PTR [eax-3]
	add	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*2]
	movzx	ecx, BYTE PTR [eax-2]
	add	edx, ecx
	shr	edx, 2
	mov	BYTE PTR [edi+esi], dl
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL10@RB2Filtere
$LN26@RB2Filtere:
	mov	eax, DWORD PTR _pSrc0$1$[esp+16]
$LN9@RB2Filtere:

; 343  :       }
; 344  :     }
; 345  :     pSrc[0] = pSrc0;

	mov	BYTE PTR [esi], al

; 346  : 
; 347  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	esi, DWORD PTR _nSrcPitch$1$[esp+20]
	sub	DWORD PTR _y_end$[esp+16], 1
	jne	$LL4@RB2Filtere
$LN3@RB2Filtere:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 348  :   }
; 349  : }

	pop	ecx
	ret	0
??$RB2FilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z ENDP	; RB2FilteredHorizontalInplace<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2FilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
tv849 = -12						; size = 4
_pDst8$1$ = -12						; size = 4
tv860 = -8						; size = 4
tv859 = -4						; size = 4
_pSrc$1$ = 8						; size = 4
_nDstPitch$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_nHeight$dead$ = 20					; size = 4
_dif$1$ = 24						; size = 4
_pDst$1$ = 24						; size = 4
_y_beg$ = 24						; size = 4
_y_end$ = 28						; size = 4
_isse2$dead$ = 32					; size = 1
??$RB2FilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z PROC	; RB2FilteredVertical<unsigned short>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 259  : {

	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR _y_beg$[esp+8]
	push	ebx
; File c:\github\mvtools\sources\interpolation.cpp

; 268  :   if (y_beg < y_loop_b)

	mov	ebx, DWORD PTR _nWidth$[esp+12]
	push	ebp
	push	esi
	mov	ebp, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, 1
	push	edi
; File c:\github\mvtools\sources\interpolation.cpp

; 259  : {

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	mov	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 259  : {

	mov	DWORD PTR _pDst8$1$[esp+28], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ecx, edx
	mov	DWORD PTR _dif$1$[esp+24], ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 268  :   if (y_beg < y_loop_b)

	cmp	eax, ecx
	jge	SHORT $LN3@RB2Filtere

; 269  :   {
; 270  :     for (int x = 0; x < nWidth; x++)

	test	ebx, ebx
	jle	SHORT $LN3@RB2Filtere
	mov	eax, DWORD PTR _nSrcPitch$[esp+24]
	mov	ebx, ebp
	shr	eax, 1
	mov	edx, edi
	lea	esi, DWORD PTR [eax*2]
	add	esi, ebp
	sub	ebx, edi
	mov	edi, DWORD PTR _nWidth$[esp+24]
	npad	8
$LL4@RB2Filtere:

; 271  :     {
; 272  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	ecx, WORD PTR [ebx+edx]
	lea	edx, DWORD PTR [edx+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	WORD PTR [edx-2], ax
	sub	edi, 1
	jne	SHORT $LL4@RB2Filtere
	mov	ecx, DWORD PTR _dif$1$[esp+24]
	mov	ebx, DWORD PTR _nWidth$[esp+24]
	mov	edi, DWORD PTR _pDst8$1$[esp+28]
$LN3@RB2Filtere:

; 273  :     }
; 274  :   }
; 275  : 
; 276  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	esi, DWORD PTR _nDstPitch$[esp+24]
	shr	esi, 1
	mov	eax, esi
	imul	eax, ecx
	lea	edx, DWORD PTR [edi+eax*2]
	mov	edi, DWORD PTR _nSrcPitch$[esp+24]
	shr	edi, 1
	mov	eax, edi
	mov	DWORD PTR _pDst$1$[esp+24], edx
	imul	eax, ecx
	mov	DWORD PTR _nSrcPitch$[esp+24], edi
	lea	ebp, DWORD PTR [ebp+eax*4]

; 277  : 
; 278  :   if ((sizeof(pixel_t) == 1) && isse2 && nWidthMMX >= 4)
; 279  :   {
; 280  :     for (; y < y_end; ++y)
; 281  :     {
; 282  :       RB2FilteredVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);
; 283  : 
; 284  :       for (int x = nWidthMMX; x < nWidth; x++)
; 285  :       {
; 286  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)] + pSrc[x] * 2 + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 2) / 4;
; 287  :       }
; 288  : 
; 289  :       pDst += nDstPitch / sizeof(pixel_t);
; 290  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;
; 291  :     }
; 292  : #ifndef _M_X64
; 293  :     _mm_empty();
; 294  : #endif
; 295  :   }
; 296  :   else
; 297  :   {
; 298  :     for (; y < y_end; ++y)

	mov	eax, DWORD PTR _y_end$[esp+24]
	mov	DWORD PTR _pSrc$1$[esp+24], ebp
	cmp	ecx, eax
	jge	$LN12@RB2Filtere

; 273  :     }
; 274  :   }
; 275  : 
; 276  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	add	esi, esi
	shl	edi, 2
	sub	eax, ecx
	mov	DWORD PTR tv860[esp+28], esi
	mov	DWORD PTR tv859[esp+28], edi
	mov	DWORD PTR _y_end$[esp+24], eax
	npad	1
$LL13@RB2Filtere:

; 299  :     {
; 300  :       for (int x = 0; x < nWidth; x++)

	test	ebx, ebx
	jle	SHORT $LN15@RB2Filtere
	mov	ecx, DWORD PTR _nSrcPitch$[esp+24]
	mov	esi, ebp
	add	ecx, ecx
	mov	DWORD PTR tv849[esp+28], ebp
	sub	esi, ecx
	mov	eax, edx
	lea	edi, DWORD PTR [ecx+ebp]
	sub	ebp, edx
	npad	7
$LL16@RB2Filtere:

; 301  :       {
; 302  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)] + pSrc[x] * 2 + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 2) / 4;

	movzx	ecx, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	edx, WORD PTR [eax+ebp]
	lea	edi, DWORD PTR [edi+2]
	add	ecx, 2
	lea	eax, DWORD PTR [eax+2]
	lea	edx, DWORD PTR [ecx+edx*2]
	movzx	ecx, WORD PTR [edi-2]
	add	edx, ecx
	shr	edx, 2
	mov	WORD PTR [eax-2], dx
	sub	ebx, 1
	jne	SHORT $LL16@RB2Filtere
	mov	ebp, DWORD PTR _pSrc$1$[esp+24]
	mov	edx, DWORD PTR _pDst$1$[esp+24]
	mov	eax, DWORD PTR _y_end$[esp+24]
	mov	ebx, DWORD PTR _nWidth$[esp+24]
	mov	esi, DWORD PTR tv860[esp+28]
	mov	edi, DWORD PTR tv859[esp+28]
$LN15@RB2Filtere:

; 303  :       }
; 304  : 
; 305  :       pDst += nDstPitch / sizeof(pixel_t);

	add	edx, esi

; 306  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ebp, edi
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+24], edx
	mov	DWORD PTR _pSrc$1$[esp+24], ebp
	mov	DWORD PTR _y_end$[esp+24], eax
	jne	SHORT $LL13@RB2Filtere
$LN12@RB2Filtere:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 307  :     }
; 308  :   }
; 309  : }

	add	esp, 12					; 0000000cH
	ret	0
??$RB2FilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z ENDP	; RB2FilteredVertical<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2FilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z
_TEXT	SEGMENT
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
tv419 = 16						; size = 4
_y_beg$ = 16						; size = 4
_y_end$ = 20						; size = 4
_isse2$dead$ = 24					; size = 1
??$RB2FilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z PROC	; RB2FilteredHorizontalInplace<unsigned short>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 317  : {

	push	ebx

; 318  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;
; 319  :   int				y = 0;
; 320  : 
; 321  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 322  : 
; 323  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	mov	ebx, DWORD PTR _y_beg$[esp]
	push	esi
	mov	esi, edx

; 324  : 
; 325  :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+4]
	shr	esi, 1
	mov	eax, esi
	imul	eax, ebx
	push	edi
	lea	edi, DWORD PTR [ecx+eax*2]
	cmp	ebx, edx
	jge	SHORT $LN3@RB2Filtere

; 318  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;
; 319  :   int				y = 0;
; 320  : 
; 321  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 322  : 
; 323  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	sub	edx, ebx
	lea	eax, DWORD PTR [esi+esi]
	mov	ebx, DWORD PTR _nWidth$[esp+8]
	mov	DWORD PTR tv419[esp+8], eax
	mov	DWORD PTR _y_end$[esp+8], edx
	push	ebp
	npad	3
$LL4@RB2Filtere:

; 326  :   {
; 327  :     const int x = 0;
; 328  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	ebp, WORD PTR [edi]

; 329  : 
; 330  :     if (sizeof(pixel_t) == 1 && isse2)
; 331  :     {
; 332  :       RB2FilteredHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX); // very first is skipped
; 333  :       for (int x = nWidthMMX; x < nWidth; x++)
; 334  :       {
; 335  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 2 + pSrc[x * 2 + 1] + 2) / 4;
; 336  :       }
; 337  :     }
; 338  :     else
; 339  :     {
; 340  :       for (int x = 1; x < nWidth; x++)

	mov	esi, 1
	movzx	ecx, WORD PTR [edi+2]
	inc	ebp
	add	ebp, ecx
	shr	ebp, 1
	cmp	ebx, esi
	jle	SHORT $LN9@RB2Filtere

; 326  :   {
; 327  :     const int x = 0;
; 328  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	lea	eax, DWORD PTR [edi+6]
	npad	8
$LL10@RB2Filtere:

; 341  :       {
; 342  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 2 + pSrc[x * 2 + 1] + 2) / 4;

	movzx	ecx, WORD PTR [eax-4]
	lea	eax, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [eax-6]
	add	ecx, 2
	lea	edx, DWORD PTR [ecx+edx*2]
	movzx	ecx, WORD PTR [eax-4]
	add	edx, ecx
	shr	edx, 2
	mov	WORD PTR [edi+esi*2], dx
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL10@RB2Filtere
	mov	edx, DWORD PTR _y_end$[esp+12]
$LN9@RB2Filtere:

; 343  :       }
; 344  :     }
; 345  :     pSrc[0] = pSrc0;

	mov	WORD PTR [edi], bp

; 346  : 
; 347  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	edi, DWORD PTR tv419[esp+12]
	sub	edx, 1
	mov	DWORD PTR _y_end$[esp+12], edx
	jne	SHORT $LL4@RB2Filtere
	pop	ebp
$LN3@RB2Filtere:
	pop	edi
	pop	esi
	pop	ebx

; 348  :   }
; 349  : }

	ret	0
??$RB2FilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z ENDP	; RB2FilteredHorizontalInplace<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2BilinearFilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_y$1$ = -20						; size = 4
_nWidthMMX$1$ = -16					; size = 4
tv1353 = -12						; size = 4
tv1345 = -12						; size = 4
_pSrc8$1$ = -12						; size = 4
tv1347 = -8						; size = 4
tv1344 = -8						; size = 4
_pDst8$1$ = -8						; size = 4
tv1354 = -4						; size = 4
tv1346 = -4						; size = 4
$T1 = -4						; size = 4
_nDstPitch$ = 8						; size = 4
_pSrc$1$ = 12						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_pDst$1$ = 20						; size = 4
_nHeight$ = 20						; size = 4
_y$2$ = 24						; size = 4
$T2 = 24						; size = 4
_y_beg$ = 24						; size = 4
_y_end$1$ = 28						; size = 4
_y_end$ = 28						; size = 4
tv1342 = 32						; size = 4
tv1340 = 32						; size = 4
_pSrc$2$ = 32						; size = 4
_isse2$ = 32						; size = 1
??$RB2BilinearFilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z PROC ; RB2BilinearFilteredVertical<unsigned char>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 370  : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 371  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	ebp, DWORD PTR _nWidth$[esp+24]
	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR _y_beg$[esp+24]
; File c:\github\mvtools\sources\interpolation.cpp

; 371  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	eax, ebp
	push	esi
	push	edi
	mov	edi, edx
	mov	DWORD PTR _pDst8$1$[esp+36], ebx
	cdq
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	esi, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 371  :   int				nWidthMMX = (nWidth / 4) * 4;

	and	edx, 3
	mov	DWORD PTR _pSrc8$1$[esp+36], edi
	add	eax, edx

; 372  :   const int		y_loop_b = std::max(y_beg, 1);

	mov	DWORD PTR $T1[esp+36], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR _y_end$[esp+32]
; File c:\github\mvtools\sources\interpolation.cpp

; 371  :   int				nWidthMMX = (nWidth / 4) * 4;

	and	eax, -4					; fffffffcH
	mov	DWORD PTR _nWidthMMX$1$[esp+36], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmp	ecx, eax
	cmovl	esi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 373  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	eax, DWORD PTR _nHeight$[esp+32]
	dec	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$1$[esp+36], esi

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, edx
; File c:\github\mvtools\sources\interpolation.cpp

; 373  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	DWORD PTR $T2[esp+32], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	edx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 379  :   if (y_beg < y_loop_b)

	cmp	ecx, esi
	mov	esi, DWORD PTR _nSrcPitch$[esp+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+32], edx
; File c:\github\mvtools\sources\interpolation.cpp

; 379  :   if (y_beg < y_loop_b)

	jge	SHORT $LN3@RB2Bilinea

; 380  :   {
; 381  :     for (int x = 0; x < nWidth; x++)

	test	ebp, ebp
	jle	SHORT $LN3@RB2Bilinea
	mov	edx, edi
	sub	ebx, edi
	mov	edi, ebp
	npad	6
$LL4@RB2Bilinea:

; 382  :     {
; 383  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	movzx	ecx, BYTE PTR [edx+esi-1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [ebx+edx-1], al
	sub	edi, 1
	jne	SHORT $LL4@RB2Bilinea
	mov	edi, DWORD PTR _pSrc8$1$[esp+36]
$LN3@RB2Bilinea:

; 384  :     }
; 385  :   }
; 386  : 
; 387  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ecx, DWORD PTR _y$1$[esp+36]
	mov	ebx, ecx
	mov	edx, DWORD PTR _nDstPitch$[esp+32]
	mov	eax, ecx
	imul	eax, esi
	imul	ebx, edx
	add	ebx, DWORD PTR _pDst8$1$[esp+36]

; 388  : 
; 389  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)

	cmp	BYTE PTR _isse2$[esp+32], 0
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR _pDst$1$[esp+32], ebx
	mov	DWORD PTR _pSrc$1$[esp+32], edi
	je	$LN24@RB2Bilinea
	mov	eax, DWORD PTR _nWidthMMX$1$[esp+36]
	cmp	eax, 4
	jl	$LN24@RB2Bilinea

; 390  :   {
; 391  :     for (; y < y_loop_e; ++y)

	cmp	ecx, DWORD PTR _y$2$[esp+32]
	jge	$LN6@RB2Bilinea
	mov	edx, DWORD PTR _y$1$[esp+36]
	mov	ecx, DWORD PTR _y$2$[esp+32]
	sub	ecx, edx
	add	edx, ecx
	mov	DWORD PTR tv1342[esp+32], ecx
	mov	DWORD PTR _y$1$[esp+36], edx
$LL7@RB2Bilinea:

; 392  :     {
; 393  :       RB2BilinearFilteredVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);

	push	eax
	push	esi
	push	edi
	push	ebx
	call	_RB2BilinearFilteredVerticalLine_SSE

; 394  : 
; 395  :       for (int x = nWidthMMX; x < nWidth; x++)

	mov	eax, DWORD PTR _nWidthMMX$1$[esp+52]
	add	esp, 16					; 00000010H
	mov	edx, eax
	cmp	eax, ebp
	jge	SHORT $LN9@RB2Bilinea
	lea	ebp, DWORD PTR [edi+eax]
	mov	eax, edi
	sub	eax, esi
	sub	ebx, edi
	mov	DWORD PTR tv1347[esp+36], eax
	lea	eax, DWORD PTR [edi+esi*2]
	mov	DWORD PTR tv1345[esp+36], ebx
	mov	ebx, DWORD PTR tv1347[esp+36]
	mov	edi, DWORD PTR tv1345[esp+36]
	mov	DWORD PTR tv1354[esp+36], eax
	npad	6
$LL10@RB2Bilinea:

; 396  :       {
; 397  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)]

	movzx	eax, BYTE PTR [ebp]
	lea	ebp, DWORD PTR [ebp+1]
	movzx	ecx, BYTE PTR [esi+ebp-1]
	add	ecx, eax
	movzx	eax, BYTE PTR [ebx+edx]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, eax
	mov	eax, DWORD PTR tv1354[esp+36]
	movzx	eax, BYTE PTR [eax+edx]
	inc	edx
	add	eax, 4
	add	eax, ecx
	shr	eax, 3
	mov	BYTE PTR [edi+ebp-1], al
	cmp	edx, DWORD PTR _nWidth$[esp+32]
	jl	SHORT $LL10@RB2Bilinea
	mov	edi, DWORD PTR _pSrc$1$[esp+32]
	mov	ebx, DWORD PTR _pDst$1$[esp+32]
	mov	ebp, DWORD PTR _nWidth$[esp+32]
	mov	eax, DWORD PTR _nWidthMMX$1$[esp+36]
$LN9@RB2Bilinea:

; 398  :           + pSrc[x] * 3
; 399  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 3
; 400  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] + 4) / 8;
; 401  :       }
; 402  : 
; 403  :       pDst += nDstPitch / sizeof(pixel_t);

	mov	edx, DWORD PTR _nDstPitch$[esp+32]

; 404  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	lea	edi, DWORD PTR [edi+esi*2]
	add	ebx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], edi
	sub	DWORD PTR tv1342[esp+32], 1
	mov	DWORD PTR _pDst$1$[esp+32], ebx
	jne	$LL7@RB2Bilinea
$LN6@RB2Bilinea:

; 405  :     }
; 406  : #ifndef _M_X64
; 407  :     _mm_empty();

	emms

; 408  : #endif
; 409  :   }
; 410  :   else

	jmp	$LN67@RB2Bilinea
$LN24@RB2Bilinea:

; 411  :   {
; 412  :     for (; y < y_loop_e; ++y)

	mov	eax, DWORD PTR _y$2$[esp+32]
	cmp	ecx, eax
	jge	$LN12@RB2Bilinea
	mov	edx, DWORD PTR _y$1$[esp+36]
	lea	ecx, DWORD PTR [esi+esi]
	sub	eax, edx
	add	edx, eax
	mov	DWORD PTR tv1340[esp+32], eax
	mov	DWORD PTR _y$1$[esp+36], edx
$LL13@RB2Bilinea:

; 413  :     {
; 414  :       for (int x = 0; x < nWidth; x++)

	xor	edx, edx
	test	ebp, ebp
	jle	SHORT $LN15@RB2Bilinea
	mov	eax, edi
	mov	ebp, edi
	sub	eax, esi
	sub	ebx, edi
	mov	DWORD PTR tv1346[esp+36], eax
	lea	eax, DWORD PTR [ecx+edi]
	mov	DWORD PTR tv1344[esp+36], ebx
	mov	ebx, DWORD PTR tv1346[esp+36]
	mov	edi, DWORD PTR tv1344[esp+36]
	mov	DWORD PTR tv1353[esp+36], eax
	npad	7
$LL16@RB2Bilinea:

; 415  :       {
; 416  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)]

	movzx	eax, BYTE PTR [ebp]
	lea	ebp, DWORD PTR [ebp+1]
	movzx	ecx, BYTE PTR [esi+ebp-1]
	add	ecx, eax
	movzx	eax, BYTE PTR [ebx+edx]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, eax
	mov	eax, DWORD PTR tv1353[esp+36]
	movzx	eax, BYTE PTR [eax+edx]
	inc	edx
	add	eax, 4
	add	eax, ecx
	shr	eax, 3
	mov	BYTE PTR [edi+ebp-1], al
	cmp	edx, DWORD PTR _nWidth$[esp+32]
	jl	SHORT $LL16@RB2Bilinea
	mov	edi, DWORD PTR _pSrc$1$[esp+32]
	lea	ecx, DWORD PTR [esi+esi]
	mov	ebx, DWORD PTR _pDst$1$[esp+32]
	mov	ebp, DWORD PTR _nWidth$[esp+32]
	mov	eax, DWORD PTR tv1340[esp+32]
$LN15@RB2Bilinea:

; 417  :           + pSrc[x] * 3
; 418  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 3
; 419  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] + 4) / 8;
; 420  :       }
; 421  : 
; 422  :       pDst += nDstPitch / sizeof(pixel_t);

	mov	edx, DWORD PTR _nDstPitch$[esp+32]

; 423  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	edi, ecx
	add	ebx, edx
	mov	DWORD PTR _pSrc$1$[esp+32], edi
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+32], ebx
	mov	DWORD PTR tv1340[esp+32], eax
	jne	$LL13@RB2Bilinea
$LN67@RB2Bilinea:
	mov	eax, DWORD PTR _y$2$[esp+32]
$LN12@RB2Bilinea:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 1
	mov	ecx, eax
	mov	eax, 1
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	ecx, DWORD PTR _y$1$[esp+36]
	mov	eax, ecx
	imul	ecx, esi
	imul	eax, edx
	add	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR _y$2$[esp+32]
	cmp	eax, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	lea	ecx, DWORD PTR [edi+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edi, 1
	cmovl	eax, edi
; File c:\github\mvtools\sources\interpolation.cpp

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	DWORD PTR _pSrc$2$[esp+32], ecx

; 429  :   for (; y < y_end; ++y)

	mov	edi, DWORD PTR _y_end$[esp+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+32], eax
; File c:\github\mvtools\sources\interpolation.cpp

; 429  :   for (; y < y_end; ++y)

	cmp	eax, edi
	jge	SHORT $LN18@RB2Bilinea

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	edi, DWORD PTR _y$2$[esp+32]
	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR _y_end$1$[esp+32], edi
	npad	2
$LL19@RB2Bilinea:

; 430  :   {
; 431  :     for (int x = 0; x < nWidth; x++)

	test	ebp, ebp
	jle	SHORT $LN21@RB2Bilinea
	mov	edi, DWORD PTR _nWidth$[esp+32]
	mov	ebp, ebx
	mov	eax, ecx
	sub	ebp, ecx
	npad	2
$LL22@RB2Bilinea:

; 432  :     {
; 433  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+esi-1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+ebp-1], cl
	sub	edi, 1
	jne	SHORT $LL22@RB2Bilinea
	mov	ebp, DWORD PTR _nWidth$[esp+32]
	lea	eax, DWORD PTR [esi+esi]
	mov	ecx, DWORD PTR _pSrc$2$[esp+32]
	mov	edx, DWORD PTR _nDstPitch$[esp+32]
	mov	edi, DWORD PTR _y_end$1$[esp+32]
$LN21@RB2Bilinea:

; 434  :     }
; 435  :     pDst += nDstPitch / sizeof(pixel_t);
; 436  :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ecx, eax
	add	ebx, edx
	sub	edi, 1
	mov	DWORD PTR _pSrc$2$[esp+32], ecx
	mov	DWORD PTR _y_end$1$[esp+32], edi
	jne	SHORT $LL19@RB2Bilinea
$LN18@RB2Bilinea:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 437  :   }
; 438  : }

	add	esp, 20					; 00000014H
	ret	0
??$RB2BilinearFilteredVertical@E@@YAXPAEPBEHHHHHH_N@Z ENDP ; RB2BilinearFilteredVertical<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2BilinearFilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z
_TEXT	SEGMENT
_nWidthMMX$1$ = -8					; size = 4
_nSrcPitch$1$ = -4					; size = 4
_pSrc0$1$ = 8						; size = 4
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
tv1153 = 16						; size = 4
_y_beg$ = 16						; size = 4
tv1128 = 20						; size = 4
_y_end$ = 20						; size = 4
_isse2$ = 24						; size = 1
??$RB2BilinearFilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z PROC ; RB2BilinearFilteredHorizontalInplace<unsigned char>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 446  : {

	sub	esp, 8
	push	ebx
	push	ebp

; 447  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;

	mov	ebp, DWORD PTR _nWidth$[esp+12]
	mov	ebx, edx
	push	esi
	push	edi

; 448  :   int				y = 0;
; 449  : 
; 450  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 451  : 
; 452  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	mov	esi, ebx
	mov	DWORD PTR _nSrcPitch$1$[esp+24], ebx
	lea	eax, DWORD PTR [ebp-2]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	lea	edi, DWORD PTR [eax*4+1]
	mov	eax, DWORD PTR _y_beg$[esp+20]
	imul	esi, eax
	mov	DWORD PTR _nWidthMMX$1$[esp+24], edi
	add	esi, ecx

; 453  : 
; 454  :   for (; y < y_end; ++y)

	mov	ecx, DWORD PTR _y_end$[esp+20]
	cmp	eax, ecx
	jge	$LN3@RB2Bilinea
	lea	ebx, DWORD PTR [ebp-1]
	mov	DWORD PTR tv1128[esp+20], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ebx, 1
	mov	edx, ebx
	cmovl	edx, DWORD PTR tv1128[esp+20]
; File c:\github\mvtools\sources\interpolation.cpp

; 447  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;

	sub	ecx, eax
	mov	DWORD PTR tv1153[esp+20], edx
	mov	DWORD PTR _y_end$[esp+20], ecx
	npad	2
$LL4@RB2Bilinea:

; 455  :   {
; 456  :     int x = 0;
; 457  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	eax, BYTE PTR [esi+1]
	lea	edx, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi]
	inc	eax
	add	eax, ecx
	shr	eax, 1

; 458  : 
; 459  :     if (sizeof(pixel_t) == 1 && isse2)

	cmp	BYTE PTR _isse2$[esp+20], 0
	mov	DWORD PTR _pSrc0$1$[esp+20], eax
	je	SHORT $LN14@RB2Bilinea

; 460  :     {
; 461  :       RB2BilinearFilteredHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX); // very first is skipped

	push	edi
	push	esi
	call	_RB2BilinearFilteredHorizontalInplaceLine_SSE

; 462  :       for (int x = nWidthMMX; x < nWidth - 1; x++)

	mov	eax, DWORD PTR _nWidthMMX$1$[esp+32]
	add	esp, 8
	cmp	eax, ebx
	jge	SHORT $LN36@RB2Bilinea

; 460  :     {
; 461  :       RB2BilinearFilteredHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX); // very first is skipped

	lea	edx, DWORD PTR [eax*2-1]
	add	edx, esi
$LL7@RB2Bilinea:

; 463  :       {
; 464  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 3 + pSrc[x * 2 + 1] * 3 + pSrc[x * 2 + 2] + 4) / 8;

	movzx	eax, BYTE PTR [edx+1]
	lea	edx, DWORD PTR [edx+2]
	movzx	ecx, BYTE PTR [edx]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+1]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx-2]
	add	eax, 4
	add	eax, ecx
	shr	eax, 3
	mov	BYTE PTR [edi+esi], al
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL7@RB2Bilinea

; 465  :       }
; 466  :     }
; 467  :     else

	jmp	SHORT $LN36@RB2Bilinea
$LN14@RB2Bilinea:

; 468  :     {
; 469  :       for (int x = 1; x < nWidth - 1; x++)

	mov	edi, 1
	cmp	ebx, edi
	jle	SHORT $LN9@RB2Bilinea
	npad	7
$LL10@RB2Bilinea:

; 470  :       {
; 471  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 3 + pSrc[x * 2 + 1] * 3 + pSrc[x * 2 + 2] + 4) / 8;

	movzx	eax, BYTE PTR [edx+1]
	lea	edx, DWORD PTR [edx+2]
	movzx	ecx, BYTE PTR [edx]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+1]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx-2]
	add	eax, 4
	add	eax, ecx
	shr	eax, 3
	mov	BYTE PTR [edi+esi], al
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL10@RB2Bilinea
$LN36@RB2Bilinea:
	mov	eax, DWORD PTR _pSrc0$1$[esp+20]
$LN9@RB2Bilinea:

; 472  :       }
; 473  :     }
; 474  :     pSrc[0] = pSrc0;
; 475  : 
; 476  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	mov	edx, DWORD PTR tv1153[esp+20]
	mov	BYTE PTR [esi], al
	cmp	edx, ebp
	jge	SHORT $LN12@RB2Bilinea
	npad	9
$LL13@RB2Bilinea:

; 477  :     {
; 478  :       pSrc[x] = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	eax, BYTE PTR [esi+edx*2]
	movzx	ecx, BYTE PTR [esi+edx*2+1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edx+esi], al
	inc	edx
	cmp	edx, ebp
	jl	SHORT $LL13@RB2Bilinea
$LN12@RB2Bilinea:

; 479  :     }
; 480  : 
; 481  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	esi, DWORD PTR _nSrcPitch$1$[esp+24]
	sub	DWORD PTR _y_end$[esp+20], 1
	mov	edi, DWORD PTR _nWidthMMX$1$[esp+24]
	jne	$LL4@RB2Bilinea
$LN3@RB2Bilinea:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 482  :   }
; 483  : }

	add	esp, 8
	ret	0
??$RB2BilinearFilteredHorizontalInplace@E@@YAXPAEHHHHH_N@Z ENDP ; RB2BilinearFilteredHorizontalInplace<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2BilinearFilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_y$1$ = -24						; size = 4
_pSrc$1$ = -20						; size = 4
_pDst8$1$ = -20						; size = 4
tv1433 = -16						; size = 4
tv1424 = -12						; size = 4
_pSrc8$1$ = -12						; size = 4
tv1419 = -8						; size = 4
tv1431 = -4						; size = 4
tv1430 = -4						; size = 4
_y_end$1$ = 8						; size = 4
_nDstPitch$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_pSrc$2$ = 20						; size = 4
_pDst$1$ = 20						; size = 4
_nHeight$ = 20						; size = 4
_y$2$ = 24						; size = 4
_y_beg$ = 24						; size = 4
tv1432 = 28						; size = 4
_y_end$ = 28						; size = 4
_isse2$dead$ = 32					; size = 1
??$RB2BilinearFilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z PROC ; RB2BilinearFilteredVertical<unsigned short>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 370  : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ebp, DWORD PTR _y_end$[esp+28]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	push	esi
	mov	esi, DWORD PTR _y_beg$[esp+32]
; File c:\github\mvtools\sources\interpolation.cpp

; 370  : {

	mov	ebx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	esi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 370  : {

	mov	DWORD PTR _pSrc8$1$[esp+36], ebx
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edi, esi
; File c:\github\mvtools\sources\interpolation.cpp

; 370  : {

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	edi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 370  : {

	mov	DWORD PTR _pDst8$1$[esp+40], edx

; 371  :   int				nWidthMMX = (nWidth / 4) * 4;
; 372  :   const int		y_loop_b = std::max(y_beg, 1);
; 373  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	eax, DWORD PTR _nHeight$[esp+36]
	dec	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$1$[esp+40], edi

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, ebp
	cmovl	ebp, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 379  :   if (y_beg < y_loop_b)

	cmp	esi, edi
	mov	edi, DWORD PTR _nWidth$[esp+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+36], ebp
; File c:\github\mvtools\sources\interpolation.cpp

; 379  :   if (y_beg < y_loop_b)

	jge	SHORT $LN3@RB2Bilinea

; 380  :   {
; 381  :     for (int x = 0; x < nWidth; x++)

	test	edi, edi
	jle	SHORT $LN3@RB2Bilinea
	mov	eax, DWORD PTR _nSrcPitch$[esp+36]
	mov	ebp, ebx
	shr	eax, 1
	sub	ebp, ecx
	lea	esi, DWORD PTR [ebx+eax*2]
	mov	ebx, edi
$LL4@RB2Bilinea:

; 382  :     {
; 383  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	ecx, WORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	WORD PTR [edx-2], ax
	sub	ebx, 1
	jne	SHORT $LL4@RB2Bilinea
	mov	ebx, DWORD PTR _pSrc8$1$[esp+40]
	mov	edx, DWORD PTR _pDst8$1$[esp+40]
$LN3@RB2Bilinea:

; 384  :     }
; 385  :   }
; 386  : 
; 387  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	eax, DWORD PTR _nDstPitch$[esp+36]
	mov	esi, DWORD PTR _nSrcPitch$[esp+36]
	shr	eax, 1
	mov	DWORD PTR _nDstPitch$[esp+36], eax
	imul	eax, DWORD PTR _y$1$[esp+40]
	shr	esi, 1
	mov	DWORD PTR _nSrcPitch$[esp+36], esi
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _y$1$[esp+40]
	mov	eax, esi
	mov	DWORD PTR _pDst$1$[esp+36], ecx
	imul	eax, edx
	lea	ebp, DWORD PTR [ebx+eax*4]

; 388  : 
; 389  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)
; 390  :   {
; 391  :     for (; y < y_loop_e; ++y)
; 392  :     {
; 393  :       RB2BilinearFilteredVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);
; 394  : 
; 395  :       for (int x = nWidthMMX; x < nWidth; x++)
; 396  :       {
; 397  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)]
; 398  :           + pSrc[x] * 3
; 399  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 3
; 400  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] + 4) / 8;
; 401  :       }
; 402  : 
; 403  :       pDst += nDstPitch / sizeof(pixel_t);
; 404  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;
; 405  :     }
; 406  : #ifndef _M_X64
; 407  :     _mm_empty();
; 408  : #endif
; 409  :   }
; 410  :   else
; 411  :   {
; 412  :     for (; y < y_loop_e; ++y)

	mov	ebx, DWORD PTR _y$2$[esp+36]
	mov	DWORD PTR _pSrc$1$[esp+40], ebp
	cmp	edx, ebx
	jge	$LN12@RB2Bilinea

; 384  :     }
; 385  :   }
; 386  : 
; 387  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ebx, DWORD PTR _nDstPitch$[esp+36]
	lea	eax, DWORD PTR [ebx+ebx]
	mov	DWORD PTR tv1433[esp+40], eax
	lea	ebx, DWORD PTR [esi*4]
	mov	eax, DWORD PTR _y$2$[esp+36]
	sub	eax, edx
	mov	DWORD PTR tv1431[esp+40], ebx

; 388  : 
; 389  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)
; 390  :   {
; 391  :     for (; y < y_loop_e; ++y)
; 392  :     {
; 393  :       RB2BilinearFilteredVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);
; 394  : 
; 395  :       for (int x = nWidthMMX; x < nWidth; x++)
; 396  :       {
; 397  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)]
; 398  :           + pSrc[x] * 3
; 399  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 3
; 400  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] + 4) / 8;
; 401  :       }
; 402  : 
; 403  :       pDst += nDstPitch / sizeof(pixel_t);
; 404  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;
; 405  :     }
; 406  : #ifndef _M_X64
; 407  :     _mm_empty();
; 408  : #endif
; 409  :   }
; 410  :   else
; 411  :   {
; 412  :     for (; y < y_loop_e; ++y)

	add	edx, eax
	mov	DWORD PTR tv1424[esp+40], eax
	mov	DWORD PTR _y$1$[esp+40], edx
	mov	edx, DWORD PTR tv1433[esp+40]
	npad	3
$LL13@RB2Bilinea:

; 413  :     {
; 414  :       for (int x = 0; x < nWidth; x++)

	test	edi, edi
	jle	SHORT $LN15@RB2Bilinea
	lea	eax, DWORD PTR [esi+esi]
	mov	edx, ecx
	mov	esi, ebp
	lea	edi, DWORD PTR [ebx+ebp]
	lea	ebx, DWORD PTR [eax+ebp]
	sub	esi, eax
	mov	eax, ebp
	mov	ebp, DWORD PTR _nWidth$[esp+36]
	sub	eax, ecx
	mov	DWORD PTR tv1419[esp+40], eax
	npad	1
$LL16@RB2Bilinea:

; 415  :       {
; 416  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t)]

	movzx	ecx, WORD PTR [edx+eax]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	eax, WORD PTR [ebx-2]
	lea	esi, DWORD PTR [esi+2]
	add	ecx, eax
	lea	edi, DWORD PTR [edi+2]
	movzx	eax, WORD PTR [edi-2]
	lea	edx, DWORD PTR [edx+2]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, eax
	movzx	eax, WORD PTR [esi-2]
	add	eax, 4
	add	eax, ecx
	shr	eax, 3
	mov	WORD PTR [edx-2], ax
	mov	eax, DWORD PTR tv1419[esp+40]
	sub	ebp, 1
	jne	SHORT $LL16@RB2Bilinea
	mov	ebp, DWORD PTR _pSrc$1$[esp+40]
	mov	edi, DWORD PTR _nWidth$[esp+36]
	mov	ecx, DWORD PTR _pDst$1$[esp+36]
	mov	eax, DWORD PTR tv1424[esp+40]
	mov	esi, DWORD PTR _nSrcPitch$[esp+36]
	mov	ebx, DWORD PTR tv1431[esp+40]
	mov	edx, DWORD PTR tv1433[esp+40]
$LN15@RB2Bilinea:

; 417  :           + pSrc[x] * 3
; 418  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 3
; 419  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] + 4) / 8;
; 420  :       }
; 421  : 
; 422  :       pDst += nDstPitch / sizeof(pixel_t);

	add	ecx, edx

; 423  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ebp, ebx
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+36], ecx
	mov	DWORD PTR _pSrc$1$[esp+40], ebp
	mov	DWORD PTR tv1424[esp+40], eax
	jne	$LL13@RB2Bilinea
	mov	ebx, DWORD PTR _y$2$[esp+36]
	mov	edx, DWORD PTR _y$1$[esp+40]
$LN12@RB2Bilinea:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ebx, 1
	mov	ecx, ebx
	mov	eax, 1
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	eax, DWORD PTR _nDstPitch$[esp+36]
	sub	ecx, edx
	mov	edx, DWORD PTR _pDst$1$[esp+36]
	imul	eax, ecx
	lea	ebp, DWORD PTR [edx+eax*2]
	mov	eax, esi
	imul	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ebx, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ecx, DWORD PTR _pSrc$1$[esp+40]
	lea	ecx, DWORD PTR [ecx+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmovl	ebx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	DWORD PTR _pSrc$2$[esp+36], ecx

; 429  :   for (; y < y_end; ++y)

	mov	eax, DWORD PTR _y_end$[esp+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+36], ebx
; File c:\github\mvtools\sources\interpolation.cpp

; 429  :   for (; y < y_end; ++y)

	cmp	ebx, eax
	jge	SHORT $LN18@RB2Bilinea

; 427  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ebx, DWORD PTR _nDstPitch$[esp+36]
	sub	eax, DWORD PTR _y$2$[esp+36]
	mov	DWORD PTR _y_end$1$[esp+36], eax
	lea	edx, DWORD PTR [ebx+ebx]
	lea	ebx, DWORD PTR [esi*4]
	mov	DWORD PTR tv1432[esp+36], edx
	mov	DWORD PTR tv1430[esp+40], ebx
$LL19@RB2Bilinea:

; 430  :   {
; 431  :     for (int x = 0; x < nWidth; x++)

	test	edi, edi
	jle	SHORT $LN21@RB2Bilinea
	mov	ebx, ecx
	lea	esi, DWORD PTR [ecx+esi*2]
	mov	eax, ebp
	sub	ebx, ebp
$LL22@RB2Bilinea:

; 432  :     {
; 433  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	ecx, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	edx, WORD PTR [eax+ebx]
	lea	eax, DWORD PTR [eax+2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [eax-2], cx
	sub	edi, 1
	jne	SHORT $LL22@RB2Bilinea
	mov	ecx, DWORD PTR _pSrc$2$[esp+36]
	mov	edi, DWORD PTR _nWidth$[esp+36]
	mov	eax, DWORD PTR _y_end$1$[esp+36]
	mov	edx, DWORD PTR tv1432[esp+36]
	mov	ebx, DWORD PTR tv1430[esp+40]
	mov	esi, DWORD PTR _nSrcPitch$[esp+36]
$LN21@RB2Bilinea:

; 434  :     }
; 435  :     pDst += nDstPitch / sizeof(pixel_t);
; 436  :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ecx, ebx
	add	ebp, edx
	sub	eax, 1
	mov	DWORD PTR _pSrc$2$[esp+36], ecx
	mov	DWORD PTR _y_end$1$[esp+36], eax
	jne	SHORT $LL19@RB2Bilinea
$LN18@RB2Bilinea:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 437  :   }
; 438  : }

	add	esp, 24					; 00000018H
	ret	0
??$RB2BilinearFilteredVertical@G@@YAXPAEPBEHHHHHH_N@Z ENDP ; RB2BilinearFilteredVertical<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2BilinearFilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z
_TEXT	SEGMENT
tv755 = -4						; size = 4
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
_pSrc0$1$ = 16						; size = 4
_y_beg$ = 16						; size = 4
_y_end$ = 20						; size = 4
_isse2$dead$ = 24					; size = 1
??$RB2BilinearFilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z PROC ; RB2BilinearFilteredHorizontalInplace<unsigned short>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 446  : {

	push	ecx
	push	ebx

; 447  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;
; 448  :   int				y = 0;
; 449  : 
; 450  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 451  : 
; 452  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	mov	ebx, DWORD PTR _y_beg$[esp+4]
	push	esi
	push	edi
	mov	edi, edx

; 453  : 
; 454  :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+12]
	shr	edi, 1
	mov	eax, edi
	imul	eax, ebx
	lea	esi, DWORD PTR [ecx+eax*2]
	cmp	ebx, edx
	jge	$LN3@RB2Bilinea

; 447  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;
; 448  :   int				y = 0;
; 449  : 
; 450  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 451  : 
; 452  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	push	ebp
	mov	ebp, DWORD PTR _nWidth$[esp+16]
	lea	eax, DWORD PTR [edi+edi]
	dec	ebp
	mov	DWORD PTR tv755[esp+20], eax
	sub	edx, ebx
	mov	DWORD PTR _y_end$[esp+16], edx
$LL4@RB2Bilinea:

; 455  :   {
; 456  :     int x = 0;
; 457  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	eax, WORD PTR [esi]

; 458  : 
; 459  :     if (sizeof(pixel_t) == 1 && isse2)
; 460  :     {
; 461  :       RB2BilinearFilteredHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX); // very first is skipped
; 462  :       for (int x = nWidthMMX; x < nWidth - 1; x++)
; 463  :       {
; 464  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 3 + pSrc[x * 2 + 1] * 3 + pSrc[x * 2 + 2] + 4) / 8;
; 465  :       }
; 466  :     }
; 467  :     else
; 468  :     {
; 469  :       for (int x = 1; x < nWidth - 1; x++)

	mov	edi, 1
	movzx	ecx, WORD PTR [esi+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	DWORD PTR _pSrc0$1$[esp+16], eax
	cmp	ebp, edi
	jle	SHORT $LN9@RB2Bilinea

; 455  :   {
; 456  :     int x = 0;
; 457  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	lea	edx, DWORD PTR [esi+2]
	npad	1
$LL10@RB2Bilinea:

; 470  :       {
; 471  :         pSrc[x] = (pSrc[x * 2 - 1] + pSrc[x * 2] * 3 + pSrc[x * 2 + 1] * 3 + pSrc[x * 2 + 2] + 4) / 8;

	movzx	eax, WORD PTR [edx+2]
	lea	edx, DWORD PTR [edx+4]
	movzx	ecx, WORD PTR [edx]
	add	ecx, eax
	movzx	eax, WORD PTR [edx+2]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, eax
	movzx	eax, WORD PTR [edx-4]
	add	eax, 4
	add	eax, ecx
	shr	eax, 3
	mov	WORD PTR [esi+edi*2], ax
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL10@RB2Bilinea
	mov	eax, DWORD PTR _pSrc0$1$[esp+16]
	mov	edx, DWORD PTR _y_end$[esp+16]
$LN9@RB2Bilinea:

; 476  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	mov	edi, DWORD PTR _nWidth$[esp+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ebp, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 474  :     pSrc[0] = pSrc0;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, 1
	mov	eax, ebp
	cmovl	eax, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 476  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	cmp	eax, edi
	jge	SHORT $LN12@RB2Bilinea
	npad	6
$LL13@RB2Bilinea:

; 477  :     {
; 478  :       pSrc[x] = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	ecx, WORD PTR [esi+eax*4+2]
	movzx	edx, WORD PTR [esi+eax*4]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [esi+eax*2], cx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL13@RB2Bilinea
	mov	edx, DWORD PTR _y_end$[esp+16]
$LN12@RB2Bilinea:

; 479  :     }
; 480  : 
; 481  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	esi, DWORD PTR tv755[esp+20]
	sub	edx, 1
	mov	DWORD PTR _y_end$[esp+16], edx
	jne	$LL4@RB2Bilinea
	pop	ebp
$LN3@RB2Bilinea:
	pop	edi
	pop	esi
	pop	ebx

; 482  :   }
; 483  : }

	pop	ecx
	ret	0
??$RB2BilinearFilteredHorizontalInplace@G@@YAXPAEHHHHH_N@Z ENDP ; RB2BilinearFilteredHorizontalInplace<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2QuadraticVertical@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_pSrc$1$ = -44						; size = 4
_nWidthMMX$1$ = -40					; size = 4
tv1915 = -36						; size = 4
tv1919 = -32						; size = 4
_pSrc8$1$ = -32						; size = 4
tv1916 = -28						; size = 4
tv1910 = -28						; size = 4
_pDst8$1$ = -28						; size = 4
tv1914 = -24						; size = 4
tv1924 = -20						; size = 4
_x$1$ = -20						; size = 4
tv1921 = -16						; size = 4
tv1917 = -16						; size = 4
tv1918 = -12						; size = 4
tv1913 = -12						; size = 4
tv1925 = -8						; size = 4
_x$1$ = -8						; size = 4
tv1892 = -4						; size = 4
$T1 = -4						; size = 4
_nDstPitch$ = 8						; size = 4
_pDst$1$ = 12						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_y$2$ = 20						; size = 4
$T2 = 20						; size = 4
_nHeight$ = 20						; size = 4
_y$1$ = 24						; size = 4
_y_beg$ = 24						; size = 4
_y_end$1$ = 28						; size = 4
_y_end$ = 28						; size = 4
tv1920 = 32						; size = 4
tv1912 = 32						; size = 4
_pSrc$2$ = 32						; size = 4
_isse2$ = 32						; size = 1
??$RB2QuadraticVertical@E@@YAXPAEPBEHHHHHH_N@Z PROC	; RB2QuadraticVertical<unsigned char>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 504  : {

	sub	esp, 44					; 0000002cH
	push	ebx

; 505  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	ebx, DWORD PTR _nWidth$[esp+44]
	mov	eax, ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, edx

; 506  :   const int		y_loop_b = std::max(y_beg, 1);

	mov	DWORD PTR $T1[esp+60], 1
	cdq
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	esi, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 505  :   int				nWidthMMX = (nWidth / 4) * 4;

	and	edx, 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR tv1892[esp+60], esi
; File c:\github\mvtools\sources\interpolation.cpp

; 505  :   int				nWidthMMX = (nWidth / 4) * 4;

	add	edx, eax
	mov	DWORD PTR _pSrc8$1$[esp+60], edi
	and	edx, -4					; fffffffcH
	mov	ebp, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR _y_beg$[esp+56]
	mov	eax, ecx
	cmp	ecx, esi
; File c:\github\mvtools\sources\interpolation.cpp

; 504  : {

	mov	DWORD PTR _pDst8$1$[esp+60], ebp

; 505  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	DWORD PTR _nWidthMMX$1$[esp+60], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, esi

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	esi, DWORD PTR _y_end$[esp+56]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$1$[esp+56], eax
; File c:\github\mvtools\sources\interpolation.cpp

; 507  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	eax, DWORD PTR _nHeight$[esp+56]
	dec	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, esi
; File c:\github\mvtools\sources\interpolation.cpp

; 507  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	DWORD PTR $T2[esp+56], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	esi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 513  :   if (y_beg < y_loop_b)

	mov	eax, DWORD PTR _y$1$[esp+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+56], esi
; File c:\github\mvtools\sources\interpolation.cpp

; 513  :   if (y_beg < y_loop_b)

	mov	esi, DWORD PTR _nSrcPitch$[esp+56]
	cmp	ecx, eax
	jge	SHORT $LN3@RB2Quadrat

; 514  :   {
; 515  :     for (int x = 0; x < nWidth; x++)

	test	ebx, ebx
	jle	SHORT $LN3@RB2Quadrat
	mov	edx, edi
	sub	ebp, edi
	mov	edi, ebx
$LL4@RB2Quadrat:

; 516  :     {
; 517  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	movzx	ecx, BYTE PTR [edx+esi-1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edx+ebp-1], al
	sub	edi, 1
	jne	SHORT $LL4@RB2Quadrat
	mov	edx, DWORD PTR _nWidthMMX$1$[esp+60]
	mov	ebp, DWORD PTR _pDst8$1$[esp+60]
	mov	eax, DWORD PTR _y$1$[esp+56]
$LN3@RB2Quadrat:

; 518  :     }
; 519  :   }
; 520  : 
; 521  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ecx, DWORD PTR _pSrc8$1$[esp+60]
	mov	edi, eax
	imul	edi, DWORD PTR _nDstPitch$[esp+56]
	imul	eax, esi
	add	edi, ebp

; 522  : 
; 523  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)

	cmp	BYTE PTR _isse2$[esp+56], 0
	mov	DWORD PTR _pDst$1$[esp+56], edi
	lea	ebp, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _pSrc$1$[esp+60], ebp
	je	$LN24@RB2Quadrat
	cmp	edx, 4
	jl	$LN24@RB2Quadrat

; 524  :   {
; 525  :     for (; y < y_loop_e; ++y)

	mov	eax, DWORD PTR _y$1$[esp+56]
	cmp	eax, DWORD PTR _y$2$[esp+56]
	jge	$LN6@RB2Quadrat
	lea	ecx, DWORD PTR [esi+esi]
	mov	eax, ebp
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR tv1915[esp+60], eax
	lea	eax, DWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR _y$1$[esp+56]
	mov	DWORD PTR tv1914[esp+60], eax
	mov	eax, DWORD PTR _y$2$[esp+56]
	sub	eax, ecx
	add	ecx, eax
	mov	DWORD PTR tv1916[esp+60], eax
	mov	DWORD PTR _y$1$[esp+56], ecx
	npad	4
$LL7@RB2Quadrat:

; 526  :     {
; 527  :       RB2QuadraticVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);

	push	edx
	push	esi
	push	ebp
	push	edi
	call	_RB2QuadraticVerticalLine_SSE

; 528  : 
; 529  :       for (int x = nWidthMMX; x < nWidth; x++)

	mov	edx, DWORD PTR _nWidthMMX$1$[esp+76]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$1$[esp+60], edx
	cmp	edx, ebx
	jge	$LN9@RB2Quadrat

; 524  :   {
; 525  :     for (; y < y_loop_e; ++y)

	mov	ecx, DWORD PTR tv1915[esp+60]
	lea	eax, DWORD PTR [edi+edx]

; 526  :     {
; 527  :       RB2QuadraticVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);

	mov	edx, DWORD PTR tv1914[esp+60]
	mov	DWORD PTR tv1921[esp+60], eax
	add	edx, ecx

; 528  : 
; 529  :       for (int x = nWidthMMX; x < nWidth; x++)

	mov	eax, ebp
	mov	DWORD PTR tv1920[esp+56], edx
	sub	eax, edi
	mov	DWORD PTR tv1919[esp+60], ecx
	mov	edi, DWORD PTR _x$1$[esp+60]
	mov	DWORD PTR tv1918[esp+60], eax
	lea	eax, DWORD PTR [esi*2]
	add	eax, ebp
	mov	ebp, DWORD PTR tv1921[esp+60]
	add	eax, esi
	mov	DWORD PTR tv1925[esp+60], eax
$LL10@RB2Quadrat:

; 530  :       {
; 531  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]

	movzx	eax, BYTE PTR [edx+esi]
	lea	ebp, DWORD PTR [ebp+1]
	movzx	ecx, BYTE PTR [ecx+esi]
	add	ecx, eax
	mov	eax, DWORD PTR tv1918[esp+60]
	lea	edx, DWORD PTR [ecx+ecx*8]
	movzx	ecx, BYTE PTR [eax+ebp-1]
	mov	eax, DWORD PTR tv1920[esp+56]
	movzx	eax, BYTE PTR [eax]
	add	ecx, eax
	imul	eax, ecx, 22
	mov	ecx, DWORD PTR tv1919[esp+60]
	add	edx, eax
	mov	eax, DWORD PTR tv1925[esp+60]
	movzx	eax, BYTE PTR [eax+edi]
	inc	edi
	add	edx, eax
	movzx	eax, BYTE PTR [ecx]
	add	eax, 32					; 00000020H
	inc	ecx
	add	eax, edx
	mov	DWORD PTR tv1919[esp+60], ecx
	mov	edx, DWORD PTR tv1920[esp+56]
	shr	eax, 6
	inc	edx
	mov	BYTE PTR [ebp-1], al
	mov	DWORD PTR tv1920[esp+56], edx
	cmp	edi, ebx
	jl	SHORT $LL10@RB2Quadrat
	mov	edi, DWORD PTR _pDst$1$[esp+56]
	mov	ebp, DWORD PTR _pSrc$1$[esp+60]
	mov	edx, DWORD PTR _nWidthMMX$1$[esp+60]
$LN9@RB2Quadrat:

; 532  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 9
; 533  :           + pSrc[x] * 22
; 534  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 22
; 535  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 9
; 536  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 32) / 64;
; 537  :       }
; 538  : 
; 539  :       pDst += nDstPitch / sizeof(pixel_t);

	add	edi, DWORD PTR _nDstPitch$[esp+56]

; 540  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	lea	eax, DWORD PTR [esi+esi]
	add	DWORD PTR tv1915[esp+60], eax
	lea	ebp, DWORD PTR [ebp+esi*2]
	sub	DWORD PTR tv1916[esp+60], 1
	mov	DWORD PTR _pDst$1$[esp+56], edi
	mov	DWORD PTR _pSrc$1$[esp+60], ebp
	jne	$LL7@RB2Quadrat
	mov	eax, DWORD PTR _y$1$[esp+56]
$LN6@RB2Quadrat:

; 541  :     }
; 542  : #ifndef _M_X64
; 543  :     _mm_empty();

	emms

; 544  : #endif
; 545  :   }
; 546  :   else

	jmp	$LN68@RB2Quadrat
$LN24@RB2Quadrat:

; 547  :   {
; 548  :     for (; y < y_loop_e; ++y)

	mov	edx, DWORD PTR _y$1$[esp+56]
	mov	eax, DWORD PTR _y$2$[esp+56]
	cmp	edx, eax
	jge	$LN67@RB2Quadrat
	sub	eax, edx
	lea	ecx, DWORD PTR [esi+esi]
	add	edx, eax
	mov	DWORD PTR tv1910[esp+60], eax
	mov	DWORD PTR _y$1$[esp+56], edx
	mov	edx, DWORD PTR _nDstPitch$[esp+56]
	npad	10
$LL13@RB2Quadrat:

; 549  :     {
; 550  :       for (int x = 0; x < nWidth; x++)

	mov	DWORD PTR _x$1$[esp+60], 0
	test	ebx, ebx
	jle	$LN15@RB2Quadrat
	mov	eax, ebp
	mov	DWORD PTR tv1913[esp+60], edi
	sub	eax, edi
	lea	edx, DWORD PTR [esi+ebp]
	mov	edi, DWORD PTR _x$1$[esp+60]
	mov	ebx, ebp
	mov	DWORD PTR tv1917[esp+60], eax
	sub	ebx, ecx
	lea	eax, DWORD PTR [esi*2]
	mov	DWORD PTR tv1912[esp+56], edx
	add	eax, ebp
	mov	ebp, DWORD PTR tv1913[esp+60]
	add	eax, esi
	mov	DWORD PTR tv1924[esp+60], eax
	npad	2
$LL16@RB2Quadrat:

; 551  :       {
; 552  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]

	movzx	eax, BYTE PTR [edx+esi]
	lea	ebx, DWORD PTR [ebx+1]
	movzx	ecx, BYTE PTR [ebx+esi-1]
	lea	ebp, DWORD PTR [ebp+1]
	add	ecx, eax
	mov	eax, DWORD PTR tv1917[esp+60]
	lea	edx, DWORD PTR [ecx+ecx*8]
	movzx	ecx, BYTE PTR [eax+ebp-1]
	mov	eax, DWORD PTR tv1912[esp+56]
	movzx	eax, BYTE PTR [eax]
	add	ecx, eax
	imul	eax, ecx, 22
	add	edx, eax
	mov	eax, DWORD PTR tv1924[esp+60]
	movzx	eax, BYTE PTR [eax+edi]
	inc	edi
	add	edx, eax
	movzx	eax, BYTE PTR [ebx-1]
	add	edx, 32					; 00000020H
	add	eax, edx
	mov	edx, DWORD PTR tv1912[esp+56]
	shr	eax, 6
	inc	edx
	mov	BYTE PTR [ebp-1], al
	mov	DWORD PTR tv1912[esp+56], edx
	cmp	edi, DWORD PTR _nWidth$[esp+56]
	jl	SHORT $LL16@RB2Quadrat
	mov	edi, DWORD PTR _pDst$1$[esp+56]
	lea	ecx, DWORD PTR [esi+esi]
	mov	ebp, DWORD PTR _pSrc$1$[esp+60]
	mov	ebx, DWORD PTR _nWidth$[esp+56]
	mov	eax, DWORD PTR tv1910[esp+60]
	mov	edx, DWORD PTR _nDstPitch$[esp+56]
$LN15@RB2Quadrat:

; 553  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 9
; 554  :           + pSrc[x] * 22
; 555  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 22
; 556  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 9
; 557  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 32) / 64;
; 558  :       }
; 559  : 
; 560  :       pDst += nDstPitch / sizeof(pixel_t);

	add	edi, edx

; 561  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ebp, ecx
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+56], edi
	mov	DWORD PTR _pSrc$1$[esp+60], ebp
	mov	DWORD PTR tv1910[esp+60], eax
	jne	$LL13@RB2Quadrat
	mov	eax, DWORD PTR _y$1$[esp+56]
	jmp	SHORT $LN12@RB2Quadrat
$LN67@RB2Quadrat:
	mov	eax, DWORD PTR _y$1$[esp+56]
$LN68@RB2Quadrat:
	mov	edx, DWORD PTR _nDstPitch$[esp+56]
$LN12@RB2Quadrat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR _y$2$[esp+56]
	cmp	ecx, 1
	cmovl	ecx, DWORD PTR tv1892[esp+60]
; File c:\github\mvtools\sources\interpolation.cpp

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	ecx, eax
	mov	eax, ecx
	imul	ecx, esi
	imul	eax, edx

; 567  :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+56]
	add	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	lea	ecx, DWORD PTR [ecx*2]
	add	ecx, ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ebp, DWORD PTR _y$2$[esp+56]
	cmp	ebp, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	DWORD PTR _pSrc$2$[esp+56], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ebp, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 567  :   for (; y < y_end; ++y)

	cmp	ebp, edx
	jge	SHORT $LN18@RB2Quadrat

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	edx, ebp
	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR _y_end$1$[esp+56], edx
$LL19@RB2Quadrat:

; 568  :   {
; 569  :     for (int x = 0; x < nWidth; x++)

	test	ebx, ebx
	jle	SHORT $LN21@RB2Quadrat
	mov	ebp, edi
	mov	eax, ecx
	sub	ebp, ecx
$LL22@RB2Quadrat:

; 570  :     {
; 571  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+esi-1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+ebp-1], cl
	sub	ebx, 1
	jne	SHORT $LL22@RB2Quadrat
	mov	ebx, DWORD PTR _nWidth$[esp+56]
	lea	eax, DWORD PTR [esi+esi]
	mov	ecx, DWORD PTR _pSrc$2$[esp+56]
	mov	edx, DWORD PTR _y_end$1$[esp+56]
$LN21@RB2Quadrat:

; 572  :     }
; 573  :     pDst += nDstPitch / sizeof(pixel_t);

	add	edi, DWORD PTR _nDstPitch$[esp+56]

; 574  :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ecx, eax
	sub	edx, 1
	mov	DWORD PTR _pSrc$2$[esp+56], ecx
	mov	DWORD PTR _y_end$1$[esp+56], edx
	jne	SHORT $LL19@RB2Quadrat
$LN18@RB2Quadrat:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 575  :   }
; 576  : }

	add	esp, 44					; 0000002cH
	ret	0
??$RB2QuadraticVertical@E@@YAXPAEPBEHHHHHH_N@Z ENDP	; RB2QuadraticVertical<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2QuadraticHorizontalInplace@E@@YAXPAEHHHHHH@Z
_TEXT	SEGMENT
_nWidthMMX$1$ = -12					; size = 4
tv1464 = -8						; size = 4
_nSrcPitch$1$ = -4					; size = 4
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
_pSrc0$1$ = 16						; size = 4
_y_beg$ = 16						; size = 4
_y_end$ = 20						; size = 4
_isse2$ = 24						; size = 4
??$RB2QuadraticHorizontalInplace@E@@YAXPAEHHHHHH@Z PROC	; RB2QuadraticHorizontalInplace<unsigned char>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 584  : {

	sub	esp, 12					; 0000000cH
	push	ebx

; 585  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;

	mov	ebx, DWORD PTR _nWidth$[esp+12]
	push	ebp
	mov	ebp, edx
	push	esi
	lea	eax, DWORD PTR [ebx-2]
	mov	DWORD PTR _nSrcPitch$1$[esp+24], ebp
	cdq

; 586  :   int				y = 0;
; 587  : 
; 588  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 589  : 
; 590  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	mov	esi, ebp
	and	edx, 3
	add	eax, edx

; 591  : 
; 592  :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+20]
	sar	eax, 2
	push	edi
	lea	edi, DWORD PTR [eax*4+1]
	mov	eax, DWORD PTR _y_beg$[esp+24]
	imul	esi, eax
	mov	DWORD PTR _nWidthMMX$1$[esp+28], edi
	add	esi, ecx
	cmp	eax, edx
	jge	$LN3@RB2Quadrat
	lea	ebp, DWORD PTR [ebx-1]
	mov	ebx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ebp, ebx
	mov	ecx, ebp
	cmovl	ecx, ebx
; File c:\github\mvtools\sources\interpolation.cpp

; 585  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;

	sub	edx, eax
	mov	DWORD PTR tv1464[esp+28], ecx
	mov	DWORD PTR _y_end$[esp+24], edx
$LL4@RB2Quadrat:

; 593  :   {
; 594  :     int x = 0;
; 595  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2; // store temporary

	movzx	ebx, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [esi+1]
	inc	ebx
	add	ebx, ecx
	shr	ebx, 1

; 596  : 
; 597  :     if (sizeof(pixel_t) == 1 && isse2)

	cmp	DWORD PTR _isse2$[esp+24], 0
	mov	DWORD PTR _pSrc0$1$[esp+24], ebx
	je	SHORT $LN14@RB2Quadrat

; 598  :     {
; 599  :       RB2QuadraticHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX);

	push	edi
	push	esi
	call	_RB2QuadraticHorizontalInplaceLine_SSE
	add	esp, 8

; 600  :       for (int x = nWidthMMX; x < nWidth - 1; x++)

	mov	ebx, edi
	cmp	edi, ebp
	jge	$LN9@RB2Quadrat

; 598  :     {
; 599  :       RB2QuadraticHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX);

	inc	edi
	lea	edi, DWORD PTR [esi+edi*2]
	npad	9
$LL7@RB2Quadrat:

; 601  :       {
; 602  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 9 + pSrc[x * 2] * 22

	movzx	eax, BYTE PTR [edi-1]
	lea	edi, DWORD PTR [edi+2]
	movzx	ecx, BYTE PTR [edi-4]
	add	ecx, eax
	movzx	eax, BYTE PTR [edi-2]
	imul	edx, ecx, 22
	movzx	ecx, BYTE PTR [edi-5]
	add	ecx, eax
	lea	eax, DWORD PTR [ecx+ecx*8]
	add	edx, eax
	movzx	eax, BYTE PTR [edi-6]
	add	edx, eax
	movzx	eax, BYTE PTR [edi-1]
	add	eax, 32					; 00000020H
	add	eax, edx
	shr	eax, 6
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, ebp
	jl	SHORT $LL7@RB2Quadrat

; 603  :           + pSrc[x * 2 + 1] * 22 + pSrc[x * 2 + 2] * 9 + pSrc[x * 2 + 3] + 32) / 64;
; 604  :       }
; 605  :     }
; 606  :     else

	jmp	SHORT $LN36@RB2Quadrat
$LN14@RB2Quadrat:

; 607  :     {
; 608  :       for (int x = 1; x < nWidth - 1; x++)

	mov	ebx, 1
	cmp	ebp, ebx
	jle	SHORT $LN9@RB2Quadrat

; 591  : 
; 592  :   for (; y < y_end; ++y)

	lea	edi, DWORD PTR [esi+4]
	npad	9
$LL10@RB2Quadrat:

; 609  :       {
; 610  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 9 + pSrc[x * 2] * 22

	movzx	eax, BYTE PTR [edi-1]
	lea	edi, DWORD PTR [edi+2]
	movzx	ecx, BYTE PTR [edi-4]
	add	ecx, eax
	movzx	eax, BYTE PTR [edi-2]
	imul	edx, ecx, 22
	movzx	ecx, BYTE PTR [edi-5]
	add	ecx, eax
	lea	eax, DWORD PTR [ecx+ecx*8]
	add	edx, eax
	movzx	eax, BYTE PTR [edi-6]
	add	edx, eax
	movzx	eax, BYTE PTR [edi-1]
	add	eax, 32					; 00000020H
	add	eax, edx
	shr	eax, 6
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, ebp
	jl	SHORT $LL10@RB2Quadrat
$LN36@RB2Quadrat:
	mov	edi, DWORD PTR _nWidthMMX$1$[esp+28]
$LN9@RB2Quadrat:

; 611  :           + pSrc[x * 2 + 1] * 22 + pSrc[x * 2 + 2] * 9 + pSrc[x * 2 + 3] + 32) / 64;
; 612  :       }
; 613  :     }
; 614  :     pSrc[0] = pSrc0;
; 615  : 
; 616  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	mov	edx, DWORD PTR tv1464[esp+28]
	mov	ebx, DWORD PTR _nWidth$[esp+24]
	mov	eax, DWORD PTR _pSrc0$1$[esp+24]
	mov	BYTE PTR [esi], al
	cmp	edx, ebx
	jge	SHORT $LN12@RB2Quadrat
	npad	1
$LL13@RB2Quadrat:

; 617  :     {
; 618  :       pSrc[x] = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	eax, BYTE PTR [esi+edx*2]
	movzx	ecx, BYTE PTR [esi+edx*2+1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [edx+esi], al
	inc	edx
	cmp	edx, ebx
	jl	SHORT $LL13@RB2Quadrat
$LN12@RB2Quadrat:

; 619  :     }
; 620  : 
; 621  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	esi, DWORD PTR _nSrcPitch$1$[esp+28]
	sub	DWORD PTR _y_end$[esp+24], 1
	jne	$LL4@RB2Quadrat
$LN3@RB2Quadrat:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 622  :   }
; 623  : }

	add	esp, 12					; 0000000cH
	ret	0
??$RB2QuadraticHorizontalInplace@E@@YAXPAEHHHHHH@Z ENDP	; RB2QuadraticHorizontalInplace<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2QuadraticVertical@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
tv1908 = -40						; size = 4
tv1909 = -36						; size = 4
_pDst$1$ = -32						; size = 4
tv1902 = -28						; size = 4
tv1921 = -24						; size = 4
_pSrc$1$ = -20						; size = 4
tv1906 = -16						; size = 4
_pDst8$1$ = -16						; size = 4
tv1911 = -12						; size = 4
tv1904 = -8						; size = 4
tv1919 = -4						; size = 4
tv1918 = -4						; size = 4
_y_end$1$ = 8						; size = 4
_nDstPitch$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_y$2$ = 20						; size = 4
_nHeight$ = 20						; size = 4
_pSrc$2$ = 24						; size = 4
_y$1$ = 24						; size = 4
_y_beg$ = 24						; size = 4
tv1920 = 28						; size = 4
_y_end$ = 28						; size = 4
_isse2$dead$ = 32					; size = 1
??$RB2QuadraticVertical@G@@YAXPAEPBEHHHHHH_N@Z PROC	; RB2QuadraticVertical<unsigned short>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 504  : {

	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 504  : {

	mov	ebp, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR _y_end$[esp+44]
	push	esi

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	esi, DWORD PTR _y_beg$[esp+48]
	mov	ebx, esi
	cmp	esi, eax
	push	edi
	cmovl	ebx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 504  : {

	mov	edi, ecx

; 505  :   int				nWidthMMX = (nWidth / 4) * 4;
; 506  :   const int		y_loop_b = std::max(y_beg, 1);
; 507  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	eax, DWORD PTR _nHeight$[esp+52]
	dec	eax
	mov	DWORD PTR _pDst8$1$[esp+56], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$1$[esp+52], ebx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	edx, eax
	mov	DWORD PTR _y$2$[esp+52], edx
; File c:\github\mvtools\sources\interpolation.cpp

; 513  :   if (y_beg < y_loop_b)

	mov	edx, DWORD PTR _nWidth$[esp+52]
	cmp	esi, ebx
	jge	SHORT $LN3@RB2Quadrat

; 514  :   {
; 515  :     for (int x = 0; x < nWidth; x++)

	test	edx, edx
	jle	SHORT $LN3@RB2Quadrat
	mov	eax, DWORD PTR _nSrcPitch$[esp+52]
	mov	ebx, ebp
	shr	eax, 1
	mov	edx, edi
	lea	esi, DWORD PTR [eax*2]
	add	esi, ebp
	sub	ebx, edi
	mov	edi, DWORD PTR _nWidth$[esp+52]
	npad	6
$LL4@RB2Quadrat:

; 516  :     {
; 517  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	ecx, WORD PTR [ebx+edx]
	lea	edx, DWORD PTR [edx+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	WORD PTR [edx-2], ax
	sub	edi, 1
	jne	SHORT $LL4@RB2Quadrat
	mov	edx, DWORD PTR _nWidth$[esp+52]
	mov	edi, DWORD PTR _pDst8$1$[esp+56]
	mov	ebx, DWORD PTR _y$1$[esp+52]
$LN3@RB2Quadrat:

; 518  :     }
; 519  :   }
; 520  : 
; 521  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	eax, DWORD PTR _nDstPitch$[esp+52]
	mov	ecx, DWORD PTR _nSrcPitch$[esp+52]

; 522  : 
; 523  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)
; 524  :   {
; 525  :     for (; y < y_loop_e; ++y)
; 526  :     {
; 527  :       RB2QuadraticVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);
; 528  : 
; 529  :       for (int x = nWidthMMX; x < nWidth; x++)
; 530  :       {
; 531  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]
; 532  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 9
; 533  :           + pSrc[x] * 22
; 534  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 22
; 535  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 9
; 536  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 32) / 64;
; 537  :       }
; 538  : 
; 539  :       pDst += nDstPitch / sizeof(pixel_t);
; 540  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;
; 541  :     }
; 542  : #ifndef _M_X64
; 543  :     _mm_empty();
; 544  : #endif
; 545  :   }
; 546  :   else
; 547  :   {
; 548  :     for (; y < y_loop_e; ++y)

	mov	esi, DWORD PTR _y$2$[esp+52]
	shr	eax, 1
	mov	DWORD PTR _nDstPitch$[esp+52], eax
	imul	eax, ebx
	shr	ecx, 1
	mov	DWORD PTR _nSrcPitch$[esp+52], ecx
	lea	ebx, DWORD PTR [edi+eax*2]
	mov	eax, ecx
	imul	eax, DWORD PTR _y$1$[esp+52]
	mov	DWORD PTR _pDst$1$[esp+56], ebx
	lea	edi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _y$1$[esp+52]
	add	edi, ebp
	mov	DWORD PTR _pSrc$1$[esp+56], edi
	cmp	eax, esi
	jge	$LN12@RB2Quadrat

; 518  :     }
; 519  :   }
; 520  : 
; 521  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	eax, DWORD PTR _nDstPitch$[esp+52]
	lea	ebp, DWORD PTR [ecx*4]
	add	eax, eax
	mov	DWORD PTR tv1919[esp+56], ebp
	mov	DWORD PTR tv1921[esp+56], eax
	mov	eax, esi
	mov	esi, DWORD PTR _y$1$[esp+52]
	sub	eax, esi

; 522  : 
; 523  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)
; 524  :   {
; 525  :     for (; y < y_loop_e; ++y)
; 526  :     {
; 527  :       RB2QuadraticVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);
; 528  : 
; 529  :       for (int x = nWidthMMX; x < nWidth; x++)
; 530  :       {
; 531  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]
; 532  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 9
; 533  :           + pSrc[x] * 22
; 534  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 22
; 535  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 9
; 536  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 32) / 64;
; 537  :       }
; 538  : 
; 539  :       pDst += nDstPitch / sizeof(pixel_t);
; 540  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;
; 541  :     }
; 542  : #ifndef _M_X64
; 543  :     _mm_empty();
; 544  : #endif
; 545  :   }
; 546  :   else
; 547  :   {
; 548  :     for (; y < y_loop_e; ++y)

	add	esi, eax
	mov	DWORD PTR tv1906[esp+56], eax
	mov	DWORD PTR _y$1$[esp+52], esi
	mov	esi, DWORD PTR tv1921[esp+56]
$LL13@RB2Quadrat:

; 549  :     {
; 550  :       for (int x = 0; x < nWidth; x++)

	test	edx, edx
	jle	$LN15@RB2Quadrat
	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR tv1902[esp+56], edx
	lea	eax, DWORD PTR [edi+eax*2]
	mov	esi, ebx
	mov	DWORD PTR tv1911[esp+56], eax
	mov	ebx, edi
	lea	eax, DWORD PTR [ecx+ecx]
	sub	ebx, ebp
	lea	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv1909[esp+56], ecx
	lea	ecx, DWORD PTR [edi+ebp]
	mov	DWORD PTR tv1908[esp+56], ecx
	mov	ebp, edi
	mov	ecx, edi
	sub	ebp, eax
	sub	ecx, DWORD PTR _pDst$1$[esp+56]
	mov	edi, DWORD PTR tv1911[esp+56]
	mov	eax, DWORD PTR tv1909[esp+56]
	mov	DWORD PTR tv1904[esp+56], ecx
	npad	9
$LL16@RB2Quadrat:

; 551  :       {
; 552  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]

	movzx	eax, WORD PTR [eax]
	lea	ebp, DWORD PTR [ebp+2]
	movzx	ecx, WORD PTR [ecx+esi]
	lea	ebx, DWORD PTR [ebx+2]
	add	ecx, eax
	lea	edi, DWORD PTR [edi+2]
	mov	eax, DWORD PTR tv1908[esp+56]
	lea	esi, DWORD PTR [esi+2]
	add	DWORD PTR tv1908[esp+56], 2
	imul	edx, ecx, 22
	movzx	ecx, WORD PTR [eax]
	movzx	eax, WORD PTR [ebp-2]
	add	ecx, eax
	lea	eax, DWORD PTR [ecx+ecx*8]
	mov	ecx, DWORD PTR tv1904[esp+56]
	add	edx, eax
	movzx	eax, WORD PTR [ebx-2]
	add	edx, eax
	movzx	eax, WORD PTR [edi-2]
	add	eax, 32					; 00000020H
	add	eax, edx
	shr	eax, 6
	mov	WORD PTR [esi-2], ax
	mov	eax, DWORD PTR tv1909[esp+56]
	add	eax, 2
	sub	DWORD PTR tv1902[esp+56], 1
	mov	DWORD PTR tv1909[esp+56], eax
	jne	SHORT $LL16@RB2Quadrat
	mov	edi, DWORD PTR _pSrc$1$[esp+56]
	mov	edx, DWORD PTR _nWidth$[esp+52]
	mov	ebx, DWORD PTR _pDst$1$[esp+56]
	mov	eax, DWORD PTR tv1906[esp+56]
	mov	ecx, DWORD PTR _nSrcPitch$[esp+52]
	mov	ebp, DWORD PTR tv1919[esp+56]
	mov	esi, DWORD PTR tv1921[esp+56]
$LN15@RB2Quadrat:

; 553  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 9
; 554  :           + pSrc[x] * 22
; 555  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 22
; 556  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 9
; 557  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 32) / 64;
; 558  :       }
; 559  : 
; 560  :       pDst += nDstPitch / sizeof(pixel_t);

	add	ebx, esi

; 561  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	edi, ebp
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+56], ebx
	mov	DWORD PTR _pSrc$1$[esp+56], edi
	mov	DWORD PTR tv1906[esp+56], eax
	jne	$LL13@RB2Quadrat
	mov	esi, DWORD PTR _y$2$[esp+52]
	mov	eax, DWORD PTR _y$1$[esp+52]
$LN12@RB2Quadrat:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	esi, 1
	mov	ecx, esi
	mov	ebp, 1
	cmovl	ecx, ebp
; File c:\github\mvtools\sources\interpolation.cpp

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	ecx, eax
	mov	eax, DWORD PTR _nDstPitch$[esp+52]
	imul	eax, ecx
	lea	ebp, DWORD PTR [ebx+eax*2]
	mov	ebx, DWORD PTR _nSrcPitch$[esp+52]
	mov	eax, ebx
	imul	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	esi, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	lea	ecx, DWORD PTR [edi+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmovl	esi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	DWORD PTR _pSrc$2$[esp+52], ecx

; 567  :   for (; y < y_end; ++y)

	mov	eax, DWORD PTR _y_end$[esp+52]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+52], esi
; File c:\github\mvtools\sources\interpolation.cpp

; 567  :   for (; y < y_end; ++y)

	cmp	esi, eax
	jge	SHORT $LN18@RB2Quadrat

; 565  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	esi, DWORD PTR _nDstPitch$[esp+52]
	lea	edi, DWORD PTR [ebx*4]
	add	esi, esi
	mov	DWORD PTR tv1918[esp+56], edi
	sub	eax, DWORD PTR _y$2$[esp+52]
	mov	DWORD PTR tv1920[esp+52], esi
	mov	DWORD PTR _y_end$1$[esp+52], eax
$LL19@RB2Quadrat:

; 568  :   {
; 569  :     for (int x = 0; x < nWidth; x++)

	test	edx, edx
	jle	SHORT $LN21@RB2Quadrat
	lea	esi, DWORD PTR [ecx+ebx*2]
	mov	eax, ebp
	mov	ebx, ecx
	mov	edi, edx
	sub	ebx, ebp
$LL22@RB2Quadrat:

; 570  :     {
; 571  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	ecx, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	edx, WORD PTR [eax+ebx]
	lea	eax, DWORD PTR [eax+2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [eax-2], cx
	sub	edi, 1
	jne	SHORT $LL22@RB2Quadrat
	mov	ecx, DWORD PTR _pSrc$2$[esp+52]
	mov	edx, DWORD PTR _nWidth$[esp+52]
	mov	eax, DWORD PTR _y_end$1$[esp+52]
	mov	ebx, DWORD PTR _nSrcPitch$[esp+52]
	mov	esi, DWORD PTR tv1920[esp+52]
	mov	edi, DWORD PTR tv1918[esp+56]
$LN21@RB2Quadrat:

; 572  :     }
; 573  :     pDst += nDstPitch / sizeof(pixel_t);
; 574  :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ecx, edi
	add	ebp, esi
	sub	eax, 1
	mov	DWORD PTR _pSrc$2$[esp+52], ecx
	mov	DWORD PTR _y_end$1$[esp+52], eax
	jne	SHORT $LL19@RB2Quadrat
$LN18@RB2Quadrat:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 575  :   }
; 576  : }

	add	esp, 40					; 00000028H
	ret	0
??$RB2QuadraticVertical@G@@YAXPAEPBEHHHHHH_N@Z ENDP	; RB2QuadraticVertical<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2QuadraticHorizontalInplace@G@@YAXPAEHHHHHH@Z
_TEXT	SEGMENT
tv896 = -8						; size = 4
tv894 = -4						; size = 4
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
_pSrc0$1$ = 16						; size = 4
_y_beg$ = 16						; size = 4
_y_end$ = 20						; size = 4
_isse2$dead$ = 24					; size = 4
??$RB2QuadraticHorizontalInplace@G@@YAXPAEHHHHHH@Z PROC	; RB2QuadraticHorizontalInplace<unsigned short>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 584  : {

	sub	esp, 8
	push	ebx
	mov	ebx, edx

; 591  : 
; 592  :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+8]
	shr	ebx, 1
	mov	eax, ebx
	imul	eax, DWORD PTR _y_beg$[esp+8]
	push	ebp
	push	esi
	lea	esi, DWORD PTR [ecx+eax*2]
	cmp	DWORD PTR _y_beg$[esp+16], edx
	jge	$LN3@RB2Quadrat

; 585  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;
; 586  :   int				y = 0;
; 587  : 
; 588  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 589  : 
; 590  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	mov	ebp, DWORD PTR _nWidth$[esp+16]
	lea	eax, DWORD PTR [ebx+ebx]
	sub	edx, DWORD PTR _y_beg$[esp+16]
	push	edi
	mov	DWORD PTR tv894[esp+24], eax
	lea	edi, DWORD PTR [ebp-1]
	mov	DWORD PTR _y_end$[esp+20], edx
	mov	DWORD PTR tv896[esp+24], edi
	npad	3
$LL4@RB2Quadrat:

; 593  :   {
; 594  :     int x = 0;
; 595  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2; // store temporary

	movzx	eax, WORD PTR [esi]

; 596  : 
; 597  :     if (sizeof(pixel_t) == 1 && isse2)
; 598  :     {
; 599  :       RB2QuadraticHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX);
; 600  :       for (int x = nWidthMMX; x < nWidth - 1; x++)
; 601  :       {
; 602  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 9 + pSrc[x * 2] * 22
; 603  :           + pSrc[x * 2 + 1] * 22 + pSrc[x * 2 + 2] * 9 + pSrc[x * 2 + 3] + 32) / 64;
; 604  :       }
; 605  :     }
; 606  :     else
; 607  :     {
; 608  :       for (int x = 1; x < nWidth - 1; x++)

	mov	ebx, 1
	movzx	ecx, WORD PTR [esi+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	DWORD PTR _pSrc0$1$[esp+20], eax
	cmp	edi, ebx
	jle	SHORT $LN9@RB2Quadrat

; 593  :   {
; 594  :     int x = 0;
; 595  :     int pSrc0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2; // store temporary

	mov	ebp, DWORD PTR tv896[esp+24]
	lea	edi, DWORD PTR [esi+8]
$LL10@RB2Quadrat:

; 609  :       {
; 610  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 9 + pSrc[x * 2] * 22

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	ecx, WORD PTR [edi-8]
	add	ecx, eax
	movzx	eax, WORD PTR [edi-4]
	imul	edx, ecx, 22
	movzx	ecx, WORD PTR [edi-10]
	add	ecx, eax
	lea	eax, DWORD PTR [ecx+ecx*8]
	add	edx, eax
	movzx	eax, WORD PTR [edi-12]
	add	edx, eax
	movzx	eax, WORD PTR [edi-2]
	add	eax, 32					; 00000020H
	add	eax, edx
	shr	eax, 6
	mov	WORD PTR [esi+ebx*2], ax
	inc	ebx
	cmp	ebx, ebp
	jl	SHORT $LL10@RB2Quadrat
	mov	ebp, DWORD PTR _nWidth$[esp+20]
	mov	edi, DWORD PTR tv896[esp+24]
	mov	eax, DWORD PTR _pSrc0$1$[esp+20]
	mov	edx, DWORD PTR _y_end$[esp+20]
$LN9@RB2Quadrat:

; 611  :           + pSrc[x * 2 + 1] * 22 + pSrc[x * 2 + 2] * 9 + pSrc[x * 2 + 3] + 32) / 64;
; 612  :       }
; 613  :     }
; 614  :     pSrc[0] = pSrc0;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	edi, 1
	mov	eax, edi
	mov	ecx, 1
	cmovl	eax, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 616  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	cmp	eax, ebp
	jge	SHORT $LN12@RB2Quadrat
	npad	2
$LL13@RB2Quadrat:

; 617  :     {
; 618  :       pSrc[x] = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	ecx, WORD PTR [esi+eax*4+2]
	movzx	edx, WORD PTR [esi+eax*4]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [esi+eax*2], cx
	inc	eax
	cmp	eax, ebp
	jl	SHORT $LL13@RB2Quadrat
	mov	edx, DWORD PTR _y_end$[esp+20]
$LN12@RB2Quadrat:

; 619  :     }
; 620  : 
; 621  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	esi, DWORD PTR tv894[esp+24]
	sub	edx, 1
	mov	DWORD PTR _y_end$[esp+20], edx
	jne	$LL4@RB2Quadrat
	pop	edi
$LN3@RB2Quadrat:
	pop	esi
	pop	ebp
	pop	ebx

; 622  :   }
; 623  : }

	add	esp, 8
	ret	0
??$RB2QuadraticHorizontalInplace@G@@YAXPAEHHHHHH@Z ENDP	; RB2QuadraticHorizontalInplace<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2CubicVertical@E@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
_y$1$ = -28						; size = 4
_nWidthMMX$1$ = -24					; size = 4
tv1741 = -20						; size = 4
_pSrc8$1$ = -20						; size = 4
tv1745 = -16						; size = 4
_x$1$ = -16						; size = 4
_pDst8$1$ = -16						; size = 4
tv1748 = -12						; size = 4
tv1747 = -12						; size = 4
tv1746 = -8						; size = 4
tv1738 = -8						; size = 4
tv1739 = -4						; size = 4
tv1735 = -4						; size = 4
$T1 = -4						; size = 4
_nDstPitch$ = 8						; size = 4
_pSrc$1$ = 12						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_pDst$1$ = 20						; size = 4
_nHeight$ = 20						; size = 4
_y$2$ = 24						; size = 4
$T2 = 24						; size = 4
_y_beg$ = 24						; size = 4
_y_end$1$ = 28						; size = 4
_y_end$ = 28						; size = 4
tv1736 = 32						; size = 4
tv1734 = 32						; size = 4
_pSrc$2$ = 32						; size = 4
_isse2$ = 32						; size = 1
??$RB2CubicVertical@E@@YAXPAEPBEHHHHHH_N@Z PROC		; RB2CubicVertical<unsigned char>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 644  : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp

; 645  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	ebp, DWORD PTR _nWidth$[esp+32]
	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR _y_beg$[esp+32]
; File c:\github\mvtools\sources\interpolation.cpp

; 645  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	eax, ebp
	push	esi
	push	edi
	mov	edi, edx
	mov	DWORD PTR _pDst8$1$[esp+44], ebx
	cdq
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	esi, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 645  :   int				nWidthMMX = (nWidth / 4) * 4;

	and	edx, 3
	mov	DWORD PTR _pSrc8$1$[esp+44], edi
	add	edx, eax

; 646  :   const int		y_loop_b = std::max(y_beg, 1);

	mov	DWORD PTR $T1[esp+44], 1
	and	edx, -4					; fffffffcH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, ecx
	cmp	ecx, esi
; File c:\github\mvtools\sources\interpolation.cpp

; 645  :   int				nWidthMMX = (nWidth / 4) * 4;

	mov	DWORD PTR _nWidthMMX$1$[esp+44], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, esi

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	esi, DWORD PTR _y_end$[esp+40]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$1$[esp+44], eax
; File c:\github\mvtools\sources\interpolation.cpp

; 647  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	eax, DWORD PTR _nHeight$[esp+40]
	dec	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, esi
; File c:\github\mvtools\sources\interpolation.cpp

; 647  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	DWORD PTR $T2[esp+40], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	esi, eax
	mov	DWORD PTR _y$2$[esp+40], esi
; File c:\github\mvtools\sources\interpolation.cpp

; 653  :   if (y_beg < y_loop_b)

	mov	esi, DWORD PTR _nSrcPitch$[esp+40]
	cmp	ecx, DWORD PTR _y$1$[esp+44]
	jge	SHORT $LN3@RB2CubicVe

; 654  :   {
; 655  :     for (int x = 0; x < nWidth; x++)

	test	ebp, ebp
	jle	SHORT $LN3@RB2CubicVe
	mov	edx, edi
	sub	ebx, edi
	mov	edi, ebp
	npad	4
$LL4@RB2CubicVe:

; 656  :     {
; 657  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	movzx	ecx, BYTE PTR [edx+esi-1]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	BYTE PTR [ebx+edx-1], al
	sub	edi, 1
	jne	SHORT $LL4@RB2CubicVe
	mov	edx, DWORD PTR _nWidthMMX$1$[esp+44]
	mov	edi, DWORD PTR _pSrc8$1$[esp+44]
$LN3@RB2CubicVe:

; 658  :     }
; 659  :   }
; 660  : 
; 661  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	ecx, DWORD PTR _y$1$[esp+44]
	mov	eax, ecx
	imul	eax, esi
	mov	ebx, ecx
	imul	ebx, DWORD PTR _nDstPitch$[esp+40]
	add	ebx, DWORD PTR _pDst8$1$[esp+44]

; 662  : 
; 663  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)

	cmp	BYTE PTR _isse2$[esp+40], 0
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR _pDst$1$[esp+40], ebx
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	je	$LN24@RB2CubicVe
	cmp	edx, 4
	jl	$LN24@RB2CubicVe

; 664  :   {
; 665  :     for (; y < y_loop_e; ++y)

	cmp	ecx, DWORD PTR _y$2$[esp+40]
	jge	$LN6@RB2CubicVe
	mov	eax, DWORD PTR _y$2$[esp+40]
	sub	eax, ecx
	add	ecx, eax
	mov	DWORD PTR tv1736[esp+40], eax
	mov	DWORD PTR _y$1$[esp+44], ecx
	npad	2
$LL7@RB2CubicVe:

; 666  :     {
; 667  :       RB2CubicVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);

	push	edx
	push	esi
	push	edi
	push	ebx
	call	_RB2CubicVerticalLine_SSE

; 668  : 
; 669  :       for (int x = nWidthMMX; x < nWidth; x++)

	mov	edx, DWORD PTR _nWidthMMX$1$[esp+60]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$1$[esp+44], edx
	cmp	edx, ebp
	jge	$LN9@RB2CubicVe
	lea	eax, DWORD PTR [edi+edx]
	sub	ebx, edi
	mov	DWORD PTR tv1741[esp+44], eax
	lea	ecx, DWORD PTR [esi+esi]
	lea	eax, DWORD PTR [ecx+edi]
	mov	DWORD PTR tv1739[esp+44], ebx
	mov	ebx, DWORD PTR _x$1$[esp+44]
	mov	edx, edi
	sub	edx, ecx
	mov	DWORD PTR tv1748[esp+44], eax
	add	edx, DWORD PTR _nWidthMMX$1$[esp+44]
	lea	eax, DWORD PTR [edi+esi*2]
	mov	edi, DWORD PTR tv1741[esp+44]
	add	eax, esi
	mov	DWORD PTR tv1746[esp+44], eax
	npad	4
$LL10@RB2CubicVe:

; 670  :       {
; 671  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	movzx	ecx, BYTE PTR [edi+esi-1]
	lea	edx, DWORD PTR [edx+1]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+esi-1]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	eax, DWORD PTR tv1748[esp+44]
	movzx	eax, BYTE PTR [eax+ebx]
	add	ecx, eax
	mov	eax, DWORD PTR tv1746[esp+44]
	movzx	eax, BYTE PTR [eax+ebx]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	inc	ebx
	movzx	eax, BYTE PTR [edx-1]
	add	ecx, 16					; 00000010H
	add	eax, ecx
	mov	ecx, DWORD PTR tv1739[esp+44]
	shr	eax, 5
	mov	BYTE PTR [ecx+edi-1], al
	cmp	ebx, ebp
	jl	SHORT $LL10@RB2CubicVe
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
	mov	ebx, DWORD PTR _pDst$1$[esp+40]
	mov	edx, DWORD PTR _nWidthMMX$1$[esp+44]
$LN9@RB2CubicVe:

; 672  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 5
; 673  :           + pSrc[x] * 10
; 674  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 10
; 675  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 5
; 676  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 16) / 32;
; 677  :       }
; 678  : 
; 679  :       pDst += nDstPitch / sizeof(pixel_t);

	add	ebx, DWORD PTR _nDstPitch$[esp+40]

; 680  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	lea	edi, DWORD PTR [edi+esi*2]
	sub	DWORD PTR tv1736[esp+40], 1
	mov	DWORD PTR _pDst$1$[esp+40], ebx
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	jne	$LL7@RB2CubicVe
$LN6@RB2CubicVe:

; 681  :     }
; 682  : #ifndef _M_X64
; 683  :     _mm_empty();

	emms

; 684  : #endif
; 685  :   }
; 686  :   else

	mov	eax, DWORD PTR _y$2$[esp+40]
$LN67@RB2CubicVe:
	mov	edx, DWORD PTR _nDstPitch$[esp+40]
$LN12@RB2CubicVe:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 1
	mov	ecx, eax
	mov	eax, 1
	cmovl	ecx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	ecx, DWORD PTR _y$1$[esp+44]
	mov	eax, ecx
	imul	ecx, esi
	imul	eax, edx

; 707  :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+40]
	add	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	lea	ecx, DWORD PTR [edi+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edi, DWORD PTR _y$2$[esp+40]
	cmp	edi, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	DWORD PTR _pSrc$2$[esp+40], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	edi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 707  :   for (; y < y_end; ++y)

	cmp	edi, edx
	jge	SHORT $LN18@RB2CubicVe

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	sub	edx, edi
	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR _y_end$1$[esp+40], edx
	npad	6
$LL19@RB2CubicVe:

; 708  :   {
; 709  :     for (int x = 0; x < nWidth; x++)

	test	ebp, ebp
	jle	SHORT $LN21@RB2CubicVe
	mov	edi, DWORD PTR _nWidth$[esp+40]
	mov	ebp, ebx
	mov	eax, ecx
	sub	ebp, ecx
	npad	2
$LL22@RB2CubicVe:

; 710  :     {
; 711  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	ecx, BYTE PTR [eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	edx, BYTE PTR [eax+esi-1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+ebp-1], cl
	sub	edi, 1
	jne	SHORT $LL22@RB2CubicVe
	mov	ebp, DWORD PTR _nWidth$[esp+40]
	lea	eax, DWORD PTR [esi+esi]
	mov	ecx, DWORD PTR _pSrc$2$[esp+40]
	mov	edx, DWORD PTR _y_end$1$[esp+40]
$LN21@RB2CubicVe:

; 712  :     }
; 713  :     pDst += nDstPitch / sizeof(pixel_t);

	add	ebx, DWORD PTR _nDstPitch$[esp+40]

; 714  :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ecx, eax
	sub	edx, 1
	mov	DWORD PTR _pSrc$2$[esp+40], ecx
	mov	DWORD PTR _y_end$1$[esp+40], edx
	jne	SHORT $LL19@RB2CubicVe
$LN18@RB2CubicVe:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 715  :   }
; 716  : }

	add	esp, 28					; 0000001cH
	ret	0
$LN24@RB2CubicVe:

; 687  :   {
; 688  :     for (; y < y_loop_e; ++y)

	mov	eax, DWORD PTR _y$2$[esp+40]
	cmp	ecx, eax
	jge	$LN67@RB2CubicVe
	mov	edx, DWORD PTR _y$1$[esp+44]
	lea	ecx, DWORD PTR [esi+esi]
	sub	eax, edx
	add	edx, eax
	mov	DWORD PTR tv1734[esp+40], eax
	mov	DWORD PTR _y$1$[esp+44], edx
$LL13@RB2CubicVe:

; 689  :     {
; 690  :       for (int x = 0; x < nWidth; x++)

	xor	edx, edx
	test	ebp, ebp
	jle	$LN15@RB2CubicVe
	lea	eax, DWORD PTR [ecx+edi]
	mov	DWORD PTR tv1735[esp+44], edi
	sub	ebx, edi
	mov	DWORD PTR tv1747[esp+44], eax
	mov	ebp, edi
	mov	DWORD PTR tv1738[esp+44], ebx
	lea	eax, DWORD PTR [edi+esi*2]
	sub	ebp, ecx
	add	eax, esi
	mov	ebx, edi
	mov	edi, DWORD PTR tv1738[esp+44]
	mov	DWORD PTR tv1745[esp+44], eax
$LL16@RB2CubicVe:

; 691  :       {
; 692  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+1]
	movzx	ecx, BYTE PTR [ebx+esi-1]
	lea	ebp, DWORD PTR [ebp+1]
	add	ecx, eax
	mov	eax, DWORD PTR tv1747[esp+44]
	movzx	eax, BYTE PTR [eax+edx]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR [esi+ebp-1]
	add	ecx, eax
	mov	eax, DWORD PTR tv1745[esp+44]
	movzx	eax, BYTE PTR [eax+edx]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	inc	edx
	movzx	eax, BYTE PTR [ebp-1]
	add	eax, 16					; 00000010H
	add	eax, ecx
	shr	eax, 5
	mov	BYTE PTR [edi+ebx-1], al
	cmp	edx, DWORD PTR _nWidth$[esp+40]
	jl	SHORT $LL16@RB2CubicVe
	mov	edi, DWORD PTR _pSrc$1$[esp+40]
	lea	ecx, DWORD PTR [esi+esi]
	mov	ebx, DWORD PTR _pDst$1$[esp+40]
	mov	ebp, DWORD PTR _nWidth$[esp+40]
	mov	eax, DWORD PTR tv1734[esp+40]
$LN15@RB2CubicVe:

; 693  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 5
; 694  :           + pSrc[x] * 10
; 695  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 10
; 696  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 5
; 697  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 16) / 32;
; 698  :       }
; 699  : 
; 700  :       pDst += nDstPitch / sizeof(pixel_t);

	mov	edx, DWORD PTR _nDstPitch$[esp+40]

; 701  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	edi, ecx
	add	ebx, edx
	mov	DWORD PTR _pSrc$1$[esp+40], edi
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+40], ebx
	mov	DWORD PTR tv1734[esp+40], eax
	jne	$LL13@RB2CubicVe
	mov	eax, DWORD PTR _y$2$[esp+40]
	jmp	$LN12@RB2CubicVe
??$RB2CubicVertical@E@@YAXPAEPBEHHHHHH_N@Z ENDP		; RB2CubicVertical<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2CubicHorizontalInplace@E@@YAXPAEHHHHH_N@Z
_TEXT	SEGMENT
_nSrcPitch$1$ = -4					; size = 4
_nWidthMMX$1$ = 8					; size = 4
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
_pSrcw0$1$ = 16						; size = 4
$T1 = 16						; size = 4
_y_beg$ = 16						; size = 4
$T2 = 20						; size = 4
_y_end$ = 20						; size = 4
_isse2$ = 24						; size = 1
??$RB2CubicHorizontalInplace@E@@YAXPAEHHHHH_N@Z PROC	; RB2CubicHorizontalInplace<unsigned char>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 724  : {

	push	ecx
	push	ebx
	push	ebp

; 725  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;

	mov	ebp, DWORD PTR _nWidth$[esp+8]
	mov	ebx, edx
	push	esi

; 726  :   int				y = 0;
; 727  : 
; 728  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 729  : 
; 730  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	mov	esi, ebx
	mov	DWORD PTR _nSrcPitch$1$[esp+16], ebx
	lea	eax, DWORD PTR [ebp-2]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	lea	eax, DWORD PTR [eax*4+1]
	mov	DWORD PTR _nWidthMMX$1$[esp+12], eax
	mov	eax, DWORD PTR _y_beg$[esp+12]
	imul	esi, eax
	add	esi, ecx

; 731  : 
; 732  :   for (; y < y_end; ++y)

	mov	ecx, DWORD PTR _y_end$[esp+12]
	cmp	eax, ecx
	jge	$LN3@RB2CubicHo

; 755  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	sub	ecx, eax
	mov	DWORD PTR $T2[esp+12], 1
	push	edi
	lea	edi, DWORD PTR [ebp-1]
	mov	DWORD PTR _y_end$[esp+16], ecx
	npad	2
$LL4@RB2CubicHo:

; 731  : 
; 732  :   for (; y < y_end; ++y)

	movzx	ebx, BYTE PTR [esi]
	lea	edx, DWORD PTR [esi+1]

; 733  :   {
; 734  :     int x = 0;
; 735  :     int pSrcw0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2; // store temporary

	movzx	ecx, BYTE PTR [edx]
	inc	ebx
	add	ebx, ecx
	shr	ebx, 1

; 736  :     if (sizeof(pixel_t) == 1 && isse2)

	cmp	BYTE PTR _isse2$[esp+16], 0
	mov	DWORD PTR _pSrcw0$1$[esp+16], ebx
	je	SHORT $LN14@RB2CubicHo

; 737  :     {
; 738  :       RB2CubicHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX);

	push	DWORD PTR _nWidthMMX$1$[esp+16]
	push	esi
	call	_RB2CubicHorizontalInplaceLine_SSE

; 739  :       for (int x = nWidthMMX; x < nWidth - 1; x++)

	mov	eax, DWORD PTR _nWidthMMX$1$[esp+24]
	add	esp, 8
	mov	ebx, eax
	cmp	eax, edi
	jge	$LN9@RB2CubicHo

; 737  :     {
; 738  :       RB2CubicHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX);

	lea	edx, DWORD PTR [eax*2-1]
	add	edx, esi
	npad	3
$LL7@RB2CubicHo:

; 740  :       {
; 741  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 5 + pSrc[x * 2] * 10

	movzx	eax, BYTE PTR [edx+1]
	lea	edx, DWORD PTR [edx+2]
	movzx	ecx, BYTE PTR [edx]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+1]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR [edx-2]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx-3]
	add	eax, 16					; 00000010H
	add	eax, ecx
	shr	eax, 5
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL7@RB2CubicHo

; 742  :           + pSrc[x * 2 + 1] * 10 + pSrc[x * 2 + 2] * 5 + pSrc[x * 2 + 3] + 16) / 32;
; 743  :       }
; 744  :     }
; 745  :     else

	jmp	SHORT $LN9@RB2CubicHo
$LN14@RB2CubicHo:

; 746  :     {
; 747  :       for (int x = 1; x < nWidth - 1; x++)

	mov	ebx, 1
	cmp	edi, ebx
	jle	SHORT $LN9@RB2CubicHo
$LL10@RB2CubicHo:

; 748  :       {
; 749  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 5 + pSrc[x * 2] * 10

	movzx	eax, BYTE PTR [edx+1]
	lea	edx, DWORD PTR [edx+2]
	movzx	ecx, BYTE PTR [edx]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+1]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR [edx-2]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	movzx	eax, BYTE PTR [edx-3]
	add	eax, 16					; 00000010H
	add	eax, ecx
	shr	eax, 5
	mov	BYTE PTR [ebx+esi], al
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL10@RB2CubicHo
$LN9@RB2CubicHo:

; 753  :     pSrc[0] = pSrcw0;

	mov	eax, DWORD PTR _pSrcw0$1$[esp+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	edi, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 753  :     pSrc[0] = pSrcw0;

	mov	BYTE PTR [esi], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, 1
	mov	eax, edi
; File c:\github\mvtools\sources\interpolation.cpp

; 755  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	mov	DWORD PTR $T1[esp+16], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 755  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	cmp	eax, ebp
	jge	SHORT $LN12@RB2CubicHo
$LL13@RB2CubicHo:

; 756  :     {
; 757  :       pSrc[x] = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	ecx, BYTE PTR [esi+eax*2]
	movzx	edx, BYTE PTR [esi+eax*2+1]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	BYTE PTR [eax+esi], cl
	inc	eax
	cmp	eax, ebp
	jl	SHORT $LL13@RB2CubicHo
$LN12@RB2CubicHo:

; 758  :     }
; 759  : 
; 760  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	esi, DWORD PTR _nSrcPitch$1$[esp+20]
	sub	DWORD PTR _y_end$[esp+16], 1
	jne	$LL4@RB2CubicHo
	pop	edi
$LN3@RB2CubicHo:

; 761  :   }
; 762  : 
; 763  :   if (isse2)

	cmp	BYTE PTR _isse2$[esp+12], 0
	pop	esi
	pop	ebp
	pop	ebx
	je	SHORT $LN16@RB2CubicHo

; 764  :   {
; 765  : #ifndef _M_X64
; 766  :     _mm_empty();

	emms
$LN16@RB2CubicHo:

; 767  : #endif
; 768  :   }
; 769  : }

	pop	ecx
	ret	0
??$RB2CubicHorizontalInplace@E@@YAXPAEHHHHH_N@Z ENDP	; RB2CubicHorizontalInplace<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2CubicVertical@G@@YAXPAEPBEHHHHHH_N@Z
_TEXT	SEGMENT
tv1926 = -36						; size = 4
_pDst$1$ = -32						; size = 4
_pDst8$1$ = -32						; size = 4
tv1929 = -28						; size = 4
tv1924 = -24						; size = 4
tv1943 = -20						; size = 4
_pSrc$1$ = -16						; size = 4
tv1928 = -12						; size = 4
_pSrc8$1$ = -12						; size = 4
tv1931 = -8						; size = 4
tv1941 = -4						; size = 4
tv1940 = -4						; size = 4
_y_end$1$ = 8						; size = 4
_nDstPitch$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_nWidth$ = 16						; size = 4
_y$2$ = 20						; size = 4
_nHeight$ = 20						; size = 4
_pSrc$2$ = 24						; size = 4
_y$1$ = 24						; size = 4
_y_beg$ = 24						; size = 4
tv1942 = 28						; size = 4
_y_end$ = 28						; size = 4
_isse2$dead$ = 32					; size = 1
??$RB2CubicVertical@G@@YAXPAEPBEHHHHHH_N@Z PROC		; RB2CubicVertical<unsigned short>, COMDAT
; _pDst8$ = ecx
; _pSrc8$ = edx

; 644  : {

	sub	esp, 36					; 00000024H
	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ebp, DWORD PTR _y_end$[esp+40]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	push	esi
	mov	esi, DWORD PTR _y_beg$[esp+44]
; File c:\github\mvtools\sources\interpolation.cpp

; 644  : {

	mov	ebx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	esi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 644  : {

	mov	DWORD PTR _pSrc8$1$[esp+48], ebx
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edi, esi
; File c:\github\mvtools\sources\interpolation.cpp

; 644  : {

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	edi, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 644  : {

	mov	DWORD PTR _pDst8$1$[esp+52], edx

; 645  :   int				nWidthMMX = (nWidth / 4) * 4;
; 646  :   const int		y_loop_b = std::max(y_beg, 1);
; 647  :   const int		y_loop_e = std::min(y_end, nHeight - 1);

	mov	eax, DWORD PTR _nHeight$[esp+48]
	dec	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$1$[esp+48], edi

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, ebp
	cmovl	ebp, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 653  :   if (y_beg < y_loop_b)

	cmp	esi, edi
	mov	edi, DWORD PTR _nWidth$[esp+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+48], ebp
; File c:\github\mvtools\sources\interpolation.cpp

; 653  :   if (y_beg < y_loop_b)

	jge	SHORT $LN3@RB2CubicVe

; 654  :   {
; 655  :     for (int x = 0; x < nWidth; x++)

	test	edi, edi
	jle	SHORT $LN3@RB2CubicVe
	mov	eax, DWORD PTR _nSrcPitch$[esp+48]
	mov	ebp, ebx
	shr	eax, 1
	sub	ebp, ecx
	lea	esi, DWORD PTR [ebx+eax*2]
	mov	ebx, edi
$LL4@RB2CubicVe:

; 656  :     {
; 657  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	eax, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	ecx, WORD PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+2]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	WORD PTR [edx-2], ax
	sub	ebx, 1
	jne	SHORT $LL4@RB2CubicVe
	mov	ebp, DWORD PTR _y$2$[esp+48]
	mov	edx, DWORD PTR _pDst8$1$[esp+52]
$LN3@RB2CubicVe:

; 658  :     }
; 659  :   }
; 660  : 
; 661  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	eax, DWORD PTR _nDstPitch$[esp+48]
	mov	ebx, DWORD PTR _nSrcPitch$[esp+48]
	shr	eax, 1
	mov	DWORD PTR _nDstPitch$[esp+48], eax
	imul	eax, DWORD PTR _y$1$[esp+48]
	shr	ebx, 1
	mov	DWORD PTR _nSrcPitch$[esp+48], ebx
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _pSrc8$1$[esp+52]
	mov	eax, ebx
	mov	DWORD PTR _pDst$1$[esp+52], ecx
	imul	eax, DWORD PTR _y$1$[esp+48]
	lea	esi, DWORD PTR [edx+eax*4]

; 662  : 
; 663  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)
; 664  :   {
; 665  :     for (; y < y_loop_e; ++y)
; 666  :     {
; 667  :       RB2CubicVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);
; 668  : 
; 669  :       for (int x = nWidthMMX; x < nWidth; x++)
; 670  :       {
; 671  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]
; 672  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 5
; 673  :           + pSrc[x] * 10
; 674  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 10
; 675  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 5
; 676  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 16) / 32;
; 677  :       }
; 678  : 
; 679  :       pDst += nDstPitch / sizeof(pixel_t);
; 680  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;
; 681  :     }
; 682  : #ifndef _M_X64
; 683  :     _mm_empty();
; 684  : #endif
; 685  :   }
; 686  :   else
; 687  :   {
; 688  :     for (; y < y_loop_e; ++y)

	mov	eax, DWORD PTR _y$1$[esp+48]
	mov	DWORD PTR _pSrc$1$[esp+52], esi
	cmp	eax, ebp
	jge	$LN12@RB2CubicVe

; 658  :     }
; 659  :   }
; 660  : 
; 661  :   RB2_jump(y_loop_b, y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	edx, DWORD PTR _nDstPitch$[esp+48]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv1943[esp+52], eax
	lea	edx, DWORD PTR [ebx*4]
	mov	eax, ebp
	mov	DWORD PTR tv1941[esp+52], edx
	mov	ebp, DWORD PTR _y$1$[esp+48]
	sub	eax, ebp

; 662  : 
; 663  :   if (sizeof(pixel_t) == 1 && isse2 && nWidthMMX >= 4)
; 664  :   {
; 665  :     for (; y < y_loop_e; ++y)
; 666  :     {
; 667  :       RB2CubicVerticalLine_SSE((uint8_t *)pDst, (uint8_t *)pSrc, nSrcPitch, nWidthMMX);
; 668  : 
; 669  :       for (int x = nWidthMMX; x < nWidth; x++)
; 670  :       {
; 671  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]
; 672  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 5
; 673  :           + pSrc[x] * 10
; 674  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 10
; 675  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 5
; 676  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 16) / 32;
; 677  :       }
; 678  : 
; 679  :       pDst += nDstPitch / sizeof(pixel_t);
; 680  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;
; 681  :     }
; 682  : #ifndef _M_X64
; 683  :     _mm_empty();
; 684  : #endif
; 685  :   }
; 686  :   else
; 687  :   {
; 688  :     for (; y < y_loop_e; ++y)

	add	ebp, eax
	mov	DWORD PTR tv1928[esp+52], eax
	mov	DWORD PTR _y$1$[esp+48], ebp
	mov	ebp, DWORD PTR tv1943[esp+52]
$LL13@RB2CubicVe:

; 689  :     {
; 690  :       for (int x = 0; x < nWidth; x++)

	test	edi, edi
	jle	$LN15@RB2CubicVe
	lea	eax, DWORD PTR [ebx+ebx*2]
	mov	DWORD PTR tv1926[esp+52], esi
	lea	ebp, DWORD PTR [esi+eax*2]
	mov	edi, esi
	lea	eax, DWORD PTR [ebx*4]
	mov	edx, ecx
	sub	edi, eax
	add	eax, esi
	mov	DWORD PTR tv1931[esp+52], eax
	lea	eax, DWORD PTR [ebx+ebx]
	mov	ebx, esi
	sub	ebx, eax
	add	eax, esi
	sub	DWORD PTR tv1926[esp+52], ecx
	mov	ecx, DWORD PTR _nWidth$[esp+48]
	mov	esi, DWORD PTR tv1931[esp+52]
	mov	DWORD PTR tv1929[esp+52], eax
	mov	DWORD PTR tv1924[esp+52], ecx
$LL16@RB2CubicVe:

; 691  :       {
; 692  :         pDst[x] = (pSrc[x - nSrcPitch / sizeof(pixel_t) * 2]

	movzx	eax, WORD PTR [eax]
	lea	ebx, DWORD PTR [ebx+2]
	mov	ecx, DWORD PTR tv1926[esp+52]
	lea	esi, DWORD PTR [esi+2]
	lea	edi, DWORD PTR [edi+2]
	lea	ebp, DWORD PTR [ebp+2]
	lea	edx, DWORD PTR [edx+2]
	movzx	ecx, WORD PTR [ecx+edx-2]
	add	ecx, eax
	movzx	eax, WORD PTR [esi-2]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [ebx-2]
	add	ecx, eax
	movzx	eax, WORD PTR [ebp-2]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	movzx	eax, WORD PTR [edi-2]
	add	eax, 16					; 00000010H
	add	eax, ecx
	shr	eax, 5
	mov	WORD PTR [edx-2], ax
	mov	eax, DWORD PTR tv1929[esp+52]
	add	eax, 2
	sub	DWORD PTR tv1924[esp+52], 1
	mov	DWORD PTR tv1929[esp+52], eax
	jne	SHORT $LL16@RB2CubicVe
	mov	esi, DWORD PTR _pSrc$1$[esp+52]
	mov	edi, DWORD PTR _nWidth$[esp+48]
	mov	ecx, DWORD PTR _pDst$1$[esp+52]
	mov	eax, DWORD PTR tv1928[esp+52]
	mov	ebx, DWORD PTR _nSrcPitch$[esp+48]
	mov	edx, DWORD PTR tv1941[esp+52]
	mov	ebp, DWORD PTR tv1943[esp+52]
$LN15@RB2CubicVe:

; 693  :           + pSrc[x - nSrcPitch / sizeof(pixel_t)] * 5
; 694  :           + pSrc[x] * 10
; 695  :           + pSrc[x + nSrcPitch / sizeof(pixel_t)] * 10
; 696  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 2] * 5
; 697  :           + pSrc[x + nSrcPitch / sizeof(pixel_t) * 3] + 16) / 32;
; 698  :       }
; 699  : 
; 700  :       pDst += nDstPitch / sizeof(pixel_t);

	add	ecx, ebp

; 701  :       pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	esi, edx
	sub	eax, 1
	mov	DWORD PTR _pDst$1$[esp+52], ecx
	mov	DWORD PTR _pSrc$1$[esp+52], esi
	mov	DWORD PTR tv1928[esp+52], eax
	jne	$LL13@RB2CubicVe
	mov	ebp, DWORD PTR _y$2$[esp+48]
	mov	eax, DWORD PTR _y$1$[esp+48]
$LN12@RB2CubicVe:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ebp, 1
	mov	ecx, ebp
	mov	edx, 1
	cmovl	ecx, edx
; File c:\github\mvtools\sources\interpolation.cpp

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	edx, DWORD PTR _pDst$1$[esp+52]
	sub	ecx, eax
	mov	eax, DWORD PTR _nDstPitch$[esp+48]
	imul	eax, ecx
	lea	ebp, DWORD PTR [edx+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, DWORD PTR _y$2$[esp+48]
; File c:\github\mvtools\sources\interpolation.cpp

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	eax, ebx
	imul	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	edx, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	lea	ecx, DWORD PTR [esi+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmovl	edx, eax
; File c:\github\mvtools\sources\interpolation.cpp

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	DWORD PTR _pSrc$2$[esp+48], ecx

; 707  :   for (; y < y_end; ++y)

	mov	eax, DWORD PTR _y_end$[esp+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	DWORD PTR _y$2$[esp+48], edx
; File c:\github\mvtools\sources\interpolation.cpp

; 707  :   for (; y < y_end; ++y)

	cmp	edx, eax
	jge	SHORT $LN18@RB2CubicVe

; 705  :   RB2_jump(std::max(y_loop_e, 1), y, pDst, pSrc, nDstPitch, nSrcPitch);

	mov	edx, DWORD PTR _nDstPitch$[esp+48]
	lea	esi, DWORD PTR [ebx*4]
	add	edx, edx
	mov	DWORD PTR tv1940[esp+52], esi
	sub	eax, DWORD PTR _y$2$[esp+48]
	mov	DWORD PTR tv1942[esp+48], edx
	mov	DWORD PTR _y_end$1$[esp+48], eax
$LL19@RB2CubicVe:

; 708  :   {
; 709  :     for (int x = 0; x < nWidth; x++)

	test	edi, edi
	jle	SHORT $LN21@RB2CubicVe
	lea	esi, DWORD PTR [ecx+ebx*2]
	mov	eax, ebp
	mov	ebx, ecx
	sub	ebx, ebp
$LL22@RB2CubicVe:

; 710  :     {
; 711  :       pDst[x] = (pSrc[x] + pSrc[x + nSrcPitch / sizeof(pixel_t)] + 1) / 2;

	movzx	ecx, WORD PTR [esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	edx, WORD PTR [eax+ebx]
	lea	eax, DWORD PTR [eax+2]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [eax-2], cx
	sub	edi, 1
	jne	SHORT $LL22@RB2CubicVe
	mov	ecx, DWORD PTR _pSrc$2$[esp+48]
	mov	edi, DWORD PTR _nWidth$[esp+48]
	mov	eax, DWORD PTR _y_end$1$[esp+48]
	mov	ebx, DWORD PTR _nSrcPitch$[esp+48]
	mov	edx, DWORD PTR tv1942[esp+48]
	mov	esi, DWORD PTR tv1940[esp+52]
$LN21@RB2CubicVe:

; 712  :     }
; 713  :     pDst += nDstPitch / sizeof(pixel_t);
; 714  :     pSrc += nSrcPitch / sizeof(pixel_t) * 2;

	add	ecx, esi
	add	ebp, edx
	sub	eax, 1
	mov	DWORD PTR _pSrc$2$[esp+48], ecx
	mov	DWORD PTR _y_end$1$[esp+48], eax
	jne	SHORT $LL19@RB2CubicVe
$LN18@RB2CubicVe:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 715  :   }
; 716  : }

	add	esp, 36					; 00000024H
	ret	0
??$RB2CubicVertical@G@@YAXPAEPBEHHHHHH_N@Z ENDP		; RB2CubicVertical<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\interpolation.cpp
;	COMDAT ??$RB2CubicHorizontalInplace@G@@YAXPAEHHHHH_N@Z
_TEXT	SEGMENT
tv904 = -4						; size = 4
_nWidth$ = 8						; size = 4
_nHeight$dead$ = 12					; size = 4
_pSrcw0$1$ = 16						; size = 4
$T1 = 16						; size = 4
_y_beg$ = 16						; size = 4
$T2 = 20						; size = 4
_y_end$ = 20						; size = 4
_isse2$ = 24						; size = 1
??$RB2CubicHorizontalInplace@G@@YAXPAEHHHHH_N@Z PROC	; RB2CubicHorizontalInplace<unsigned short>, COMDAT
; _pSrc8$ = ecx
; _nSrcPitch$ = edx

; 724  : {

	push	ecx
	push	ebx

; 725  :   int				nWidthMMX = 1 + ((nWidth - 2) / 4) * 4;
; 726  :   int				y = 0;
; 727  : 
; 728  :   pixel_t *pSrc = reinterpret_cast<pixel_t *>(pSrc8);
; 729  : 
; 730  :   RB2_jump_1(y_beg, y, pSrc, nSrcPitch);

	mov	ebx, DWORD PTR _y_beg$[esp+4]
	push	esi
	push	edi
	mov	edi, edx

; 731  : 
; 732  :   for (; y < y_end; ++y)

	mov	edx, DWORD PTR _y_end$[esp+12]
	shr	edi, 1
	mov	eax, edi
	imul	eax, ebx
	lea	esi, DWORD PTR [ecx+eax*2]
	cmp	ebx, edx
	jge	$LN3@RB2CubicHo

; 755  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	push	ebp
	mov	ebp, DWORD PTR _nWidth$[esp+16]
	lea	eax, DWORD PTR [edi+edi]
	dec	ebp
	mov	DWORD PTR $T2[esp+16], 1
	sub	edx, ebx
	mov	DWORD PTR tv904[esp+20], eax
	mov	DWORD PTR _y_end$[esp+16], edx
	npad	5
$LL4@RB2CubicHo:

; 736  :     if (sizeof(pixel_t) == 1 && isse2)
; 737  :     {
; 738  :       RB2CubicHorizontalInplaceLine_SSE((uint8_t *)pSrc, nWidthMMX);
; 739  :       for (int x = nWidthMMX; x < nWidth - 1; x++)
; 740  :       {
; 741  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 5 + pSrc[x * 2] * 10
; 742  :           + pSrc[x * 2 + 1] * 10 + pSrc[x * 2 + 2] * 5 + pSrc[x * 2 + 3] + 16) / 32;
; 743  :       }
; 744  :     }
; 745  :     else
; 746  :     {
; 747  :       for (int x = 1; x < nWidth - 1; x++)

	movzx	eax, WORD PTR [esi+2]
	mov	edi, 1
	movzx	ecx, WORD PTR [esi]
	inc	eax
	add	eax, ecx
	shr	eax, 1
	mov	DWORD PTR _pSrcw0$1$[esp+16], eax
	cmp	ebp, edi
	jle	SHORT $LN9@RB2CubicHo

; 733  :   {
; 734  :     int x = 0;
; 735  :     int pSrcw0 = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2; // store temporary

	lea	edx, DWORD PTR [esi+2]
	npad	4
$LL10@RB2CubicHo:

; 748  :       {
; 749  :         pSrc[x] = (pSrc[x * 2 - 2] + pSrc[x * 2 - 1] * 5 + pSrc[x * 2] * 10

	movzx	eax, WORD PTR [edx+2]
	lea	edx, DWORD PTR [edx+4]
	movzx	ecx, WORD PTR [edx]
	add	ecx, eax
	movzx	eax, WORD PTR [edx+2]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edx-4]
	add	ecx, eax
	movzx	eax, WORD PTR [edx+4]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	add	ecx, eax
	movzx	eax, WORD PTR [edx-6]
	add	eax, 16					; 00000010H
	add	eax, ecx
	shr	eax, 5
	mov	WORD PTR [esi+edi*2], ax
	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL10@RB2CubicHo
	mov	eax, DWORD PTR _pSrcw0$1$[esp+16]
	mov	edx, DWORD PTR _y_end$[esp+16]
$LN9@RB2CubicHo:

; 755  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	mov	edi, DWORD PTR _nWidth$[esp+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ebp, 1
; File c:\github\mvtools\sources\interpolation.cpp

; 753  :     pSrc[0] = pSrcw0;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, 1
	mov	eax, ebp
; File c:\github\mvtools\sources\interpolation.cpp

; 755  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	mov	DWORD PTR $T1[esp+16], ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, ecx
; File c:\github\mvtools\sources\interpolation.cpp

; 755  :     for (int x = std::max(nWidth - 1, 1); x < nWidth; x++)

	cmp	eax, edi
	jge	SHORT $LN12@RB2CubicHo
	npad	5
$LL13@RB2CubicHo:

; 756  :     {
; 757  :       pSrc[x] = (pSrc[x * 2] + pSrc[x * 2 + 1] + 1) / 2;

	movzx	ecx, WORD PTR [esi+eax*4+2]
	movzx	edx, WORD PTR [esi+eax*4]
	inc	ecx
	add	ecx, edx
	shr	ecx, 1
	mov	WORD PTR [esi+eax*2], cx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL13@RB2CubicHo
	mov	edx, DWORD PTR _y_end$[esp+16]
$LN12@RB2CubicHo:

; 758  :     }
; 759  : 
; 760  :     pSrc += nSrcPitch / sizeof(pixel_t);

	add	esi, DWORD PTR tv904[esp+20]
	sub	edx, 1
	mov	DWORD PTR _y_end$[esp+16], edx
	jne	$LL4@RB2CubicHo
	pop	ebp
$LN3@RB2CubicHo:

; 761  :   }
; 762  : 
; 763  :   if (isse2)

	cmp	BYTE PTR _isse2$[esp+12], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN16@RB2CubicHo

; 764  :   {
; 765  : #ifndef _M_X64
; 766  :     _mm_empty();

	emms
$LN16@RB2CubicHo:

; 767  : #endif
; 768  :   }
; 769  : }

	pop	ecx
	ret	0
??$RB2CubicHorizontalInplace@G@@YAXPAEHHHHH_N@Z ENDP	; RB2CubicHorizontalInplace<unsigned short>
_TEXT	ENDS
END
