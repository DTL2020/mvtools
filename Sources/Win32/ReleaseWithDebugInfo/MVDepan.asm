; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvdepan.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02BKFDOEMK@wt?$AA@			; `string'
PUBLIC	??_C@_0CF@IBLHHJBC@MDePan?3?5Log?5file?5can?5not?5be?5crea@ ; `string'
PUBLIC	??_C@_0CJ@FNNFAIFJ@MDePan?3?5motion?5vectors?5delta?5mus@ ; `string'
PUBLIC	??_C@_07MOAMEKHM@depan06?$AA@			; `string'
PUBLIC	??_C@_0BP@MMGMAAL@?5?$CF5dA?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@LPFCONMI@?5?$CF5dB?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@OPADOGEG@?5?$CF6d?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@ ; `string'
PUBLIC	??_C@_0N@HIMCJIOC@MVDepan?5data?$AA@		; `string'
PUBLIC	??_C@_0BM@NJFLLIJH@fn?$DN?$CF5d?5iter?$DN?$CF3d?5error?$DN?$CF7?43f?$AA@ ; `string'
PUBLIC	??_C@_0CA@CANPJNCH@?5?5?5?5?5dx?5?5?5?5?5?5dy?5?5?5?5?5rot?5?5?5?5zoom?$AA@ ; `string'
PUBLIC	??_C@_0BI@PGPKJDHB@?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?$AA@ ; `string'
PUBLIC	??_R0?AVMVDepan@@@8				; MVDepan `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@MVDepan@@8			; MVDepan::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7MVDepan@@6B@				; MVDepan::`vftable'
PUBLIC	??_R2MVDepan@@8					; MVDepan::`RTTI Base Class Array'
PUBLIC	??_R3MVDepan@@8					; MVDepan::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4MVDepan@@6B@				; MVDepan::`RTTI Complete Object Locator'
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	__imp__rand:PROC
;	COMDAT ??_R4MVDepan@@6B@
rdata$r	SEGMENT
??_R4MVDepan@@6B@ DD 00H				; MVDepan::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVDepan@@@8
	DD	FLAT:??_R3MVDepan@@8
rdata$r	ENDS
;	COMDAT ??_R3MVDepan@@8
rdata$r	SEGMENT
??_R3MVDepan@@8 DD 00H					; MVDepan::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVDepan@@8
rdata$r	ENDS
;	COMDAT ??_R2MVDepan@@8
rdata$r	SEGMENT
??_R2MVDepan@@8 DD FLAT:??_R1A@?0A@EA@MVDepan@@8	; MVDepan::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_7MVDepan@@6B@
CONST	SEGMENT
??_7MVDepan@@6B@ DD FLAT:??_R4MVDepan@@6B@		; MVDepan::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@GenericVideoFilter@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVDepan@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@MVDepan@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVDepan@@8 DD FLAT:??_R0?AVMVDepan@@@8	; MVDepan::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVDepan@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVDepan@@@8
data$r	SEGMENT
??_R0?AVMVDepan@@@8 DD FLAT:??_7type_info@@6B@		; MVDepan `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVDepan@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BI@PGPKJDHB@?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?$AA@
CONST	SEGMENT
??_C@_0BI@PGPKJDHB@?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?$AA@ DB '%7'
	DB	'.2f %7.2f %7.3f %7.5f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CANPJNCH@?5?5?5?5?5dx?5?5?5?5?5?5dy?5?5?5?5?5rot?5?5?5?5zoom?$AA@
CONST	SEGMENT
??_C@_0CA@CANPJNCH@?5?5?5?5?5dx?5?5?5?5?5?5dy?5?5?5?5?5rot?5?5?5?5zoom?$AA@ DB ' '
	DB	'    dx      dy     rot    zoom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NJFLLIJH@fn?$DN?$CF5d?5iter?$DN?$CF3d?5error?$DN?$CF7?43f?$AA@
CONST	SEGMENT
??_C@_0BM@NJFLLIJH@fn?$DN?$CF5d?5iter?$DN?$CF3d?5error?$DN?$CF7?43f?$AA@ DB 'f'
	DB	'n=%5d iter=%3d error=%7.3f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HIMCJIOC@MVDepan?5data?$AA@
CONST	SEGMENT
??_C@_0N@HIMCJIOC@MVDepan?5data?$AA@ DB 'MVDepan data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OPADOGEG@?5?$CF6d?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@
CONST	SEGMENT
??_C@_0BO@OPADOGEG@?5?$CF6d?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@ DB ' '
	DB	'%6d %7.2f %7.2f %7.3f %7.5f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LPFCONMI@?5?$CF5dB?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@
CONST	SEGMENT
??_C@_0BP@LPFCONMI@?5?$CF5dB?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@ DB ' '
	DB	'%5dB %7.2f %7.2f %7.3f %7.5f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MMGMAAL@?5?$CF5dA?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@
CONST	SEGMENT
??_C@_0BP@MMGMAAL@?5?$CF5dA?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@ DB ' '
	DB	'%5dA %7.2f %7.2f %7.3f %7.5f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MOAMEKHM@depan06?$AA@
CONST	SEGMENT
??_C@_07MOAMEKHM@depan06?$AA@ DB 'depan06', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FNNFAIFJ@MDePan?3?5motion?5vectors?5delta?5mus@
CONST	SEGMENT
??_C@_0CJ@FNNFAIFJ@MDePan?3?5motion?5vectors?5delta?5mus@ DB 'MDePan: mot'
	DB	'ion vectors delta must be =1!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IBLHHJBC@MDePan?3?5Log?5file?5can?5not?5be?5crea@
CONST	SEGMENT
??_C@_0CF@IBLHHJBC@MDePan?3?5Log?5file?5can?5not?5be?5crea@ DB 'MDePan: L'
	DB	'og file can not be created!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BKFDOEMK@wt?$AA@
CONST	SEGMENT
??_C@_02BKFDOEMK@wt?$AA@ DB 'wt', 00H			; `string'
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ		; sprintf_s<128>
PUBLIC	?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVDepan::GetFrame
PUBLIC	?RejectBadBlocks@MVDepan@@AAEXUtransformstruct@@QAM1QAH221HHMMHM1H@Z ; MVDepan::RejectBadBlocks
PUBLIC	?TrasformUpdate@MVDepan@@AAEXPAUtransformstruct@@QAM1QAH221HHM_N3PAMM@Z ; MVDepan::TrasformUpdate
PUBLIC	?inversetransform@MVDepan@@AAEXUtransformstruct@@PAU2@@Z ; MVDepan::inversetransform
PUBLIC	?transform2motion@MVDepan@@AAEXUtransformstruct@@HMMMPAM111@Z ; MVDepan::transform2motion
PUBLIC	?write_deshakerlog1@MVDepan@@AAEXPAU_iobuf@@HHHMMMM@Z ; MVDepan::write_deshakerlog1
PUBLIC	?write_depan_data@MVDepan@@AAEXPAEHHQAM111@Z	; MVDepan::write_depan_data
PUBLIC	??1MVDepan@@UAE@XZ				; MVDepan::~MVDepan
PUBLIC	??_GMVDepan@@UAEPAXI@Z				; MVDepan::`scalar deleting destructor'
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	_sqrtf
PUBLIC	_sinf
PUBLIC	_fabsf
PUBLIC	_cosf
PUBLIC	_atanf
PUBLIC	_vsprintf_s
PUBLIC	__vsprintf_s_l
PUBLIC	_fprintf
PUBLIC	__vfprintf_l
PUBLIC	?GetHeight@VideoFrame@@QBEHH@Z			; VideoFrame::GetHeight
PUBLIC	?IsTFF@VideoInfo@@QBE_NXZ			; VideoInfo::IsTFF
PUBLIC	??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z ; MVDepan::MVDepan
EXTRN	??_EMVDepan@@UAEPAXI@Z:PROC			; MVDepan::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVDepan@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1MVDepan@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVDepan@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVDepan@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVDepan@@UAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVDepan@@UAE@XZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
_mvs$ = 12						; size = 4
__mask$ = 16						; size = 4
__zoom$ = 20						; size = 1
__rot$ = 24						; size = 1
__pixaspect$ = 28					; size = 4
__error$ = 32						; size = 4
__info$ = 36						; size = 1
__logfilename$ = 40					; size = 4
__wrong$ = 44						; size = 4
__zerow$ = 48						; size = 4
__range$ = 52						; size = 4
_nSCD1$ = 56						; size = 4
_nSCD2$ = 60						; size = 4
_isse$dead$ = 64					; size = 1
__planar$ = 68						; size = 1
_env$ = 72						; size = 4
??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z PROC ; MVDepan::MVDepan, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvdepan.cpp

; 34   :   GenericVideoFilter(_child),

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN19@MVDepan
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN19@MVDepan
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN19@MVDepan:
; File c:\github\mvtools\sources\mvdepan.cpp

; 34   :   GenericVideoFilter(_child),

	mov	ecx, esi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 35   :   mvclip(mvs, nSCD1, nSCD2, env, 1, 0),
; 36   :   MVFilter(mvs, "MDepan", env, 1, 0),

	mov	edi, DWORD PTR _env$[ebp]
	lea	eax, DWORD PTR _mvs$[ebp]
	push	0
	push	1
	push	edi
	push	OFFSET ??_C@_06FLAAMDNN@MDepan?$AA@
	push	eax
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter
	push	0
	push	1
	push	edi
	push	DWORD PTR _nSCD2$[ebp]
	lea	eax, DWORD PTR _mvs$[ebp]

; 42   : {

	mov	DWORD PTR [esi], OFFSET ??_7MVDepan@@6B@
	push	DWORD PTR _nSCD1$[ebp]
	lea	ecx, DWORD PTR [esi+152]
	push	eax
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip

; 41   :   ifZoom(_zoom), ifRot(_rot), pixaspect(_pixaspect), error(_error), info(_info), logfilename(_logfilename)

	mov	al, BYTE PTR __zoom$[ebp]

; 37   :   mask(_mask),

	lea	ecx, DWORD PTR [esi+424]
	movss	xmm0, DWORD PTR __pixaspect$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	BYTE PTR [esi+392], al
	mov	al, BYTE PTR __rot$[ebp]
	mov	BYTE PTR [esi+393], al
	mov	al, BYTE PTR __info$[ebp]
	movss	DWORD PTR [esi+396], xmm0
	movss	xmm0, DWORD PTR __error$[ebp]
	mov	BYTE PTR [esi+404], al
	mov	eax, DWORD PTR __logfilename$[ebp]
	movss	DWORD PTR [esi+400], xmm0
	movss	xmm0, DWORD PTR __wrong$[ebp]
	mov	DWORD PTR [esi+408], eax
	mov	eax, DWORD PTR __range$[ebp]
	movss	DWORD PTR [esi+412], xmm0
	movss	xmm0, DWORD PTR __zerow$[ebp]
	mov	DWORD PTR [esi+420], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvdepan.cpp

; 40   :   zeroWeight(_zerow), range(_range),

	movss	DWORD PTR [esi+416], xmm0
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN23@MVDepan
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN23@MVDepan
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __mask$[ebp]
	push	edx
	call	eax
$LN23@MVDepan:
; File c:\github\mvtools\sources\mvdepan.cpp

; 38   :   planar(_planar),

	mov	al, BYTE PTR __planar$[ebp]

; 43   :   blockDx = new float[nBlkX * nBlkY]; // dx vector

	xor	ecx, ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, 4
	mov	BYTE PTR [esi+428], al
	mov	eax, DWORD PTR [esi+64]
	imul	eax, DWORD PTR [esi+68]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+436], eax

; 44   :   blockDy = new float[nBlkX * nBlkY]; // dy

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+64]
	mov	edx, 4
	imul	eax, DWORD PTR [esi+68]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+440], eax

; 45   :   blockSAD = new sad_t[nBlkX * nBlkY];

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+64]
	mov	edx, 4
	imul	eax, DWORD PTR [esi+68]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+444], eax

; 46   :   blockX = new int[nBlkX * nBlkY]; // block x position

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+64]
	mov	edx, 4
	imul	eax, DWORD PTR [esi+68]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+448], eax

; 47   :   blockY = new int[nBlkX * nBlkY];

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+64]
	mov	edx, 4
	imul	eax, DWORD PTR [esi+68]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+452], eax

; 48   :   blockWeight = new float[nBlkX * nBlkY];

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+64]
	mov	edx, 4
	imul	eax, DWORD PTR [esi+68]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+456], eax

; 49   :   blockWeightMask = new float[nBlkX * nBlkY];

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+64]
	mov	ebx, 4
	imul	eax, DWORD PTR [esi+68]
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 28					; 0000001cH

; 50   : 
; 51   :   if (lstrlen(logfilename) > 0) { // v.1.2.3

	push	DWORD PTR [esi+408]
	mov	DWORD PTR [esi+460], eax
	call	DWORD PTR __imp__lstrlenA@4
	test	eax, eax
	jle	SHORT $LN5@MVDepan

; 52   :     logfile = fopen(logfilename, "wt");

	push	OFFSET ??_C@_02BKFDOEMK@wt?$AA@
	push	DWORD PTR [esi+408]
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	DWORD PTR [esi+432], eax

; 53   :     if (logfile == NULL)	env->ThrowError("MDePan: Log file can not be created!");

	test	eax, eax
	jne	SHORT $LN6@MVDepan
	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CF@IBLHHJBC@MDePan?3?5Log?5file?5can?5not?5be?5crea@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8

; 54   :   }
; 55   :   else

	jmp	SHORT $LN6@MVDepan
$LN5@MVDepan:

; 56   :     logfile = NULL;

	mov	DWORD PTR [esi+432], 0
$LN6@MVDepan:

; 57   : 
; 58   :   if (mvclip.nDeltaFrame != 1)

	cmp	DWORD PTR [esi+292], 1
	je	SHORT $LN8@MVDepan

; 59   :     env->ThrowError("MDePan: motion vectors delta must be =1!");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CJ@FNNFAIFJ@MDePan?3?5motion?5vectors?5delta?5mus@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN8@MVDepan:

; 60   : 
; 61   :   motionx = new float[vi.num_frames + 1];

	mov	eax, DWORD PTR [esi+32]
	xor	ecx, ecx
	inc	eax
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+464], eax

; 62   :   motiony = new float[vi.num_frames + 1];

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+32]
	inc	eax
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+468], eax

; 63   :   motionzoom = new float[vi.num_frames + 1];

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+32]
	inc	eax
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+472], eax

; 64   :   motionrot = new float[vi.num_frames + 1];

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+32]
	inc	eax
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 65   : 
; 66   :   for (int i = 0; i <= vi.num_frames; i++)

	xor	ecx, ecx
	mov	DWORD PTR [esi+476], eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+32], ecx
	jl	SHORT $LN3@MVDepan
$LL4@MVDepan:

; 67   :     motionx[i] = MOTIONUNKNOWN;

	mov	eax, DWORD PTR [esi+464]
	mov	DWORD PTR [eax+ecx*4], 1176255488	; 461c3c00H
	inc	ecx
	cmp	ecx, DWORD PTR [esi+32]
	jle	SHORT $LL4@MVDepan
$LN3@MVDepan:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN27@MVDepan
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN27@MVDepan
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN27@MVDepan:
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	test	eax, eax
	je	SHORT $LN32@MVDepan
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN32@MVDepan
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _mvs$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN32@MVDepan:
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	test	eax, eax
	je	SHORT $LN44@MVDepan
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN44@MVDepan
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mask$[ebp]
	call	eax
$LN44@MVDepan:
; File c:\github\mvtools\sources\mvdepan.cpp

; 68   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	68					; 00000044H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR __mask$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _mvs$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 424				; 000001a8H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVDepan@@QAE@VPClip@@00_N1MM1PBDMMHHH11PAVIScriptEnvironment@@@Z ENDP ; MVDepan::MVDepan
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?IsTFF@VideoInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsTFF@VideoInfo@@QBE_NXZ PROC				; VideoInfo::IsTFF, COMDAT
; _this$ = ecx

; 640  :   bool IsTFF() const AVS_BakedCode(return AVS_LinkCall(IsTFF)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@IsTFF
	cmp	DWORD PTR [eax], 76			; 0000004cH
	jbe	SHORT $LN3@IsTFF
	mov	eax, DWORD PTR [eax+76]
	call	eax
	movzx	eax, al
	ret	0
$LN3@IsTFF:
	xor	al, al
	ret	0
?IsTFF@VideoInfo@@QBE_NXZ ENDP				; VideoInfo::IsTFF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?GetHeight@VideoFrame@@QBEHH@Z
_TEXT	SEGMENT
_plane$ = 8						; size = 4
?GetHeight@VideoFrame@@QBEHH@Z PROC			; VideoFrame::GetHeight, COMDAT
; _this$ = ecx

; 799  :   int GetHeight(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetHeight)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@GetHeight
	cmp	DWORD PTR [eax], 200			; 000000c8H
	jbe	SHORT $LN3@GetHeight
	mov	eax, DWORD PTR [eax+200]
	jmp	eax
$LN3@GetHeight:
	xor	eax, eax
	ret	4
?GetHeight@VideoFrame@@QBEHH@Z ENDP			; VideoFrame::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vfprintf_l PROC					; COMDAT
; __Stream$ = ecx
; __Format$ = edx

; 638  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 640  : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 831  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 832  :     int _Result;
; 833  :     va_list _ArgList;
; 834  :     __crt_va_start(_ArgList, _Format);
; 835  :     _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 836  :     __crt_va_end(_ArgList);
; 837  :     return _Result;
; 838  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$dead$ = 12					; size = 4
__ArgList$ = 16						; size = 4
__vsprintf_s_l PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$ = edx

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[esp-4]
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1499 : }

	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_s
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__ArgList$ = 12						; size = 4
_vsprintf_s PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$ = edx

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[esp-4]
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1516 :         return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1517 :     }

	ret	0
_vsprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
_atanf	PROC						; COMDAT
; __X$ = xmm0s

; 625  :         return (float)atan(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_atan_precise
	cvtsd2ss xmm0, xmm0

; 626  :     }

	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
_cosf	PROC						; COMDAT
; __X$ = xmm0s

; 635  :         return (float)cos(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0

; 636  :     }

	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
_fabsf	PROC						; COMDAT
; __X$ = xmm0s

; 658  :         return (float)fabs(_X);

	cvtss2sd xmm0, xmm0
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtsd2ss xmm0, xmm0

; 659  :     }

	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
_sinf	PROC						; COMDAT
; __X$ = xmm0s

; 736  :         return (float)sin(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0

; 737  :     }

	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
_sqrtf	PROC						; COMDAT
; __X$ = xmm0s

; 745  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 746  :         return (float)sqrt(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
	cvtsd2ss xmm0, xmm0

; 747  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
?atan@@YAMM@Z PROC					; atan, COMDAT
; __Xx$ = xmm0s
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 625  :         return (float)atan(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_atan_precise
	cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 58   : 	}

	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
?cos@@YAMM@Z PROC					; cos, COMDAT
; __Xx$ = xmm0s
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 89   : 	}

	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
?fabs@@YAMM@Z PROC					; fabs, COMDAT
; __Xx$ = xmm0s
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	cvtss2sd xmm0, xmm0
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 124  : 	}

	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
?sin@@YAMM@Z PROC					; sin, COMDAT
; __Xx$ = xmm0s
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 296  : 	}

	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT
; __Xx$ = xmm0s

; 304  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
	cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 306  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVDepan@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVDepan@@UAEPAXI@Z PROC				; MVDepan::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVDepan@@UAE@XZ			; MVDepan::~MVDepan
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	608					; 00000260H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVDepan@@UAEPAXI@Z ENDP				; MVDepan::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ??1MVDepan@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVDepan@@UAE@XZ PROC					; MVDepan::~MVDepan, COMDAT
; _this$ = ecx

; 72   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVDepan@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 73   :   delete[] blockDx;

	push	DWORD PTR [esi+436]
	mov	DWORD PTR [esi], OFFSET ??_7MVDepan@@6B@
	call	??_V@YAXPAX@Z				; operator delete[]

; 74   :   delete[] blockDy;

	push	DWORD PTR [esi+440]
	call	??_V@YAXPAX@Z				; operator delete[]

; 75   :   delete[] blockSAD;

	push	DWORD PTR [esi+444]
	call	??_V@YAXPAX@Z				; operator delete[]

; 76   :   delete[] blockX;

	push	DWORD PTR [esi+448]
	call	??_V@YAXPAX@Z				; operator delete[]

; 77   :   delete[] blockY;

	push	DWORD PTR [esi+452]
	call	??_V@YAXPAX@Z				; operator delete[]

; 78   :   delete[] blockWeight;

	push	DWORD PTR [esi+456]
	call	??_V@YAXPAX@Z				; operator delete[]

; 79   :   delete[] blockWeightMask;

	push	DWORD PTR [esi+460]
	call	??_V@YAXPAX@Z				; operator delete[]

; 80   :   if (logfile != NULL)

	mov	eax, DWORD PTR [esi+432]
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN2@MVDepan

; 81   :     fclose(logfile);

	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN2@MVDepan:

; 82   : 
; 83   :   delete[] motionx;

	push	DWORD PTR [esi+464]
	call	??_V@YAXPAX@Z				; operator delete[]

; 84   :   delete[] motiony;

	push	DWORD PTR [esi+468]
	call	??_V@YAXPAX@Z				; operator delete[]

; 85   :   delete[] motionzoom;

	push	DWORD PTR [esi+472]
	call	??_V@YAXPAX@Z				; operator delete[]

; 86   :   delete[] motionrot;

	push	DWORD PTR [esi+476]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN6@MVDepan
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN6@MVDepan
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvdepan.cpp

; 87   : }

	lea	ecx, DWORD PTR [esi+424]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
$LN6@MVDepan:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN17@MVDepan
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN17@MVDepan
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN17@MVDepan:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN34@MVDepan
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN34@MVDepan
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN34@MVDepan:
; File c:\github\mvtools\sources\mvdepan.cpp

; 87   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvdepan.cpp

; 87   : }

	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVDepan@@UAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVDepan@@UAE@XZ$3:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVDepan@@UAE@XZ$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVDepan@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVDepan@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVDepan@@UAE@XZ ENDP					; MVDepan::~MVDepan
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ?write_depan_data@MVDepan@@AAEXPAEHHQAM111@Z
_TEXT	SEGMENT
tv352 = -48						; size = 4
_header$ = -48						; size = 16
_signaturegood$ = -48					; size = 8
_framedata$ = -32					; size = 20
_dstp$ = 8						; size = 4
_framefirst$ = 12					; size = 4
_framelast$ = 16					; size = 4
_motionx$ = 20						; size = 4
_motiony$ = 24						; size = 4
_motionzoom$ = 28					; size = 4
_motionrot$ = 32					; size = 4
?write_depan_data@MVDepan@@AAEXPAEHHQAM111@Z PROC	; MVDepan::write_depan_data, COMDAT
; _this$dead$ = ecx

; 146  : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H
	sub	esp, 56					; 00000038H

; 147  :   char signaturegood[8] = DEPANSIGNATURE;

	mov	eax, DWORD PTR ??_C@_07MOAMEKHM@depan06?$AA@

; 148  :   depanheader header;
; 149  :   depandata framedata;
; 150  : //	int frame;
; 151  : 
; 152  :   for (int i = 0; i < sizeof(signaturegood); i++) {
; 153  :     header.signature[i] = signaturegood[i];
; 154  :   }
; 155  : 
; 156  :   header.nframes = framelast - framefirst + 1; // number of frames to write motion info about

	mov	ecx, DWORD PTR _framelast$[ebp]
	mov	edx, DWORD PTR _framefirst$[ebp]
	mov	DWORD PTR _signaturegood$[esp+56], eax
	mov	eax, DWORD PTR ??_C@_07MOAMEKHM@depan06?$AA@+4
	mov	DWORD PTR _signaturegood$[esp+60], eax
	mov	eax, ecx
	movq	xmm0, QWORD PTR _signaturegood$[esp+56]
	sub	eax, edx
	inc	eax
	movq	QWORD PTR _header$[esp+56], xmm0
	push	esi

; 157  : 
; 158  :   int sizeheader = sizeof(header);
; 159  :   int sizedata = sizeof(framedata);
; 160  : 
; 161  :   // write date to first line of frame
; 162  :   memcpy(dstp, &header, sizeheader);

	mov	esi, DWORD PTR _dstp$[ebp]
	mov	DWORD PTR _header$[esp+72], eax

; 163  :   dstp += sizeheader;
; 164  : 
; 165  :   for (int frame = framefirst; frame < framelast + 1; frame++) {

	lea	eax, DWORD PTR [ecx+1]
	movups	xmm0, XMMWORD PTR _header$[esp+60]
	push	edi
	mov	DWORD PTR tv352[esp+64], eax
	movups	XMMWORD PTR [esi], xmm0
	add	esi, 16					; 00000010H
	cmp	edx, eax
	jge	SHORT $LN6@write_depa
	mov	eax, DWORD PTR _motiony$[ebp]
	mov	edi, DWORD PTR _motionx$[ebp]
	sub	DWORD PTR _motionzoom$[ebp], eax
	sub	edi, eax
	sub	DWORD PTR _motionrot$[ebp], eax
	lea	ecx, DWORD PTR [eax+edx*4]
$LL7@write_depa:

; 166  :     framedata.frame = frame; // some frame number
; 167  :     framedata.dx = motionx[frame]; // motion x for frame

	movss	xmm0, DWORD PTR [edi+ecx]

; 168  :     framedata.dy = motiony[frame]; // motion y for frame
; 169  :     framedata.zoom = motionzoom[frame]; // zoom for frame
; 170  :     framedata.rot = motionrot[frame]; // rotation for frame
; 171  :     memcpy(dstp, &framedata, sizedata);
; 172  :     dstp += sizedata;

	lea	esi, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _motionzoom$[ebp]
	lea	ecx, DWORD PTR [ecx+4]
	movss	DWORD PTR _framedata$[esp+68], xmm0
	movss	xmm0, DWORD PTR [ecx-4]
	movss	DWORD PTR _framedata$[esp+72], xmm0
	movss	xmm0, DWORD PTR [eax+ecx-4]
	mov	eax, DWORD PTR _motionrot$[ebp]
	movss	DWORD PTR _framedata$[esp+76], xmm0
	mov	DWORD PTR _framedata$[esp+64], edx
	inc	edx
	movss	xmm0, DWORD PTR [eax+ecx-4]
	movss	DWORD PTR _framedata$[esp+80], xmm0
	movups	xmm0, XMMWORD PTR _framedata$[esp+64]
	mov	eax, DWORD PTR _framedata$[esp+80]
	movups	XMMWORD PTR [esi-20], xmm0
	mov	DWORD PTR [esi-4], eax
	cmp	edx, DWORD PTR tv352[esp+64]
	jl	SHORT $LL7@write_depa
$LN6@write_depa:

; 173  :   }
; 174  : 
; 175  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?write_depan_data@MVDepan@@AAEXPAEHHQAM111@Z ENDP	; MVDepan::write_depan_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ?write_deshakerlog1@MVDepan@@AAEXPAU_iobuf@@HHHMMMM@Z
_TEXT	SEGMENT
_logfile$ = 8						; size = 4
_IsFieldBased$ = 12					; size = 4
_IsTFF$dead$ = 16					; size = 4
_ndest$ = 20						; size = 4
_motionx$ = 24						; size = 4
_motiony$ = 28						; size = 4
_motionzoom$ = 32					; size = 4
_rotation$ = 36						; size = 4
?write_deshakerlog1@MVDepan@@AAEXPAU_iobuf@@HHHMMMM@Z PROC ; MVDepan::write_deshakerlog1, COMDAT
; _this$dead$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	movss	xmm0, DWORD PTR _motionzoom$[ebp]

; 190  :       fprintf(logfile, " %5dA %7.2f %7.2f %7.3f %7.5f\n", ndest / 2, motionx, motiony, rotation, motionzoom);

	sub	esp, 32					; 00000020H
	cmp	DWORD PTR _IsFieldBased$[ebp], 0
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR _rotation$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _motiony$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _motionx$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	je	SHORT $LN2@write_desh

; 183  : 
; 184  :   //	float rotation = 0.0; // no rotation estimation in current version
; 185  : 
; 186  : 
; 187  :       // write frame number, dx, dy, rotation and zoom in Deshaker log format
; 188  :   if (IsFieldBased) { // fields from interlaced clip, A or B ( A is time first in Deshaker log )
; 189  :     if ((ndest % 2 == 0)) { // even TFF or BFF fields

	mov	eax, DWORD PTR _ndest$[ebp]
	test	al, 1

; 190  :       fprintf(logfile, " %5dA %7.2f %7.2f %7.3f %7.5f\n", ndest / 2, motionx, motiony, rotation, motionzoom);

	cdq
	jne	SHORT $LN4@write_desh
	sub	eax, edx
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_0BP@MMGMAAL@?5?$CF5dA?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@

; 194  :     }
; 195  :   }
; 196  :   else { // progressive
; 197  :     fprintf(logfile, " %6d %7.2f %7.2f %7.3f %7.5f\n", ndest, motionx, motiony, rotation, motionzoom);

	push	DWORD PTR _logfile$[ebp]
	call	_fprintf
	add	esp, 44					; 0000002cH

; 198  :   }
; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN4@write_desh:

; 191  :     }
; 192  :     else { // odd TFF or BFF fields
; 193  :       fprintf(logfile, " %5dB %7.2f %7.2f %7.3f %7.5f\n", ndest / 2, motionx, motiony, rotation, motionzoom);

	sub	eax, edx
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_0BP@LPFCONMI@?5?$CF5dB?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@

; 194  :     }
; 195  :   }
; 196  :   else { // progressive
; 197  :     fprintf(logfile, " %6d %7.2f %7.2f %7.3f %7.5f\n", ndest, motionx, motiony, rotation, motionzoom);

	push	DWORD PTR _logfile$[ebp]
	call	_fprintf
	add	esp, 44					; 0000002cH

; 198  :   }
; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN2@write_desh:

; 194  :     }
; 195  :   }
; 196  :   else { // progressive
; 197  :     fprintf(logfile, " %6d %7.2f %7.2f %7.3f %7.5f\n", ndest, motionx, motiony, rotation, motionzoom);

	push	DWORD PTR _ndest$[ebp]
	push	OFFSET ??_C@_0BO@OPADOGEG@?5?$CF6d?5?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?6?$AA@
	push	DWORD PTR _logfile$[ebp]
	call	_fprintf
	add	esp, 44					; 0000002cH

; 198  :   }
; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?write_deshakerlog1@MVDepan@@AAEXPAU_iobuf@@HHHMMMM@Z ENDP ; MVDepan::write_deshakerlog1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ?transform2motion@MVDepan@@AAEXUtransformstruct@@HMMMPAM111@Z
_TEXT	SEGMENT
_xcenter$1$ = -4					; size = 4
_tr$ = 8						; size = 24
_rotradian$2$ = 32					; size = 4
_rotradian$1$ = 32					; size = 4
_forward$ = 32						; size = 4
_ycenter$ = 36						; size = 4
_pixaspect$ = 40					; size = 4
_dx$ = 44						; size = 4
_dy$ = 48						; size = 4
_sinus$2$ = 52						; size = 4
_sinus$1$ = 52						; size = 4
_rot$ = 52						; size = 4
_zoom$ = 56						; size = 4
?transform2motion@MVDepan@@AAEXUtransformstruct@@HMMMPAM111@Z PROC ; MVDepan::transform2motion, COMDAT
; _this$dead$ = ecx
; _xcenter$ = xmm3s

; 268  : {

	push	ecx

; 273  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	movss	xmm0, DWORD PTR _tr$[esp+8]
	mulss	xmm0, DWORD PTR _pixaspect$[esp]
	movss	DWORD PTR _xcenter$1$[esp+4], xmm3
	divss	xmm0, DWORD PTR _tr$[esp+4]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 625  :         return (float)atan(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_atan_precise
	xorps	xmm1, xmm1
; File c:\github\mvtools\sources\mvdepan.cpp

; 274  :     *rot = rotradian * 180 / PI;

	mov	eax, DWORD PTR _rot$[esp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 625  :         return (float)atan(_X);

	cvtsd2ss xmm1, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 272  :   if (forward != 0) {         //  get motion for forward

	cmp	DWORD PTR _forward$[esp], 0

; 273  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000

; 274  :     *rot = rotradian * 180 / PI;

	movaps	xmm0, xmm1
	movss	DWORD PTR _rotradian$1$[esp], xmm1
	mulss	xmm0, DWORD PTR __real@43340000
	divss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [eax], xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	cvtss2sd xmm0, xmm1
; File c:\github\mvtools\sources\mvdepan.cpp

; 272  :   if (forward != 0) {         //  get motion for forward

	je	$LN2@transform2
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	call	__libm_sse2_sin_precise

; 635  :         return (float)cos(_X);

	movss	xmm1, DWORD PTR _rotradian$1$[esp]

; 736  :         return (float)sin(_X);

	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinus$1$[esp], xmm0

; 635  :         return (float)cos(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\mvdepan.cpp

; 278  :     *dx = tr.dxc - xcenter - (-xcenter*cosinus + ycenter / pixaspect*sinus)*(*zoom);

	movss	xmm3, DWORD PTR _ycenter$[esp]
	xorps	xmm4, xmm4
	divss	xmm3, DWORD PTR _pixaspect$[esp]
	mov	ecx, DWORD PTR _zoom$[esp]
	mov	eax, DWORD PTR _dx$[esp]
	movss	xmm5, DWORD PTR _sinus$1$[esp]
	movss	xmm6, DWORD PTR _tr$[esp+4]
	movaps	xmm1, xmm3
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	cvtsd2ss xmm4, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 278  :     *dx = tr.dxc - xcenter - (-xcenter*cosinus + ycenter / pixaspect*sinus)*(*zoom);

	mulss	xmm1, xmm5
	movaps	xmm0, xmm4
	movss	xmm2, DWORD PTR _tr$[esp]
	mulss	xmm0, DWORD PTR _xcenter$1$[esp+4]
	divss	xmm6, xmm4
	subss	xmm1, xmm0

; 279  :     *dy = tr.dyc / pixaspect - ycenter / pixaspect - ((-ycenter) / pixaspect*cosinus + (-xcenter)*sinus)*(*zoom);// dyc

	mulss	xmm5, DWORD PTR _xcenter$1$[esp+4]
	movss	xmm0, DWORD PTR _tr$[esp+12]
	divss	xmm0, DWORD PTR _pixaspect$[esp]
	subss	xmm2, DWORD PTR _xcenter$1$[esp+4]
	subss	xmm0, xmm3
	mulss	xmm1, xmm6
	mulss	xmm3, xmm4
	subss	xmm2, xmm1
	movss	DWORD PTR [ecx], xmm6
	addss	xmm3, xmm5
	movss	DWORD PTR [eax], xmm2
	mov	eax, DWORD PTR _dy$[esp]
	mulss	xmm3, DWORD PTR [ecx]
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, xmm3
	movss	DWORD PTR [eax], xmm0

; 307  : 
; 308  : 
; 309  :   }
; 310  : }

	pop	ecx
	ret	52					; 00000034H
$LN2@transform2:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	call	__libm_sse2_sin_precise

; 635  :         return (float)cos(_X);

	movss	xmm1, DWORD PTR _rotradian$2$[esp]

; 736  :         return (float)sin(_X);

	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinus$2$[esp], xmm0

; 635  :         return (float)cos(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\mvdepan.cpp

; 287  :     *zoom = tr.dxx / cosinus;

	movss	xmm6, DWORD PTR _tr$[esp+4]
	xorps	xmm7, xmm7
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	cvtsd2ss xmm7, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 287  :     *zoom = tr.dxx / cosinus;

	mov	ecx, DWORD PTR _zoom$[esp]

; 288  : 
; 289  : 
; 290  :     //		tr.dxc/(*zoom) = xcenter/(*zoom) + (-xcenter + dx)*cosinus - ((-ycenter)/pixaspect + dy)*sinus ;
; 291  :     //		tr.dyc/(*zoom)/pixaspect = ycenter/(*zoom)/pixaspect +  ((-ycenter)/pixaspect +dy)*cosinus + (-xcenter + dx)*sinus ;
; 292  :     // *cosinus:
; 293  :     //		tr.dxc/(*zoom)*cosinus = xcenter/(*zoom)*cosinus + (-xcenter + dx)*cosinus*cosinus - ((-ycenter)/pixaspect + dy)*sinus*cosinus ;
; 294  :     // *sinus:
; 295  :     //		tr.dyc/(*zoom)/pixaspect*sinus = ycenter/(*zoom)/pixaspect*sinus +  ((-ycenter)/pixaspect +dy)*cosinus*sinus + (-xcenter + dx)*sinus*sinus ;
; 296  :     // summa:
; 297  :     //		tr.dxc/(*zoom)*cosinus + tr.dyc/(*zoom)/pixaspect*sinus = xcenter/(*zoom)*cosinus + (-xcenter + dx) + ycenter/(*zoom)/pixaspect*sinus   ;
; 298  :     *dx = tr.dxc / (*zoom)*cosinus + tr.dyc / (*zoom) / pixaspect*sinus - xcenter / (*zoom)*cosinus + xcenter - ycenter / (*zoom) / pixaspect*sinus;

	mov	eax, DWORD PTR _dx$[esp]
	movss	xmm4, DWORD PTR _tr$[esp+12]
	divss	xmm6, xmm7
	movaps	xmm1, xmm4
	movss	xmm2, DWORD PTR _tr$[esp]
	divss	xmm1, xmm6
	movaps	xmm0, xmm2
	movss	xmm5, DWORD PTR _sinus$2$[esp]
	divss	xmm1, DWORD PTR _pixaspect$[esp]
	divss	xmm0, xmm6
	mulss	xmm1, xmm5
	mulss	xmm0, xmm7
	movss	xmm3, DWORD PTR _ycenter$[esp]
	movss	DWORD PTR [ecx], xmm6
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _xcenter$1$[esp+4]
	divss	xmm0, xmm6
	mulss	xmm0, xmm7
	subss	xmm1, xmm0
	movaps	xmm0, xmm3
	divss	xmm0, xmm6
	movss	xmm6, DWORD PTR _pixaspect$[esp]
	divss	xmm0, xmm6
	addss	xmm1, DWORD PTR _xcenter$1$[esp+4]
	mulss	xmm0, xmm5
	subss	xmm1, xmm0

; 299  : 
; 300  :     // *sinus:
; 301  :     //		tr.dxc/(*zoom)*sinus = xcenter/(*zoom)*sinus + (-xcenter + dx)*cosinus*sinus - ((-ycenter)/pixaspect + dy)*sinus*sinus ;
; 302  :     // *cosinus:
; 303  :     //		tr.dyc/(*zoom)/pixaspect*cosinus = ycenter/(*zoom)/pixaspect*cosinus +  ((-ycenter)/pixaspect +dy)*cosinus*cosinus + (-xcenter + dx)*sinus*cosinus ;
; 304  :     // diff:
; 305  :     //		tr.dxc/(*zoom)*sinus - tr.dyc/(*zoom)/pixaspect*cosinus = xcenter/(*zoom)*sinus - (-ycenter/pixaspect + dy) - ycenter/(*zoom)/pixaspect*cosinus   ;
; 306  :     *dy = -tr.dxc / (*zoom)*sinus + tr.dyc / (*zoom) / pixaspect*cosinus + xcenter / (*zoom)*sinus - (-ycenter / pixaspect) - ycenter / (*zoom) / pixaspect*cosinus;

	movss	xmm0, DWORD PTR _xcenter$1$[esp+4]
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [ecx]
	divss	xmm4, xmm1
	mov	eax, DWORD PTR _dy$[esp]
	divss	xmm2, xmm1
	divss	xmm4, xmm6
	divss	xmm0, xmm1
	mulss	xmm4, xmm7
	mulss	xmm2, xmm5
	mulss	xmm0, xmm5
	subss	xmm4, xmm2
	addss	xmm4, xmm0
	movaps	xmm0, xmm3
	divss	xmm3, xmm1
	divss	xmm0, xmm6
	divss	xmm3, xmm6
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm4, xmm0
	mulss	xmm3, xmm7
	subss	xmm4, xmm3
	movss	DWORD PTR [eax], xmm4

; 307  : 
; 308  : 
; 309  :   }
; 310  : }

	pop	ecx
	ret	52					; 00000034H
?transform2motion@MVDepan@@AAEXUtransformstruct@@HMMMPAM111@Z ENDP ; MVDepan::transform2motion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ?inversetransform@MVDepan@@AAEXUtransformstruct@@PAU2@@Z
_TEXT	SEGMENT
_ta$ = 8						; size = 24
_tinv$ = 32						; size = 4
?inversetransform@MVDepan@@AAEXUtransformstruct@@PAU2@@Z PROC ; MVDepan::inversetransform, COMDAT
; _this$dead$ = ecx

; 316  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 317  :   float pixaspect;
; 318  : 
; 319  :   if (ta.dxy != 0) pixaspect = sqrt(-ta.dyx / ta.dxy);

	movss	xmm4, DWORD PTR _ta$[ebp+8]
	ucomiss	xmm4, DWORD PTR __real@00000000
	movss	xmm7, DWORD PTR __xmm@80000000800000008000000080000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@inversetra
	movss	xmm0, DWORD PTR _ta$[ebp+16]
	divss	xmm0, xmm4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 305  : 	return (_CSTD sqrtf(_Xx));

	xorps	xmm0, xmm7
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 306  : 	}

	movss	xmm4, DWORD PTR _ta$[ebp+8]
	xorps	xmm6, xmm6
	movss	xmm7, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	cvtsd2ss xmm6, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 306  : 	}

	jmp	SHORT $LN3@inversetra
$LN2@inversetra:
; File c:\github\mvtools\sources\mvdepan.cpp

; 320  :   else pixaspect = 1.0;

	movss	xmm6, DWORD PTR __real@3f800000
$LN3@inversetra:

; 321  : 
; 322  :   tinv->dxx = ta.dxx / ((ta.dxx)*ta.dxx + ta.dxy*ta.dxy*pixaspect*pixaspect);

	movss	xmm2, DWORD PTR _ta$[ebp+4]
	movaps	xmm1, xmm4
	mulss	xmm1, xmm4
	movaps	xmm0, xmm2
	mov	eax, DWORD PTR _tinv$[ebp]
	mulss	xmm0, xmm2
	movaps	xmm5, xmm2
	mulss	xmm1, xmm6
	mulss	xmm1, xmm6
	addss	xmm1, xmm0
	divss	xmm5, xmm1

; 323  :   tinv->dyy = tinv->dxx;
; 324  :   tinv->dxy = -tinv->dxx * ta.dxy / ta.dxx;

	movaps	xmm3, xmm5
	movss	DWORD PTR [eax+4], xmm5
	mulss	xmm3, xmm4

; 325  :   tinv->dyx = -tinv->dxy * pixaspect*pixaspect;
; 326  :   tinv->dxc = -tinv->dxx * ta.dxc - tinv->dxy * ta.dyc;

	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _ta$[ebp]
	divss	xmm3, xmm2
	movss	DWORD PTR [eax+20], xmm5
	xorps	xmm0, xmm7

; 327  :   tinv->dyc = -tinv->dyx * ta.dxc - tinv->dyy * ta.dyc;

	mulss	xmm5, DWORD PTR _ta$[ebp+12]
	xorps	xmm3, xmm7
	movaps	xmm4, xmm3
	movss	DWORD PTR [eax+8], xmm3
	mulss	xmm3, DWORD PTR _ta$[ebp+12]
	mulss	xmm4, xmm6
	subss	xmm0, xmm3
	mulss	xmm4, xmm6
	movss	DWORD PTR [eax], xmm0
	xorps	xmm4, xmm7
	movss	DWORD PTR [eax+16], xmm4
	mulss	xmm4, DWORD PTR _ta$[ebp]
	xorps	xmm4, xmm7
	subss	xmm4, xmm5
	movss	DWORD PTR [eax+12], xmm4

; 328  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?inversetransform@MVDepan@@AAEXUtransformstruct@@PAU2@@Z ENDP ; MVDepan::inversetransform
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ?TrasformUpdate@MVDepan@@AAEXPAUtransformstruct@@QAM1QAH221HHM_N3PAMM@Z
_TEXT	SEGMENT
_x2$1$ = -64						; size = 4
_y2$1$ = -60						; size = 4
_trderiv$6$ = -56					; size = 4
_trderiv$8$ = -52					; size = 4
_trderiv$2$ = -48					; size = 4
_norm$1$ = -44						; size = 4
_trderiv$12$ = -40					; size = 4
_error2$1$ = -36					; size = 4
_trderiv$4$ = -32					; size = 4
tv1077 = -32						; size = 4
_trderiv$10$ = -28					; size = 4
_trderiv$ = -24						; size = 24
_tr$ = 8						; size = 4
_blockDx$ = 12						; size = 4
_blockDy$ = 16						; size = 4
_blockSAD$dead$ = 20					; size = 4
_blockX$ = 24						; size = 4
_blockY$ = 28						; size = 4
_blockWeight$ = 32					; size = 4
_nBlkX$ = 36						; size = 4
_nBlkY$ = 40						; size = 4
_safety$ = 44						; size = 4
_ifZoom1$ = 48						; size = 1
_ifRot1$ = 52						; size = 1
_error1$ = 56						; size = 4
_pixaspect$ = 60					; size = 4
?TrasformUpdate@MVDepan@@AAEXPAUtransformstruct@@QAM1QAH221HHM_N3PAMM@Z PROC ; MVDepan::TrasformUpdate, COMDAT
; _this$dead$ = ecx

; 332  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 64					; 00000040H

; 333  :   transform trderiv;
; 334  :   int n = nBlkX*nBlkY;

	mov	eax, DWORD PTR _nBlkX$[ebp]
	xorps	xmm0, xmm0
	imul	eax, DWORD PTR _nBlkY$[ebp]
	xorps	xmm6, xmm6
	movups	XMMWORD PTR _trderiv$[esp+64], xmm0
	push	esi

; 335  :   trderiv.dxc = 0;
; 336  :   trderiv.dxx = 0;
; 337  :   trderiv.dxy = 0;
; 338  :   trderiv.dyc = 0;
; 339  :   trderiv.dyx = 0;
; 340  :   trderiv.dyy = 0;
; 341  :   float norm = 0.1f;

	movss	xmm0, DWORD PTR __real@3dcccccd
	movaps	xmm4, xmm6

; 342  :   float x2 = 0.1f;
; 343  :   float y2 = 0.1f;
; 344  :   float error2 = 0.1f;
; 345  :   for (int i = 0; i < n; i++)

	mov	esi, DWORD PTR _tr$[ebp]

; 346  :   {
; 347  :     float bw = blockWeight[i];
; 348  :     float xdif = (tr->dxc + tr->dxx*blockX[i] + tr->dxy*blockY[i] - blockX[i] - blockDx[i]);

	movss	xmm5, DWORD PTR _trderiv$[esp+76]
	movss	xmm1, DWORD PTR _trderiv$[esp+72]
	mov	DWORD PTR _nBlkX$[ebp], eax
	movss	DWORD PTR _trderiv$2$[esp+68], xmm6
	movss	DWORD PTR _norm$1$[esp+68], xmm0
	movss	DWORD PTR _x2$1$[esp+68], xmm0
	movss	DWORD PTR _y2$1$[esp+68], xmm0
	movss	DWORD PTR _error2$1$[esp+68], xmm0
	push	edi
	test	eax, eax
	jle	$LN24@TrasformUp

; 342  :   float x2 = 0.1f;
; 343  :   float y2 = 0.1f;
; 344  :   float error2 = 0.1f;
; 345  :   for (int i = 0; i < n; i++)

	mov	eax, DWORD PTR _blockDx$[ebp]
	mov	ecx, DWORD PTR _blockWeight$[ebp]

; 346  :   {
; 347  :     float bw = blockWeight[i];
; 348  :     float xdif = (tr->dxc + tr->dxx*blockX[i] + tr->dxy*blockY[i] - blockX[i] - blockDx[i]);

	movss	xmm0, DWORD PTR _trderiv$[esp+84]
	sub	ecx, eax
	mov	edi, DWORD PTR _blockX$[ebp]
	sub	DWORD PTR _blockDy$[ebp], eax
	sub	eax, edi
	mov	edx, DWORD PTR _blockY$[ebp]
	movss	DWORD PTR _trderiv$12$[esp+72], xmm0
	sub	edx, edi
	movss	xmm0, DWORD PTR _trderiv$[esp+72]
	mov	DWORD PTR _blockWeight$[ebp], ecx
	mov	DWORD PTR _blockDx$[ebp], eax
	mov	DWORD PTR _blockY$[ebp], edx
	movss	DWORD PTR _trderiv$8$[esp+72], xmm1
	movss	DWORD PTR _trderiv$6$[esp+72], xmm0
	npad	4
$LL16@TrasformUp:
	mov	edx, DWORD PTR [edx+edi]
	add	eax, edi

; 349  :     trderiv.dxc += 2 * xdif*bw;
; 350  :     if (ifZoom1) trderiv.dxx += 2 * blockX[i] * xdif*bw;

	cmp	BYTE PTR _ifZoom1$[ebp], 0
	movss	xmm2, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR [esi+8]
	movss	xmm3, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [edi]
	movd	xmm6, edx
	cvtdq2ps xmm6, xmm6
	movd	xmm7, ecx
	cvtdq2ps xmm7, xmm7
	mulss	xmm0, xmm6
	mulss	xmm2, xmm7
	addss	xmm2, DWORD PTR [esi]
	addss	xmm2, xmm0
	subss	xmm2, xmm7
	subss	xmm2, DWORD PTR [eax]
	movaps	xmm0, xmm2
	addss	xmm0, xmm2
	mulss	xmm0, xmm3
	addss	xmm0, DWORD PTR _trderiv$6$[esp+72]
	movss	DWORD PTR _trderiv$6$[esp+72], xmm0
	je	SHORT $LN17@TrasformUp
	lea	eax, DWORD PTR [ecx+ecx]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	mulss	xmm0, xmm3
	addss	xmm0, xmm1
	movss	DWORD PTR _trderiv$8$[esp+72], xmm0
$LN17@TrasformUp:

; 351  :     if (ifRot1)	trderiv.dxy += 2 * blockY[i] * xdif*bw;

	cmp	BYTE PTR _ifRot1$[ebp], 0
	je	SHORT $LN18@TrasformUp
	lea	eax, DWORD PTR [edx+edx]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	mulss	xmm0, xmm3
	addss	xmm5, xmm0
$LN18@TrasformUp:

; 352  :     float ydif = (tr->dyc + tr->dyx*blockX[i] + tr->dyy*blockY[i] - blockY[i] - blockDy[i]);

	movss	xmm1, DWORD PTR [esi+16]
	movss	xmm0, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _blockDx$[ebp]
	mov	ecx, DWORD PTR _blockDy$[ebp]
	add	eax, edi

; 353  :     trderiv.dyc += 2 * ydif*bw;
; 354  :     if (ifRot1) trderiv.dyx += 2 * blockX[i] * ydif*bw;

	cmp	BYTE PTR _ifRot1$[ebp], 0
	mulss	xmm1, xmm7
	mulss	xmm0, xmm6
	addss	xmm1, DWORD PTR [esi+12]
	mov	esi, DWORD PTR _tr$[ebp]
	addss	xmm1, xmm0
	subss	xmm1, xmm6
	movss	xmm6, DWORD PTR _trderiv$2$[esp+72]
	subss	xmm1, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR [edi]
	movaps	xmm7, xmm1
	addss	xmm7, xmm1
	mulss	xmm7, xmm3
	addss	xmm7, DWORD PTR _trderiv$12$[esp+72]
	movss	DWORD PTR _trderiv$12$[esp+72], xmm7
	je	SHORT $LN19@TrasformUp
	lea	eax, DWORD PTR [ecx+ecx]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	mulss	xmm0, xmm3
	addss	xmm6, xmm0
	movss	DWORD PTR _trderiv$2$[esp+72], xmm6
$LN19@TrasformUp:

; 355  :     if (ifZoom1) trderiv.dyy += 2 * blockY[i] * ydif*bw;

	cmp	BYTE PTR _ifZoom1$[ebp], 0
	je	SHORT $LN20@TrasformUp
	lea	eax, DWORD PTR [edx+edx]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	mulss	xmm0, xmm3
	addss	xmm4, xmm0
$LN20@TrasformUp:

; 356  :     norm += bw;
; 357  :     x2 += blockX[i] * blockX[i] * bw;

	imul	ecx, ecx
	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR _norm$1$[esp+72]
	mov	eax, DWORD PTR _blockDx$[ebp]
	add	edi, 4

; 358  :     y2 += blockY[i] * blockY[i] * bw;

	imul	edx, edx
	sub	DWORD PTR _nBlkX$[ebp], 1

; 359  :     error2 += (xdif*xdif + ydif*ydif)*bw;

	mulss	xmm1, xmm1
	movss	DWORD PTR _norm$1$[esp+72], xmm0
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mov	ecx, DWORD PTR _blockWeight$[ebp]
	mulss	xmm2, xmm2
	mulss	xmm0, xmm3
	addss	xmm1, xmm2
	addss	xmm0, DWORD PTR _x2$1$[esp+72]
	mulss	xmm1, xmm3
	movss	DWORD PTR _x2$1$[esp+72], xmm0
	movd	xmm0, edx
	addss	xmm1, DWORD PTR _error2$1$[esp+72]
	mov	edx, DWORD PTR _blockY$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _error2$1$[esp+72], xmm1
	movss	xmm1, DWORD PTR _trderiv$8$[esp+72]
	mulss	xmm0, xmm3
	addss	xmm0, DWORD PTR _y2$1$[esp+72]
	movss	DWORD PTR _y2$1$[esp+72], xmm0
	jne	$LL16@TrasformUp
	movss	xmm0, DWORD PTR _norm$1$[esp+72]
	movss	xmm2, DWORD PTR _trderiv$6$[esp+72]
	jmp	SHORT $LN3@TrasformUp
$LN24@TrasformUp:

; 342  :   float x2 = 0.1f;
; 343  :   float y2 = 0.1f;
; 344  :   float error2 = 0.1f;
; 345  :   for (int i = 0; i < n; i++)

	movss	xmm7, DWORD PTR _trderiv$[esp+84]
	movss	xmm2, DWORD PTR _trderiv$[esp+72]
$LN3@TrasformUp:

; 360  :   }
; 361  :   trderiv.dxc /= norm * 2;

	movaps	xmm3, xmm0
	addss	xmm3, xmm0

; 362  :   trderiv.dxx /= x2 * 2 * 1.5f; // with additional safety factors

	movss	xmm0, DWORD PTR _x2$1$[esp+72]
	addss	xmm0, xmm0
	divss	xmm2, xmm3
	movss	DWORD PTR _x2$1$[esp+72], xmm0
	mulss	xmm0, DWORD PTR __real@3fc00000

; 363  :   trderiv.dxy /= y2 * 2 * 3;
; 364  :   trderiv.dyc /= norm * 2;

	divss	xmm7, xmm3
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR _y2$1$[esp+72]
	addss	xmm0, xmm0
	movss	DWORD PTR _trderiv$6$[esp+72], xmm2
	movss	DWORD PTR _trderiv$8$[esp+72], xmm1
	movss	DWORD PTR _trderiv$12$[esp+72], xmm7
	movss	DWORD PTR _y2$1$[esp+72], xmm0
	mulss	xmm0, DWORD PTR __real@40400000
	divss	xmm5, xmm0

; 365  :   trderiv.dyx /= x2 * 2 * 3;

	movss	xmm0, DWORD PTR _x2$1$[esp+72]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _trderiv$10$[esp+72], xmm5
	divss	xmm6, xmm0

; 366  :   trderiv.dyy /= y2 * 2 * 1.5f;

	movss	xmm0, DWORD PTR _y2$1$[esp+72]
	mulss	xmm0, DWORD PTR __real@3fc00000
	movss	DWORD PTR _trderiv$2$[esp+72], xmm6
	divss	xmm4, xmm0

; 367  : 
; 368  :   error2 /= norm;

	movss	xmm0, DWORD PTR _error2$1$[esp+72]
	divss	xmm0, DWORD PTR _norm$1$[esp+72]
	movss	DWORD PTR _trderiv$4$[esp+72], xmm4
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\github\mvtools\sources\mvdepan.cpp

; 369  :   *error1 = sqrtf(error2);

	mov	eax, DWORD PTR _error1$[ebp]

; 371  :   tr->dxc -= safety*trderiv.dxc;

	movss	xmm4, DWORD PTR _safety$[ebp]
	movss	xmm1, DWORD PTR _trderiv$6$[esp+72]

; 372  :   if (ifZoom1) 	tr->dxx -= safety*0.5f*(trderiv.dxx + trderiv.dyy);

	movss	xmm5, DWORD PTR __real@3f000000
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 371  :   tr->dxc -= safety*trderiv.dxc;

	mulss	xmm1, xmm4
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [esi]

; 372  :   if (ifZoom1) 	tr->dxx -= safety*0.5f*(trderiv.dxx + trderiv.dyy);

	mov	al, BYTE PTR _ifZoom1$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0
	test	al, al
	je	SHORT $LN9@TrasformUp
	movss	xmm1, DWORD PTR _trderiv$4$[esp+72]
	movaps	xmm0, xmm4
	addss	xmm1, DWORD PTR _trderiv$8$[esp+72]
	mulss	xmm0, xmm5
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR [esi+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0
$LN9@TrasformUp:

; 373  : 
; 374  :   tr->dxy -= safety*0.5f*(trderiv.dxy - trderiv.dyx / (pixaspect*pixaspect));

	movss	xmm2, DWORD PTR _pixaspect$[ebp]
	movss	xmm0, DWORD PTR _trderiv$2$[esp+72]
	mulss	xmm2, xmm2
	movss	xmm3, DWORD PTR _trderiv$10$[esp+72]
	movss	xmm1, DWORD PTR [esi+8]
	divss	xmm0, xmm2
	subss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm5
	mulss	xmm3, xmm0

; 375  :   tr->dyc -= safety*trderiv.dyc;

	movss	xmm0, DWORD PTR [esi+12]
	subss	xmm1, xmm3
	movss	xmm3, DWORD PTR _trderiv$12$[esp+72]
	mulss	xmm3, xmm4
	movss	DWORD PTR [esi+8], xmm1
	subss	xmm0, xmm3
	movss	DWORD PTR [esi+12], xmm0

; 376  : //	tr->dyx -= safety*trderiv.dyx;
; 377  : //	tr->dyy -= safety*trderiv.dyy;
; 378  :   if (ifZoom1) 	tr->dyy = tr->dxx;

	test	al, al
	je	SHORT $LN10@TrasformUp
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+20], eax
$LN10@TrasformUp:

; 379  : //	float pixaspect=1; // was for test and forgot remove?! disabled in v1.2.5
; 380  :   tr->dyx = -pixaspect*pixaspect * tr->dxy;

	mulss	xmm1, xmm2

; 381  : 
; 382  : }

	pop	edi
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+16], xmm1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
?TrasformUpdate@MVDepan@@AAEXPAUtransformstruct@@QAM1QAH221HHM_N3PAMM@Z ENDP ; MVDepan::TrasformUpdate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ?RejectBadBlocks@MVDepan@@AAEXUtransformstruct@@QAM1QAH221HHMMHM1H@Z
_TEXT	SEGMENT
tv1887 = -28						; size = 4
tv1879 = -24						; size = 4
tv1884 = -20						; size = 4
tv1885 = -16						; size = 4
tv1878 = -12						; size = 4
tv1886 = -8						; size = 4
_j$1$ = -4						; size = 4
_tr$ = 8						; size = 24
_blockDx$ = 32						; size = 4
_blockDy$ = 36						; size = 4
_blockSAD$ = 40						; size = 4
_blockX$ = 44						; size = 4
_blockY$ = 48						; size = 4
_blockWeight$ = 52					; size = 4
_nBlkX$ = 56						; size = 4
_nBlkY$ = 60						; size = 4
tv1881 = 64						; size = 4
_wrongDif$ = 64						; size = 4
_globalDif$ = 68					; size = 4
_thSCD1$ = 72						; size = 4
_zeroWeight$ = 76					; size = 4
_blockWeightMask$ = 80					; size = 4
_ignoredBorder$ = 84					; size = 4
?RejectBadBlocks@MVDepan@@AAEXUtransformstruct@@QAM1QAH221HHMMHM1H@Z PROC ; MVDepan::RejectBadBlocks, COMDAT
; _this$dead$ = ecx

; 386  : {

	sub	esp, 28					; 0000001cH

; 387  :   for (int j = 0; j < nBlkY; j++)

	xor	ecx, ecx
	mov	DWORD PTR _j$1$[esp+28], ecx
	cmp	DWORD PTR _nBlkY$[esp+24], ecx
	jle	$LN3@RejectBadB
	movss	xmm7, DWORD PTR _wrongDif$[esp+24]
	xorps	xmm6, xmm6
	movsd	xmm5, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movss	xmm1, DWORD PTR __real@3e000000
	mov	edx, DWORD PTR _nBlkX$[esp+24]
	mov	eax, DWORD PTR _nBlkY$[esp+24]
	push	esi
	push	edi
$LL4@RejectBadB:

; 388  :   {
; 389  :     for (int i = 0; i < nBlkX; i++)

	xor	esi, esi
	test	edx, edx
	jle	$LN2@RejectBadB

; 397  :       {
; 398  :         blockWeight[n] = 0; // disable bad block with big SAD

	mov	eax, DWORD PTR _blockDx$[esp+32]
	mov	edi, DWORD PTR _blockY$[esp+32]
	imul	ecx, edx
	mov	edx, DWORD PTR _blockX$[esp+32]
	mov	DWORD PTR tv1885[esp+36], edi
	mov	edi, DWORD PTR _blockWeight$[esp+32]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _blockDy$[esp+32]
	sub	ecx, eax
	mov	DWORD PTR tv1887[esp+36], ecx
	mov	ecx, DWORD PTR _blockSAD$[esp+32]
	mov	DWORD PTR tv1886[esp+36], ecx
	mov	ecx, DWORD PTR _blockX$[esp+32]
	sub	eax, ecx
	sub	DWORD PTR tv1886[esp+36], ecx
	sub	DWORD PTR tv1885[esp+36], ecx
	mov	DWORD PTR tv1884[esp+36], eax
	mov	eax, DWORD PTR _blockDy$[esp+32]
	sub	eax, ecx
	mov	DWORD PTR tv1881[esp+32], eax
	mov	eax, DWORD PTR _blockWeightMask$[esp+32]
	sub	eax, ecx
	sub	edi, ecx
	mov	ecx, DWORD PTR _j$1$[esp+36]
	mov	DWORD PTR tv1879[esp+36], eax
	mov	eax, DWORD PTR _nBlkX$[esp+32]
	mov	DWORD PTR tv1878[esp+36], edi
$LL7@RejectBadB:

; 390  :     {
; 391  :       int n = j*nBlkX + i;
; 392  :       if (i < ignoredBorder || i >= nBlkX - ignoredBorder || j < ignoredBorder || j >= nBlkY - ignoredBorder)

	cmp	esi, DWORD PTR _ignoredBorder$[esp+32]
	jl	$LN10@RejectBadB
	sub	eax, DWORD PTR _ignoredBorder$[esp+32]
	cmp	esi, eax
	jge	$LN10@RejectBadB
	cmp	ecx, DWORD PTR _ignoredBorder$[esp+32]
	jl	$LN10@RejectBadB
	mov	eax, DWORD PTR _nBlkY$[esp+32]
	sub	eax, DWORD PTR _ignoredBorder$[esp+32]
	cmp	ecx, eax
	jge	$LN10@RejectBadB

; 395  :       }
; 396  :       else if (blockSAD[n] > thSCD1)

	mov	eax, DWORD PTR tv1886[esp+36]
	mov	edi, DWORD PTR _thSCD1$[esp+32]
	cmp	DWORD PTR [eax+edx], edi
	mov	edi, DWORD PTR tv1878[esp+36]
	jg	$LN10@RejectBadB

; 400  :       else if (i > 0 && i < (nBlkX - 1) && (fabs((blockDx[n - 1 - nBlkX] + blockDx[n - nBlkX] + blockDx[n + 1 - nBlkX] +

	test	esi, esi
	jle	SHORT $LN13@RejectBadB
	mov	eax, DWORD PTR _nBlkX$[esp+32]
	dec	eax
	cmp	esi, eax
	jge	SHORT $LN13@RejectBadB
	mov	edi, DWORD PTR _blockDx$[esp+32]
	dec	ecx
	imul	ecx, DWORD PTR _nBlkX$[esp+32]
	mov	eax, DWORD PTR _j$1$[esp+36]
	inc	eax
	imul	eax, DWORD PTR _nBlkX$[esp+32]
	add	ecx, esi
	add	eax, esi
	movss	xmm0, DWORD PTR [edi+ecx*4-4]
	addss	xmm0, DWORD PTR [edi+ecx*4]
	addss	xmm0, DWORD PTR [edi+ecx*4+4]
	mov	ecx, DWORD PTR tv1884[esp+36]
	addss	xmm0, DWORD PTR [ecx+edx-4]
	addss	xmm0, DWORD PTR [ecx+edx+4]
	addss	xmm0, DWORD PTR [edi+eax*4-4]
	addss	xmm0, DWORD PTR [edi+eax*4]
	addss	xmm0, DWORD PTR [edi+eax*4+4]
	mov	edi, DWORD PTR tv1878[esp+36]
	mulss	xmm0, xmm1
	subss	xmm0, DWORD PTR [ecx+edx]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm5
	cvtpd2ps xmm0, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 400  :       else if (i > 0 && i < (nBlkX - 1) && (fabs((blockDx[n - 1 - nBlkX] + blockDx[n - nBlkX] + blockDx[n + 1 - nBlkX] +

	comiss	xmm0, xmm7
	ja	$LN10@RejectBadB
	mov	ecx, DWORD PTR _j$1$[esp+36]
$LN13@RejectBadB:

; 406  :       else if (j > 0 && j < (nBlkY - 1) && (fabs((blockDy[n - 1 - nBlkX] + blockDy[n - nBlkX] + blockDy[n + 1 - nBlkX] +

	test	ecx, ecx
	jle	$LN54@RejectBadB
	mov	eax, DWORD PTR _nBlkY$[esp+32]
	dec	eax
	cmp	ecx, eax
	jge	SHORT $LN54@RejectBadB
	mov	edi, DWORD PTR _blockDy$[esp+32]
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, DWORD PTR _nBlkX$[esp+32]
	inc	ecx
	imul	ecx, DWORD PTR _nBlkX$[esp+32]
	add	eax, esi
	add	ecx, esi
	movss	xmm0, DWORD PTR [edi+eax*4-4]
	addss	xmm0, DWORD PTR [edi+eax*4]
	addss	xmm0, DWORD PTR [edi+eax*4+4]
	mov	eax, DWORD PTR tv1881[esp+32]
	addss	xmm0, DWORD PTR [eax+edx-4]
	mov	eax, DWORD PTR tv1884[esp+36]
	add	eax, DWORD PTR tv1887[esp+36]
	addss	xmm0, DWORD PTR [eax+edx+4]
	mov	eax, edi
	mov	edi, DWORD PTR tv1878[esp+36]
	addss	xmm0, DWORD PTR [eax+ecx*4-4]
	addss	xmm0, DWORD PTR [eax+ecx*4]
	addss	xmm0, DWORD PTR [eax+ecx*4+4]
	mov	ecx, DWORD PTR tv1881[esp+32]
	mulss	xmm0, xmm1
	subss	xmm0, DWORD PTR [ecx+edx]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm5
	cvtpd2ps xmm0, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 406  :       else if (j > 0 && j < (nBlkY - 1) && (fabs((blockDy[n - 1 - nBlkX] + blockDy[n - nBlkX] + blockDy[n + 1 - nBlkX] +

	comiss	xmm0, xmm7
	jbe	SHORT $LN15@RejectBadB

; 407  :         blockDy[n - 1] + blockDy[n + 1] +
; 408  :         blockDy[n - 1 + nBlkX] + blockDy[n + nBlkX] + blockDy[n + 1 + nBlkX]) / 8 - blockDy[n]) > wrongDif))
; 409  :       {
; 410  :         blockWeight[n] = 0; // disable blocks very different from neighbours

	jmp	$LN10@RejectBadB
$LN54@RejectBadB:
	mov	ecx, DWORD PTR tv1881[esp+32]
$LN15@RejectBadB:
	movd	xmm2, DWORD PTR [edx]

; 412  :       else if (fabs(tr.dxc + tr.dxx*blockX[n] + tr.dxy*blockY[n] - blockX[n] - blockDx[n]) > globalDif)

	mov	eax, DWORD PTR tv1885[esp+36]
	cvtdq2ps xmm2, xmm2
	movd	xmm3, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR tv1884[esp+36]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR _tr$[esp+36]
	cvtdq2ps xmm3, xmm3
	addss	xmm1, DWORD PTR _tr$[esp+32]
	movss	xmm4, DWORD PTR [eax+edx]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _tr$[esp+40]
	addss	xmm1, xmm0
	subss	xmm1, xmm2
	subss	xmm1, xmm4
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andps	xmm0, xmm5
	cvtpd2ps xmm0, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 412  :       else if (fabs(tr.dxc + tr.dxx*blockX[n] + tr.dxy*blockY[n] - blockX[n] - blockDx[n]) > globalDif)

	comiss	xmm0, DWORD PTR _globalDif$[esp+32]
	ja	SHORT $LN55@RejectBadB

; 416  :       else if (fabs(tr.dyc + tr.dyx*blockX[n] + tr.dyy*blockY[n] - blockY[n] - blockDy[n]) > globalDif)

	mulss	xmm2, DWORD PTR _tr$[esp+48]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _tr$[esp+52]
	addss	xmm2, DWORD PTR _tr$[esp+44]
	movss	xmm1, DWORD PTR [ecx+edx]
	addss	xmm2, xmm0
	subss	xmm2, xmm3
	subss	xmm2, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andps	xmm0, xmm5
	cvtpd2ps xmm0, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 416  :       else if (fabs(tr.dyc + tr.dyx*blockX[n] + tr.dyy*blockY[n] - blockY[n] - blockDy[n]) > globalDif)

	comiss	xmm0, DWORD PTR _globalDif$[esp+32]
	ja	SHORT $LN55@RejectBadB

; 419  :       }
; 420  :       else if (blockDx[n] == 0 && blockDy[n] == 0)

	ucomiss	xmm4, xmm6
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@RejectBadB
	ucomiss	xmm1, xmm6
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@RejectBadB

; 421  :       {
; 422  :         blockWeight[n] = zeroWeight*blockWeightMask[n];//0.05f; // decrease weight of blocks with strictly zero motion - added in v1.2.5

	mov	eax, DWORD PTR tv1879[esp+36]

; 423  :       }
; 424  :       else

	movss	xmm1, DWORD PTR __real@3e000000
	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR _zeroWeight$[esp+32]
	movss	DWORD PTR [edi+edx], xmm0
	jmp	SHORT $LN5@RejectBadB
$LN21@RejectBadB:

; 425  :       {
; 426  :         blockWeight[n] = blockWeightMask[n]; // good block

	mov	eax, DWORD PTR tv1879[esp+36]
	movss	xmm1, DWORD PTR __real@3e000000
	mov	eax, DWORD PTR [eax+edx]
	mov	DWORD PTR [edi+edx], eax
	jmp	SHORT $LN5@RejectBadB
$LN55@RejectBadB:

; 417  :       {
; 418  :         blockWeight[n] = 0; // disable blocks very different from global

	movss	xmm1, DWORD PTR __real@3e000000
$LN10@RejectBadB:

; 393  :       {
; 394  :         blockWeight[n] = 0; // disable  blocks near frame borders

	mov	DWORD PTR [edi+edx], 0
$LN5@RejectBadB:

; 388  :   {
; 389  :     for (int i = 0; i < nBlkX; i++)

	mov	eax, DWORD PTR _nBlkX$[esp+32]
	inc	esi
	mov	ecx, DWORD PTR _j$1$[esp+36]
	add	edx, 4
	cmp	esi, eax
	jl	$LL7@RejectBadB
	mov	edx, eax
	mov	eax, DWORD PTR _nBlkY$[esp+32]
$LN2@RejectBadB:

; 387  :   for (int j = 0; j < nBlkY; j++)

	inc	ecx
	mov	DWORD PTR _j$1$[esp+36], ecx
	cmp	ecx, eax
	jl	$LL4@RejectBadB
	pop	edi
	pop	esi
$LN3@RejectBadB:

; 427  :       }
; 428  :     }
; 429  :   }
; 430  : 
; 431  : }

	add	esp, 28					; 0000001cH
	ret	80					; 00000050H
?RejectBadBlocks@MVDepan@@AAEXUtransformstruct@@QAM1QAH221HHMMHM1H@Z ENDP ; MVDepan::RejectBadBlocks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvdepan.cpp
;	COMDAT ?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -168						; size = 12
$T3 = -156						; size = 12
_trinv$5$ = -144					; size = 4
_dPel$1$ = -140						; size = 4
$T4 = -136						; size = 4
_tr$ = -132						; size = 24
_zoom$1$ = -108						; size = 4
_dx$1$ = -108						; size = 4
_pixaspect$1$ = -104					; size = 4
_trinv$4$ = -104					; size = 4
_sinus$1$ = -100					; size = 4
_sinus$1$ = -100					; size = 4
_pixaspect$1$ = -96					; size = 4
_dy$1$ = -96						; size = 4
tv2558 = -92						; size = 4
_nFields$1$ = -88					; size = 4
_mvn$5 = -84						; size = 4
$T6 = -84						; size = 4
_rotradian$1$ = -80					; size = 4
_dy$1$ = -80						; size = 4
_mask_pitch$ = -80					; size = 4
_maskp$ = -80						; size = 4
_maskp$1$ = -76						; size = 4
_mask_pitch$1$ = -72					; size = 4
_framefirst$1$ = -68					; size = 4
$T7 = -68						; size = 4
$T8 = -68						; size = 4
_framelast$1$ = -64					; size = 4
$T9 = -64						; size = 4
$T10 = -64						; size = 4
_rotradian$1$ = -60					; size = 4
_BPP$1$ = -60						; size = 4
tv2791 = -60						; size = 4
tv2788 = -53						; size = 1
tv2776 = -52						; size = 4
_trinv$1$ = -48						; size = 4
_nb$1$ = -48						; size = 4
_nframemv$1$ = -48					; size = 4
tv2700 = -48						; size = 4
_maskf$ = -44						; size = 4
_xcenter$1$ = -40					; size = 4
_errorcur$ = -40					; size = 4
_nframe$1$ = -36					; size = 4
_src_pitch$4$ = -36					; size = 4
_src_pitch$3$ = -36					; size = 4
_src_pitch$2$ = -36					; size = 4
_src_pitch$1$ = -36					; size = 4
_errorprev$1$ = -32					; size = 4
_srcp$4$ = -32						; size = 4
_srcp$3$ = -32						; size = 4
_srcp$2$ = -32						; size = 4
_srcp$1$ = -32						; size = 4
_src$ = -28						; size = 4
_j$1$ = -24						; size = 4
_iter$1$ = -24						; size = 4
_src_width$4$ = -24					; size = 4
_src_width$3$ = -24					; size = 4
_src_width$2$ = -24					; size = 4
_src_width$1$ = -24					; size = 4
_tr$1$ = -20						; size = 4
_ycenter$1$ = -20					; size = 4
_i$1$ = -20						; size = 4
_src_height$4$ = -20					; size = 4
_src_height$3$ = -20					; size = 4
_src_height$2$ = -20					; size = 4
_src_height$1$ = -20					; size = 4
tv2792 = -20						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_ndest$ = 16						; size = 4
_env$ = 20						; size = 4
?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVDepan::GetFrame, COMDAT

; 436  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	sub	esp, 152				; 00000098H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T4[ebp], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvdepan.cpp

; 436  : {

	push	esi
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	test	eax, eax
	je	SHORT $LN62@GetFrame
	cmp	DWORD PTR [eax], 64			; 00000040H
	jbe	SHORT $LN62@GetFrame
; File c:\github\mvtools\sources\mvdepan.cpp

; 444  :   int nFields = (vi.IsFieldBased()) ? 2 : 1;

	mov	esi, DWORD PTR _this$[ebx]
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	mov	eax, DWORD PTR [eax+64]
; File c:\github\mvtools\sources\mvdepan.cpp

; 444  :   int nFields = (vi.IsFieldBased()) ? 2 : 1;

	lea	ecx, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	call	eax
	movzx	eax, al
	jmp	SHORT $LN63@GetFrame
$LN62@GetFrame:
	mov	esi, DWORD PTR _this$[ebx]
	xor	eax, eax
$LN63@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 446  :   PVideoFrame	src = child->GetFrame(ndest, env);

	push	DWORD PTR _env$[ebx]
	xor	ecx, ecx
	lea	edx, DWORD PTR _src$[ebp]
	push	DWORD PTR _ndest$[ebx]
	test	al, al
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvdepan.cpp

; 446  :   PVideoFrame	src = child->GetFrame(ndest, env);

	push	edx
	setne	cl
	inc	ecx
	mov	DWORD PTR _nFields$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]

; 447  :   PVideoFrame	dst = env->NewVideoFrame(vi);

	mov	ecx, DWORD PTR _env$[ebx]
	lea	edi, DWORD PTR [esi+16]
	push	32					; 00000020H
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv2558[ebp], edi
	call	DWORD PTR [eax+56]
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR $T4[ebp], 1
	test	eax, eax
	je	SHORT $LN68@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN68@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _maskf$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN68@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 449  :   PVideoFrame maskf;

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 945  :   operator void*() const { return p; }

	mov	ecx, DWORD PTR [esi+424]
; File c:\github\mvtools\sources\mvdepan.cpp

; 450  :   if (mask)

	test	ecx, ecx
	je	SHORT $LN79@GetFrame

; 451  :     maskf = mask->GetFrame(ndest, env);

	push	DWORD PTR _env$[ebx]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T8[ebp]
	push	DWORD PTR _ndest$[ebx]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN76@GetFrame
	cmp	DWORD PTR [eax], 268			; 0000010cH
	jbe	SHORT $LN76@GetFrame
	mov	eax, DWORD PTR [eax+268]
	push	ecx
	lea	ecx, DWORD PTR _maskf$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN76@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN80@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN80@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR $T8[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN80@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 2
$LN79@GetFrame:

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	test	eax, eax
	je	$LN233@GetFrame
	cmp	DWORD PTR [eax], 24			; 00000018H
	jbe	SHORT $LN516@GetFrame
	mov	eax, DWORD PTR [eax+24]
	mov	ecx, edi
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvdepan.cpp

; 464  :   if ((vi.IsYUV() || vi.IsYUVA()) && !vi.IsYUY2())

	test	al, al
	jne	SHORT $LN20@GetFrame
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN516@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 716  :   bool IsYUVA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsYUVA, false) )

	test	eax, eax
	je	$LN233@GetFrame
	cmp	DWORD PTR [eax], 564			; 00000234H
	jbe	$LN18@GetFrame
	mov	eax, DWORD PTR [eax+564]
	mov	ecx, edi
	call	eax
; File c:\github\mvtools\sources\mvdepan.cpp

; 464  :   if ((vi.IsYUV() || vi.IsYUVA()) && !vi.IsYUY2())

	test	al, al
	je	$LN521@GetFrame
$LN20@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN99@GetFrame
	cmp	DWORD PTR [eax], 28			; 0000001cH
	jbe	SHORT $LN517@GetFrame
	mov	eax, DWORD PTR [eax+28]
	mov	ecx, edi
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvdepan.cpp

; 464  :   if ((vi.IsYUV() || vi.IsYUVA()) && !vi.IsYUY2())

	test	al, al
	jne	$LN521@GetFrame
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN517@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN99@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN99@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	2
	call	eax
	mov	DWORD PTR _srcp$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN100@GetFrame
$LN99@GetFrame:
	mov	DWORD PTR _srcp$1$[ebp], 0
$LN100@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	eax, eax
	je	SHORT $LN105@GetFrame
	cmp	DWORD PTR [eax], 196			; 000000c4H
	jbe	SHORT $LN105@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+196]
	push	2
	call	eax
	mov	DWORD PTR _src_width$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN106@GetFrame
$LN105@GetFrame:
	mov	DWORD PTR _src_width$1$[ebp], 0
$LN106@GetFrame:

; 799  :   int GetHeight(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetHeight)(plane) )

	test	eax, eax
	je	SHORT $LN111@GetFrame
	cmp	DWORD PTR [eax], 200			; 000000c8H
	jbe	SHORT $LN111@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+200]
	push	2
	call	eax
	mov	DWORD PTR _src_height$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN112@GetFrame
$LN111@GetFrame:
	mov	DWORD PTR _src_height$1$[ebp], 0
$LN112@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN117@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN117@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	DWORD PTR _src_pitch$1$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN118@GetFrame
$LN117@GetFrame:
	mov	DWORD PTR _src_pitch$1$[ebp], 0
$LN118@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN123@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN123@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+220]
	push	2
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN124@GetFrame
$LN123@GetFrame:
	xor	edi, edi
$LN124@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN129@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN129@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+192]
	push	2
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN130@GetFrame
$LN129@GetFrame:
	xor	ecx, ecx
$LN130@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 473  :     env->BitBlt(dstp, dst_pitch, srcp, src_pitch, src_width, src_height);

	push	DWORD PTR _src_height$1$[ebp]
	mov	edx, DWORD PTR _env$[ebx]
	push	DWORD PTR _src_width$1$[ebp]
	push	DWORD PTR _src_pitch$1$[ebp]
	mov	eax, DWORD PTR [edx]
	push	DWORD PTR _srcp$1$[ebp]
	push	ecx
	push	edi
	push	edx
	call	DWORD PTR [eax+64]
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN135@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN135@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	4
	call	eax
	mov	DWORD PTR _srcp$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN136@GetFrame
$LN135@GetFrame:
	mov	DWORD PTR _srcp$2$[ebp], 0
$LN136@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	eax, eax
	je	SHORT $LN141@GetFrame
	cmp	DWORD PTR [eax], 196			; 000000c4H
	jbe	SHORT $LN141@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+196]
	push	4
	call	eax
	mov	DWORD PTR _src_width$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN142@GetFrame
$LN141@GetFrame:
	mov	DWORD PTR _src_width$2$[ebp], 0
$LN142@GetFrame:

; 799  :   int GetHeight(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetHeight)(plane) )

	test	eax, eax
	je	SHORT $LN147@GetFrame
	cmp	DWORD PTR [eax], 200			; 000000c8H
	jbe	SHORT $LN147@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+200]
	push	4
	call	eax
	mov	DWORD PTR _src_height$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN148@GetFrame
$LN147@GetFrame:
	mov	DWORD PTR _src_height$2$[ebp], 0
$LN148@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN153@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN153@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	DWORD PTR _src_pitch$2$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN154@GetFrame
$LN153@GetFrame:
	mov	DWORD PTR _src_pitch$2$[ebp], 0
$LN154@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN159@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN159@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+220]
	push	4
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN160@GetFrame
$LN159@GetFrame:
	xor	edi, edi
$LN160@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN165@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN165@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+192]
	push	4
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN166@GetFrame
$LN165@GetFrame:
	xor	ecx, ecx
$LN166@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 482  :     env->BitBlt(dstp, dst_pitch, srcp, src_pitch, src_width, src_height);

	push	DWORD PTR _src_height$2$[ebp]
	mov	edx, DWORD PTR _env$[ebx]
	push	DWORD PTR _src_width$2$[ebp]
	push	DWORD PTR _src_pitch$2$[ebp]
	mov	eax, DWORD PTR [edx]
	push	DWORD PTR _srcp$2$[ebp]
	push	ecx
	push	edi
	push	edx
	call	DWORD PTR [eax+64]
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN171@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN171@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	1
	call	eax
	mov	DWORD PTR _srcp$3$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN172@GetFrame
$LN171@GetFrame:
	mov	DWORD PTR _srcp$3$[ebp], 0
$LN172@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	eax, eax
	je	SHORT $LN177@GetFrame
	cmp	DWORD PTR [eax], 196			; 000000c4H
	jbe	SHORT $LN177@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+196]
	push	1
	call	eax
	mov	DWORD PTR _src_width$3$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN178@GetFrame
$LN177@GetFrame:
	mov	DWORD PTR _src_width$3$[ebp], 0
$LN178@GetFrame:

; 799  :   int GetHeight(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetHeight)(plane) )

	test	eax, eax
	je	SHORT $LN183@GetFrame
	cmp	DWORD PTR [eax], 200			; 000000c8H
	jbe	SHORT $LN183@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+200]
	push	1
	call	eax
	mov	DWORD PTR _src_height$3$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN184@GetFrame
$LN183@GetFrame:
	mov	DWORD PTR _src_height$3$[ebp], 0
$LN184@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN189@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN189@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	DWORD PTR _src_pitch$3$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN190@GetFrame
$LN189@GetFrame:
	mov	DWORD PTR _src_pitch$3$[ebp], 0
$LN190@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN195@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN195@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+220]
	push	1
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN196@GetFrame
$LN195@GetFrame:
	xor	edi, edi
$LN196@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN201@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN201@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+192]
	push	1
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN202@GetFrame
$LN201@GetFrame:
	xor	ecx, ecx
$LN202@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 491  :     env->BitBlt(dstp, dst_pitch, srcp, src_pitch, src_width, src_height);

	push	DWORD PTR _src_height$3$[ebp]
	mov	edx, DWORD PTR _env$[ebx]
	push	DWORD PTR _src_width$3$[ebp]
	push	DWORD PTR _src_pitch$3$[ebp]
	mov	eax, DWORD PTR [edx]
	push	DWORD PTR _srcp$3$[ebp]
	push	ecx
	push	edi
	push	edx
	call	DWORD PTR [eax+64]

; 492  :     if (mask)

	cmp	DWORD PTR [esi+424], 0
	je	$LN522@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edi, edi
	je	SHORT $LN209@GetFrame
	cmp	DWORD PTR [edi], 212			; 000000d4H
	jbe	SHORT $LN209@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+212]
	push	1
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _maskp$1$[ebp], eax
	jmp	SHORT $LN210@GetFrame
$LN209@GetFrame:
	mov	DWORD PTR _maskp$1$[ebp], 0
$LN210@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	edi, edi
	je	SHORT $LN227@GetFrame
	cmp	DWORD PTR [edi], 196			; 000000c4H
	jbe	SHORT $LN215@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+196]
	push	1
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN215@GetFrame:

; 799  :   int GetHeight(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetHeight)(plane) )

	test	edi, edi
	je	SHORT $LN227@GetFrame
	cmp	DWORD PTR [edi], 200			; 000000c8H
	jbe	SHORT $LN221@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+200]
	push	1
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN221@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edi, edi
	je	SHORT $LN227@GetFrame
	cmp	DWORD PTR [edi], 192			; 000000c0H
	jbe	SHORT $LN227@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+192]
	push	1
	call	eax
	jmp	$LN534@GetFrame
$LN227@GetFrame:
	mov	DWORD PTR _mask_pitch$1$[ebp], 0
; File c:\github\mvtools\sources\mvdepan.cpp

; 500  :   else

	jmp	$LN290@GetFrame
$LN521@GetFrame:
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN18@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN233@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN233@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	0
	call	eax
	mov	DWORD PTR _srcp$4$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN234@GetFrame
$LN233@GetFrame:
	mov	DWORD PTR _srcp$4$[ebp], 0
$LN234@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	eax, eax
	je	SHORT $LN239@GetFrame
	cmp	DWORD PTR [eax], 196			; 000000c4H
	jbe	SHORT $LN239@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+196]
	push	0
	call	eax
	mov	DWORD PTR _src_width$4$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN240@GetFrame
$LN239@GetFrame:
	mov	DWORD PTR _src_width$4$[ebp], 0
$LN240@GetFrame:

; 799  :   int GetHeight(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetHeight)(plane) )

	test	eax, eax
	je	SHORT $LN245@GetFrame
	cmp	DWORD PTR [eax], 200			; 000000c8H
	jbe	SHORT $LN245@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+200]
	push	0
	call	eax
	mov	DWORD PTR _src_height$4$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN246@GetFrame
$LN245@GetFrame:
	mov	DWORD PTR _src_height$4$[ebp], 0
$LN246@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN251@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN251@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	0
	call	eax
	mov	DWORD PTR _src_pitch$4$[ebp], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN252@GetFrame
$LN251@GetFrame:
	mov	DWORD PTR _src_pitch$4$[ebp], 0
$LN252@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN257@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN257@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+220]
	push	0
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN258@GetFrame
$LN257@GetFrame:
	xor	edi, edi
$LN258@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN263@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN263@GetFrame
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	mov	eax, DWORD PTR [eax+192]
	push	0
	mov	ecx, DWORD PTR [ecx]
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN264@GetFrame
$LN263@GetFrame:
	xor	ecx, ecx
$LN264@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 508  :     env->BitBlt(dstp, dst_pitch, srcp, src_pitch, src_width, src_height);

	push	DWORD PTR _src_height$4$[ebp]
	mov	edx, DWORD PTR _env$[ebx]
	push	DWORD PTR _src_width$4$[ebp]
	push	DWORD PTR _src_pitch$4$[ebp]
	mov	eax, DWORD PTR [edx]
	push	DWORD PTR _srcp$4$[ebp]
	push	ecx
	push	edi
	push	edx
	call	DWORD PTR [eax+64]

; 509  :     if (mask)

	cmp	DWORD PTR [esi+424], 0
	je	$LN522@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edi, edi
	je	SHORT $LN271@GetFrame
	cmp	DWORD PTR [edi], 212			; 000000d4H
	jbe	SHORT $LN271@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+212]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _maskp$1$[ebp], eax
	jmp	SHORT $LN272@GetFrame
$LN271@GetFrame:
	mov	DWORD PTR _maskp$1$[ebp], 0
$LN272@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	edi, edi
	je	$LN227@GetFrame
	cmp	DWORD PTR [edi], 196			; 000000c4H
	jbe	SHORT $LN277@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+196]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN277@GetFrame:

; 799  :   int GetHeight(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetHeight)(plane) )

	test	edi, edi
	je	$LN227@GetFrame
	cmp	DWORD PTR [edi], 200			; 000000c8H
	jbe	SHORT $LN283@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+200]
	push	0
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN283@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	edi, edi
	je	$LN227@GetFrame
	cmp	DWORD PTR [edi], 192			; 000000c0H
	jbe	$LN227@GetFrame
	mov	ecx, DWORD PTR _maskf$[ebp]
	mov	eax, DWORD PTR [edi+192]
	push	0
	call	eax
	jmp	SHORT $LN534@GetFrame
$LN522@GetFrame:
	mov	eax, DWORD PTR _maskp$[ebp]
	mov	DWORD PTR _maskp$1$[ebp], eax
	mov	eax, DWORD PTR _mask_pitch$[ebp]
$LN534@GetFrame:
	mov	DWORD PTR _mask_pitch$1$[ebp], eax
$LN290@GetFrame:
	movd	xmm0, DWORD PTR [esi+104]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T10[ebp]
; File c:\github\mvtools\sources\mvdepan.cpp

; 518  :   float dPel = 1.0f / nPel;  // subpixel precision value

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [esi+296]
; File c:\github\mvtools\sources\mvdepan.cpp

; 529  :   int framefirst = std::max(ndest - range, 0);

	mov	edi, DWORD PTR _ndest$[ebx]
	mov	ecx, DWORD PTR [esi+420]
	cvtdq2ps xmm0, xmm0
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	BYTE PTR tv2788[ebp], al
; File c:\github\mvtools\sources\mvdepan.cpp

; 529  :   int framefirst = std::max(ndest - range, 0);

	mov	eax, edi
	sub	eax, ecx
	mov	DWORD PTR $T7[ebp], 0
	mov	DWORD PTR $T10[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T7[ebp]
	cmovns	eax, edx
; File c:\github\mvtools\sources\mvdepan.cpp

; 530  :   int framelast = std::min(ndest + range, vi.num_frames - 1);

	mov	edx, DWORD PTR [esi+32]
	dec	edx
	divss	xmm1, xmm0
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _framefirst$1$[ebp], eax
	lea	eax, DWORD PTR [ecx+edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	edx, eax
; File c:\github\mvtools\sources\mvdepan.cpp

; 530  :   int framelast = std::min(ndest + range, vi.num_frames - 1);

	mov	DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T9[ebp]
; File c:\github\mvtools\sources\mvdepan.cpp

; 530  :   int framelast = std::min(ndest + range, vi.num_frames - 1);

	mov	DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edi, DWORD PTR $T6[ebp]
	cmovge	ecx, edi
; File c:\github\mvtools\sources\mvdepan.cpp

; 530  :   int framelast = std::min(ndest + range, vi.num_frames - 1);

	mov	eax, DWORD PTR [ecx]

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	mov	ecx, DWORD PTR _framefirst$1$[ebp]
	mov	edx, ecx
	mov	DWORD PTR _framelast$1$[ebp], eax
	mov	DWORD PTR _nframe$1$[ebp], ecx
	movss	DWORD PTR _dPel$1$[ebp], xmm1
	cmp	ecx, eax
	jg	$LN3@GetFrame
	npad	7
$LL4@GetFrame:
	movaps	xmm0, XMMWORD PTR __xmm@00000000000000003f80000000000000
	lea	ecx, DWORD PTR [edx*4]

; 540  :   {
; 541  : 
; 542  :     // init motion transform as null
; 543  :     tr.dxc = 0;
; 544  :     tr.dxx = 1;
; 545  :     tr.dxy = 0;
; 546  :     tr.dyc = 0;
; 547  :     tr.dyx = 0;
; 548  :     tr.dyy = 1;
; 549  : 
; 550  :     errorcur = error * 2; // v1.2.3
; 551  :     iter = 0; // start iteration
; 552  : 
; 553  :     if (motionx[nframe] == MOTIONUNKNOWN)

	mov	eax, DWORD PTR [esi+464]
	xor	edi, edi
	movups	XMMWORD PTR _tr$[ebp], xmm0
	mov	DWORD PTR _tr$[ebp+20], 1065353216	; 3f800000H
	xorps	xmm0, xmm0
	mov	DWORD PTR _iter$1$[ebp], edi
	movss	DWORD PTR _tr$1$[ebp], xmm0
	movss	DWORD PTR _tr$[ebp+16], xmm0
	movss	xmm0, DWORD PTR [esi+400]
	addss	xmm0, xmm0
	mov	DWORD PTR tv2776[ebp], ecx
	movss	DWORD PTR _errorprev$1$[ebp], xmm0
	movss	DWORD PTR _errorcur$[ebp], xmm0
	movss	xmm0, DWORD PTR [ecx+eax]
	ucomiss	xmm0, DWORD PTR __real@461c3c00
	lahf
	test	ah, 68					; 00000044H
	jp	$LN454@GetFrame
	cmp	BYTE PTR tv2788[ebp], 0

; 554  :     {
; 555  :       int nframemv = (backward) ? nframe - 1 : nframe; // set prev frame number as data frame if backward

	je	SHORT $LN50@GetFrame
	lea	ecx, DWORD PTR [edx-1]
	mov	DWORD PTR _nframemv$1$[ebp], ecx
	jmp	SHORT $LN51@GetFrame
$LN50@GetFrame:
	mov	ecx, edx
	mov	DWORD PTR _nframemv$1$[ebp], edx
$LN51@GetFrame:

; 556  :       PVideoFrame mvn = mvclip.GetFrame(nframemv, env);

	push	DWORD PTR _env$[ebx]
	mov	eax, DWORD PTR [esi+152]
	lea	edi, DWORD PTR [esi+152]
	push	ecx
	lea	ecx, DWORD PTR _mvn$5[ebp]
	push	ecx
	push	edi
	call	DWORD PTR [eax+4]

; 557  :       mvclip.Update(mvn, env);

	push	DWORD PTR _env$[ebx]
	lea	eax, DWORD PTR _mvn$5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	eax
	mov	ecx, edi
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update

; 558  : 
; 559  :       int BPP; // step bytes luma per pixel
; 560  :       if (!planar && vi.IsYUY2())

	cmp	BYTE PTR [esi+428], 0
	jne	SHORT $LN523@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edi, edi
	je	SHORT $LN523@GetFrame
	cmp	DWORD PTR [edi], 28			; 0000001cH
	jbe	SHORT $LN523@GetFrame
	mov	eax, DWORD PTR [edi+28]
	lea	ecx, DWORD PTR [esi+16]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvdepan.cpp

; 561  :         BPP = 2;

	mov	DWORD PTR _BPP$1$[ebp], 2
	test	al, al
	jne	SHORT $LN27@GetFrame
$LN523@GetFrame:

; 562  :       else
; 563  :         BPP = 1;

	mov	DWORD PTR _BPP$1$[ebp], 1
$LN27@GetFrame:

; 564  : 
; 565  :       if (nframemv >= 0 && mvclip.IsUsable())

	cmp	DWORD PTR _nframemv$1$[ebp], 0
	jl	$LN529@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [esi+372]
	mov	ecx, DWORD PTR [esi+240]
	push	DWORD PTR [esi+368]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN529@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [esi+220]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN529@GetFrame
; File c:\github\mvtools\sources\mvdepan.cpp

; 570  :         for (int j = 0; j < nBlkY; j++)

	xor	edx, edx
	mov	DWORD PTR _j$1$[ebp], edx
	cmp	DWORD PTR [esi+68], edx
	jle	$LN6@GetFrame
	npad	4
$LL7@GetFrame:

; 571  :         {
; 572  :           for (int i = 0; i < nBlkX; i++)

	mov	ecx, DWORD PTR [esi+64]
	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	test	ecx, ecx
	jle	$LN5@GetFrame
	movss	xmm1, DWORD PTR _dPel$1$[ebp]
	npad	8
$LL10@GetFrame:

; 574  :             int nb = j*nBlkX + i;

	imul	edx, ecx
	add	edx, eax
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [esi+240]
; File c:\github\mvtools\sources\mvdepan.cpp

; 574  :             int nb = j*nBlkX + i;

	mov	DWORD PTR _nb$1$[ebp], edx
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	edi, DWORD PTR [edx+edx*4]
	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [eax+edi*4+8]
; File c:\github\mvtools\sources\mvdepan.cpp

; 575  :             blockDx[nb] = mvclip.GetBlock(0, nb).GetMV().x * dPel;

	mov	eax, DWORD PTR [esi+436]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[ebp], xmm0
	movd	xmm0, DWORD PTR $T3[ebp]
; File c:\github\mvtools\sources\mvdepan.cpp

; 575  :             blockDx[nb] = mvclip.GetBlock(0, nb).GetMV().x * dPel;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+edx*4], xmm0
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [esi+240]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [eax+edi*4+8]
; File c:\github\mvtools\sources\mvdepan.cpp

; 576  :             blockDy[nb] = mvclip.GetBlock(0, nb).GetMV().y * dPel;

	mov	eax, DWORD PTR [esi+440]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T2[ebp], xmm0
	movd	xmm0, DWORD PTR $T2[ebp+4]
; File c:\github\mvtools\sources\mvdepan.cpp

; 576  :             blockDy[nb] = mvclip.GetBlock(0, nb).GetMV().y * dPel;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+edx*4], xmm0
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [esi+240]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	mov	eax, DWORD PTR [eax+52]
	mov	ecx, DWORD PTR [eax+edi*4+16]
; File c:\github\mvtools\sources\mvdepan.cpp

; 577  :             blockSAD[nb] = mvclip.GetBlock(0, nb).GetSAD();

	mov	eax, DWORD PTR [esi+444]
	mov	DWORD PTR [eax+edx*4], ecx
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [esi+240]
; File c:\github\mvtools\sources\mvdepan.cpp

; 578  :             blockX[nb] = mvclip.GetBlock(0, nb).GetX() + nBlkSizeX / 2;//i*nBlkSize + nBlkSize/2;// rewritten in v1.2.5

	mov	ecx, DWORD PTR _this$[ebx]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeblockdata.h

; 52   : 	inline int GetX() const { return x; }

	mov	eax, DWORD PTR [eax+52]
	mov	esi, DWORD PTR [eax+edi*4]
; File c:\github\mvtools\sources\mvdepan.cpp

; 578  :             blockX[nb] = mvclip.GetBlock(0, nb).GetX() + nBlkSizeX / 2;//i*nBlkSize + nBlkSize/2;// rewritten in v1.2.5

	mov	eax, DWORD PTR [ecx+76]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _this$[ebx]
	mov	ecx, eax
	sar	ecx, 1
	add	ecx, esi
	mov	esi, DWORD PTR _nb$1$[ebp]
	mov	eax, DWORD PTR [edx+448]
	mov	DWORD PTR [eax+esi*4], ecx
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [edx+240]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeblockdata.h

; 53   : 	inline int GetY() const { return y; }

	mov	eax, DWORD PTR [eax+52]
	mov	esi, DWORD PTR [eax+edi*4+4]
; File c:\github\mvtools\sources\mvdepan.cpp

; 579  :             blockY[nb] = mvclip.GetBlock(0, nb).GetY() + nBlkSizeY / 2;//j*nBlkSize + nBlkSize/2;//

	mov	eax, DWORD PTR [edx+80]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _nb$1$[ebp]
	mov	ecx, eax
	sar	ecx, 1
	add	ecx, esi
	mov	esi, DWORD PTR _this$[ebx]
	mov	eax, DWORD PTR [esi+452]
	mov	DWORD PTR [eax+edx*4], ecx

; 580  :             if (mask && blockX[nb] < vi.width && blockY[nb] < vi.height)

	cmp	DWORD PTR [esi+424], 0
	je	SHORT $LN29@GetFrame
	mov	eax, DWORD PTR [esi+448]
	mov	edi, DWORD PTR [eax+edx*4]
	cmp	edi, DWORD PTR [esi+16]
	jge	SHORT $LN29@GetFrame
	mov	eax, DWORD PTR [esi+452]
	mov	ecx, DWORD PTR [eax+edx*4]
	cmp	ecx, DWORD PTR [esi+20]
	jge	SHORT $LN29@GetFrame

; 581  :               blockWeightMask[nb] = maskp[blockX[nb] * BPP + blockY[nb] * mask_pitch];

	mov	eax, DWORD PTR _BPP$1$[ebp]
	imul	ecx, DWORD PTR _mask_pitch$1$[ebp]
	imul	eax, edi
	add	eax, DWORD PTR _maskp$1$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	movd	xmm0, eax
	mov	eax, DWORD PTR [esi+460]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [eax+edx*4], xmm0

; 582  :             else

	jmp	SHORT $LN30@GetFrame
$LN29@GetFrame:

; 583  :               blockWeightMask[nb] = 1;

	mov	eax, DWORD PTR [esi+460]
	mov	DWORD PTR [eax+edx*4], 1065353216	; 3f800000H
$LN30@GetFrame:

; 584  :             blockWeight[nb] = blockWeightMask[nb];

	mov	eax, DWORD PTR [esi+460]
	mov	ecx, DWORD PTR [esi+456]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	eax, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR [esi+64]
	inc	eax
	mov	edx, DWORD PTR _j$1$[ebp]
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, ecx
	jl	$LL10@GetFrame
$LN5@GetFrame:

; 570  :         for (int j = 0; j < nBlkY; j++)

	inc	edx
	mov	DWORD PTR _j$1$[ebp], edx
	cmp	edx, DWORD PTR [esi+68]
	jl	$LL7@GetFrame
$LN6@GetFrame:
	movd	xmm1, DWORD PTR _nFields$1$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [esi+424], eax
	mov	ecx, 4
	cvtdq2ps xmm1, xmm1
	cmove	eax, ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 945  :   operator void*() const { return p; }

	mov	DWORD PTR tv2791[ebp], 5
	mov	DWORD PTR tv2792[ebp], eax
; File c:\github\mvtools\sources\mvdepan.cpp

; 609  :         for (; iter < 5; iter++)

	mov	DWORD PTR _iter$1$[ebp], 5
	movss	DWORD PTR tv2700[ebp], xmm1
$LL13@GetFrame:

; 610  :         {
; 611  :           TrasformUpdate(&tr, blockDx, blockDy, blockSAD, blockX, blockY, blockWeight, nBlkX, nBlkY, safety, ifZoom0, ifRot0, &errorcur, pixaspect / nFields);

	mov	eax, DWORD PTR _this$[ebx]
	mov	esi, DWORD PTR [esi+68]
	push	ecx
	lea	ecx, DWORD PTR _errorcur$[ebp]
	movss	xmm0, DWORD PTR [eax+396]
	divss	xmm0, xmm1
	mov	edi, DWORD PTR [eax+64]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	push	0
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1050253722		; 3e99999aH
	push	esi
	push	edi
	push	DWORD PTR [eax+456]
	push	DWORD PTR [eax+452]
	push	DWORD PTR [eax+448]
	push	ecx
	push	DWORD PTR [eax+440]
	push	DWORD PTR [eax+436]
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	call	?TrasformUpdate@MVDepan@@AAEXPAUtransformstruct@@QAM1QAH221HHM_N3PAMM@Z ; MVDepan::TrasformUpdate

; 612  :           RejectBadBlocks(tr, blockDx, blockDy, blockSAD, blockX, blockY, blockWeight, nBlkX, nBlkY, wrongDif, globalDif0, mvclip.GetThSCD1(), zeroWeight, blockWeightMask, ignoredBorder);

	push	DWORD PTR tv2792[ebp]
	mov	ecx, DWORD PTR _this$[ebx]
	push	DWORD PTR [ecx+460]
	movss	xmm0, DWORD PTR [ecx+412]
	push	ecx
	mov	DWORD PTR [esp], 1028443341		; 3d4ccccdH
	push	DWORD PTR [ecx+368]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1148846080		; 447a0000H
	movss	DWORD PTR [esp], xmm0
	push	esi
	movups	xmm0, XMMWORD PTR _tr$[ebp]
	mov	esi, ecx
	push	edi
	push	DWORD PTR [esi+456]
	push	DWORD PTR [esi+452]
	push	DWORD PTR [esi+448]
	push	DWORD PTR [esi+444]
	push	DWORD PTR [esi+440]
	push	DWORD PTR [esi+436]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR _tr$[ebp+16]
	movq	QWORD PTR [eax+16], xmm0
	call	?RejectBadBlocks@MVDepan@@AAEXUtransformstruct@@QAM1QAH221HHMMHM1H@Z ; MVDepan::RejectBadBlocks
	sub	DWORD PTR tv2791[ebp], 1
	movss	xmm1, DWORD PTR tv2700[ebp]
	jne	$LL13@GetFrame

; 609  :         for (; iter < 5; iter++)

	movss	xmm0, DWORD PTR _errorcur$[ebp]
	mov	edi, DWORD PTR _iter$1$[ebp]
	movss	DWORD PTR _errorprev$1$[ebp], xmm0
$LL16@GetFrame:

; 617  :         {
; 618  :           if (iter < 8)

	cmp	edi, 8
	jge	SHORT $LN33@GetFrame

; 619  :             safety = 0.3f; // use for safety

	movss	xmm1, DWORD PTR __real@3e99999a
	jmp	SHORT $LN36@GetFrame
$LN33@GetFrame:

; 620  :           else if (iter < 10)

	cmp	edi, 10					; 0000000aH
	jge	SHORT $LN35@GetFrame

; 621  :             safety = 0.6f;

	movss	xmm1, DWORD PTR __real@3f19999a

; 622  :           else

	jmp	SHORT $LN36@GetFrame
$LN35@GetFrame:

; 623  :             safety = 1.0f;

	movss	xmm1, DWORD PTR __real@3f800000
$LN36@GetFrame:

; 624  :           float errorprev = errorcur;
; 625  :           TrasformUpdate(&tr, blockDx, blockDy, blockSAD, blockX, blockY, blockWeight, nBlkX, nBlkY, safety, ifZoom, ifRot, &errorcur, pixaspect / nFields);

	movss	xmm0, DWORD PTR [esi+396]
	lea	eax, DWORD PTR _errorcur$[ebp]
	divss	xmm0, DWORD PTR tv2700[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	movzx	eax, BYTE PTR [esi+393]
	push	eax
	movzx	eax, BYTE PTR [esi+392]
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm1
	lea	eax, DWORD PTR _tr$[ebp]
	push	DWORD PTR [esi+68]
	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+456]
	push	DWORD PTR [esi+452]
	push	DWORD PTR [esi+448]
	push	ecx
	push	DWORD PTR [esi+440]
	push	DWORD PTR [esi+436]
	push	eax
	call	?TrasformUpdate@MVDepan@@AAEXPAUtransformstruct@@QAM1QAH221HHM_N3PAMM@Z ; MVDepan::TrasformUpdate

; 626  :           if (((errorprev - errorcur) < errordif*0.5 && iter > 9) || errorcur < errordif) break; // check convergence, accuracy increased in v1.2.5

	movss	xmm0, DWORD PTR _errorprev$1$[ebp]
	movss	xmm1, DWORD PTR _errorcur$[ebp]
	movss	xmm2, DWORD PTR __real@3ba3d70a
	subss	xmm0, xmm1
	movss	DWORD PTR _errorprev$1$[ebp], xmm1
	comiss	xmm2, xmm0
	jbe	SHORT $LN39@GetFrame
	cmp	edi, 9
	jg	$LN524@GetFrame
$LN39@GetFrame:
	movss	xmm0, DWORD PTR __real@3c23d70a
	comiss	xmm0, xmm1
	ja	$LN524@GetFrame

; 627  :           float globalDif = errorcur * 2;
; 628  :           RejectBadBlocks(tr, blockDx, blockDy, blockSAD, blockX, blockY, blockWeight, nBlkX, nBlkY, wrongDif, globalDif, mvclip.GetThSCD1(), zeroWeight, blockWeightMask, ignoredBorder);

	push	DWORD PTR tv2792[ebp]
	movaps	xmm0, xmm1
	push	DWORD PTR [esi+460]
	mulss	xmm0, DWORD PTR __real@40000000
	push	ecx
	mov	DWORD PTR [esp], 1028443341		; 3d4ccccdH
	push	DWORD PTR [esi+368]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [esi+412]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [esi+68]
	movups	xmm0, XMMWORD PTR _tr$[ebp]
	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+456]
	push	DWORD PTR [esi+452]
	push	DWORD PTR [esi+448]
	push	DWORD PTR [esi+444]
	push	DWORD PTR [esi+440]
	push	DWORD PTR [esi+436]
	sub	esp, 24					; 00000018H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR _tr$[ebp+16]
	movq	QWORD PTR [eax+16], xmm0
	call	?RejectBadBlocks@MVDepan@@AAEXUtransformstruct@@QAM1QAH221HHMMHM1H@Z ; MVDepan::RejectBadBlocks
	inc	edi
	cmp	edi, 100				; 00000064H
	jl	$LL16@GetFrame
$LN524@GetFrame:

; 613  :         }
; 614  : 
; 615  : 
; 616  :         for (; iter < 100; iter++)

	movss	xmm1, DWORD PTR _tr$[ebp+16]
	mov	DWORD PTR _iter$1$[ebp], edi
	jmp	SHORT $LN38@GetFrame
$LN529@GetFrame:
	movss	xmm1, DWORD PTR _tr$1$[ebp]
$LN38@GetFrame:
	movd	xmm0, DWORD PTR [esi+16]

; 629  :         }
; 630  : 
; 631  :       }
; 632  : 
; 633  :       // we get transform (null if scenechange)
; 634  : 
; 635  :       float xcenter = (float)vi.width / 2;
; 636  :       float ycenter = (float)vi.height / 2;
; 637  : 
; 638  :       motionx[nframe] = 0;

	mov	eax, DWORD PTR [esi+464]
	mov	edx, DWORD PTR tv2776[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _xcenter$1$[ebp], xmm0
	movd	xmm0, DWORD PTR [esi+20]
	mov	DWORD PTR [edx+eax], 0

; 639  :       motiony[nframe] = 0;

	mov	eax, DWORD PTR [esi+468]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [edx+eax], 0

; 640  :       motionrot[nframe] = 0;

	mov	eax, DWORD PTR [esi+476]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	DWORD PTR [edx+eax], 0

; 641  :       motionzoom[nframe] = 1;

	mov	eax, DWORD PTR [esi+472]
	movss	DWORD PTR _ycenter$1$[ebp], xmm0
	mov	DWORD PTR [edx+eax], 1065353216		; 3f800000H

; 642  : 
; 643  :       if (errorcur < error) // if not bad result

	movss	xmm0, DWORD PTR [esi+400]
	comiss	xmm0, DWORD PTR _errorprev$1$[ebp]
	jbe	$LN46@GetFrame
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [esi+296]
; File c:\github\mvtools\sources\mvdepan.cpp

; 646  :         if (mvclip.IsBackward())

	test	al, al
	je	$LN41@GetFrame

; 319  :   if (ta.dxy != 0) pixaspect = sqrt(-ta.dyx / ta.dxy);

	movss	xmm5, DWORD PTR _tr$[ebp+8]
	xorps	xmm0, xmm0
	ucomiss	xmm5, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN364@GetFrame
	divss	xmm1, xmm5
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 305  : 	return (_CSTD sqrtf(_Xx));

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 306  : 	}

	movss	xmm5, DWORD PTR _tr$[ebp+8]
	xorps	xmm7, xmm7
	mov	edx, DWORD PTR tv2776[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	cvtsd2ss xmm7, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 306  : 	}

	jmp	SHORT $LN365@GetFrame
$LN364@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 320  :   else pixaspect = 1.0;

	movss	xmm7, DWORD PTR __real@3f800000
$LN365@GetFrame:

; 321  : 
; 322  :   tinv->dxx = ta.dxx / ((ta.dxx)*ta.dxx + ta.dxy*ta.dxy*pixaspect*pixaspect);

	movss	xmm2, DWORD PTR _tr$[ebp+4]
	movaps	xmm1, xmm5
	mulss	xmm1, xmm5
	movaps	xmm0, xmm2

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	mov	eax, DWORD PTR [esi+464]

; 322  :   tinv->dxx = ta.dxx / ((ta.dxx)*ta.dxx + ta.dxy*ta.dxy*pixaspect*pixaspect);

	mulss	xmm0, xmm2
	movaps	xmm4, xmm2

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	mov	ecx, DWORD PTR _this$[ebx]
	add	eax, edx

; 322  :   tinv->dxx = ta.dxx / ((ta.dxx)*ta.dxx + ta.dxy*ta.dxy*pixaspect*pixaspect);

	mulss	xmm1, xmm7

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	mov	DWORD PTR _dx$1$[ebp], eax
	mov	eax, DWORD PTR [esi+468]
	mov	edi, DWORD PTR [ecx+472]
	add	eax, edx

; 322  :   tinv->dxx = ta.dxx / ((ta.dxx)*ta.dxx + ta.dxy*ta.dxy*pixaspect*pixaspect);

	mulss	xmm1, xmm7

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	add	edi, edx
	mov	DWORD PTR _dy$1$[ebp], eax

; 322  :   tinv->dxx = ta.dxx / ((ta.dxx)*ta.dxx + ta.dxy*ta.dxy*pixaspect*pixaspect);

	addss	xmm1, xmm0

; 323  :   tinv->dyy = tinv->dxx;
; 324  :   tinv->dxy = -tinv->dxx * ta.dxy / ta.dxx;

	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm4, xmm1

; 647  :         {
; 648  :           transform trinv;
; 649  :           inversetransform(tr, &trinv);
; 650  :           transform2motion(trinv, 0, xcenter, ycenter, pixaspect / nFields, &motionx[nframe], &motiony[nframe], &motionrot[nframe], &motionzoom[nframe]);

	movss	xmm1, DWORD PTR [esi+396]

; 324  :   tinv->dxy = -tinv->dxx * ta.dxy / ta.dxx;

	movaps	xmm3, xmm4

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	mov	esi, DWORD PTR [esi+476]

; 324  :   tinv->dxy = -tinv->dxx * ta.dxy / ta.dxx;

	mulss	xmm3, xmm5

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	add	esi, edx

; 326  :   tinv->dxc = -tinv->dxx * ta.dxc - tinv->dxy * ta.dyc;

	movaps	xmm5, xmm4
	movss	DWORD PTR _trinv$1$[ebp], xmm4
	mulss	xmm5, DWORD PTR _tr$[ebp]
	divss	xmm3, xmm2
	xorps	xmm5, xmm0
	xorps	xmm3, xmm0
	movaps	xmm6, xmm3
	mulss	xmm6, xmm7
	mulss	xmm6, xmm7
	xorps	xmm6, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _tr$[ebp+12]

; 327  :   tinv->dyc = -tinv->dyx * ta.dxc - tinv->dyy * ta.dyc;

	mulss	xmm6, DWORD PTR _tr$[ebp]
	subss	xmm5, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _tr$[ebp+12]
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm6, xmm0
	movss	DWORD PTR _trinv$4$[ebp], xmm5
	movd	xmm0, DWORD PTR _nFields$1$[ebp]

; 647  :         {
; 648  :           transform trinv;
; 649  :           inversetransform(tr, &trinv);
; 650  :           transform2motion(trinv, 0, xcenter, ycenter, pixaspect / nFields, &motionx[nframe], &motiony[nframe], &motionrot[nframe], &motionzoom[nframe]);

	cvtdq2ps xmm0, xmm0

; 327  :   tinv->dyc = -tinv->dyx * ta.dxc - tinv->dyy * ta.dyc;

	movss	DWORD PTR _trinv$5$[ebp], xmm6

; 647  :         {
; 648  :           transform trinv;
; 649  :           inversetransform(tr, &trinv);
; 650  :           transform2motion(trinv, 0, xcenter, ycenter, pixaspect / nFields, &motionx[nframe], &motiony[nframe], &motionrot[nframe], &motionzoom[nframe]);

	divss	xmm1, xmm0
	xorps	xmm0, xmm0

; 283  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	mulss	xmm3, xmm1

; 647  :         {
; 648  :           transform trinv;
; 649  :           inversetransform(tr, &trinv);
; 650  :           transform2motion(trinv, 0, xcenter, ycenter, pixaspect / nFields, &motionx[nframe], &motiony[nframe], &motionrot[nframe], &motionzoom[nframe]);

	movss	DWORD PTR _pixaspect$1$[ebp], xmm1

; 283  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	divss	xmm3, xmm4
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 625  :         return (float)atan(_X);

	cvtss2sd xmm0, xmm3
	call	__libm_sse2_atan_precise
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 283  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000

; 284  :     *rot = rotradian * 180 / PI;

	movaps	xmm0, xmm1
	movss	DWORD PTR _rotradian$1$[ebp], xmm1
	mulss	xmm0, DWORD PTR __real@43340000
	divss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [esi], xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sin_precise

; 635  :         return (float)cos(_X);

	movss	xmm1, DWORD PTR _rotradian$1$[ebp]

; 736  :         return (float)sin(_X);

	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinus$1$[ebp], xmm0

; 635  :         return (float)cos(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\mvdepan.cpp

; 287  :     *zoom = tr.dxx / cosinus;

	movss	xmm5, DWORD PTR _trinv$1$[ebp]
	xorps	xmm3, xmm3
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	cvtsd2ss xmm3, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 298  :     *dx = tr.dxc / (*zoom)*cosinus + tr.dyc / (*zoom) / pixaspect*sinus - xcenter / (*zoom)*cosinus + xcenter - ycenter / (*zoom) / pixaspect*sinus;

	movss	xmm7, DWORD PTR _trinv$5$[ebp]
	divss	xmm5, xmm3
	movaps	xmm1, xmm7
	movss	xmm4, DWORD PTR _pixaspect$1$[ebp]
	divss	xmm1, xmm5
	movss	xmm2, DWORD PTR _sinus$1$[ebp]
	movss	DWORD PTR [edi], xmm5
	divss	xmm1, xmm4
	movss	xmm6, DWORD PTR _trinv$4$[ebp]
	movaps	xmm0, xmm6
	mulss	xmm1, xmm2
	mov	eax, DWORD PTR _dx$1$[ebp]
	divss	xmm0, xmm5
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _xcenter$1$[ebp]
	divss	xmm0, xmm5
	mulss	xmm0, xmm3
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _ycenter$1$[ebp]
	divss	xmm0, xmm5
	addss	xmm1, DWORD PTR _xcenter$1$[ebp]
	divss	xmm0, xmm4
	mulss	xmm0, xmm2
	subss	xmm1, xmm0

; 299  : 
; 300  :     // *sinus:
; 301  :     //		tr.dxc/(*zoom)*sinus = xcenter/(*zoom)*sinus + (-xcenter + dx)*cosinus*sinus - ((-ycenter)/pixaspect + dy)*sinus*sinus ;
; 302  :     // *cosinus:
; 303  :     //		tr.dyc/(*zoom)/pixaspect*cosinus = ycenter/(*zoom)/pixaspect*cosinus +  ((-ycenter)/pixaspect +dy)*cosinus*cosinus + (-xcenter + dx)*sinus*cosinus ;
; 304  :     // diff:
; 305  :     //		tr.dxc/(*zoom)*sinus - tr.dyc/(*zoom)/pixaspect*cosinus = xcenter/(*zoom)*sinus - (-ycenter/pixaspect + dy) - ycenter/(*zoom)/pixaspect*cosinus   ;
; 306  :     *dy = -tr.dxc / (*zoom)*sinus + tr.dyc / (*zoom) / pixaspect*cosinus + xcenter / (*zoom)*sinus - (-ycenter / pixaspect) - ycenter / (*zoom) / pixaspect*cosinus;

	movss	xmm0, DWORD PTR _xcenter$1$[ebp]
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [edi]
	divss	xmm7, xmm1
	mov	eax, DWORD PTR _dy$1$[ebp]
	divss	xmm6, xmm1
	divss	xmm7, xmm4
	divss	xmm0, xmm1
	mulss	xmm6, xmm2
	mulss	xmm7, xmm3
	mulss	xmm0, xmm2
	movss	xmm2, DWORD PTR _ycenter$1$[ebp]
	subss	xmm7, xmm6
	addss	xmm7, xmm0
	movaps	xmm0, xmm2
	divss	xmm2, xmm1
	divss	xmm0, xmm4
	divss	xmm2, xmm4
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm7, xmm0
	mulss	xmm2, xmm3
	subss	xmm7, xmm2
	movss	DWORD PTR [eax], xmm7

; 651  :         }
; 652  :         else

	jmp	$LN408@GetFrame
$LN41@GetFrame:
	movd	xmm0, DWORD PTR _nFields$1$[ebp]

; 653  :           transform2motion(tr, 1, xcenter, ycenter, pixaspect / nFields, &motionx[nframe], &motiony[nframe], &motionrot[nframe], &motionzoom[nframe]);

	movss	xmm1, DWORD PTR [esi+396]
	cvtdq2ps xmm0, xmm0
	mov	eax, DWORD PTR [esi+468]
	mov	ecx, DWORD PTR _this$[ebx]
	add	eax, edx
	mov	edi, DWORD PTR [esi+464]
	mov	esi, DWORD PTR [esi+476]
	add	edi, edx
	mov	DWORD PTR _dy$1$[ebp], eax
	add	esi, edx
	divss	xmm1, xmm0
	mov	eax, DWORD PTR [ecx+472]
	add	eax, edx
	mov	DWORD PTR _zoom$1$[ebp], eax

; 273  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	movaps	xmm0, xmm1

; 653  :           transform2motion(tr, 1, xcenter, ycenter, pixaspect / nFields, &motionx[nframe], &motiony[nframe], &motionrot[nframe], &motionzoom[nframe]);

	movss	DWORD PTR _pixaspect$1$[ebp], xmm1

; 273  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	mulss	xmm0, DWORD PTR _tr$[ebp+8]
	divss	xmm0, DWORD PTR _tr$[ebp+4]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 625  :         return (float)atan(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_atan_precise
	xorps	xmm1, xmm1
	cvtsd2ss xmm1, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 273  :     rotradian = -atan(pixaspect*tr.dxy / tr.dxx);

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000

; 274  :     *rot = rotradian * 180 / PI;

	movaps	xmm0, xmm1
	movss	DWORD PTR _rotradian$1$[ebp], xmm1
	mulss	xmm0, DWORD PTR __real@43340000
	divss	xmm0, DWORD PTR __real@40490fdb
	movss	DWORD PTR [esi], xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sin_precise

; 635  :         return (float)cos(_X);

	movss	xmm1, DWORD PTR _rotradian$1$[ebp]

; 736  :         return (float)sin(_X);

	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sinus$1$[ebp], xmm0

; 635  :         return (float)cos(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_cos_precise
; File c:\github\mvtools\sources\mvdepan.cpp

; 278  :     *dx = tr.dxc - xcenter - (-xcenter*cosinus + ycenter / pixaspect*sinus)*(*zoom);

	movss	xmm7, DWORD PTR _ycenter$1$[ebp]
	xorps	xmm3, xmm3
	divss	xmm7, DWORD PTR _pixaspect$1$[ebp]
	mov	eax, DWORD PTR _zoom$1$[ebp]
	movss	xmm5, DWORD PTR _tr$[ebp+4]
	movss	xmm4, DWORD PTR _sinus$1$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	cvtsd2ss xmm3, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 278  :     *dx = tr.dxc - xcenter - (-xcenter*cosinus + ycenter / pixaspect*sinus)*(*zoom);

	movss	xmm2, DWORD PTR _tr$[ebp]
	movaps	xmm1, xmm4
	divss	xmm5, xmm3
	movaps	xmm0, xmm3
	mulss	xmm1, xmm7
	mulss	xmm0, DWORD PTR _xcenter$1$[ebp]
	subss	xmm2, DWORD PTR _xcenter$1$[ebp]

; 279  :     *dy = tr.dyc / pixaspect - ycenter / pixaspect - ((-ycenter) / pixaspect*cosinus + (-xcenter)*sinus)*(*zoom);// dyc

	mulss	xmm4, DWORD PTR _xcenter$1$[ebp]
	subss	xmm1, xmm0
	mulss	xmm3, xmm7
	movss	xmm0, DWORD PTR _tr$[ebp+12]
	divss	xmm0, DWORD PTR _pixaspect$1$[ebp]
	addss	xmm3, xmm4
	movss	DWORD PTR [eax], xmm5
	mulss	xmm1, xmm5
	subss	xmm0, xmm7
	subss	xmm2, xmm1
	movss	DWORD PTR [edi], xmm2
	mulss	xmm3, DWORD PTR [eax]
	mov	eax, DWORD PTR _dy$1$[ebp]
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm0, xmm3
	movss	DWORD PTR [eax], xmm0
$LN408@GetFrame:

; 654  : 
; 655  :         // fieldbased correction - added in v1.2.3
; 656  :         int isnframeodd = nframe % 2;  // =0 for even,    =1 for odd

	mov	esi, DWORD PTR _nframe$1$[ebp]
	and	esi, -2147483647			; 80000001H
	jns	SHORT $LN533@GetFrame
	dec	esi
	or	esi, -2					; fffffffeH
	inc	esi
$LN533@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN531@GetFrame
	cmp	DWORD PTR [eax], 64			; 00000040H
	jbe	SHORT $LN531@GetFrame
	mov	edi, DWORD PTR tv2558[ebp]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+64]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvdepan.cpp

; 658  :         if (vi.IsFieldBased()) { // correct line shift for fields, if not scenechange

	test	al, al
	je	SHORT $LN531@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 640  :   bool IsTFF() const AVS_BakedCode(return AVS_LinkCall(IsTFF)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN525@GetFrame
	cmp	DWORD PTR [eax], 76			; 0000004cH
	jbe	SHORT $LN525@GetFrame
	mov	eax, DWORD PTR [eax+76]
	mov	ecx, edi
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvdepan.cpp

; 661  :             if (vi.IsTFF())

	test	al, al
	je	SHORT $LN525@GetFrame

; 662  :               yadd += 0.5f - isnframeodd; // TFF

	movss	xmm1, DWORD PTR __real@3f000000
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0

; 663  :             else

	jmp	SHORT $LN45@GetFrame
$LN525@GetFrame:
	movd	xmm1, esi

; 664  :               yadd += -0.5f + isnframeodd; // BFF (or undefined?)

	cvtdq2ps xmm1, xmm1
	subss	xmm1, DWORD PTR __real@3f000000
$LN45@GetFrame:

; 665  :           }
; 666  :           // scale dy for fieldbased frame by factor 2 (for compatibility)
; 667  :           yadd = yadd * 2;
; 668  :           motiony[nframe] += yadd;

	mov	esi, DWORD PTR _this$[ebx]
	xorps	xmm0, xmm0
	mov	edx, DWORD PTR tv2776[ebp]
	addss	xmm1, xmm0
	mov	eax, DWORD PTR [esi+468]
	addss	xmm1, xmm1
	movss	xmm0, DWORD PTR [eax+edx]
	addss	xmm0, xmm1
	movss	DWORD PTR [eax+edx], xmm0
	jmp	SHORT $LN43@GetFrame
$LN531@GetFrame:
	mov	esi, DWORD PTR _this$[ebx]
	mov	edx, DWORD PTR tv2776[ebp]
$LN43@GetFrame:

; 671  :         if (fabs(motionx[nframe]) < 0.01f)  // if it is accidentally very small, reset it to small, but non-zero value ,

	mov	eax, DWORD PTR [esi+464]
	movss	xmm1, DWORD PTR __real@3c23d70a
	movss	xmm0, DWORD PTR [edx+eax]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\github\mvtools\sources\mvdepan.cpp

; 671  :         if (fabs(motionx[nframe]) < 0.01f)  // if it is accidentally very small, reset it to small, but non-zero value ,

	comiss	xmm1, xmm0
	jbe	SHORT $LN46@GetFrame

; 672  :           motionx[nframe] = (2 * rand() - RAND_MAX) > 0 ? 0.011f : -0.011f; // to differ from pure 0, which be interpreted as bad value mark (scene change)

	call	DWORD PTR __imp__rand
	lea	eax, DWORD PTR [eax*2-32767]
	test	eax, eax
	jle	SHORT $LN52@GetFrame
	movss	xmm0, DWORD PTR __real@3c343958
	jmp	SHORT $LN53@GetFrame
$LN52@GetFrame:
	movss	xmm0, DWORD PTR __real@bc343958
$LN53@GetFrame:
	mov	eax, DWORD PTR [esi+464]
	mov	ecx, DWORD PTR tv2776[ebp]
	movss	DWORD PTR [ecx+eax], xmm0
$LN46@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN455@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN455@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvn$5[ebp]
	call	eax
$LN455@GetFrame:
	mov	edi, DWORD PTR _iter$1$[ebp]
	mov	edx, DWORD PTR _nframe$1$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
$LN454@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 679  :     if (info && nframe == ndest) // type text info to output frame

	cmp	BYTE PTR [esi+404], 0
	je	$LN2@GetFrame
	cmp	edx, DWORD PTR _ndest$[ebx]
	jne	$LN2@GetFrame

; 680  :     {
; 681  :       int xmsg = 0;
; 682  :       int ymsg = 1;
; 683  : 
; 684  :       sprintf_s(messagebuf, "MVDepan data");

	add	esi, 480				; 000001e0H
	push	OFFSET ??_C@_0N@HIMCJIOC@MVDepan?5data?$AA@
	push	esi
	call	??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ	; sprintf_s<128>

; 685  :       DrawString(dst, vi, xmsg, ymsg, messagebuf);

	mov	edx, DWORD PTR tv2558[ebp]
	add	esp, 8
	push	esi
	push	1
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	call	?DrawString@@YAXAAVPVideoFrame@@AAUVideoInfo@@HHPBD@Z ; DrawString
	movss	xmm0, DWORD PTR _errorprev$1$[ebp]

; 686  : 
; 687  :       sprintf_s(messagebuf, "fn=%5d iter=%3d error=%7.3f", nframe, iter, errorcur);

	add	esp, 4
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	edi
	push	DWORD PTR _nframe$1$[ebp]
	push	OFFSET ??_C@_0BM@NJFLLIJH@fn?$DN?$CF5d?5iter?$DN?$CF3d?5error?$DN?$CF7?43f?$AA@
	push	esi
	call	??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ	; sprintf_s<128>

; 688  :       ymsg++;
; 689  :       DrawString(dst, vi, xmsg, ymsg, messagebuf);

	mov	edi, DWORD PTR tv2558[ebp]
	add	esp, 24					; 00000018H
	mov	edx, edi
	push	esi
	push	2
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	call	?DrawString@@YAXAAVPVideoFrame@@AAUVideoInfo@@HHPBD@Z ; DrawString

; 690  : 
; 691  :       sprintf_s(messagebuf, "     dx      dy     rot    zoom");

	push	OFFSET ??_C@_0CA@CANPJNCH@?5?5?5?5?5dx?5?5?5?5?5?5dy?5?5?5?5?5rot?5?5?5?5zoom?$AA@
	push	esi
	call	??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ	; sprintf_s<128>
	add	esp, 20					; 00000014H

; 692  :       ymsg++;
; 693  :       DrawString(dst, vi, xmsg, ymsg, messagebuf);

	mov	edx, edi
	push	esi
	push	3
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	call	?DrawString@@YAXAAVPVideoFrame@@AAUVideoInfo@@HHPBD@Z ; DrawString

; 694  : 
; 695  :       sprintf_s(messagebuf, "%7.2f %7.2f %7.3f %7.5f", motionx[nframe], motiony[nframe], motionrot[nframe], motionzoom[nframe]);

	mov	ecx, DWORD PTR _this$[ebx]
	sub	esp, 20					; 00000014H
	mov	edx, DWORD PTR tv2776[ebp]
	mov	eax, DWORD PTR [ecx+472]
	movss	xmm0, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+476]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+468]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+464]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [eax+edx]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BI@PGPKJDHB@?$CF7?42f?5?$CF7?42f?5?$CF7?43f?5?$CF7?45f?$AA@
	push	esi
	call	??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ	; sprintf_s<128>
	add	esp, 40					; 00000028H

; 696  :       ymsg++;
; 697  :       DrawString(dst, vi, xmsg, ymsg, messagebuf);

	mov	edx, edi
	push	esi
	push	4
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	call	?DrawString@@YAXAAVPVideoFrame@@AAUVideoInfo@@HHPBD@Z ; DrawString
	mov	esi, DWORD PTR _this$[ebx]
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _nframe$1$[ebp]
$LN2@GetFrame:

; 531  : 
; 532  :   float safety;
; 533  :   float errorcur;
; 534  :   int iter;
; 535  :   float errordif = 0.01f; // error difference to terminate iterations
; 536  :   int itermax = 150; // maximum iteration number
; 537  :   float zeroWeight = 0.05f; // zero vector weight
; 538  : 
; 539  :   for (int nframe = framefirst; nframe <= framelast; nframe++)

	inc	edx
	mov	DWORD PTR _nframe$1$[ebp], edx
	cmp	edx, DWORD PTR _framelast$1$[ebp]
	jle	$LL4@GetFrame
$LN3@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edi, edi
	je	SHORT $LN462@GetFrame
	cmp	DWORD PTR [edi], 220			; 000000dcH
	jbe	SHORT $LN462@GetFrame
	mov	eax, DWORD PTR ___$ReturnUdt$[ebx]
	push	0
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+220]
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN463@GetFrame
$LN462@GetFrame:
	xor	eax, eax
$LN463@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 703  :   write_depan_data(dst->GetWritePtr(), framefirst, framelast, motionx, motiony, motionzoom, motionrot);

	push	DWORD PTR [esi+476]
	push	DWORD PTR [esi+472]
	push	DWORD PTR [esi+468]
	push	DWORD PTR [esi+464]
	push	DWORD PTR _framelast$1$[ebp]
	push	DWORD PTR _framefirst$1$[ebp]
	push	eax
	call	?write_depan_data@MVDepan@@AAEXPAEHHQAM111@Z ; MVDepan::write_depan_data

; 704  : 
; 705  :   int nf = (backward) ? ndest : ndest; // set next frame number as data frame if backward
; 706  : //	nframe = ndest; // set next frame number as data frame if backward
; 707  : 
; 708  :   if (logfile != NULL) // write frame number, dx, dy, rotation and zoom in Deshaker log format - aaded in v.1.2.3

	cmp	DWORD PTR [esi+432], 0
	je	$LN48@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 640  :   bool IsTFF() const AVS_BakedCode(return AVS_LinkCall(IsTFF)())

	test	edi, edi
	je	SHORT $LN478@GetFrame
	cmp	DWORD PTR [edi], 76			; 0000004cH
	jbe	SHORT $LN474@GetFrame
	mov	eax, DWORD PTR [edi+76]
	lea	ecx, DWORD PTR [esi+16]
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN474@GetFrame:

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	test	edi, edi
	je	SHORT $LN478@GetFrame
	cmp	DWORD PTR [edi], 64			; 00000040H
	jbe	SHORT $LN478@GetFrame
	mov	eax, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR [esi+16]
	call	eax
	movzx	ecx, al
	jmp	SHORT $LN479@GetFrame
$LN478@GetFrame:
	xor	ecx, ecx
$LN479@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 709  :     write_deshakerlog1(logfile, vi.IsFieldBased(), vi.IsTFF(), nf, motionx[nf], motiony[nf], motionzoom[nf], motionrot[nf]);

	mov	edx, DWORD PTR _ndest$[ebx]
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR [esi+476]
	movss	xmm0, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+472]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+468]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+464]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR [esp], xmm0
	push	edx
	push	ecx
	movzx	eax, cl
	push	eax
	push	DWORD PTR [esi+432]
	call	?write_deshakerlog1@MVDepan@@AAEXPAU_iobuf@@HHHMMMM@Z ; MVDepan::write_deshakerlog1
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN48@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	test	edi, edi
	je	SHORT $LN488@GetFrame
	cmp	DWORD PTR [edi], 272			; 00000110H
	jbe	SHORT $LN488@GetFrame
	mov	eax, DWORD PTR [edi+272]
	lea	ecx, DWORD PTR _maskf$[ebp]
	call	eax
	mov	edi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN488@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	test	edi, edi
	je	SHORT $LN519@GetFrame
	cmp	DWORD PTR [edi], 272			; 00000110H
	jbe	SHORT $LN519@GetFrame
	mov	edx, DWORD PTR [edi+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	edx
$LN519@GetFrame:
; File c:\github\mvtools\sources\mvdepan.cpp

; 712  :   return dst;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebx]

; 713  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	mov	ebx, DWORD PTR [ebp-16]
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN56@GetFrame
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebx]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN56@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _maskf$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR _mvn$5[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVDepan@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVDepan::GetFrame
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT ??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ PROC		; sprintf_s<128>, COMDAT

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	128					; 00000080H
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1499 : }
; 1500 : #endif
; 1501 : 
; 1502 : #if __STDC_WANT_SECURE_LIB__
; 1503 : 
; 1504 :     _Success_(return >= 0)
; 1505 :     _Check_return_opt_
; 1506 :     _CRT_STDIO_INLINE int __CRTDECL vsprintf_s(
; 1507 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1508 :         _In_                          size_t      const _BufferCount,
; 1509 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1510 :                                       va_list           _ArgList
; 1511 :         )
; 1512 : #if defined _NO_CRT_STDIO_INLINE
; 1513 : ;
; 1514 : #else
; 1515 :     {
; 1516 :         return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1517 :     }
; 1518 : #endif
; 1519 :     
; 1520 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
; 1521 :         _Success_(return >= 0)
; 1522 :         int, vsprintf_s,
; 1523 :         _Post_z_                      char,        _Buffer,
; 1524 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1525 :                                       va_list,     _ArgList
; 1526 :         )
; 1527 : 
; 1528 : #endif
; 1529 : 
; 1530 : _Success_(return >= 0)
; 1531 : _Check_return_opt_
; 1532 : _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p_l(
; 1533 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1534 :     _In_                                    size_t      const _BufferCount,
; 1535 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1536 :     _In_opt_                                _locale_t   const _Locale,
; 1537 :                                             va_list           _ArgList
; 1538 :     )
; 1539 : #if defined _NO_CRT_STDIO_INLINE
; 1540 : ;
; 1541 : #else
; 1542 : {
; 1543 :     int const _Result = __stdio_common_vsprintf_p(
; 1544 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1545 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1546 : 
; 1547 :     return _Result < 0 ? -1 : _Result;
; 1548 : }
; 1549 : #endif
; 1550 : 
; 1551 : _Success_(return >= 0)
; 1552 : _Check_return_opt_
; 1553 : _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p(
; 1554 :     _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1555 :     _In_                          size_t      const _BufferCount,
; 1556 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1557 :                                   va_list           _ArgList
; 1558 :     )
; 1559 : #if defined _NO_CRT_STDIO_INLINE
; 1560 : ;
; 1561 : #else
; 1562 : {
; 1563 :     return _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1564 : }
; 1565 : #endif
; 1566 : 
; 1567 : _Success_(return >= 0)
; 1568 : _Check_return_opt_
; 1569 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s_l(
; 1570 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1571 :     _In_                                    size_t      const _BufferCount,
; 1572 :     _In_                                    size_t      const _MaxCount,
; 1573 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1574 :     _In_opt_                                _locale_t   const _Locale,
; 1575 :                                             va_list          _ArgList
; 1576 :     )
; 1577 : #if defined _NO_CRT_STDIO_INLINE
; 1578 : ;
; 1579 : #else
; 1580 : {
; 1581 :     int const _Result = __stdio_common_vsnprintf_s(
; 1582 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1583 :         _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1584 : 
; 1585 :     return _Result < 0 ? -1 : _Result;
; 1586 : }
; 1587 : #endif
; 1588 : 
; 1589 : _Success_(return >= 0)
; 1590 : _Check_return_opt_
; 1591 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s(
; 1592 :     _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1593 :     _In_                          size_t      const _BufferCount,
; 1594 :     _In_                          size_t      const _MaxCount,
; 1595 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1596 :                                   va_list           _ArgList
; 1597 :     )
; 1598 : #if defined _NO_CRT_STDIO_INLINE
; 1599 : ;
; 1600 : #else
; 1601 : {
; 1602 :     return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1603 : }
; 1604 : #endif
; 1605 : 
; 1606 : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1607 :     _Success_(return >= 0)
; 1608 :     int, _vsnprintf_s,
; 1609 :     _Post_z_                      char,        _Buffer,
; 1610 :     _In_                          size_t,      _BufferCount,
; 1611 :     _In_z_ _Printf_format_string_ char const*, _Format,
; 1612 :                                   va_list,     _ArgList
; 1613 :     )
; 1614 : 
; 1615 : #if __STDC_WANT_SECURE_LIB__
; 1616 : 
; 1617 :     _Success_(return >= 0)
; 1618 :     _Check_return_opt_
; 1619 :     _CRT_STDIO_INLINE int __CRTDECL vsnprintf_s(
; 1620 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1621 :         _In_                          size_t      const _BufferCount,
; 1622 :         _In_                          size_t      const _MaxCount,
; 1623 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1624 :                                       va_list           _ArgList
; 1625 :         )
; 1626 : #if defined _NO_CRT_STDIO_INLINE
; 1627 : ;
; 1628 : #else
; 1629 :     {
; 1630 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1631 :     }
; 1632 : #endif
; 1633 :     
; 1634 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1635 :         _Success_(return >= 0)
; 1636 :         int, vsnprintf_s,
; 1637 :         _Post_z_                      char,        _Buffer,
; 1638 :         _In_                          size_t,      _BufferCount,
; 1639 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1640 :                                       va_list,     _ArgList
; 1641 :         )
; 1642 : 
; 1643 : #endif
; 1644 : 
; 1645 : _Check_return_opt_
; 1646 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_l(
; 1647 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1648 :     _In_opt_                                _locale_t   const _Locale,
; 1649 :                                             va_list           _ArgList
; 1650 :     )
; 1651 : #if defined _NO_CRT_STDIO_INLINE
; 1652 : ;
; 1653 : #else
; 1654 : {
; 1655 :     int const _Result = __stdio_common_vsprintf(
; 1656 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1657 :         NULL, 0, _Format, _Locale, _ArgList);
; 1658 : 
; 1659 :     return _Result < 0 ? -1 : _Result;
; 1660 : }
; 1661 : #endif
; 1662 : 
; 1663 : _Check_return_
; 1664 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf(
; 1665 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1666 :                                   va_list           _ArgList
; 1667 :     )
; 1668 : #if defined _NO_CRT_STDIO_INLINE
; 1669 : ;
; 1670 : #else
; 1671 : {
; 1672 :     return _vscprintf_l(_Format, NULL, _ArgList);
; 1673 : }
; 1674 : #endif
; 1675 : 
; 1676 : _Check_return_opt_
; 1677 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p_l(
; 1678 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1679 :     _In_opt_                                _locale_t   const _Locale,
; 1680 :                                             va_list           _ArgList
; 1681 :     )
; 1682 : #if defined _NO_CRT_STDIO_INLINE
; 1683 : ;
; 1684 : #else
; 1685 : {
; 1686 :     int const _Result = __stdio_common_vsprintf_p(
; 1687 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1688 :         NULL, 0, _Format, _Locale, _ArgList);
; 1689 : 
; 1690 :     return _Result < 0 ? -1 : _Result;
; 1691 : }
; 1692 : #endif
; 1693 : 
; 1694 : _Check_return_
; 1695 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p(
; 1696 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1697 :                                   va_list           _ArgList
; 1698 :     )
; 1699 : #if defined _NO_CRT_STDIO_INLINE
; 1700 : ;
; 1701 : #else
; 1702 : {
; 1703 :     return _vscprintf_p_l(_Format, NULL, _ArgList);
; 1704 : }
; 1705 : #endif
; 1706 : 
; 1707 : _Check_return_opt_
; 1708 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c_l(
; 1709 :     _Out_writes_(_BufferCount)              char*       const _Buffer,
; 1710 :     _In_                                    size_t      const _BufferCount,
; 1711 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1712 :     _In_opt_                                _locale_t   const _Locale,
; 1713 :                                             va_list           _ArgList
; 1714 :     )
; 1715 : #if defined _NO_CRT_STDIO_INLINE
; 1716 : ;
; 1717 : #else
; 1718 : {
; 1719 :     int const _Result = __stdio_common_vsprintf(
; 1720 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1721 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1722 : 
; 1723 :     return _Result < 0 ? -1 : _Result;
; 1724 : }
; 1725 : #endif
; 1726 : 
; 1727 : _Success_(return >= 0)
; 1728 : _Check_return_opt_
; 1729 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c(
; 1730 :     _Out_writes_(_BufferCount)    char*       const _Buffer,
; 1731 :     _In_                          size_t      const _BufferCount,
; 1732 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1733 :                                   va_list           _ArgList
; 1734 :     )
; 1735 : #if defined _NO_CRT_STDIO_INLINE
; 1736 : ;
; 1737 : #else
; 1738 : {
; 1739 :     return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1740 : }
; 1741 : #endif
; 1742 : 
; 1743 : _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l)
; 1744 : _CRT_STDIO_INLINE int __CRTDECL _sprintf_l(
; 1745 :     _Pre_notnull_ _Post_z_                  char*       const _Buffer,
; 1746 :     _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1747 :     _In_opt_                                _locale_t   const _Locale,
; 1748 :     ...)
; 1749 : #if defined _NO_CRT_STDIO_INLINE
; 1750 : ;
; 1751 : #else
; 1752 : {
; 1753 :     int _Result;
; 1754 :     va_list _ArgList;
; 1755 :     __crt_va_start(_ArgList, _Locale);
; 1756 : 
; 1757 :     #pragma warning(push)
; 1758 :     #pragma warning(disable: 4996) // Deprecation
; 1759 :     _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
; 1760 :     #pragma warning(pop)
; 1761 : 
; 1762 :     __crt_va_end(_ArgList);
; 1763 :     return _Result;
; 1764 : }
; 1765 : #endif
; 1766 : 
; 1767 : _Success_(return >= 0)
; 1768 : _Check_return_opt_
; 1769 : _CRT_STDIO_INLINE int __CRTDECL sprintf(
; 1770 :     _Pre_notnull_ _Post_z_        char*       const _Buffer,
; 1771 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1772 :     ...)
; 1773 : #if defined _NO_CRT_STDIO_INLINE
; 1774 : ;
; 1775 : #else
; 1776 : {
; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }
; 1789 : #endif
; 1790 : 
; 1791 : #pragma warning(push)
; 1792 : #pragma warning(disable: 4996)
; 1793 : __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(
; 1794 :     _Success_(return >= 0)
; 1795 :     int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, sprintf, vsprintf,
; 1796 :     _Pre_notnull_ _Post_z_,       char,        _Buffer,
; 1797 :     _In_z_ _Printf_format_string_ char const*, _Format
; 1798 :     )
; 1799 : #pragma warning(pop)
; 1800 : 
; 1801 : _Success_(return >= 0)
; 1802 : _Check_return_opt_
; 1803 : _CRT_STDIO_INLINE int __CRTDECL _sprintf_s_l(
; 1804 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1805 :     _In_                                    size_t      const _BufferCount,
; 1806 :     _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1807 :     _In_opt_                                _locale_t   const _Locale,
; 1808 :     ...)
; 1809 : #if defined _NO_CRT_STDIO_INLINE
; 1810 : ;
; 1811 : #else
; 1812 : {
; 1813 :     int _Result;
; 1814 :     va_list _ArgList;
; 1815 :     __crt_va_start(_ArgList, _Locale);
; 1816 :     _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1817 :     __crt_va_end(_ArgList);
; 1818 :     return _Result;
; 1819 : }
; 1820 : #endif
; 1821 : 
; 1822 : #if __STDC_WANT_SECURE_LIB__
; 1823 : 
; 1824 :     _Success_(return >= 0)
; 1825 :     _Check_return_opt_
; 1826 :     _CRT_STDIO_INLINE int __CRTDECL sprintf_s(
; 1827 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1828 :         _In_                          size_t      const _BufferCount,
; 1829 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1830 :         ...)
; 1831 : #if defined _NO_CRT_STDIO_INLINE
; 1832 : ;
; 1833 : #else
; 1834 :     {
; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }
; 1842 : #endif
; 1843 : 
; 1844 : #endif
; 1845 : 
; 1846 : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(

	ret	0
??$sprintf_s@$0IA@@@YAHAAY0IA@DPBDZZ ENDP		; sprintf_s<128>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
END
