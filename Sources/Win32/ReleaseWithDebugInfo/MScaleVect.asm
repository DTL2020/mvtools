; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mscalevect.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DB@HOFMNHAM@MScaleVect?3?5Clip?5does?5not?5contai@ ; `string'
PUBLIC	??_C@_0DI@CEABJFHF@MScaleVect?3?5Scale?5must?5be?51?0?52?0?5@ ; `string'
PUBLIC	??_C@_0DJ@CLCAOODI@MScaleVect?3?5ScaleV?5must?5be?51?0?52?0@ ; `string'
PUBLIC	??_C@_0DC@OCJLJGAB@MScaleVect?3?5Scaling?5creates?5too?5@ ; `string'
PUBLIC	??_C@_0FC@FHENIOPH@MScaleVect?3?5Horizontal?5and?5verti@ ; `string'
PUBLIC	??_C@_0EH@BICBMGCD@MScaleVect?3?5Scaling?5takes?5Subpel@ ; `string'
PUBLIC	??_C@_0DC@BABCNFPC@MScaleVect?3?5Scaling?5creates?5too?5@ ; `string'
PUBLIC	??_C@_0DA@EDKKKMEN@MScaleVect?3?5Scaling?5creates?5non?9@ ; `string'
PUBLIC	??_C@_0DJ@HKFPBANL@MScaleVect?3?5Scaling?5creates?5non?9@ ; `string'
PUBLIC	??_C@_0DA@FJLFKPJE@MScaleVect?3?5Scaling?5creates?5non?9@ ; `string'
PUBLIC	??_C@_0BL@DLMFEHGF@MScaleVect?3?5Internal?5error?$AA@ ; `string'
PUBLIC	??_R4MScaleVect@@6B@				; MScaleVect::`RTTI Complete Object Locator'
PUBLIC	??_7MScaleVect@@6B@				; MScaleVect::`vftable'
PUBLIC	??_R2MScaleVect@@8				; MScaleVect::`RTTI Base Class Array'
PUBLIC	??_R0?AVMScaleVect@@@8				; MScaleVect `RTTI Type Descriptor'
PUBLIC	??_R3MScaleVect@@8				; MScaleVect::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@MScaleVect@@8			; MScaleVect::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@MScaleVect@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MScaleVect@@8 DD FLAT:??_R0?AVMScaleVect@@@8 ; MScaleVect::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MScaleVect@@8
rdata$r	ENDS
;	COMDAT ??_R3MScaleVect@@8
rdata$r	SEGMENT
??_R3MScaleVect@@8 DD 00H				; MScaleVect::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2MScaleVect@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMScaleVect@@@8
data$r	SEGMENT
??_R0?AVMScaleVect@@@8 DD FLAT:??_7type_info@@6B@	; MScaleVect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMScaleVect@@', 00H
data$r	ENDS
;	COMDAT ??_R2MScaleVect@@8
rdata$r	SEGMENT
??_R2MScaleVect@@8 DD FLAT:??_R1A@?0A@EA@MScaleVect@@8	; MScaleVect::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
rdata$r	ENDS
;	COMDAT ??_7MScaleVect@@6B@
CONST	SEGMENT
??_7MScaleVect@@6B@ DD FLAT:??_R4MScaleVect@@6B@	; MScaleVect::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MScaleVect@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMScaleVect@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4MScaleVect@@6B@
rdata$r	SEGMENT
??_R4MScaleVect@@6B@ DD 00H				; MScaleVect::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMScaleVect@@@8
	DD	FLAT:??_R3MScaleVect@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BL@DLMFEHGF@MScaleVect?3?5Internal?5error?$AA@
CONST	SEGMENT
??_C@_0BL@DLMFEHGF@MScaleVect?3?5Internal?5error?$AA@ DB 'MScaleVect: Int'
	DB	'ernal error', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FJLFKPJE@MScaleVect?3?5Scaling?5creates?5non?9@
CONST	SEGMENT
??_C@_0DA@FJLFKPJE@MScaleVect?3?5Scaling?5creates?5non?9@ DB 'MScaleVect:'
	DB	' Scaling creates non-integer padding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HKFPBANL@MScaleVect?3?5Scaling?5creates?5non?9@
CONST	SEGMENT
??_C@_0DJ@HKFPBANL@MScaleVect?3?5Scaling?5creates?5non?9@ DB 'MScaleVect:'
	DB	' Scaling creates non-integer frame dimensions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EDKKKMEN@MScaleVect?3?5Scaling?5creates?5non?9@
CONST	SEGMENT
??_C@_0DA@EDKKKMEN@MScaleVect?3?5Scaling?5creates?5non?9@ DB 'MScaleVect:'
	DB	' Scaling creates non-integer overlap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BABCNFPC@MScaleVect?3?5Scaling?5creates?5too?5@
CONST	SEGMENT
??_C@_0DC@BABCNFPC@MScaleVect?3?5Scaling?5creates?5too?5@ DB 'MScaleVect:'
	DB	' Scaling creates too small a blocksize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@BICBMGCD@MScaleVect?3?5Scaling?5takes?5Subpel@
CONST	SEGMENT
??_C@_0EH@BICBMGCD@MScaleVect?3?5Scaling?5takes?5Subpel@ DB 'MScaleVect: '
	DB	'Scaling takes Subpel out of range (use AdjustSubpel=false)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@FHENIOPH@MScaleVect?3?5Horizontal?5and?5verti@
CONST	SEGMENT
??_C@_0FC@FHENIOPH@MScaleVect?3?5Horizontal?5and?5verti@ DB 'MScaleVect: '
	DB	'Horizontal and vertical scale must be the same when AdjustSub'
	DB	'Pel=true', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OCJLJGAB@MScaleVect?3?5Scaling?5creates?5too?5@
CONST	SEGMENT
??_C@_0DC@OCJLJGAB@MScaleVect?3?5Scaling?5creates?5too?5@ DB 'MScaleVect:'
	DB	' Scaling creates too large a blocksize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CLCAOODI@MScaleVect?3?5ScaleV?5must?5be?51?0?52?0@
CONST	SEGMENT
??_C@_0DJ@CLCAOODI@MScaleVect?3?5ScaleV?5must?5be?51?0?52?0@ DB 'MScaleVe'
	DB	'ct: ScaleV must be 1, 2, 4 or 8 for modes 0 or 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CEABJFHF@MScaleVect?3?5Scale?5must?5be?51?0?52?0?5@
CONST	SEGMENT
??_C@_0DI@CEABJFHF@MScaleVect?3?5Scale?5must?5be?51?0?52?0?5@ DB 'MScaleV'
	DB	'ect: Scale must be 1, 2, 4 or 8 for modes 0 or 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HOFMNHAM@MScaleVect?3?5Clip?5does?5not?5contai@
CONST	SEGMENT
??_C@_0DB@HOFMNHAM@MScaleVect?3?5Clip?5does?5not?5contai@ DB 'MScaleVect:'
	DB	' Clip does not contain motion vectors', 00H	; `string'
PUBLIC	?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MScaleVect::GetFrame
PUBLIC	??1MScaleVect@@UAE@XZ				; MScaleVect::~MScaleVect
PUBLIC	??_GMScaleVect@@UAEPAXI@Z			; MScaleVect::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MScaleVect@@UAGHHH@Z		; MScaleVect::SetCacheHints
PUBLIC	??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z ; MScaleVect::MScaleVect
EXTRN	??_EMScaleVect@@UAEPAXI@Z:PROC			; MScaleVect::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GMScaleVect@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GMScaleVect@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_GMScaleVect@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GMScaleVect@@UAEPAXI@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MScaleVect@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MScaleVect@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MScaleVect@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MScaleVect@@UAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
;	COMDAT ??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_ScaleY$1$ = -36					; size = 8
_ScaleX$1$ = -28					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_Child$ = 8						; size = 4
_Mode$ = 12						; size = 4
_Flip$ = 16						; size = 1
_iScaleY$1$ = 20					; size = 4
_AdjustSubpel$ = 20					; size = 1
_Env$ = 24						; size = 4
??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z PROC ; MScaleVect::MScaleVect, COMDAT
; _this$ = ecx
; _ScaleX$ = xmm2l
; _ScaleY$ = xmm3l

; 13   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, ecx
	movsd	QWORD PTR _ScaleY$1$[ebp], xmm3
	push	edi
	movsd	QWORD PTR _ScaleX$1$[ebp], xmm2
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mscalevect.cpp

; 12   : 	 : mScaleX(ScaleX), mScaleY(ScaleY), mMode(Mode), mAdjustSubpel(AdjustSubpel), GenericVideoFilter( Child ), mRevert (false)

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN35@MScaleVect
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN35@MScaleVect
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _Child$[ebp]
	push	edx
	call	eax
$LN35@MScaleVect:
; File c:\github\mvtools\sources\mscalevect.cpp

; 12   : 	 : mScaleX(ScaleX), mScaleY(ScaleY), mMode(Mode), mAdjustSubpel(AdjustSubpel), GenericVideoFilter( Child ), mRevert (false)

	mov	ecx, esi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter
	mov	eax, DWORD PTR _Mode$[ebp]
	movsd	xmm0, QWORD PTR _ScaleX$1$[ebp]

; 14   : 	// Get vector data
; 15   : 	if (vi.nchannels >= 0 &&  vi.nchannels < 9) 

	mov	edi, DWORD PTR _Env$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [esi+152], eax
	mov	al, BYTE PTR _AdjustSubpel$[ebp]
	movsd	QWORD PTR [esi+160], xmm0
	movsd	xmm0, QWORD PTR _ScaleY$1$[ebp]
	mov	BYTE PTR [esi+176], al
	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [esi], OFFSET ??_7MScaleVect@@6B@
	movsd	QWORD PTR [esi+168], xmm0
	mov	BYTE PTR [esi+177], 0
	test	eax, eax
	js	SHORT $LN2@MScaleVect
	cmp	eax, 9
	jge	SHORT $LN2@MScaleVect

; 16   : 		Env->ThrowError("MScaleVect: Clip does not contain motion vectors");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DB@HOFMNHAM@MScaleVect?3?5Clip?5does?5not?5contai@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@MScaleVect:

; 17   : #if !defined(_WIN64)
; 18   :     mVectorsInfo = *reinterpret_cast<MVAnalysisData *>(vi.nchannels);

	mov	eax, DWORD PTR [esi+56]
	lea	ebx, DWORD PTR [esi+64]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ebx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ebx+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR [ebx+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR [ebx+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	movups	XMMWORD PTR [ebx+64], xmm0
	movq	xmm0, QWORD PTR [eax+80]
	movq	QWORD PTR [ebx+80], xmm0

; 19   : #else
; 20   :     uintptr_t p = (((uintptr_t)(unsigned int)vi.nchannels ^ 0x80000000) << 32) | (uintptr_t)(unsigned int)vi.sample_type;
; 21   :     mVectorsInfo = *reinterpret_cast<MVAnalysisData *>(p);
; 22   : #endif
; 23   : 	if (mVectorsInfo.nMagicKey != MVAnalysisData::MOTION_MAGIC_KEY || mVectorsInfo.nVersion != MVAnalysisData::VERSION) 

	cmp	DWORD PTR [ebx], 22093			; 0000564dH
	jne	SHORT $LN4@MScaleVect
	cmp	DWORD PTR [esi+68], 5
	je	SHORT $LN3@MScaleVect
$LN4@MScaleVect:

; 24   : 		Env->ThrowError("MScaleVect: Clip does not contain motion vectors");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DB@HOFMNHAM@MScaleVect?3?5Clip?5does?5not?5contai@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN3@MScaleVect:

; 25   : #if !defined(_WIN64)
; 26   : 	vi.nchannels = reinterpret_cast <uintptr_t> (&mVectorsInfo);
; 27   : #else
; 28   : 	p = reinterpret_cast <uintptr_t> (&mVectorsInfo);
; 29   : 	vi.nchannels = 0x80000000L | (int)(p >> 32);
; 30   : 	vi.sample_type = (int)(p & 0xffffffffUL);
; 31   : #endif
; 32   : 
; 33   : 	// Scale appropriate fields for different sized frame
; 34   : 	if (mMode == IncreaseBlockSize || mMode == DecreaseBlockSize)

	mov	eax, DWORD PTR [esi+152]
	mov	DWORD PTR [esi+56], ebx
	test	eax, eax
	je	SHORT $LN7@MScaleVect
	cmp	eax, 1
	je	SHORT $LN7@MScaleVect

; 102  : 		}
; 103  : 	}
; 104  : 
; 105  : 	// Scale mode = VectorsOnly, flip the backwards flag as required
; 106  : 	else if (mMode == VectorsOnly && Flip)

	cmp	eax, 2
	jne	$LN11@MScaleVect
	cmp	BYTE PTR _Flip$[ebp], 0
	je	$LN11@MScaleVect

; 107  : 	{
; 108  : 		mVectorsInfo.isBackward = !mVectorsInfo.isBackward;

	cmp	BYTE PTR [esi+92], 0

; 109  : 		mRevert = true;

	mov	BYTE PTR [esi+177], 1
	sete	al
	mov	BYTE PTR [esi+92], al
	jmp	$LN11@MScaleVect
$LN7@MScaleVect:

; 35   : 	{
; 36   : 		// Check for valid scale value. [Tests for equality on integers directly stored in floats are OK]
; 37   : 		if (mScaleX != 1.0 && mScaleX != 2.0 && mScaleX != 4.0 && mScaleX != 8.0)

	movsd	xmm1, QWORD PTR [esi+160]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	xmm2, QWORD PTR __real@4000000000000000
	movsd	xmm3, QWORD PTR __real@4010000000000000
	movsd	xmm4, QWORD PTR __real@4020000000000000
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@MScaleVect
	ucomisd	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@MScaleVect
	ucomisd	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@MScaleVect
	ucomisd	xmm1, xmm4
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN8@MScaleVect

; 38   : 			Env->ThrowError("MScaleVect: Scale must be 1, 2, 4 or 8 for modes 0 or 1");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DI@CEABJFHF@MScaleVect?3?5Scale?5must?5be?51?0?52?0?5@
	push	edi
	call	DWORD PTR [eax+20]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	add	esp, 8
	movsd	xmm2, QWORD PTR __real@4000000000000000
	movsd	xmm3, QWORD PTR __real@4010000000000000
	movsd	xmm4, QWORD PTR __real@4020000000000000
$LN8@MScaleVect:

; 39   : 		if (mScaleY != 1.0 && mScaleY != 2.0 && mScaleY != 4.0 && mScaleY != 8.0)

	movsd	xmm1, QWORD PTR [esi+168]
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@MScaleVect
	ucomisd	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@MScaleVect
	ucomisd	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@MScaleVect
	ucomisd	xmm1, xmm4
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN9@MScaleVect

; 40   : 			Env->ThrowError("MScaleVect: ScaleV must be 1, 2, 4 or 8 for modes 0 or 1");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DJ@CLCAOODI@MScaleVect?3?5ScaleV?5must?5be?51?0?52?0@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN9@MScaleVect:

; 41   : 
; 42   : 		// Switch to integer scaling here for simpler code
; 43   : 		int iScaleX = static_cast<int>(mScaleX);
; 44   : 		int iScaleY = static_cast<int>(mScaleY);
; 45   : 		if (mMode == IncreaseBlockSize)

	cmp	DWORD PTR [esi+152], 0
	cvttsd2si ecx, QWORD PTR [esi+168]

; 46   : 		{
; 47   : 			// Scale to larger frame, check that result will be valid
; 48   : 			if (mVectorsInfo.nBlkSizeX * iScaleX > 32 || mVectorsInfo.nBlkSizeY * iScaleY > 32)

	mov	eax, DWORD PTR [esi+72]
	cvttsd2si ebx, QWORD PTR [esi+160]
	mov	DWORD PTR _iScaleY$1$[ebp], ecx
	jne	$LN10@MScaleVect
	imul	eax, ebx
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN13@MScaleVect
	mov	eax, DWORD PTR [esi+76]
	imul	eax, ecx
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN12@MScaleVect
$LN13@MScaleVect:

; 49   : 				Env->ThrowError("MScaleVect: Scaling creates too large a blocksize");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DC@OCJLJGAB@MScaleVect?3?5Scaling?5creates?5too?5@
	push	edi
	call	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _iScaleY$1$[ebp]
	add	esp, 8
$LN12@MScaleVect:

; 50   : 
; 51   : 			mVectorsInfo.nBlkSizeX = mVectorsInfo.nBlkSizeX * iScaleX;

	mov	eax, DWORD PTR [esi+72]
	imul	eax, ebx
	mov	DWORD PTR [esi+72], eax

; 52   : 			mVectorsInfo.nBlkSizeY = mVectorsInfo.nBlkSizeY * iScaleY;

	mov	eax, DWORD PTR [esi+76]
	imul	eax, ecx
	mov	DWORD PTR [esi+76], eax

; 53   : 			mVectorsInfo.nOverlapX = mVectorsInfo.nOverlapX * iScaleX;

	mov	eax, DWORD PTR [esi+108]
	imul	eax, ebx
	mov	DWORD PTR [esi+108], eax

; 54   : 			mVectorsInfo.nOverlapY = mVectorsInfo.nOverlapY * iScaleY;

	mov	eax, DWORD PTR [esi+112]
	imul	eax, ecx
	mov	DWORD PTR [esi+112], eax

; 55   : 			mVectorsInfo.nWidth    = mVectorsInfo.nWidth    * iScaleX;

	mov	eax, DWORD PTR [esi+100]
	imul	eax, ebx
	mov	DWORD PTR [esi+100], eax

; 56   : 			mVectorsInfo.nHeight   = mVectorsInfo.nHeight   * iScaleY;

	mov	eax, DWORD PTR [esi+104]
	imul	eax, ecx
	mov	DWORD PTR [esi+104], eax

; 57   : 			mVectorsInfo.nHPadding = mVectorsInfo.nHPadding * iScaleX;

	mov	eax, DWORD PTR [esi+144]
	imul	eax, ebx
	mov	DWORD PTR [esi+144], eax

; 58   : 			mVectorsInfo.nVPadding = mVectorsInfo.nVPadding * iScaleY;

	mov	eax, DWORD PTR [esi+148]
	imul	eax, ecx

; 59   : 
; 60   : 			if (mAdjustSubpel) 

	cmp	BYTE PTR [esi+176], 0
	mov	DWORD PTR [esi+148], eax
	je	$LN11@MScaleVect

; 61   : 			{
; 62   : 				if (mScaleX != mScaleY)

	movsd	xmm0, QWORD PTR [esi+160]
	ucomisd	xmm0, QWORD PTR [esi+168]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN15@MScaleVect

; 63   : 					Env->ThrowError("MScaleVect: Horizontal and vertical scale must be the same when AdjustSubPel=true");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0FC@FHENIOPH@MScaleVect?3?5Horizontal?5and?5verti@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN15@MScaleVect:

; 64   : 				mVectorsInfo.nPel /= iScaleX;

	mov	eax, DWORD PTR [esi+80]
	cdq
	idiv	ebx
	mov	DWORD PTR [esi+80], eax

; 65   : 				if (mVectorsInfo.nPel < 1)

	cmp	eax, 1
	jge	$LN11@MScaleVect

; 66   : 					Env->ThrowError("MScaleVect: Scaling takes Subpel out of range (use AdjustSubpel=false)");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0EH@BICBMGCD@MScaleVect?3?5Scaling?5takes?5Subpel@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8

; 67   : 			}
; 68   : 		}
; 69   : 		else

	jmp	$LN11@MScaleVect
$LN10@MScaleVect:

; 70   : 		{
; 71   : 			// Scale to smaller frame, check that result will be valid
; 72   : 			if (mVectorsInfo.nBlkSizeX / iScaleX < 4 || mVectorsInfo.nBlkSizeY / iScaleY < 4)

	cdq
	idiv	ebx
	cmp	eax, 4
	jl	SHORT $LN18@MScaleVect
	mov	eax, DWORD PTR [esi+76]
	cdq
	idiv	ecx
	cmp	eax, 4
	jge	SHORT $LN17@MScaleVect
$LN18@MScaleVect:

; 73   : 				Env->ThrowError("MScaleVect: Scaling creates too small a blocksize");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DC@BABCNFPC@MScaleVect?3?5Scaling?5creates?5too?5@
	push	edi
	call	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _iScaleY$1$[ebp]
	add	esp, 8
$LN17@MScaleVect:

; 74   : 			if (mVectorsInfo.nOverlapX % iScaleX != 0 || mVectorsInfo.nOverlapY % iScaleY != 0 )

	mov	eax, DWORD PTR [esi+108]
	cdq
	idiv	ebx
	test	edx, edx
	jne	SHORT $LN20@MScaleVect
	mov	eax, DWORD PTR [esi+112]
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN19@MScaleVect
$LN20@MScaleVect:

; 75   : 				Env->ThrowError("MScaleVect: Scaling creates non-integer overlap");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DA@EDKKKMEN@MScaleVect?3?5Scaling?5creates?5non?9@
	push	edi
	call	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _iScaleY$1$[ebp]
	add	esp, 8
$LN19@MScaleVect:

; 76   : 			if (mVectorsInfo.nWidth % iScaleX != 0 || mVectorsInfo.nHeight % iScaleY != 0 )

	mov	eax, DWORD PTR [esi+100]
	cdq
	idiv	ebx
	test	edx, edx
	jne	SHORT $LN22@MScaleVect
	mov	eax, DWORD PTR [esi+104]
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN21@MScaleVect
$LN22@MScaleVect:

; 77   : 				Env->ThrowError("MScaleVect: Scaling creates non-integer frame dimensions");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DJ@HKFPBANL@MScaleVect?3?5Scaling?5creates?5non?9@
	push	edi
	call	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _iScaleY$1$[ebp]
	add	esp, 8
$LN21@MScaleVect:

; 78   : 			if (mVectorsInfo.nHPadding % iScaleX != 0 || mVectorsInfo.nVPadding % iScaleY != 0 )

	mov	eax, DWORD PTR [esi+144]
	cdq
	idiv	ebx
	test	edx, edx
	jne	SHORT $LN24@MScaleVect
	mov	eax, DWORD PTR [esi+148]
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN23@MScaleVect
$LN24@MScaleVect:

; 79   : 				Env->ThrowError("MScaleVect: Scaling creates non-integer padding");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DA@FJLFKPJE@MScaleVect?3?5Scaling?5creates?5non?9@
	push	edi
	call	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _iScaleY$1$[ebp]
	add	esp, 8
$LN23@MScaleVect:

; 80   : 
; 81   : 			mVectorsInfo.nBlkSizeX = mVectorsInfo.nBlkSizeX / iScaleX;

	mov	eax, DWORD PTR [esi+72]
	cdq
	idiv	ebx
	mov	DWORD PTR [esi+72], eax

; 82   : 			mVectorsInfo.nBlkSizeY = mVectorsInfo.nBlkSizeY / iScaleY;

	mov	eax, DWORD PTR [esi+76]
	cdq
	idiv	ecx
	mov	DWORD PTR [esi+76], eax

; 83   : 			mVectorsInfo.nOverlapX = mVectorsInfo.nOverlapX / iScaleX;

	mov	eax, DWORD PTR [esi+108]
	cdq
	idiv	ebx
	mov	DWORD PTR [esi+108], eax

; 84   : 			mVectorsInfo.nOverlapY = mVectorsInfo.nOverlapY / iScaleY;

	mov	eax, DWORD PTR [esi+112]
	cdq
	idiv	ecx
	mov	DWORD PTR [esi+112], eax

; 85   : 			mVectorsInfo.nWidth    = mVectorsInfo.nWidth    / iScaleX;

	mov	eax, DWORD PTR [esi+100]
	cdq
	idiv	ebx
	mov	DWORD PTR [esi+100], eax

; 86   : 			mVectorsInfo.nHeight   = mVectorsInfo.nHeight   / iScaleY;

	mov	eax, DWORD PTR [esi+104]
	cdq
	idiv	ecx
	mov	DWORD PTR [esi+104], eax

; 87   : 			mVectorsInfo.nHPadding = mVectorsInfo.nHPadding / iScaleX;

	mov	eax, DWORD PTR [esi+144]
	cdq
	idiv	ebx
	mov	DWORD PTR [esi+144], eax

; 88   : 			mVectorsInfo.nVPadding = mVectorsInfo.nVPadding / iScaleY;

	mov	eax, DWORD PTR [esi+148]
	cdq
	idiv	ecx

; 89   : 
; 90   : 			if (mAdjustSubpel)

	cmp	BYTE PTR [esi+176], 0
	mov	DWORD PTR [esi+148], eax
	je	SHORT $LN27@MScaleVect

; 91   : 			{
; 92   : 				if (mScaleX != mScaleY)

	movsd	xmm0, QWORD PTR [esi+160]
	ucomisd	xmm0, QWORD PTR [esi+168]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@MScaleVect

; 93   : 					Env->ThrowError("MScaleVect: Horizontal and vertical scale must be the same when AdjustSubPel=true");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0FC@FHENIOPH@MScaleVect?3?5Horizontal?5and?5verti@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN26@MScaleVect:

; 94   : 				mVectorsInfo.nPel *= iScaleX;

	mov	eax, DWORD PTR [esi+80]
	imul	eax, ebx
	mov	DWORD PTR [esi+80], eax

; 95   : 				if (mVectorsInfo.nPel > 4)

	cmp	eax, 4
	jle	SHORT $LN27@MScaleVect

; 96   : 					Env->ThrowError("MScaleVect: Scaling takes Subpel out of range (use AdjustSubpel=false)");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0EH@BICBMGCD@MScaleVect?3?5Scaling?5takes?5Subpel@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN27@MScaleVect:

; 97   : 			}
; 98   : 
; 99   : 			// Store actual scaling used for vectors
; 100  : 			mScaleX = 1.0f / mScaleX;

	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	movaps	xmm0, xmm1
	divsd	xmm0, QWORD PTR [esi+160]

; 101  : 			mScaleY = 1.0f / mScaleY;

	divsd	xmm1, QWORD PTR [esi+168]
	movsd	QWORD PTR [esi+160], xmm0
	movsd	QWORD PTR [esi+168], xmm1
$LN11@MScaleVect:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN42@MScaleVect
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN42@MScaleVect
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _Child$[ebp]
	call	eax
$LN42@MScaleVect:
; File c:\github\mvtools\sources\mscalevect.cpp

; 111  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _Child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z$3:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MScaleVect@@QAE@VPClip@@NNW4ScaleMode@0@_N2PAVIScriptEnvironment@@@Z ENDP ; MScaleVect::MScaleVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mscalevect.h
;	COMDAT ?SetCacheHints@MScaleVect@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MScaleVect@@UAGHHH@Z PROC		; MScaleVect::SetCacheHints, COMDAT

; 44   :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 45   :   }

	ret	12					; 0000000cH
?SetCacheHints@MScaleVect@@UAGHHH@Z ENDP		; MScaleVect::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??_GMScaleVect@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GMScaleVect@@UAEPAXI@Z PROC				; MScaleVect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_GMScaleVect@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN12@scalar
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN12@scalar
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN12@scalar:
	test	BYTE PTR ___flags$[ebp], 1

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	je	SHORT $LN18@scalar
	push	184					; 000000b8H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GMScaleVect@@UAEPAXI@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_GMScaleVect@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GMScaleVect@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GMScaleVect@@UAEPAXI@Z ENDP				; MScaleVect::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??1MScaleVect@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MScaleVect@@UAE@XZ PROC				; MScaleVect::~MScaleVect, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MScaleVect@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN14@MScaleVect
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN14@MScaleVect
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN14@MScaleVect:
	mov	ecx, DWORD PTR __$EHRec$[ebp]

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MScaleVect@@UAE@XZ$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MScaleVect@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MScaleVect@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MScaleVect@@UAE@XZ ENDP				; MScaleVect::~MScaleVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mscalevect.cpp
;	COMDAT ?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
_pEnd$1$ = -72						; size = 4
_yMax$1$ = -68						; size = 4
_extendedWidth$1$ = -64					; size = 4
_paddingXScaled$1$ = -60				; size = 4
_extendedHeight$1$ = -56				; size = 4
_yMin$1$ = -52						; size = 4
_levelNumBlocksX$1$ = -52				; size = 4
_heightCovered$1$ = -48					; size = 4
_widthCovered$1$ = -44					; size = 4
_pPlanes$1$ = -40					; size = 4
_src$ = -36						; size = 4
_yEnd$1$ = -32						; size = 4
_level$1$ = -28						; size = 4
_pData$1$ = -28						; size = 4
_y$1$ = -24						; size = 4
_pBlocks$1$ = -24					; size = 4
_x$1$ = -20						; size = 4
_levelNumBlocksY$1$ = -20				; size = 4
_xEnd$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dst$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_paddingYScaled$1$ = 16					; size = 4
tv1279 = 16						; size = 4
_pDst$1$ = 16						; size = 4
_FrameNum$ = 16						; size = 4
_Env$ = 20						; size = 4
?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MScaleVect::GetFrame, COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx

; 117  : 	PVideoFrame src = child->GetFrame(FrameNum, Env);

	mov	ebx, DWORD PTR _Env$[ebp]
	lea	edx, DWORD PTR _src$[ebp]
	push	esi
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	edi, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\mscalevect.cpp

; 117  : 	PVideoFrame src = child->GetFrame(FrameNum, Env);

	push	ebx
	push	DWORD PTR _FrameNum$[ebp]
	mov	DWORD PTR $T2[ebp], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mscalevect.cpp

; 117  : 	PVideoFrame src = child->GetFrame(FrameNum, Env);

	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]

; 118  : 	PVideoFrame dst = Env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [ebx]
	push	eax
	lea	eax, DWORD PTR _dst$[ebp]
	push	eax
	push	ebx
	call	DWORD PTR [ecx+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	ebx, ebx
	je	SHORT $LN41@GetFrame
	cmp	DWORD PTR [ebx], 212			; 000000d4H
	jbe	SHORT $LN41@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ebx+212]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, eax
	mov	DWORD PTR _pData$1$[ebp], eax
	jmp	SHORT $LN42@GetFrame
$LN41@GetFrame:
	xor	esi, esi
	mov	DWORD PTR _pData$1$[ebp], esi
$LN42@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	ebx, ebx
	je	SHORT $LN47@GetFrame
	cmp	DWORD PTR [ebx], 220			; 000000dcH
	jbe	SHORT $LN47@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ebx+220]
	push	0
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN48@GetFrame
$LN47@GetFrame:
	xor	ecx, ecx
	mov	DWORD PTR _pDst$1$[ebp], ecx
$LN48@GetFrame:
; File c:\github\mvtools\sources\mscalevect.cpp

; 123  : 	int headerSize = *pData;

	mov	esi, DWORD PTR [esi]

; 124  : 	memcpy(pDst, pData, headerSize);

	push	esi
	push	DWORD PTR _pData$1$[ebp]
	push	ecx
	call	_memcpy

; 125  : 
; 126  : 	const MVAnalysisData &	hdr_src =
; 127  : 		*reinterpret_cast <const MVAnalysisData *> (pData + 1);
; 128  : 	MVAnalysisData &	hdr_dst =
; 129  : 		*reinterpret_cast <MVAnalysisData *> (pDst + 1);
; 130  : 
; 131  : 	// Use the main header as default value
; 132  : 	// Copy delta and direction from the original frame (for multi-vector clips)
; 133  : 	// Fix the direction if required
; 134  : 	hdr_dst             = mVectorsInfo;

	mov	ecx, DWORD PTR _pDst$1$[ebp]
	movups	xmm0, XMMWORD PTR [edi+64]

; 135  : 	hdr_dst.nDeltaFrame = hdr_src.nDeltaFrame;

	mov	edx, DWORD PTR _pData$1$[ebp]
	movups	XMMWORD PTR [ecx+4], xmm0
	movups	xmm0, XMMWORD PTR [edi+80]
	movups	XMMWORD PTR [ecx+20], xmm0
	movups	xmm0, XMMWORD PTR [edi+96]
	movups	XMMWORD PTR [ecx+36], xmm0
	movups	xmm0, XMMWORD PTR [edi+112]
	movups	XMMWORD PTR [ecx+52], xmm0
	movups	xmm0, XMMWORD PTR [edi+128]
	movups	XMMWORD PTR [ecx+68], xmm0
	movq	xmm0, QWORD PTR [edi+144]
	movq	QWORD PTR [ecx+84], xmm0
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax

; 136  : 	hdr_dst.isBackward  = (!! hdr_src.isBackward) ^ mRevert;

	cmp	BYTE PTR [edx+32], 0
	setne	al

; 137  : 
; 138  : 	// Copy all planes
; 139  : 	pData = reinterpret_cast<const int*>(reinterpret_cast<const char*>(pData) + headerSize);

	add	edx, esi
	xor	al, BYTE PTR [edi+177]
	mov	BYTE PTR [ecx+32], al

; 140  : 	pDst  = reinterpret_cast<int*>(reinterpret_cast<char*>(pDst) + headerSize);

	add	ecx, esi
	mov	DWORD PTR _pDst$1$[ebp], ecx

; 141  : 	memcpy(pDst, pData, *pData * sizeof(int));

	mov	eax, DWORD PTR [edx]
	shl	eax, 2
	push	eax
	push	edx
	push	ecx
	call	_memcpy

; 145  : 	if (pPlanes[1] == 0) return dst; // Marked invalid

	mov	ecx, DWORD PTR _pDst$1$[ebp]
	add	esp, 24					; 00000018H
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN15@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	ebx, ebx
	je	SHORT $LN51@GetFrame
	cmp	DWORD PTR [ebx], 256			; 00000100H
	jbe	SHORT $LN51@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebx+256]
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN51@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	test	ebx, ebx
	je	SHORT $LN55@GetFrame
	cmp	DWORD PTR [ebx], 272			; 00000110H
	jbe	SHORT $LN55@GetFrame
	mov	eax, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN55@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\mscalevect.cpp

; 145  : 	if (pPlanes[1] == 0) return dst; // Marked invalid

	jmp	$LN110@GetFrame
$LN15@GetFrame:

; 146  : 	int* pEnd = pPlanes + *pPlanes;

	mov	eax, DWORD PTR [ecx]

; 147  : 	pPlanes += 2;

	lea	edx, DWORD PTR [ecx+8]
	lea	esi, DWORD PTR [ecx+eax*4]

; 148  : 
; 149  : 	// Changing blocksize is straightforward since scaled vectors are guaranteed to be valid with scaled blocksizes
; 150  : 	if (mMode == IncreaseBlockSize || mMode == DecreaseBlockSize)

	mov	eax, DWORD PTR [edi+152]
	mov	DWORD PTR _pEnd$1$[ebp], esi
	test	eax, eax
	je	$LN81@GetFrame
	cmp	eax, 1
	je	$LN81@GetFrame

; 167  : 			}
; 168  : 		}
; 169  : 	}
; 170  : 
; 171  : 	// If scaling vectors only (blocksize remains same) then must check if new vectors go out of frame
; 172  : 	else if (mMode == VectorsOnly)

	cmp	eax, 2
	jne	$LN3@GetFrame

; 173  : 	{
; 174  : 
; 175  : 		// Dimensions of frame covered by blocks (where frame is not exactly divisible by block size there is a small border that will not be motion compensated)
; 176  : 		int widthCovered  = (mVectorsInfo.nBlkSizeX - mVectorsInfo.nOverlapX) * mVectorsInfo.nBlkX + mVectorsInfo.nOverlapX;

	mov	ecx, DWORD PTR [edi+72]
	sub	ecx, DWORD PTR [edi+108]
	imul	ecx, DWORD PTR [edi+116]
	add	ecx, DWORD PTR [edi+108]
	mov	DWORD PTR _widthCovered$1$[ebp], ecx

; 177  : 		int heightCovered = (mVectorsInfo.nBlkSizeY - mVectorsInfo.nOverlapY) * mVectorsInfo.nBlkY + mVectorsInfo.nOverlapY;

	mov	ecx, DWORD PTR [edi+76]
	sub	ecx, DWORD PTR [edi+112]
	imul	ecx, DWORD PTR [edi+120]
	add	ecx, DWORD PTR [edi+112]
	mov	DWORD PTR _heightCovered$1$[ebp], ecx

; 178  : 
; 179  : 		// Go through blocks at each level
; 180  : 		int level = mVectorsInfo.nLvCount - 1; // Start at coarsest level

	mov	ecx, DWORD PTR [edi+84]
	sub	ecx, 1
	mov	DWORD PTR _level$1$[ebp], ecx

; 181  : 		while (level >= 0)

	js	$LN7@GetFrame

; 199  : 				levelHeight = (mVectorsInfo.nVPadding >= yRatioUV) ? ((levelHeight/yRatioUV + 1) / 2) * yRatioUV : ((levelHeight/yRatioUV) / 2) * yRatioUV;

	movsd	xmm1, QWORD PTR __real@3fe0000000000000
$LL6@GetFrame:

; 182  : 		{
; 183  : 			int blocksSize = *pPlanes;

	mov	eax, DWORD PTR [edx]

; 184  : 			VECTOR* pBlocks = reinterpret_cast<VECTOR*>(pPlanes + 1);

	lea	esi, DWORD PTR [edx+4]

; 185  : 			pPlanes += blocksSize;
; 186  : 
; 187  : 			// Width and height of this level in blocks...
; 188  : 			int levelNumBlocksX = ((widthCovered  >> level) - mVectorsInfo.nOverlapX) / (mVectorsInfo.nBlkSizeX - mVectorsInfo.nOverlapX);

	mov	ebx, DWORD PTR [edi+72]
	sub	ebx, DWORD PTR [edi+108]
	mov	DWORD PTR _xEnd$1$[ebp], ebx
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _pBlocks$1$[ebp], esi
	mov	eax, DWORD PTR _widthCovered$1$[ebp]
	sar	eax, cl
	sub	eax, DWORD PTR [edi+108]
	mov	DWORD PTR _pPlanes$1$[ebp], edx
	cdq
	idiv	ebx

; 189  : 			int levelNumBlocksY = ((heightCovered >> level) - mVectorsInfo.nOverlapY) / (mVectorsInfo.nBlkSizeY - mVectorsInfo.nOverlapY);

	mov	ebx, DWORD PTR [edi+76]
	sub	ebx, DWORD PTR [edi+112]
	mov	DWORD PTR _levelNumBlocksX$1$[ebp], eax
	mov	eax, DWORD PTR _heightCovered$1$[ebp]
	sar	eax, cl
	sub	eax, DWORD PTR [edi+112]
	cdq
	idiv	ebx

; 190  : 
; 191  : 			// ... and in pixels
; 192  : 			int levelWidth  = mVectorsInfo.nWidth;
; 193  : 			int levelHeight = mVectorsInfo.nHeight;
; 194  : 			for (int i = 1; i <= level; i++)

	mov	edx, DWORD PTR _level$1$[ebp]
	mov	ecx, DWORD PTR [edi+100]
	mov	DWORD PTR _yEnd$1$[ebp], ebx
	mov	ebx, DWORD PTR [edi+104]
	mov	DWORD PTR _levelNumBlocksY$1$[ebp], eax
	cmp	edx, 1
	jl	SHORT $LN9@GetFrame

; 195  : 			{
; 196  : 				int xRatioUV = mVectorsInfo.xRatioUV;
; 197  : 				int yRatioUV = mVectorsInfo.yRatioUV;
; 198  : 				levelWidth  = (mVectorsInfo.nHPadding >= xRatioUV) ? ((levelWidth /xRatioUV + 1) / 2) * xRatioUV : ((levelWidth /xRatioUV) / 2) * xRatioUV;

	mov	esi, DWORD PTR [edi+144]
	mov	DWORD PTR tv1279[ebp], edx
	npad	8
$LL88@GetFrame:
	mov	eax, ecx
	cdq
	idiv	DWORD PTR [edi+132]
	cmp	esi, DWORD PTR [edi+132]
	jl	SHORT $LN89@GetFrame
	inc	eax
$LN89@GetFrame:
	cdq
	sub	eax, edx
	mov	ecx, eax

; 199  : 				levelHeight = (mVectorsInfo.nVPadding >= yRatioUV) ? ((levelHeight/yRatioUV + 1) / 2) * yRatioUV : ((levelHeight/yRatioUV) / 2) * yRatioUV;

	mov	eax, DWORD PTR [edi+148]
	sar	ecx, 1
	imul	ecx, DWORD PTR [edi+132]
	cmp	eax, DWORD PTR [edi+128]
	mov	eax, ebx
	cdq
	jl	SHORT $LN91@GetFrame
	idiv	DWORD PTR [edi+128]
	inc	eax
	jmp	SHORT $LN111@GetFrame
$LN91@GetFrame:
	idiv	DWORD PTR [edi+128]
$LN111@GetFrame:
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	imul	ebx, DWORD PTR [edi+128]
	sub	DWORD PTR tv1279[ebp], 1
	jne	SHORT $LL88@GetFrame
	mov	esi, DWORD PTR _pBlocks$1$[ebp]
	mov	eax, DWORD PTR _levelNumBlocksY$1$[ebp]
$LN9@GetFrame:

; 200  : 			}
; 201  : 			int extendedWidth  = levelWidth  + 2 * mVectorsInfo.nHPadding; // Including padding

	mov	edx, DWORD PTR [edi+144]
	mov	DWORD PTR _x$1$[ebp], edx
	lea	ecx, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR _extendedWidth$1$[ebp], ecx

; 202  : 			int extendedHeight = levelHeight + 2 * mVectorsInfo.nVPadding;

	mov	ecx, DWORD PTR [edi+148]
	mov	DWORD PTR _y$1$[ebp], ecx
	lea	ecx, DWORD PTR [ebx+ecx*2]

; 203  : 
; 204  : 			// Padding is effectively smaller on coarser levels
; 205  : 			int paddingXScaled = mVectorsInfo.nHPadding >> level;

	mov	ebx, edx
	mov	DWORD PTR _extendedHeight$1$[ebp], ecx
	mov	ecx, DWORD PTR _level$1$[ebp]
	sar	ebx, cl
	mov	DWORD PTR _paddingXScaled$1$[ebp], ebx

; 206  : 			int paddingYScaled = mVectorsInfo.nVPadding >> level;

	mov	ebx, DWORD PTR _y$1$[ebp]
	mov	DWORD PTR _paddingYScaled$1$[ebp], ebx
	sar	DWORD PTR _paddingYScaled$1$[ebp], cl

; 207  : 
; 208  : 			// Loop through block positions (top-left of each block, coordinates relative to top-left of padding)
; 209  : 			int x = mVectorsInfo.nHPadding;
; 210  : 			int y = mVectorsInfo.nVPadding;
; 211  : 			int xEnd = x + levelNumBlocksX * (mVectorsInfo.nBlkSizeX - mVectorsInfo.nOverlapX);

	mov	ecx, DWORD PTR _xEnd$1$[ebp]
	imul	ecx, DWORD PTR _levelNumBlocksX$1$[ebp]
	add	ecx, edx
	mov	DWORD PTR _xEnd$1$[ebp], ecx

; 212  : 			int yEnd = y + levelNumBlocksY * (mVectorsInfo.nBlkSizeY - mVectorsInfo.nOverlapY);

	mov	ecx, DWORD PTR _yEnd$1$[ebp]
	imul	ecx, eax
	add	ecx, ebx
	mov	DWORD PTR _yEnd$1$[ebp], ecx

; 213  : 			while (y < yEnd)

	cmp	ebx, ecx
	jge	$LN12@GetFrame
	npad	6
$LL11@GetFrame:

; 214  : 			{
; 215  : 				// Max/min vector length for this block
; 216  : 				int yMin = -mVectorsInfo.nPel * (y - mVectorsInfo.nVPadding + paddingYScaled);

	mov	eax, DWORD PTR [edi+148]
	sub	ebx, eax
	add	ebx, DWORD PTR _paddingYScaled$1$[ebp]
	imul	ebx, DWORD PTR [edi+80]
	neg	ebx
	mov	DWORD PTR _yMin$1$[ebp], ebx

; 217  : 				int yMax =  mVectorsInfo.nPel * (extendedHeight - y - mVectorsInfo.nBlkSizeY - mVectorsInfo.nVPadding + paddingYScaled);

	mov	ebx, DWORD PTR _paddingYScaled$1$[ebp]
	sub	ebx, eax
	sub	ebx, DWORD PTR [edi+76]
	sub	ebx, DWORD PTR _y$1$[ebp]
	add	ebx, DWORD PTR _extendedHeight$1$[ebp]
	imul	ebx, DWORD PTR [edi+80]
	mov	DWORD PTR _yMax$1$[ebp], ebx

; 218  : 
; 219  : 				while (x < xEnd)

	cmp	edx, DWORD PTR _xEnd$1$[ebp]
	jge	$LN14@GetFrame
$LL13@GetFrame:
	movd	xmm0, DWORD PTR [esi]

; 220  : 				{
; 221  : 					int xMin = -mVectorsInfo.nPel * (x - mVectorsInfo.nHPadding + paddingXScaled);

	mov	eax, DWORD PTR [edi+144]
	sub	edx, eax
	mov	ebx, DWORD PTR _paddingXScaled$1$[ebp]
	add	edx, ebx
	imul	edx, DWORD PTR [edi+80]

; 222  : 					int xMax =  mVectorsInfo.nPel * (extendedWidth - x - mVectorsInfo.nBlkSizeX - mVectorsInfo.nHPadding + paddingXScaled);

	sub	ebx, eax
	sub	ebx, DWORD PTR [edi+72]
	sub	ebx, DWORD PTR _x$1$[ebp]
	add	ebx, DWORD PTR _extendedWidth$1$[ebp]
	imul	ebx, DWORD PTR [edi+80]

; 223  : 				
; 224  : 					// Scale each block's vector & SAD
; 225  : 					pBlocks->x = (int)(pBlocks->x * mScaleX + 0.5);

	cvtdq2pd xmm0, xmm0
	neg	edx
	mulsd	xmm0, QWORD PTR [edi+160]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	movd	xmm0, DWORD PTR [esi+4]

; 226  : 					pBlocks->y = (int)(pBlocks->y * mScaleY + 0.5);

	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [esi], eax

; 227  : 					if (pBlocks->x < xMin || pBlocks->x > xMax || pBlocks->y < yMin || pBlocks->y > yMax)

	mov	ecx, DWORD PTR [esi]
	mulsd	xmm0, QWORD PTR [edi+168]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR [esi+4], eax
	cmp	ecx, edx
	jl	SHORT $LN23@GetFrame
	cmp	ecx, ebx
	jg	SHORT $LN23@GetFrame
	cmp	eax, DWORD PTR _yMin$1$[ebp]
	jl	SHORT $LN23@GetFrame
	cmp	eax, DWORD PTR _yMax$1$[ebp]
	jg	SHORT $LN23@GetFrame

; 232  : 					}
; 233  : 					else
; 234  : 						pBlocks->sad = (int)(pBlocks->sad * mScaleX * mScaleY + 0.5); // Vector is OK, scale SAD for larger blocksize

	movd	xmm0, DWORD PTR [esi+8]
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [edi+160]
	mulsd	xmm0, QWORD PTR [edi+168]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	jmp	SHORT $LN112@GetFrame
$LN23@GetFrame:

; 228  : 					{
; 229  : 						// Scaling vector makes motion go out of frame, set 0 vector instead and large SAD
; 230  : 						pBlocks->x = pBlocks->y = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0

; 231  : 						pBlocks->sad = mVectorsInfo.nBlkSizeX * mVectorsInfo.nBlkSizeY * 256;

	mov	eax, DWORD PTR [edi+76]
	imul	eax, DWORD PTR [edi+72]
	shl	eax, 8
$LN112@GetFrame:

; 235  : 					pBlocks++;
; 236  : 
; 237  : 					// Next block position
; 238  : 					x += mVectorsInfo.nBlkSizeX - mVectorsInfo.nOverlapX;

	mov	edx, DWORD PTR _x$1$[ebp]
	mov	DWORD PTR [esi+8], eax
	add	esi, 12					; 0000000cH
	mov	eax, DWORD PTR [edi+72]
	sub	eax, DWORD PTR [edi+108]
	add	edx, eax
	mov	DWORD PTR _x$1$[ebp], edx
	cmp	edx, DWORD PTR _xEnd$1$[ebp]
	jl	$LL13@GetFrame
$LN14@GetFrame:

; 239  : 				}
; 240  : 				x =  mVectorsInfo.nHPadding;
; 241  : 				y += mVectorsInfo.nBlkSizeY - mVectorsInfo.nOverlapY;

	mov	eax, DWORD PTR [edi+76]
	sub	eax, DWORD PTR [edi+112]
	mov	ebx, DWORD PTR _y$1$[ebp]
	mov	edx, DWORD PTR [edi+144]
	add	ebx, eax
	mov	DWORD PTR _x$1$[ebp], edx
	mov	DWORD PTR _y$1$[ebp], ebx
	cmp	ebx, DWORD PTR _yEnd$1$[ebp]
	jl	$LL11@GetFrame
$LN12@GetFrame:

; 242  : 			}
; 243  : 			if (reinterpret_cast<int*>(pBlocks) != pPlanes) Env->ThrowError("MScaleVect: Internal error"); // Debugging check

	mov	edx, DWORD PTR _pPlanes$1$[ebp]
	cmp	esi, edx
	je	SHORT $LN24@GetFrame
	mov	ecx, DWORD PTR _Env$[ebp]
	push	OFFSET ??_C@_0BL@DLMFEHGF@MScaleVect?3?5Internal?5error?$AA@
	push	ecx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR __real@3fe0000000000000
	add	esp, 8
	mov	edx, DWORD PTR _pPlanes$1$[ebp]
$LN24@GetFrame:

; 244  : 			level--;

	mov	ecx, DWORD PTR _level$1$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _level$1$[ebp], ecx
	jns	$LL6@GetFrame

; 181  : 		while (level >= 0)

	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR _pEnd$1$[ebp]
$LN7@GetFrame:

; 245  : 		}
; 246  : 		if (pPlanes != pEnd) Env->ThrowError("MScaleVect: Internal error"); // Debugging check

	cmp	edx, esi
	je	$LN3@GetFrame
	mov	ecx, DWORD PTR _Env$[ebp]
	push	OFFSET ??_C@_0BL@DLMFEHGF@MScaleVect?3?5Internal?5error?$AA@
	push	ecx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+20]
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
	jmp	$LN3@GetFrame
$LN81@GetFrame:

; 151  : 	{
; 152  : 		while (pPlanes != pEnd)

	cmp	edx, esi
	je	$LN3@GetFrame
	movsd	xmm1, QWORD PTR __real@3fe0000000000000
$LL2@GetFrame:

; 153  : 		{
; 154  : 			// Scale each block's vector & SAD
; 155  : 			int blocksSize = *pPlanes;

	mov	eax, DWORD PTR [edx]

; 156  : 			VECTOR* pBlocks = reinterpret_cast<VECTOR*>(pPlanes + 1);

	lea	ecx, DWORD PTR [edx+4]

; 157  : 			pPlanes += blocksSize;

	lea	edx, DWORD PTR [edx+eax*4]

; 158  : 			while (reinterpret_cast<int*>(pBlocks) != pPlanes)

	cmp	ecx, edx
	je	SHORT $LN5@GetFrame
$LL4@GetFrame:

; 159  : 			{
; 160  : 				if (!mAdjustSubpel)

	cmp	BYTE PTR [edi+176], 0
	jne	SHORT $LN19@GetFrame

; 161  : 				{
; 162  : 					pBlocks->x = (int)(pBlocks->x * mScaleX + 0.5);

	movd	xmm0, DWORD PTR [ecx]
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [edi+160]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	movd	xmm0, DWORD PTR [ecx+4]

; 163  : 					pBlocks->y = (int)(pBlocks->y * mScaleY + 0.5);

	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [ecx], eax
	mulsd	xmm0, QWORD PTR [edi+168]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR [ecx+4], eax
$LN19@GetFrame:

; 164  : 				}
; 165  : 				pBlocks->sad = (sad_t)(pBlocks->sad * mScaleX * mScaleY + 0.5);

	movd	xmm0, DWORD PTR [ecx+8]
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [edi+160]
	mulsd	xmm0, QWORD PTR [edi+168]
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	DWORD PTR [ecx+8], eax

; 166  : 				pBlocks++;

	add	ecx, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL4@GetFrame
$LN5@GetFrame:

; 151  : 	{
; 152  : 		while (pPlanes != pEnd)

	cmp	edx, esi
	jne	SHORT $LL2@GetFrame
$LN3@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	ebx, ebx
	je	SHORT $LN65@GetFrame
	cmp	DWORD PTR [ebx], 256			; 00000100H
	jbe	SHORT $LN65@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebx+256]
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN65@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	test	ebx, ebx
	je	SHORT $LN69@GetFrame
	cmp	DWORD PTR [ebx], 272			; 00000110H
	jbe	SHORT $LN69@GetFrame
	mov	eax, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	ebx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN69@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 5
$LN110@GetFrame:
	test	ebx, ebx
	je	SHORT $LN74@GetFrame
	cmp	DWORD PTR [ebx], 272			; 00000110H
	jbe	SHORT $LN74@GetFrame
	mov	edx, DWORD PTR [ebx+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	edx
$LN74@GetFrame:
; File c:\github\mvtools\sources\mscalevect.cpp

; 250  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _dst$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MScaleVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MScaleVect::GetFrame
END
