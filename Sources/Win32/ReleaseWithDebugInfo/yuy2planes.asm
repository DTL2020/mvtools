; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\yuy2planes.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z	; convert_yv16_to_yuy2_c
PUBLIC	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z	; convert_yv16_to_yuy2_sse2
PUBLIC	?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z		; YUY2FromPlanes
PUBLIC	??1YUY2Planes@@QAE@XZ				; YUY2Planes::~YUY2Planes
PUBLIC	??0YUY2Planes@@QAE@HH@Z				; YUY2Planes::YUY2Planes
PUBLIC	?YUY2ToPlanes@@YAXPBEHHH0H00H_N@Z		; YUY2ToPlanes
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ?YUY2ToPlanes@@YAXPBEHHH0H00H_N@Z
_TEXT	SEGMENT
_nWidth$ = 8						; size = 4
_nHeight$ = 12						; size = 4
_dstY$ = 16						; size = 4
_dstPitchY$ = 20					; size = 4
_dstU$ = 24						; size = 4
_dstV$ = 28						; size = 4
_dstPitchUV$ = 32					; size = 4
_sse2$ = 36						; size = 1
?YUY2ToPlanes@@YAXPBEHHH0H00H_N@Z PROC			; YUY2ToPlanes, COMDAT
; _pSrcYUY2$ = ecx
; _nSrcPitchYUY2$ = edx

; 138  : 
; 139  :   nWidth <<= 2; // real target width

	mov	eax, DWORD PTR _nWidth$[esp-4]
	shl	eax, 2

; 140  :   if (sse2 && IsPtrAligned(pSrcYUY2, 16)) {

	cmp	BYTE PTR _sse2$[esp-4], 0
	je	SHORT $LN2@YUY2ToPlan
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	cl, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 140  :   if (sse2 && IsPtrAligned(pSrcYUY2, 16)) {

	jne	SHORT $LN2@YUY2ToPlan

; 141  :     convert_yuy2_to_yv16_sse2(pSrcYUY2, (unsigned char *)dstY, (unsigned char *)dstU, (unsigned char *)dstV, nSrcPitchYUY2, dstPitchY, dstPitchUV, nWidth, nHeight);

	push	DWORD PTR _nHeight$[esp-4]
	push	eax
	push	DWORD PTR _dstPitchUV$[esp+4]
	push	DWORD PTR _dstPitchY$[esp+8]
	push	edx
	push	DWORD PTR _dstV$[esp+16]
	mov	edx, DWORD PTR _dstY$[esp+20]
	push	DWORD PTR _dstU$[esp+20]
	call	?convert_yuy2_to_yv16_sse2@@YAXPBEPAE11IIIII@Z ; convert_yuy2_to_yv16_sse2

; 142  :   }
; 143  :   else
; 144  :   {
; 145  :     convert_yuy2_to_yv16_c(pSrcYUY2, (unsigned char *)dstY, (unsigned char *)dstU, (unsigned char *)dstV, nSrcPitchYUY2, dstPitchY, dstPitchUV, nWidth, nHeight);

	add	esp, 28					; 0000001cH

; 146  :   }
; 147  : }

	ret	0
$LN2@YUY2ToPlan:

; 142  :   }
; 143  :   else
; 144  :   {
; 145  :     convert_yuy2_to_yv16_c(pSrcYUY2, (unsigned char *)dstY, (unsigned char *)dstU, (unsigned char *)dstV, nSrcPitchYUY2, dstPitchY, dstPitchUV, nWidth, nHeight);

	push	DWORD PTR _nHeight$[esp-4]
	push	eax
	push	DWORD PTR _dstPitchUV$[esp+4]
	push	DWORD PTR _dstPitchY$[esp+8]
	push	edx
	push	DWORD PTR _dstV$[esp+16]
	mov	edx, DWORD PTR _dstY$[esp+20]
	push	DWORD PTR _dstU$[esp+20]
	call	?convert_yuy2_to_yv16_c@@YAXPBEPAE11IIIII@Z ; convert_yuy2_to_yv16_c
	add	esp, 28					; 0000001cH

; 146  :   }
; 147  : }

	ret	0
?YUY2ToPlanes@@YAXPBEHHH0H00H_N@Z ENDP			; YUY2ToPlanes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ??0YUY2Planes@@QAE@HH@Z
_TEXT	SEGMENT
__nWidth$ = 8						; size = 4
__nHeight$ = 12						; size = 4
??0YUY2Planes@@QAE@HH@Z PROC				; YUY2Planes::YUY2Planes, COMDAT
; _this$ = ecx

; 26   :   nWidth = _nWidth;

	mov	eax, DWORD PTR __nWidth$[esp-4]
	push	ebx
	mov	ebx, ecx
	push	esi

; 27   :   nHeight = _nHeight;
; 28   :   srcPitch = (nWidth + 15) & (~15);

	lea	esi, DWORD PTR [eax+15]
	and	esi, -16				; fffffff0H
	mov	DWORD PTR [ebx+12], eax

; 29   :   srcPitchUV = (nWidth / 2 + 15) & (~15); //v 1.2.1

	cdq
	push	edi
	mov	edi, DWORD PTR __nHeight$[esp+8]
	sub	eax, edx
	mov	DWORD PTR [ebx+20], esi
	sar	eax, 1

; 30   :   pSrc = (unsigned char*)_aligned_malloc(srcPitch*nHeight, 128);   //v 1.2.1

	imul	esi, edi
	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	mov	DWORD PTR [ebx+16], edi
	push	128					; 00000080H
	mov	DWORD PTR [ebx+24], eax
	push	esi
	mov	esi, DWORD PTR __imp___aligned_malloc
	call	esi
	mov	DWORD PTR [ebx], eax

; 31   :   pSrcU = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, DWORD PTR [ebx+24]
	push	128					; 00000080H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+4], eax

; 32   :   pSrcV = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, DWORD PTR [ebx+24]
	push	128					; 00000080H
	push	eax
	call	esi
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+8], eax

; 33   : }

	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	ret	8
??0YUY2Planes@@QAE@HH@Z ENDP				; YUY2Planes::YUY2Planes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ??1YUY2Planes@@QAE@XZ
_TEXT	SEGMENT
??1YUY2Planes@@QAE@XZ PROC				; YUY2Planes::~YUY2Planes, COMDAT
; _this$ = ecx

; 36   : {

	push	esi

; 37   :   _aligned_free(pSrc);

	mov	esi, DWORD PTR __imp___aligned_free
	push	edi
	mov	edi, ecx
	push	DWORD PTR [edi]
	call	esi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [edi+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [edi+8]
	call	esi
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 40   : }

	ret	0
??1YUY2Planes@@QAE@XZ ENDP				; YUY2Planes::~YUY2Planes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z
_TEXT	SEGMENT
_nWidth$ = 8						; size = 4
_nHeight$ = 12						; size = 4
_srcY$ = 16						; size = 4
_srcPitch$ = 20						; size = 4
_srcU$ = 24						; size = 4
_srcV$ = 28						; size = 4
_srcPitchUV$ = 32					; size = 4
_sse2$ = 36						; size = 1
?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z PROC		; YUY2FromPlanes, COMDAT
; _pDstYUY2$ = ecx
; _nDstPitchYUY2$ = edx

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	cmp	BYTE PTR _sse2$[esp-4], 0
	mov	eax, ecx
	mov	ecx, DWORD PTR _srcY$[esp-4]
	je	SHORT $LN2@YUY2FromPl
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	cl, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	jne	SHORT $LN2@YUY2FromPl

; 155  :     //U and V don't have to be aligned since we user movq to read from those
; 156  :     convert_yv16_to_yuy2_sse2(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	DWORD PTR _nHeight$[esp-4]
	push	DWORD PTR _nWidth$[esp]
	push	edx
	push	DWORD PTR _srcPitchUV$[esp+8]
	mov	edx, DWORD PTR _srcU$[esp+12]
	push	DWORD PTR _srcPitch$[esp+12]
	push	eax
	push	DWORD PTR _srcV$[esp+20]
	call	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_sse2

; 157  :   }
; 158  :   else
; 159  :   {
; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	add	esp, 28					; 0000001cH

; 161  :   }
; 162  : }

	ret	0
$LN2@YUY2FromPl:

; 157  :   }
; 158  :   else
; 159  :   {
; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	DWORD PTR _nHeight$[esp-4]
	push	DWORD PTR _nWidth$[esp]
	push	edx
	push	DWORD PTR _srcPitchUV$[esp+8]
	mov	edx, DWORD PTR _srcU$[esp+12]
	push	DWORD PTR _srcPitch$[esp+12]
	push	eax
	push	DWORD PTR _srcV$[esp+20]
	call	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_c
	add	esp, 28					; 0000001cH

; 161  :   }
; 162  : }

	ret	0
?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z ENDP		; YUY2FromPlanes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ?convert_yuy2_to_yv16_sse2@@YAXPBEPAE11IIIII@Z
_TEXT	SEGMENT
_dstp_y$1$ = -8						; size = 4
tv365 = -4						; size = 4
_dstp_u$ = 8						; size = 4
_dstp_v$ = 12						; size = 4
_src_pitch$ = 16					; size = 4
_dst_pitch_y$ = 20					; size = 4
_dst_pitch_uv$ = 24					; size = 4
_width$ = 28						; size = 4
_height$ = 32						; size = 4
?convert_yuy2_to_yv16_sse2@@YAXPBEPAE11IIIII@Z PROC	; convert_yuy2_to_yv16_sse2, COMDAT
; _srcp$ = ecx
; _dstp_y$ = edx

; 44   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	push	esi
	push	edi

; 45   :   width /= 2;

	mov	edi, DWORD PTR _width$[ebp]
	shr	edi, 1

; 46   : 
; 47   :   for (size_t y = 0; y < height; ++y) {

	cmp	DWORD PTR _height$[ebp], 0
	mov	DWORD PTR _dstp_y$1$[esp+16], edx
	mov	DWORD PTR _width$[ebp], edi
	jbe	$LN3@convert_yu

; 45   :   width /= 2;

	mov	eax, DWORD PTR _dstp_v$[ebp]
$LL4@convert_yu:

; 48   :     for (size_t x = 0; x < width; x += 8) {

	xor	esi, esi
	test	edi, edi
	je	SHORT $LN6@convert_yu
	mov	DWORD PTR tv365[esp+16], edx
	mov	edi, eax
	mov	edx, DWORD PTR _dstp_u$[ebp]
	sub	edx, eax
	mov	eax, DWORD PTR tv365[esp+16]
	npad	7
$LL7@convert_yu:

; 49   :       __m128i p0 = _mm_load_si128(reinterpret_cast<const __m128i*>(srcp + x * 4));      // V3 Y7 U3 Y6 V2 Y5 U2 Y4 V1 Y3 U1 Y2 V0 Y1 U0 Y0

	movaps	xmm1, XMMWORD PTR [ecx+esi*4]
	lea	edi, DWORD PTR [edi+8]

; 50   :       __m128i p1 = _mm_load_si128(reinterpret_cast<const __m128i*>(srcp + x * 4 + 16)); // V7 Yf U7 Ye V6 Yd U6 Yc V5 Yb U5 Ya V4 Y9 U4 Y8
; 51   : 
; 52   :       __m128i p2 = _mm_unpacklo_epi8(p0, p1); // V5 V1 Yb Y3 U5 U1 Ya Y2 V4 V0 Y9 Y1 U4 U0 Y8 Y0

	movaps	xmm2, xmm1
	lea	eax, DWORD PTR [eax+16]

; 53   :       __m128i p3 = _mm_unpackhi_epi8(p0, p1); // V7 V3 Yf Y7 U7 U3 Ye Y6 V6 V2 Yd Y5 U6 U2 Yc Y4

	punpckhbw xmm1, XMMWORD PTR [ecx+esi*4+16]
	punpcklbw xmm2, XMMWORD PTR [ecx+esi*4+16]
	add	esi, 8

; 54   : 
; 55   :       p0 = _mm_unpacklo_epi8(p2, p3); // V6 V4 V2 V0 Yd Y9 Y5 Y1 U6 U4 U2 U0 Yc Y8 Y4 Y0

	movaps	xmm3, xmm2

; 56   :       p1 = _mm_unpackhi_epi8(p2, p3); // V7 V5 V3 V1 Yf Yb Y7 Y3 U7 U5 U3 U1 Ye Ya Y6 Y2

	punpckhbw xmm2, xmm1
	punpcklbw xmm3, xmm1

; 57   : 
; 58   :       p2 = _mm_unpacklo_epi8(p0, p1); // U7 U6 U5 U4 U3 U2 U1 U0 Ye Yc Ya Y8 Y6 Y4 Y2 Y0

	movaps	xmm1, xmm3

; 59   :       p3 = _mm_unpackhi_epi8(p0, p1); // V7 V6 V5 V4 V3 V2 V1 V0 Yf Yd Yb Y9 Y7 Y5 Y3 Y1

	punpckhbw xmm3, xmm2
	punpcklbw xmm1, xmm2

; 60   : 
; 61   :       _mm_storel_epi64(reinterpret_cast<__m128i*>(dstp_u + x), _mm_srli_si128(p2, 8));

	movaps	xmm0, xmm1

; 62   :       _mm_storel_epi64(reinterpret_cast<__m128i*>(dstp_v + x), _mm_srli_si128(p3, 8));
; 63   :       _mm_store_si128(reinterpret_cast<__m128i*>(dstp_y + x * 2), _mm_unpacklo_epi8(p2, p3));

	punpcklbw xmm1, xmm3
	psrldq	xmm0, 8
	movq	QWORD PTR [edx+edi-8], xmm0
	movaps	xmm0, xmm3
	psrldq	xmm0, 8
	movq	QWORD PTR [edi-8], xmm0
	movaps	XMMWORD PTR [eax-16], xmm1
	cmp	esi, DWORD PTR _width$[ebp]
	jb	SHORT $LL7@convert_yu
	mov	eax, DWORD PTR _dstp_v$[ebp]
	mov	edx, DWORD PTR _dstp_y$1$[esp+16]
	mov	edi, DWORD PTR _width$[ebp]
$LN6@convert_yu:

; 64   :     }
; 65   : 
; 66   :     srcp += src_pitch;
; 67   :     dstp_y += dst_pitch_y;
; 68   :     dstp_u += dst_pitch_uv;

	mov	esi, DWORD PTR _dst_pitch_uv$[ebp]

; 69   :     dstp_v += dst_pitch_uv;

	add	eax, esi
	add	edx, DWORD PTR _dst_pitch_y$[ebp]
	add	ecx, DWORD PTR _src_pitch$[ebp]
	add	DWORD PTR _dstp_u$[ebp], esi
	sub	DWORD PTR _height$[ebp], 1
	mov	DWORD PTR _dstp_y$1$[esp+16], edx
	mov	DWORD PTR _dstp_v$[ebp], eax
	jne	$LL4@convert_yu
$LN3@convert_yu:

; 70   :   }
; 71   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?convert_yuy2_to_yv16_sse2@@YAXPBEPAE11IIIII@Z ENDP	; convert_yuy2_to_yv16_sse2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ?convert_yuy2_to_yv16_c@@YAXPBEPAE11IIIII@Z
_TEXT	SEGMENT
tv454 = -4						; size = 4
_dstp_u$ = 8						; size = 4
_dstp_v$ = 12						; size = 4
_src_pitch$ = 16					; size = 4
_dst_pitch_y$ = 20					; size = 4
_dst_pitch_uv$ = 24					; size = 4
_width$ = 28						; size = 4
_height$ = 32						; size = 4
?convert_yuy2_to_yv16_c@@YAXPBEPAE11IIIII@Z PROC	; convert_yuy2_to_yv16_c, COMDAT
; _srcp$ = ecx
; _dstp_y$ = edx

; 75   : {

	push	ecx

; 76   :   width /= 2;

	mov	eax, DWORD PTR _width$[esp]
	shr	eax, 1

; 77   : 
; 78   :   for (size_t y = 0; y < height; ++y) {

	cmp	DWORD PTR _height$[esp], 0
	push	edi
	mov	edi, edx
	mov	DWORD PTR _width$[esp+4], eax
	jbe	SHORT $LN3@convert_yu

; 76   :   width /= 2;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _dstp_v$[esp+12]
	inc	ecx
	push	esi
	mov	DWORD PTR tv454[esp+20], ecx
$LL4@convert_yu:

; 79   :     for (size_t x = 0; x < width; ++x) {

	xor	edx, edx
	test	eax, eax
	je	SHORT $LN6@convert_yu
	mov	ebx, DWORD PTR _dstp_u$[esp+16]
	mov	esi, ebp
	sub	ebx, ebp
	mov	eax, ecx
	mov	ebp, DWORD PTR _width$[esp+16]
$LL7@convert_yu:

; 80   :       dstp_y[x * 2] = srcp[x * 4 + 0];

	movzx	ecx, BYTE PTR [eax-1]
	lea	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [edi+edx*2], cl
	lea	esi, DWORD PTR [esi+1]

; 81   :       dstp_y[x * 2 + 1] = srcp[x * 4 + 2];

	movzx	ecx, BYTE PTR [eax-3]
	mov	BYTE PTR [edi+edx*2+1], cl
	inc	edx

; 82   :       dstp_u[x] = srcp[x * 4 + 1];

	movzx	ecx, BYTE PTR [eax-4]
	mov	BYTE PTR [ebx+esi-1], cl

; 83   :       dstp_v[x] = srcp[x * 4 + 3];

	movzx	ecx, BYTE PTR [eax-2]
	mov	BYTE PTR [esi-1], cl
	cmp	edx, ebp
	jb	SHORT $LL7@convert_yu
	mov	ebp, DWORD PTR _dstp_v$[esp+16]
	mov	eax, DWORD PTR _width$[esp+16]
	mov	ecx, DWORD PTR tv454[esp+20]
$LN6@convert_yu:

; 84   :     }
; 85   :     srcp += src_pitch;
; 86   :     dstp_y += dst_pitch_y;
; 87   :     dstp_u += dst_pitch_uv;

	mov	edx, DWORD PTR _dst_pitch_uv$[esp+16]

; 88   :     dstp_v += dst_pitch_uv;

	add	ebp, edx
	add	ecx, DWORD PTR _src_pitch$[esp+16]
	add	edi, DWORD PTR _dst_pitch_y$[esp+16]
	add	DWORD PTR _dstp_u$[esp+16], edx
	sub	DWORD PTR _height$[esp+16], 1
	mov	DWORD PTR tv454[esp+20], ecx
	mov	DWORD PTR _dstp_v$[esp+16], ebp
	jne	SHORT $LL4@convert_yu
	pop	esi
	pop	ebp
	pop	ebx
$LN3@convert_yu:
	pop	edi

; 89   :   }
; 90   : }

	pop	ecx
	ret	0
?convert_yuy2_to_yv16_c@@YAXPBEPAE11IIIII@Z ENDP	; convert_yuy2_to_yv16_c
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z
_TEXT	SEGMENT
_srcp_u$1$ = -4						; size = 4
_srcp_v$ = 8						; size = 4
_dstp$ = 12						; size = 4
_src_pitch_y$ = 16					; size = 4
_src_pitch_uv$ = 20					; size = 4
_dst_pitch$ = 24					; size = 4
_width$ = 28						; size = 4
_height$ = 32						; size = 4
?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z PROC	; convert_yv16_to_yuy2_sse2, COMDAT
; _srcp_y$ = ecx
; _srcp_u$ = edx

; 93   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, edx

; 94   :   width /= 2;

	mov	ecx, DWORD PTR _width$[ebp]
	shr	ecx, 1

; 95   : 
; 96   :   for (size_t y = 0; y < height; y++) {

	cmp	DWORD PTR _height$[ebp], 0
	mov	DWORD PTR _srcp_u$1$[esp+16], esi
	mov	DWORD PTR _width$[ebp], ecx
	jbe	SHORT $LN3@convert_yv
$LL4@convert_yv:

; 97   :     for (size_t x = 0; x < width; x += 8) {

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN6@convert_yv
	mov	ecx, DWORD PTR _srcp_v$[ebp]
	sub	esi, ecx
	mov	edx, DWORD PTR _dstp$[ebp]
	npad	1
$LL7@convert_yv:

; 98   : 
; 99   :       __m128i yy = _mm_load_si128(reinterpret_cast<const __m128i*>(srcp_y + x * 2));
; 100  :       __m128i u = _mm_loadl_epi64(reinterpret_cast<const __m128i*>(srcp_u + x));
; 101  :       __m128i v = _mm_loadl_epi64(reinterpret_cast<const __m128i*>(srcp_v + x));

	movq	xmm0, QWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+8]
	movaps	xmm2, XMMWORD PTR [edi+eax*2]
	lea	edx, DWORD PTR [edx+32]
	movq	xmm1, QWORD PTR [esi+ecx-8]
	add	eax, 8

; 102  : 
; 103  :       __m128i uv = _mm_unpacklo_epi8(u, v);

	punpcklbw xmm1, xmm0

; 104  :       __m128i yuv_lo = _mm_unpacklo_epi8(yy, uv);

	movaps	xmm0, xmm2
	punpcklbw xmm0, xmm1

; 105  :       __m128i yuv_hi = _mm_unpackhi_epi8(yy, uv);
; 106  : 
; 107  :       _mm_stream_si128(reinterpret_cast<__m128i*>(dstp + x * 4), yuv_lo);

	movntdq	XMMWORD PTR [edx-32], xmm0
	punpckhbw xmm2, xmm1

; 108  :       _mm_stream_si128(reinterpret_cast<__m128i*>(dstp + x * 4 + 16), yuv_hi);

	movntdq	XMMWORD PTR [edx-16], xmm2
	cmp	eax, DWORD PTR _width$[ebp]
	jb	SHORT $LL7@convert_yv
	mov	ecx, DWORD PTR _width$[ebp]
	mov	esi, DWORD PTR _srcp_u$1$[esp+16]
$LN6@convert_yv:

; 109  :     }
; 110  : 
; 111  :     srcp_y += src_pitch_y;
; 112  :     srcp_u += src_pitch_uv;

	mov	eax, DWORD PTR _src_pitch_uv$[ebp]
	add	esi, eax

; 113  :     srcp_v += src_pitch_uv;

	add	DWORD PTR _srcp_v$[ebp], eax

; 114  :     dstp += dst_pitch;

	mov	eax, DWORD PTR _dst_pitch$[ebp]
	add	edi, DWORD PTR _src_pitch_y$[ebp]
	add	DWORD PTR _dstp$[ebp], eax
	sub	DWORD PTR _height$[ebp], 1
	mov	DWORD PTR _srcp_u$1$[esp+16], esi
	jne	SHORT $LL4@convert_yv
$LN3@convert_yv:

; 115  :   }
; 116  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ENDP	; convert_yv16_to_yuy2_sse2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\yuy2planes.cpp
;	COMDAT ?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z
_TEXT	SEGMENT
_srcp_u$1$ = -8						; size = 4
tv451 = -4						; size = 4
_srcp_v$ = 8						; size = 4
_dstp$ = 12						; size = 4
_src_pitch_y$ = 16					; size = 4
_src_pitch_uv$ = 20					; size = 4
_dst_pitch$ = 24					; size = 4
_width$ = 28						; size = 4
_height$ = 32						; size = 4
?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z PROC	; convert_yv16_to_yuy2_c, COMDAT
; _srcp_y$ = ecx
; _srcp_u$ = edx

; 118  : void convert_yv16_to_yuy2_c(const BYTE *srcp_y, const BYTE *srcp_u, const BYTE *srcp_v, BYTE *dstp, size_t src_pitch_y, size_t src_pitch_uv, size_t dst_pitch, size_t width, size_t height) {

	sub	esp, 8

; 119  :   for (size_t y = 0; y < height; y++) {

	cmp	DWORD PTR _height$[esp+4], 0
	push	ebx
	mov	ebx, edx
	push	edi
	mov	DWORD PTR _srcp_u$1$[esp+16], ebx
	mov	edi, ecx
	jbe	$LN3@convert_yv
	mov	ecx, DWORD PTR _width$[esp+12]
	mov	eax, DWORD PTR _dstp$[esp+12]
	push	ebp
	mov	ebp, DWORD PTR _srcp_v$[esp+16]
	shr	ecx, 1
	add	eax, 2
	push	esi
	mov	esi, DWORD PTR _src_pitch_uv$[esp+20]
	mov	DWORD PTR _width$[esp+20], ecx
	mov	DWORD PTR tv451[esp+24], eax
$LL4@convert_yv:

; 120  :     for (size_t x = 0; x < width / 2; x++) {

	xor	edx, edx
	test	ecx, ecx
	je	SHORT $LN6@convert_yv
	mov	esi, ebp
	sub	ebx, ebp
	mov	ebp, DWORD PTR _width$[esp+20]
$LL7@convert_yv:

; 121  :       dstp[x * 4 + 0] = srcp_y[x * 2];

	movzx	ecx, BYTE PTR [edi+edx*2]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [eax-2], cl
	lea	eax, DWORD PTR [eax+4]

; 122  :       dstp[x * 4 + 1] = srcp_u[x];

	movzx	ecx, BYTE PTR [ebx+esi-1]
	mov	BYTE PTR [eax-5], cl

; 123  :       dstp[x * 4 + 2] = srcp_y[x * 2 + 1];

	movzx	ecx, BYTE PTR [edi+edx*2+1]
	inc	edx
	mov	BYTE PTR [eax-4], cl

; 124  :       dstp[x * 4 + 3] = srcp_v[x];

	movzx	ecx, BYTE PTR [esi-1]
	mov	BYTE PTR [eax-3], cl
	cmp	edx, ebp
	jb	SHORT $LL7@convert_yv
	mov	ebp, DWORD PTR _srcp_v$[esp+20]
	mov	ecx, DWORD PTR _width$[esp+20]
	mov	ebx, DWORD PTR _srcp_u$1$[esp+24]
	mov	eax, DWORD PTR tv451[esp+24]
	mov	esi, DWORD PTR _src_pitch_uv$[esp+20]
$LN6@convert_yv:

; 125  :     }
; 126  :     srcp_y += src_pitch_y;
; 127  :     srcp_u += src_pitch_uv;
; 128  :     srcp_v += src_pitch_uv;
; 129  :     dstp += dst_pitch;

	add	eax, DWORD PTR _dst_pitch$[esp+20]
	add	ebx, esi
	add	edi, DWORD PTR _src_pitch_y$[esp+20]
	add	ebp, esi
	sub	DWORD PTR _height$[esp+20], 1
	mov	DWORD PTR _srcp_u$1$[esp+24], ebx
	mov	DWORD PTR _srcp_v$[esp+20], ebp
	mov	DWORD PTR tv451[esp+24], eax
	jne	SHORT $LL4@convert_yv
	pop	esi
	pop	ebp
$LN3@convert_yv:
	pop	edi
	pop	ebx

; 130  :   }
; 131  : }

	add	esp, 8
	ret	0
?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ENDP	; convert_yv16_to_yuy2_c
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ??$IsPtrAligned@$$CBE@@YA_NPBEI@Z
_TEXT	SEGMENT
??$IsPtrAligned@$$CBE@@YA_NPBEI@Z PROC			; IsPtrAligned<unsigned char const >, COMDAT
; _ptr$ = ecx
; _align$dead$ = edx

; 130  :   assert(IS_POWER2(align));
; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	cl, 15					; 0000000fH
	sete	al

; 132  : }

	ret	0
??$IsPtrAligned@$$CBE@@YA_NPBEI@Z ENDP			; IsPtrAligned<unsigned char const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ??$IsPtrAligned@E@@YA_NPAEI@Z
_TEXT	SEGMENT
??$IsPtrAligned@E@@YA_NPAEI@Z PROC			; IsPtrAligned<unsigned char>, COMDAT
; _ptr$ = ecx
; _align$dead$ = edx

; 130  :   assert(IS_POWER2(align));
; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	cl, 15					; 0000000fH
	sete	al

; 132  : }

	ret	0
??$IsPtrAligned@E@@YA_NPAEI@Z ENDP			; IsPtrAligned<unsigned char>
_TEXT	ENDS
END
