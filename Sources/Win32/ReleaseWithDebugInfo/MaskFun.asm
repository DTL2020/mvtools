; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\maskfun.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned short>
PUBLIC	??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned char>
PUBLIC	??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z	; FlowInter<unsigned short>
PUBLIC	??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z	; FlowInter<unsigned char>
PUBLIC	??$FlowInterSimple@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned short>
PUBLIC	??$FlowInterSimple@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInterSimple<unsigned char>
PUBLIC	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z		; Blend<unsigned short>
PUBLIC	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z		; Blend<unsigned char>
PUBLIC	?Merge16PlanesToBig@@YAXPAEHPBE111111111111111HHHH_N@Z ; Merge16PlanesToBig
PUBLIC	?Merge4PlanesToBig@@YAXPAEHPBE111HHHH_N@Z	; Merge4PlanesToBig
PUBLIC	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z		; VectorSmallMaskYToHalfUV
PUBLIC	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z	; MakeVectorSmallMasks
PUBLIC	?MakeSADMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z	; MakeSADMaskTime
PUBLIC	?ByteNorm@@YAEHNN@Z				; ByteNorm
PUBLIC	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime
PUBLIC	?Median3r@@YAHHHH@Z				; Median3r
PUBLIC	?ByteOccMask@@YAXPAEHNN@Z			; ByteOccMask
PUBLIC	?GetBlock@MVClip@@QBEABVFakeBlockData@@HH@Z	; MVClip::GetBlock
PUBLIC	??AFakePlaneOfBlocks@@QBEABVFakeBlockData@@H@Z	; FakePlaneOfBlocks::operator[]
PUBLIC	?GetMV@FakeBlockData@@QBE?AUVECTOR@@XZ		; FakeBlockData::GetMV
PUBLIC	?GetPlane@FakeGroupOfPlanes@@QBEABVFakePlaneOfBlocks@@H@Z ; FakeGroupOfPlanes::GetPlane
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakegroupofplanes.h
;	COMDAT ?GetPlane@FakeGroupOfPlanes@@QBEABVFakePlaneOfBlocks@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPlane@FakeGroupOfPlanes@@QBEABVFakePlaneOfBlocks@@H@Z PROC ; FakeGroupOfPlanes::GetPlane, COMDAT
; _this$ = ecx

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	ecx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4]
	ret	4
?GetPlane@FakeGroupOfPlanes@@QBEABVFakePlaneOfBlocks@@H@Z ENDP ; FakeGroupOfPlanes::GetPlane
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeblockdata.h
;	COMDAT ?GetMV@FakeBlockData@@QBE?AUVECTOR@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetMV@FakeBlockData@@QBE?AUVECTOR@@XZ PROC		; FakeBlockData::GetMV, COMDAT
; _this$ = ecx

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	movq	xmm0, QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+16]
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], ecx
	ret	4
?GetMV@FakeBlockData@@QBE?AUVECTOR@@XZ ENDP		; FakeBlockData::GetMV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\fakeplaneofblocks.h
;	COMDAT ??AFakePlaneOfBlocks@@QBEABVFakeBlockData@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??AFakePlaneOfBlocks@@QBEABVFakeBlockData@@H@Z PROC	; FakePlaneOfBlocks::operator[], COMDAT
; _this$ = ecx

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR _i$[esp-4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+52]
	lea	eax, DWORD PTR [eax+edx*4]

; 61   : 	}

	ret	4
??AFakePlaneOfBlocks@@QBEABVFakeBlockData@@H@Z ENDP	; FakePlaneOfBlocks::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvclip.h
;	COMDAT ?GetBlock@MVClip@@QBEABVFakeBlockData@@HH@Z
_TEXT	SEGMENT
_nLevel$dead$ = 8					; size = 4
_nBlk$ = 12						; size = 4
?GetBlock@MVClip@@QBEABVFakeBlockData@@HH@Z PROC	; MVClip::GetBlock, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ecx+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _nBlk$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+52]
	lea	eax, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\mvclip.h

; 85   :    __forceinline const FakeBlockData& GetBlock(int nLevel, int nBlk) const { return GetPlane(nLevel)[nBlk]; }

	ret	8
?GetBlock@MVClip@@QBEABVFakeBlockData@@HH@Z ENDP	; MVClip::GetBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ?ByteOccMask@@YAXPAEHNN@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
?ByteOccMask@@YAXPAEHNN@Z PROC				; ByteOccMask, COMDAT
; _occMask$ = ecx
; _occlusion$ = edx
; _occnorm$ = xmm2l
; _fGamma$ = xmm3l

; 31   : {

	sub	esp, 12					; 0000000cH
	movaps	xmm1, xmm3

; 32   : 	if (fGamma == 1.0)

	ucomisd	xmm1, QWORD PTR __real@3ff0000000000000
	push	ebx
	push	esi
	mov	esi, ecx
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@ByteOccMas

; 34   : 		*occMask = std::max (

	imul	eax, edx, 255
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T4[esp+20]
; File c:\github\mvtools\sources\maskfun.hpp

; 34   : 		*occMask = std::max (

	mov	DWORD PTR $T2[esp+20], 255		; 000000ffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edx, DWORD PTR $T2[esp+20]
	movd	xmm0, eax
; File c:\github\mvtools\sources\maskfun.hpp

; 34   : 		*occMask = std::max (

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm2
	cvttsd2si eax, xmm0
	mov	DWORD PTR $T4[esp+20], eax

; 35   : 			int (*occMask),
; 36   : 			std::min (int (255 * occlusion*occnorm), 255)
; 37   : 		);
; 38   : 	}
; 39   : 	else

	jmp	SHORT $LN17@ByteOccMas
$LN2@ByteOccMas:
	movd	xmm0, edx

; 41   : 		*occMask = std::max(

	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR $T3[esp+20], 255		; 000000ffH
	mulsd	xmm0, xmm2
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edx, DWORD PTR $T3[esp+20]
	lea	ecx, DWORD PTR $T1[esp+20]
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	cvttsd2si eax, xmm0
	mov	DWORD PTR $T1[esp+20], eax
$LN17@ByteOccMas:
	movzx	ebx, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 255				; 000000ffH
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	mov	DWORD PTR $T5[esp+20], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovle	edx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, ebx
	cmp	ebx, DWORD PTR [edx]
	movzx	eax, BYTE PTR [edx]
	cmovl	ecx, eax
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	mov	BYTE PTR [esi], cl

; 42   : 			int (*occMask),
; 43   : 			std::min (int (255 * pow (occlusion*occnorm, fGamma)), 255)
; 44   : 		);
; 45   : 	}
; 46   : }

	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?ByteOccMask@@YAXPAEHNN@Z ENDP				; ByteOccMask
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ?Median3r@@YAHHHH@Z
_TEXT	SEGMENT
?Median3r@@YAHHHH@Z PROC				; Median3r, COMDAT
; _b$ = ecx
; _c$ = edx

; 144  :     // reduced median - if it is known that a <= c (more fast)
; 145  : 
; 146  : 	// b a c
; 147  : 	if (b <= a) return a;
; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	cmp	edx, ecx
	cmovle	ecx, edx
	mov	eax, ecx

; 150  : 	// a b c
; 151  : 	else return b;
; 152  : 
; 153  : }

	ret	0
?Median3r@@YAHHHH@Z ENDP				; Median3r
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\maskfun.hpp
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z
_TEXT	SEGMENT
_bx$1$ = -108						; size = 4
tv645 = -104						; size = 4
_by$1$ = -100						; size = 4
_nBlkX$1$ = -96						; size = 4
_time4096X$1$ = -92					; size = 4
_mvClip$1$ = -88					; size = 4
_time4096Y$1$ = -84					; size = 4
_occlusion$2$ = -80					; size = 4
$T1 = -80						; size = 4
$T2 = -80						; size = 4
$T3 = -76						; size = 4
$T4 = -76						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
$T7 = -72						; size = 4
_occlusion$1$ = -68					; size = 4
$T8 = -68						; size = 4
$T9 = -68						; size = 4
tv654 = -64						; size = 4
$T10 = -60						; size = 4
$T11 = -60						; size = 4
_occnorm$1$ = -56					; size = 8
_dMaskNormFactor$1$ = -56				; size = 8
$T12 = -48						; size = 12
$T13 = -36						; size = 12
$T14 = -24						; size = 12
$T15 = -12						; size = 12
_nBlkY$ = 8						; size = 4
_fGamma$ = 12						; size = 8
_nPel$ = 20						; size = 4
_occMask$ = 24						; size = 4
_occMaskPitch$ = 28					; size = 4
_time256$ = 32						; size = 4
_blkSizeX$ = 36						; size = 4
_blkSizeY$ = 40						; size = 4
?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z PROC ; MakeVectorOcclusionMaskTime, COMDAT
; _mvClip$ = ecx
; _nBlkX$ = edx
; _dMaskNormFactor$ = xmm3l

; 52   : {	// analyse vectors field to detect occlusion

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 108				; 0000006cH
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	mov	eax, DWORD PTR _nBlkY$[ebp]
; File c:\github\mvtools\sources\maskfun.cpp

; 52   : {	// analyse vectors field to detect occlusion

	movaps	xmm0, xmm3
	movsd	QWORD PTR _dMaskNormFactor$1$[esp+108], xmm0
	mov	DWORD PTR _mvClip$1$[esp+108], ecx
	push	ebx
	mov	ebx, edx
	mov	DWORD PTR _nBlkX$1$[esp+112], ebx
	push	esi

; 53   : 	MemZoneSet(occMask, 0, nBlkX, nBlkY, 0, 0, nBlkX);

	mov	esi, DWORD PTR _occMask$[ebp]
	push	edi
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN21@MakeVector
; File c:\github\mvtools\sources\maskfun.cpp

; 53   : 	MemZoneSet(occMask, 0, nBlkX, nBlkY, 0, 0, nBlkX);

	mov	edi, eax
	npad	5
$LL22@MakeVector:
; File c:\github\mvtools\sources\copycode.cpp

; 107  : 		memset(ptr, value, width);

	push	ebx
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 108  : 		ptr += pitch;

	add	esi, ebx
	sub	edi, 1
	jne	SHORT $LL22@MakeVector
	movsd	xmm0, QWORD PTR _dMaskNormFactor$1$[esp+120]
$LN21@MakeVector:
; File c:\github\mvtools\sources\maskfun.cpp

; 54   : 	int time4096X = time256*16/blkSizeX;

	mov	ecx, DWORD PTR _time256$[ebp]
	shl	ecx, 4
	mov	eax, ecx
	cdq
	idiv	DWORD PTR _blkSizeX$[ebp]
	mov	DWORD PTR _time4096X$1$[esp+120], eax

; 55   : 	int time4096Y = time256*16/blkSizeY;

	mov	eax, ecx
	cdq
	idiv	DWORD PTR _blkSizeY$[ebp]
	mov	DWORD PTR _time4096Y$1$[esp+120], eax

; 56   : #ifndef _M_X64 
; 57   :   _mm_empty ();

	emms

; 58   : #endif
; 59   : 	double occnorm = 10 / dMaskNormFactor/nPel;
; 60   : 	int occlusion;
; 61   : 
; 62   : 	for (int by=0; by<nBlkY; by++)

	xor	edi, edi
	mov	ecx, DWORD PTR _nBlkY$[ebp]
	mov	DWORD PTR _by$1$[esp+120], edi
	movsd	xmm2, QWORD PTR __real@4024000000000000
	divsd	xmm2, xmm0
	movd	xmm0, DWORD PTR _nPel$[ebp]
	cvtdq2pd xmm0, xmm0
	divsd	xmm2, xmm0
	movsd	QWORD PTR _occnorm$1$[esp+120], xmm2
	test	ecx, ecx
	jle	$LN3@MakeVector
	movsd	xmm3, QWORD PTR __real@3ff0000000000000
	mov	esi, ebx
	npad	1
$LL4@MakeVector:

; 63   : 	{
; 64   : 		for (int bx=0; bx<nBlkX; bx++)

	xor	ebx, ebx
	mov	DWORD PTR _bx$1$[esp+120], ebx
	test	esi, esi
	jle	$LN2@MakeVector
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR tv654[esp+120], eax
	mov	eax, edi
	imul	eax, esi
	lea	edx, DWORD PTR [eax+eax*4]
	shl	edx, 2
	mov	DWORD PTR tv645[esp+120], edx
$LL7@MakeVector:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR _mvClip$1$[esp+120]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\maskfun.cpp

; 70   : 			if (bx < nBlkX-1) // right neighbor

	lea	eax, DWORD PTR [esi-1]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+edx+8]
	movq	QWORD PTR $T13[esp+120], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T15[esp+120], xmm0
; File c:\github\mvtools\sources\maskfun.cpp

; 70   : 			if (bx < nBlkX-1) // right neighbor

	cmp	ebx, eax
	jge	$LN9@MakeVector
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+edx+28]
; File c:\github\mvtools\sources\maskfun.cpp

; 76   : 				if (vx1<vx) {

	mov	ecx, DWORD PTR $T13[esp+120]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T12[esp+120], xmm0
; File c:\github\mvtools\sources\maskfun.cpp

; 76   : 				if (vx1<vx) {

	mov	eax, DWORD PTR $T12[esp+120]
	cmp	eax, ecx
	jge	$LN9@MakeVector

; 77   : 					occlusion = vx-vx1;

	mov	ebx, ecx

; 78   : 					for (int bxi=bx+vx1*time4096X/4096; bxi<=bx+vx*time4096X/4096+1 && bxi>=0 && bxi<nBlkX; bxi++)

	imul	ecx, DWORD PTR _time4096X$1$[esp+120]
	sub	ebx, eax
	imul	eax, DWORD PTR _time4096X$1$[esp+120]
	mov	DWORD PTR _occlusion$1$[esp+120], ebx
	cdq
	and	edx, 4095				; 00000fffH
	lea	edi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _bx$1$[esp+120]
	sar	edi, 12					; 0000000cH
	add	edi, eax
	mov	ecx, ecx
	test	ecx, ecx
	jns	SHORT $LN109@MakeVector
	add	ecx, 4095				; 00000fffH
$LN109@MakeVector:
	sar	ecx, 12					; 0000000cH
	inc	eax
	add	eax, ecx
	mov	DWORD PTR $T6[esp+120], eax
	cmp	edi, eax
	jg	$LN105@MakeVector
$LL10@MakeVector:
	test	edi, edi
	js	$LN105@MakeVector
	cmp	edi, esi
	jge	$LN105@MakeVector

; 79   : 						ByteOccMask(&occMask[bxi+by*occMaskPitch], occlusion, occnorm, fGamma);

	mov	esi, DWORD PTR _by$1$[esp+120]
	imul	esi, DWORD PTR _occMaskPitch$[ebp]
; File c:\github\mvtools\sources\maskfun.hpp

; 32   : 	if (fGamma == 1.0)

	movsd	xmm1, QWORD PTR _fGamma$[ebp]
; File c:\github\mvtools\sources\maskfun.cpp

; 79   : 						ByteOccMask(&occMask[bxi+by*occMaskPitch], occlusion, occnorm, fGamma);

	add	esi, edi
	add	esi, DWORD PTR _occMask$[ebp]
; File c:\github\mvtools\sources\maskfun.hpp

; 32   : 	if (fGamma == 1.0)

	ucomisd	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN43@MakeVector

; 34   : 		*occMask = std::max (

	imul	eax, ebx, 255
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edx, DWORD PTR $T2[esp+120]
; File c:\github\mvtools\sources\maskfun.hpp

; 34   : 		*occMask = std::max (

	mov	DWORD PTR $T2[esp+120], 255		; 000000ffH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T5[esp+120]
	movd	xmm0, eax
; File c:\github\mvtools\sources\maskfun.hpp

; 34   : 		*occMask = std::max (

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm2
	cvttsd2si eax, xmm0
	mov	DWORD PTR $T5[esp+120], eax

; 35   : 			int (*occMask),
; 36   : 			std::min (int (255 * occlusion*occnorm), 255)
; 37   : 		);
; 38   : 	}
; 39   : 	else

	jmp	SHORT $LN106@MakeVector
$LN43@MakeVector:
	movd	xmm0, ebx

; 41   : 		*occMask = std::max(

	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR $T4[esp+120], 255		; 000000ffH
	mulsd	xmm0, xmm2
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edx, DWORD PTR $T4[esp+120]
	lea	ecx, DWORD PTR $T1[esp+120]
	movsd	xmm2, QWORD PTR _occnorm$1$[esp+120]
	movsd	xmm3, QWORD PTR __real@3ff0000000000000
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	cvttsd2si eax, xmm0
	mov	DWORD PTR $T1[esp+120], eax
$LN106@MakeVector:
	movzx	ebx, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 255				; 000000ffH
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	mov	DWORD PTR $T11[esp+120], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovle	edx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, ebx
	cmp	ebx, DWORD PTR [edx]
	movzx	eax, BYTE PTR [edx]
; File c:\github\mvtools\sources\maskfun.cpp

; 78   : 					for (int bxi=bx+vx1*time4096X/4096; bxi<=bx+vx*time4096X/4096+1 && bxi>=0 && bxi<nBlkX; bxi++)

	mov	ebx, DWORD PTR _occlusion$1$[esp+120]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ecx, eax
; File c:\github\mvtools\sources\maskfun.cpp

; 78   : 					for (int bxi=bx+vx1*time4096X/4096; bxi<=bx+vx*time4096X/4096+1 && bxi>=0 && bxi<nBlkX; bxi++)

	inc	edi
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	mov	BYTE PTR [esi], cl
; File c:\github\mvtools\sources\maskfun.cpp

; 78   : 					for (int bxi=bx+vx1*time4096X/4096; bxi<=bx+vx*time4096X/4096+1 && bxi>=0 && bxi<nBlkX; bxi++)

	mov	esi, DWORD PTR _nBlkX$1$[esp+120]
	cmp	edi, DWORD PTR $T6[esp+120]
	jle	$LL10@MakeVector
$LN105@MakeVector:
	mov	ebx, DWORD PTR _bx$1$[esp+120]
	mov	edx, DWORD PTR tv645[esp+120]
	mov	edi, DWORD PTR _by$1$[esp+120]
$LN9@MakeVector:

; 80   : 				}
; 81   : 			}
; 82   : 			if (by < nBlkY-1) // bottom neighbor

	cmp	edi, DWORD PTR tv654[esp+120]
	jge	$LN5@MakeVector
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	lea	eax, DWORD PTR [edi+1]
	imul	eax, esi
	add	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR _mvClip$1$[esp+120]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+52]
	movq	xmm0, QWORD PTR [eax+ecx*4+8]
; File c:\github\mvtools\sources\maskfun.cpp

; 88   : 				if (vy1<vy) {

	mov	ecx, DWORD PTR $T15[esp+124]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T14[esp+120], xmm0
; File c:\github\mvtools\sources\maskfun.cpp

; 88   : 				if (vy1<vy) {

	mov	eax, DWORD PTR $T14[esp+124]
	cmp	eax, ecx
	jge	$LN5@MakeVector

; 89   : 					occlusion = vy-vy1;

	mov	ebx, ecx

; 90   : 					for (int byi=by+vy1*time4096Y/4096; byi<=by+vy*time4096Y/4096+1 && byi>=0 && byi<nBlkY; byi++)

	imul	ecx, DWORD PTR _time4096Y$1$[esp+120]
	sub	ebx, eax
	imul	eax, DWORD PTR _time4096Y$1$[esp+120]
	mov	DWORD PTR _occlusion$2$[esp+120], ebx
	cdq
	and	edx, 4095				; 00000fffH
	lea	esi, DWORD PTR [edx+eax]
	sar	esi, 12					; 0000000cH
	add	esi, edi
	mov	ecx, ecx
	test	ecx, ecx
	jns	SHORT $LN110@MakeVector
	add	ecx, 4095				; 00000fffH
$LN110@MakeVector:
	sar	ecx, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+1]
	add	eax, edi
	mov	DWORD PTR $T3[esp+120], eax
	cmp	esi, eax
	jg	$LN104@MakeVector

; 89   : 					occlusion = vy-vy1;

	mov	edi, esi
	imul	edi, DWORD PTR _occMaskPitch$[ebp]
	add	edi, DWORD PTR _bx$1$[esp+120]
	add	edi, DWORD PTR _occMask$[ebp]
	npad	4
$LL13@MakeVector:

; 90   : 					for (int byi=by+vy1*time4096Y/4096; byi<=by+vy*time4096Y/4096+1 && byi>=0 && byi<nBlkY; byi++)

	test	esi, esi
	js	$LN103@MakeVector
	cmp	esi, DWORD PTR _nBlkY$[ebp]
	jge	$LN103@MakeVector
; File c:\github\mvtools\sources\maskfun.hpp

; 32   : 	if (fGamma == 1.0)

	movsd	xmm1, QWORD PTR _fGamma$[ebp]
	ucomisd	xmm1, xmm3

; 34   : 		*occMask = std::max (

	mov	DWORD PTR $T9[esp+120], 255		; 000000ffH
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN67@MakeVector
	imul	eax, ebx, 255
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm2

; 35   : 			int (*occMask),
; 36   : 			std::min (int (255 * occlusion*occnorm), 255)
; 37   : 		);
; 38   : 	}
; 39   : 	else

	jmp	SHORT $LN107@MakeVector
$LN67@MakeVector:
	movd	xmm0, ebx

; 41   : 		*occMask = std::max(

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm2
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	xmm2, QWORD PTR _occnorm$1$[esp+120]
	movsd	xmm3, QWORD PTR __real@3ff0000000000000
$LN107@MakeVector:
	movzx	ebx, BYTE PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T7[esp+120]
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	cvttsd2si eax, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edx, DWORD PTR $T8[esp+120]
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	mov	DWORD PTR $T10[esp+120], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 255				; 000000ffH
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	mov	DWORD PTR $T7[esp+120], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovle	edx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, ebx
	cmp	ebx, DWORD PTR [edx]
	movzx	eax, BYTE PTR [edx]
; File c:\github\mvtools\sources\maskfun.cpp

; 90   : 					for (int byi=by+vy1*time4096Y/4096; byi<=by+vy*time4096Y/4096+1 && byi>=0 && byi<nBlkY; byi++)

	mov	ebx, DWORD PTR _occlusion$2$[esp+120]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ecx, eax
; File c:\github\mvtools\sources\maskfun.hpp

; 41   : 		*occMask = std::max(

	mov	BYTE PTR [edi], cl
; File c:\github\mvtools\sources\maskfun.cpp

; 90   : 					for (int byi=by+vy1*time4096Y/4096; byi<=by+vy*time4096Y/4096+1 && byi>=0 && byi<nBlkY; byi++)

	inc	esi
	add	edi, DWORD PTR _occMaskPitch$[ebp]
	cmp	esi, DWORD PTR $T3[esp+120]
	jle	$LL13@MakeVector
$LN103@MakeVector:
	mov	edi, DWORD PTR _by$1$[esp+120]
$LN104@MakeVector:
	mov	ebx, DWORD PTR _bx$1$[esp+120]
	mov	edx, DWORD PTR tv645[esp+120]
	mov	esi, DWORD PTR _nBlkX$1$[esp+120]
$LN5@MakeVector:

; 63   : 	{
; 64   : 		for (int bx=0; bx<nBlkX; bx++)

	inc	ebx
	add	edx, 20					; 00000014H
	mov	DWORD PTR _bx$1$[esp+120], ebx
	mov	DWORD PTR tv645[esp+120], edx
	cmp	ebx, esi
	jl	$LL7@MakeVector
	mov	ecx, DWORD PTR _nBlkY$[ebp]
$LN2@MakeVector:

; 58   : #endif
; 59   : 	double occnorm = 10 / dMaskNormFactor/nPel;
; 60   : 	int occlusion;
; 61   : 
; 62   : 	for (int by=0; by<nBlkY; by++)

	inc	edi
	mov	DWORD PTR _by$1$[esp+120], edi
	cmp	edi, ecx
	jl	$LL4@MakeVector
$LN3@MakeVector:

; 91   : 						ByteOccMask(&occMask[bx+byi*occMaskPitch], occlusion, occnorm, fGamma);
; 92   : 				}
; 93   : 			}
; 94   : 		}
; 95   : 	}
; 96   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ENDP ; MakeVectorOcclusionMaskTime
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ?ByteNorm@@YAEHNN@Z
_TEXT	SEGMENT
?ByteNorm@@YAEHNN@Z PROC				; ByteNorm, COMDAT
; _sad$ = ecx
; _dSADNormFactor$ = xmm1l
; _fGamma$ = xmm2l

; 266  : {

	movd	xmm0, ecx

; 267  :   //	    double dSADNormFactor = 4 / (dMaskNormFactor*blkSizeX*blkSizeY);
; 268  :   double l = 255 * pow(sad*dSADNormFactor, fGamma); // Fizick - now linear for gm=1

	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm1
	movaps	xmm1, xmm2
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, xmm1
	minsd	xmm1, xmm0

; 269  :   return (unsigned char)((l > 255) ? 255 : l);

	cvttsd2si eax, xmm1

; 270  : }

	ret	0
?ByteNorm@@YAEHNN@Z ENDP				; ByteNorm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ?MakeSADMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z
_TEXT	SEGMENT
_by$1$ = -64						; size = 4
tv385 = -60						; size = 4
tv382 = -56						; size = 4
_mvClip$1$ = -52					; size = 4
_time4096X$1$ = -48					; size = 4
_time4096Y$1$ = -44					; size = 4
tv388 = -40						; size = 4
tv381 = -36						; size = 4
_dSADNormFactor$1$ = -32				; size = 8
$T1 = -24						; size = 12
$T2 = -12						; size = 12
_nBlkY$ = 8						; size = 4
_fGamma$ = 12						; size = 8
_nPel$ = 20						; size = 4
_Mask$ = 24						; size = 4
_MaskPitch$ = 28					; size = 4
_time256$ = 32						; size = 4
_nBlkStepX$ = 36					; size = 4
_nBlkStepY$ = 40					; size = 4
?MakeSADMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z PROC	; MakeSADMaskTime, COMDAT
; _mvClip$ = ecx
; _nBlkX$ = edx
; _dSADNormFactor$ = xmm3l

; 274  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 68					; 00000044H
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	mov	eax, DWORD PTR _nBlkY$[ebp]
; File c:\github\mvtools\sources\maskfun.cpp

; 274  : {

	movaps	xmm1, xmm3
	movsd	QWORD PTR _dSADNormFactor$1$[esp+68], xmm1
	mov	DWORD PTR _mvClip$1$[esp+68], ecx
	push	ebx
	mov	ebx, edx
	push	esi

; 277  :   MemZoneSet(Mask, 0, nBlkX, nBlkY, 0, 0, MaskPitch);

	mov	esi, DWORD PTR _Mask$[ebp]
	push	edi
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	eax, eax
	jle	SHORT $LN13@MakeSADMas
; File c:\github\mvtools\sources\maskfun.cpp

; 277  :   MemZoneSet(Mask, 0, nBlkX, nBlkY, 0, 0, MaskPitch);

	mov	edi, eax
$LL14@MakeSADMas:
; File c:\github\mvtools\sources\copycode.cpp

; 107  : 		memset(ptr, value, width);

	push	ebx
	push	0
	push	esi
	call	_memset

; 108  : 		ptr += pitch;

	add	esi, DWORD PTR _MaskPitch$[ebp]
	add	esp, 12					; 0000000cH
	sub	edi, 1
	jne	SHORT $LL14@MakeSADMas
	movsd	xmm1, QWORD PTR _dSADNormFactor$1$[esp+80]
$LN13@MakeSADMas:
; File c:\github\mvtools\sources\maskfun.cpp

; 278  :   int time4096X = (256 - time256) * 16 / (nBlkStepX*nPel); // blkstep here is really blksize-overlap

	mov	esi, DWORD PTR _nPel$[ebp]
	mov	edi, 256				; 00000100H
	sub	edi, DWORD PTR _time256$[ebp]
	mov	ecx, esi
	imul	ecx, DWORD PTR _nBlkStepX$[ebp]
	shl	edi, 4
	mov	eax, edi

; 279  :   int time4096Y = (256 - time256) * 16 / (nBlkStepY*nPel);

	imul	esi, DWORD PTR _nBlkStepY$[ebp]
	cdq
	idiv	ecx

; 280  : 
; 281  :   for (int by = 0; by<nBlkY; by++)

	xor	ecx, ecx
	mov	DWORD PTR _time4096X$1$[esp+80], eax
	mov	eax, edi
	cdq
	idiv	esi
	mov	edx, DWORD PTR _nBlkY$[ebp]
	mov	DWORD PTR _time4096Y$1$[esp+80], eax
	mov	DWORD PTR _by$1$[esp+80], ecx
	test	edx, edx
	jle	$LN3@MakeSADMas

; 278  :   int time4096X = (256 - time256) * 16 / (nBlkStepX*nPel); // blkstep here is really blksize-overlap

	xor	edi, edi
	lea	eax, DWORD PTR [ebx+ebx*4]
	shl	eax, 2
	mov	DWORD PTR tv381[esp+80], eax
	mov	eax, DWORD PTR _Mask$[ebp]
	mov	DWORD PTR tv382[esp+80], edi
	npad	1
$LL4@MakeSADMas:

; 282  :   {
; 283  :     for (int bx = 0; bx<nBlkX; bx++)

	xor	esi, esi
	test	ebx, ebx
	jle	$LN2@MakeSADMas

; 295  :       }
; 296  :       int i1 = bxi + byi*nBlkX;
; 297  :       sad_t sad = mvClip.GetBlock(0, i1).GetSAD();
; 298  :       Mask[bx + by*nBlkX] = ByteNorm(sad, dSADNormFactor, fGamma); // bits_per_pixel scale through dSADNormFactor

	mov	ecx, edi
	mov	DWORD PTR tv385[esp+80], edi
$LL7@MakeSADMas:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR _mvClip$1$[esp+80]
; File c:\github\mvtools\sources\maskfun.cpp

; 289  :       int bxi = bx - vx*time4096X / 4096; // limits?

	mov	edi, esi
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR tv388[esp+80], edx
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+edx+8]
	movq	QWORD PTR $T1[esp+80], xmm0
	movq	xmm0, xmm0
; File c:\github\mvtools\sources\maskfun.cpp

; 289  :       int bxi = bx - vx*time4096X / 4096; // limits?

	mov	eax, DWORD PTR $T1[esp+80]
	imul	eax, DWORD PTR _time4096X$1$[esp+80]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T2[esp+80], xmm0
; File c:\github\mvtools\sources\maskfun.cpp

; 289  :       int bxi = bx - vx*time4096X / 4096; // limits?

	cdq
	and	edx, 4095				; 00000fffH
	add	eax, edx
	sar	eax, 12					; 0000000cH
	sub	edi, eax

; 290  :       int byi = by - vy*time4096Y / 4096;

	mov	eax, DWORD PTR $T2[esp+84]
	imul	eax, DWORD PTR _time4096Y$1$[esp+80]
	cdq
	and	edx, 4095				; 00000fffH
	add	eax, edx
	mov	edx, DWORD PTR _by$1$[esp+80]
	sar	eax, 12					; 0000000cH
	mov	ecx, edx
	sub	ecx, eax

; 291  :       if (bxi <0 || bxi >= nBlkX || byi <0 || byi >= nBlkY)

	test	edi, edi
	js	SHORT $LN9@MakeSADMas
	cmp	edi, ebx
	jge	SHORT $LN9@MakeSADMas
	test	ecx, ecx
	js	SHORT $LN9@MakeSADMas
	cmp	ecx, DWORD PTR _nBlkY$[ebp]
	jl	SHORT $LN8@MakeSADMas
$LN9@MakeSADMas:

; 292  :       {
; 293  :         bxi = bx;

	mov	edi, esi

; 294  :         byi = by;

	mov	ecx, edx
$LN8@MakeSADMas:

; 295  :       }
; 296  :       int i1 = bxi + byi*nBlkX;
; 297  :       sad_t sad = mvClip.GetBlock(0, i1).GetSAD();
; 298  :       Mask[bx + by*nBlkX] = ByteNorm(sad, dSADNormFactor, fGamma); // bits_per_pixel scale through dSADNormFactor

	imul	ecx, ebx
	add	ecx, edi
; File c:\github\mvtools\sources\fakeblockdata.h

; 55   : 	inline sad_t GetSAD() const { return vector.sad; }

	lea	eax, DWORD PTR [ecx+ecx*4]
; File c:\github\mvtools\sources\maskfun.cpp

; 268  :   double l = 255 * pow(sad*dSADNormFactor, fGamma); // Fizick - now linear for gm=1

	mov	ecx, DWORD PTR tv388[esp+80]
	movd	xmm0, DWORD PTR [ecx+eax*4+16]
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR _fGamma$[ebp]
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR __real@406fe00000000000

; 295  :       }
; 296  :       int i1 = bxi + byi*nBlkX;
; 297  :       sad_t sad = mvClip.GetBlock(0, i1).GetSAD();
; 298  :       Mask[bx + by*nBlkX] = ByteNorm(sad, dSADNormFactor, fGamma); // bits_per_pixel scale through dSADNormFactor

	mov	ecx, DWORD PTR _Mask$[ebp]
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	minsd	xmm1, xmm0

; 269  :   return (unsigned char)((l > 255) ? 255 : l);

	cvttsd2si eax, xmm1

; 282  :   {
; 283  :     for (int bx = 0; bx<nBlkX; bx++)

	movsd	xmm1, QWORD PTR _dSADNormFactor$1$[esp+80]

; 295  :       }
; 296  :       int i1 = bxi + byi*nBlkX;
; 297  :       sad_t sad = mvClip.GetBlock(0, i1).GetSAD();
; 298  :       Mask[bx + by*nBlkX] = ByteNorm(sad, dSADNormFactor, fGamma); // bits_per_pixel scale through dSADNormFactor

	mov	BYTE PTR [ecx+esi], al
	inc	esi
	mov	ecx, DWORD PTR tv385[esp+80]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR tv385[esp+80], ecx
	cmp	esi, ebx
	jl	$LL7@MakeSADMas
	mov	ecx, DWORD PTR _by$1$[esp+80]
	mov	edx, DWORD PTR _nBlkY$[ebp]
	mov	eax, DWORD PTR _Mask$[ebp]
	mov	edi, DWORD PTR tv382[esp+80]
$LN2@MakeSADMas:

; 280  : 
; 281  :   for (int by = 0; by<nBlkY; by++)

	add	edi, DWORD PTR tv381[esp+80]
	inc	ecx
	movsd	xmm1, QWORD PTR _dSADNormFactor$1$[esp+80]
	add	eax, ebx
	mov	DWORD PTR _by$1$[esp+80], ecx
	mov	DWORD PTR tv382[esp+80], edi
	mov	DWORD PTR _Mask$[ebp], eax
	cmp	ecx, edx
	jl	$LL4@MakeSADMas
$LN3@MakeSADMas:

; 299  :     }
; 300  :   }
; 301  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeSADMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ENDP	; MakeSADMaskTime
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z
_TEXT	SEGMENT
tv400 = -48						; size = 4
tv403 = -44						; size = 4
tv408 = -40						; size = 4
_mvClip$1$ = -36					; size = 4
_nBlkX$1$ = -32						; size = 4
tv402 = -28						; size = 4
$T1 = -24						; size = 12
$T2 = -12						; size = 12
_nBlkY$ = 8						; size = 4
_VXSmallY$ = 12						; size = 4
_pitchVXSmallY$ = 16					; size = 4
_VYSmallY$ = 20						; size = 4
_pitchVYSmallY$ = 24					; size = 4
?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z PROC	; MakeVectorSmallMasks, COMDAT
; _mvClip$ = ecx
; _nBlkX$ = edx

; 305  : {

	sub	esp, 48					; 00000030H
	push	ebx
	mov	ebx, edx
	mov	DWORD PTR _mvClip$1$[esp+52], ecx

; 306  :   // make  vector vx and vy small masks
; 307  :   for (int by = 0; by<nBlkY; by++)

	mov	edx, DWORD PTR _nBlkY$[esp+48]
	mov	DWORD PTR _nBlkX$1$[esp+52], ebx
	test	edx, edx
	jle	$LN3@MakeVector
	mov	eax, DWORD PTR _pitchVXSmallY$[esp+48]
	mov	ecx, DWORD PTR _VYSmallY$[esp+48]
	add	eax, eax
	mov	DWORD PTR tv403[esp+52], eax
	mov	eax, DWORD PTR _pitchVYSmallY$[esp+48]
	add	eax, eax
	mov	DWORD PTR tv402[esp+52], eax
	lea	eax, DWORD PTR [ebx+ebx*4]
	push	ebp
	xor	ebp, ebp
	shl	eax, 2
	push	esi
	mov	DWORD PTR tv400[esp+60], eax
	mov	eax, DWORD PTR _VXSmallY$[esp+56]
	mov	esi, DWORD PTR tv400[esp+60]
	push	edi
	mov	edi, DWORD PTR tv403[esp+64]
	mov	DWORD PTR tv408[esp+64], ebp
$LL4@MakeVector:

; 309  :     for (int bx = 0; bx<nBlkX; bx++)

	test	ebx, ebx
	jle	SHORT $LN2@MakeVector

; 315  :       VXSmallY[bx + by*pitchVXSmallY] = vx; // luma

	mov	esi, ebp
	mov	edi, ecx
	mov	ebp, DWORD PTR _mvClip$1$[esp+64]
	npad	3
$LL7@MakeVector:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	ecx, DWORD PTR [ebp+88]
; File c:\github\mvtools\sources\maskfun.cpp

; 309  :     for (int bx = 0; bx<nBlkX; bx++)

	lea	esi, DWORD PTR [esi+20]
	lea	eax, DWORD PTR [eax+2]
	lea	edi, DWORD PTR [edi+2]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [edx+esi-12]
	movq	QWORD PTR $T1[esp+64], xmm0
	movq	xmm0, xmm0
; File c:\github\mvtools\sources\maskfun.cpp

; 315  :       VXSmallY[bx + by*pitchVXSmallY] = vx; // luma

	movzx	ecx, WORD PTR $T1[esp+64]
	mov	WORD PTR [eax-2], cx
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T2[esp+64], xmm0
; File c:\github\mvtools\sources\maskfun.cpp

; 316  :       VYSmallY[bx + by*pitchVYSmallY] = vy; // luma

	movzx	ecx, WORD PTR $T2[esp+68]
	mov	WORD PTR [edi-2], cx
	sub	ebx, 1
	jne	SHORT $LL7@MakeVector
	mov	ebp, DWORD PTR tv408[esp+64]
	mov	eax, DWORD PTR _VXSmallY$[esp+60]
	mov	ecx, DWORD PTR _VYSmallY$[esp+60]
	mov	edx, DWORD PTR _nBlkY$[esp+60]
	mov	ebx, DWORD PTR _nBlkX$1$[esp+64]
	mov	esi, DWORD PTR tv400[esp+64]
	mov	edi, DWORD PTR tv403[esp+64]
$LN2@MakeVector:

; 306  :   // make  vector vx and vy small masks
; 307  :   for (int by = 0; by<nBlkY; by++)

	add	ecx, DWORD PTR tv402[esp+64]
	add	ebp, esi
	add	eax, edi
	mov	DWORD PTR tv408[esp+64], ebp
	sub	edx, 1
	mov	DWORD PTR _VYSmallY$[esp+60], ecx
	mov	DWORD PTR _VXSmallY$[esp+60], eax
	mov	DWORD PTR _nBlkY$[esp+60], edx
	jne	$LL4@MakeVector
	pop	edi
	pop	esi
	pop	ebp
$LN3@MakeVector:
	pop	ebx

; 317  :     }
; 318  :   }
; 319  : }

	add	esp, 48					; 00000030H
	ret	0
?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ENDP	; MakeVectorSmallMasks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z
_TEXT	SEGMENT
_VSmallUV$1$ = -4					; size = 4
_nBlkY$ = 8						; size = 4
_VSmallUV$ = 12						; size = 4
_nBlkY$2$ = 16						; size = 4
_nBlkY$1$ = 16						; size = 4
_ratioUV$ = 16						; size = 4
?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z PROC		; VectorSmallMaskYToHalfUV, COMDAT
; _VSmallY$ = ecx
; _nBlkX$ = edx

; 326  : {

	push	ecx

; 327  :   if (ratioUV == 2)

	cmp	DWORD PTR _ratioUV$[esp], 2
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, edx
	mov	esi, ecx
	jne	$LN14@VectorSmal

; 328  :   {
; 329  :     // e.g. YV12 colorformat 
; 330  :     for (int by = 0; by<nBlkY; by++)

	mov	ecx, DWORD PTR _nBlkY$[esp+16]
	mov	DWORD PTR _nBlkY$1$[esp+16], ecx
	test	ecx, ecx
	jle	$LN9@VectorSmal
	mov	edi, DWORD PTR _VSmallUV$[esp+16]
	lea	eax, DWORD PTR [ebx+ebx]
	mov	ebp, 1
	mov	DWORD PTR _VSmallUV$1$[esp+20], edi
$LL4@VectorSmal:

; 331  :     {
; 332  :       for (int bx = 0; bx<nBlkX; bx++)

	xor	edx, edx
	test	ebx, ebx
	jle	$LN6@VectorSmal
	cmp	ebx, 16					; 00000010H
	jb	SHORT $LN26@VectorSmal

; 333  :       {
; 334  :         VSmallUV[bx] = ((VSmallY[bx]) >> 1); // chroma

	lea	ecx, DWORD PTR [edi-2]
	add	ecx, eax
	add	eax, -2					; fffffffeH
	add	eax, esi
	cmp	edi, eax
	ja	SHORT $LN27@VectorSmal
	cmp	ecx, esi
	jae	SHORT $LN41@VectorSmal
$LN27@VectorSmal:
	mov	eax, ebx
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN42@VectorSmal
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN42@VectorSmal:
	movd	xmm1, ebp
	mov	ecx, ebx
	sub	ecx, eax

; 331  :     {
; 332  :       for (int bx = 0; bx<nBlkX; bx++)

	mov	ebp, esi
	lea	eax, DWORD PTR [edi+16]
	sub	ebp, edi
$LL7@VectorSmal:
	movups	xmm0, XMMWORD PTR [esi+edx*2]
	add	edx, 16					; 00000010H
	lea	eax, DWORD PTR [eax+32]

; 333  :       {
; 334  :         VSmallUV[bx] = ((VSmallY[bx]) >> 1); // chroma

	psraw	xmm0, xmm1
	movups	XMMWORD PTR [eax-48], xmm0
	movups	xmm0, XMMWORD PTR [eax+ebp-32]
	psraw	xmm0, xmm1
	movups	XMMWORD PTR [eax-32], xmm0
	cmp	edx, ecx
	jl	SHORT $LL7@VectorSmal
$LN41@VectorSmal:
	mov	ecx, DWORD PTR _nBlkY$1$[esp+16]
	lea	eax, DWORD PTR [ebx+ebx]
$LN26@VectorSmal:

; 331  :     {
; 332  :       for (int bx = 0; bx<nBlkX; bx++)

	cmp	edx, ebx
	jge	SHORT $LN6@VectorSmal
	mov	ebp, esi
	lea	ecx, DWORD PTR [edi+edx*2]
	sub	ebp, edi
	mov	edi, ebx
	sub	edi, edx
	npad	5
$LL25@VectorSmal:

; 333  :       {
; 334  :         VSmallUV[bx] = ((VSmallY[bx]) >> 1); // chroma

	mov	ax, WORD PTR [ecx+ebp]
	lea	ecx, DWORD PTR [ecx+2]
	sar	ax, 1
	mov	WORD PTR [ecx-2], ax
	sub	edi, 1
	jne	SHORT $LL25@VectorSmal
	mov	edi, DWORD PTR _VSmallUV$1$[esp+20]
	lea	eax, DWORD PTR [ebx+ebx]
	mov	ecx, DWORD PTR _nBlkY$1$[esp+16]
$LN6@VectorSmal:

; 335  :       }
; 336  :       VSmallY += nBlkX;
; 337  :       VSmallUV += nBlkX;

	add	edi, eax
	add	esi, eax
	sub	ecx, 1
	mov	DWORD PTR _VSmallUV$1$[esp+20], edi
	mov	DWORD PTR _nBlkY$1$[esp+16], ecx
	mov	ebp, 1
	jne	$LL4@VectorSmal
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 351  :     }
; 352  :   }
; 353  : 
; 354  : }

	pop	ecx
	ret	0
$LN14@VectorSmal:

; 338  :     }
; 339  :   }
; 340  :   else // ratioUV==1
; 341  :   {
; 342  :     // e.g. Height YUY2 colorformat
; 343  :     for (int by = 0; by<nBlkY; by++)

	mov	eax, DWORD PTR _nBlkY$[esp+16]
	mov	DWORD PTR _nBlkY$2$[esp+16], eax
	test	eax, eax
	jle	SHORT $LN9@VectorSmal
	mov	ebp, DWORD PTR _VSmallUV$[esp+16]
	lea	ecx, DWORD PTR [ebx+ebx]
$LL10@VectorSmal:

; 344  :     {
; 345  :       for (int bx = 0; bx<nBlkX; bx++)

	test	ebx, ebx
	jle	SHORT $LN12@VectorSmal
	mov	edi, esi
	mov	eax, ebp
	sub	edi, ebp
	mov	edx, ebx
	npad	3
$LL28@VectorSmal:

; 346  :       {
; 347  :         VSmallUV[bx] = VSmallY[bx]; // chroma

	mov	cx, WORD PTR [eax+edi]
	lea	eax, DWORD PTR [eax+2]
	mov	WORD PTR [eax-2], cx
	sub	edx, 1
	jne	SHORT $LL28@VectorSmal
	mov	eax, DWORD PTR _nBlkY$2$[esp+16]
	lea	ecx, DWORD PTR [ebx+ebx]
$LN12@VectorSmal:

; 348  :       }
; 349  :       VSmallY += nBlkX;

	add	esi, ecx

; 350  :       VSmallUV += nBlkX;

	add	ebp, ecx
	sub	eax, 1
	mov	DWORD PTR _nBlkY$2$[esp+16], eax
	jne	SHORT $LL10@VectorSmal
$LN9@VectorSmal:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 351  :     }
; 352  :   }
; 353  : 
; 354  : }

	pop	ecx
	ret	0
?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z ENDP		; VectorSmallMaskYToHalfUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ?Merge4PlanesToBig@@YAXPAEHPBE111HHHH_N@Z
_TEXT	SEGMENT
_pel2Plane$ = -8					; size = 4
_pel2Pitch$ = -4					; size = 4
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_width$ = 24						; size = 4
_height$ = 28						; size = 4
_pitch$ = 32						; size = 4
_pixelsize$ = 36					; size = 4
_isse$ = 40						; size = 1
?Merge4PlanesToBig@@YAXPAEHPBE111HHHH_N@Z PROC		; Merge4PlanesToBig, COMDAT
; _pel2Plane$ = ecx
; _pel2Pitch$ = edx

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 415  : 	// copy refined planes to big one plane
; 416  :   // P =  p0 p1 p0 p1 p0 p1 p0 p1...
; 417  :   //      p2 p3 p2 p3 p2 p3 p2 p3
; 418  :   // 
; 419  : #if defined(_M_X64) && defined(_MSC_VER)
; 420  :   isse = false;
; 421  :   // todo: Merge4PlanesToBig_sse2
; 422  : #endif
; 423  : 
; 424  : 	if (!isse || pixelsize>1)

	cmp	BYTE PTR _isse$[ebp], 0
	mov	eax, DWORD PTR _pixelsize$[ebp]
	mov	DWORD PTR _pel2Pitch$[ebp], edx
	mov	DWORD PTR _pel2Plane$[ebp], ecx
	je	$LN4@Merge4Plan
	cmp	eax, 1
	jg	$LN5@Merge4Plan

; 432  : 	}
; 433  : #if !(defined(_M_X64) && defined(_MSC_VER))
; 434  :   else // isse - not very optimized
; 435  : 	{
; 436  :     // todo SIMD intrinsic
; 437  : 		_asm

	push	ebx
	push	esi
	push	edi

; 438  : 		{
; 439  : #if !defined(_M_X64)
; 440  : #define pitch_ pitch
; 441  : #define pel2Pitch_ pel2Pitch
; 442  : #else
; 443  : #define pitch_ r8
; 444  : #define pel2Pitch_ r9
; 445  : 		movsx_int pitch_,pitch
; 446  : 		movsx_int pel2Pitch_,pel2Pitch
; 447  : #endif
; 448  : 		//	push ebx;
; 449  : 		//	push esi;
; 450  : 		//	push edi;
; 451  : 			mov rdi, pel2Plane;

	mov	edi, DWORD PTR _pel2Plane$[ebp]

; 452  : 			mov rsi, pPlane0;

	mov	esi, DWORD PTR _pPlane0$[ebp]

; 453  : 			mov rdx, pPlane1;

	mov	edx, DWORD PTR _pPlane1$[ebp]

; 454  : 
; 455  : 			mov ebx, height;

	mov	ebx, DWORD PTR _height$[ebp]
$looph1$14:

; 456  : looph1:
; 457  : 			mov ecx, width;

	mov	ecx, DWORD PTR _width$[ebp]

; 458  : 			mov eax, 0;

	mov	eax, 0
	npad	7
$loopw1$15:

; 459  : align 16
; 460  : loopw1:
; 461  : 			movd mm0, [rsi+rax];

	movd	mm0, DWORD PTR [esi+eax]

; 462  : 			movd mm1, [rdx+rax];

	movd	mm1, DWORD PTR [edx+eax]

; 463  : 			punpcklbw mm0, mm1;

	punpcklbw mm0, mm1

; 464  : 			shl eax, 1;

	shl	eax, 1

; 465  : 			movq [rdi+rax], mm0;

	movq	MMWORD PTR [edi+eax], mm0

; 466  : 			shr eax, 1;

	shr	eax, 1

; 467  : 			add eax, 4;

	add	eax, 4

; 468  : 			cmp eax, ecx;

	cmp	eax, ecx

; 469  : 			jl loopw1;

	jl	SHORT $loopw1$15

; 470  : 
; 471  : 			mov rax, pel2Pitch_;

	mov	eax, DWORD PTR _pel2Pitch$[ebp]

; 472  : 			add rdi, rax;

	add	edi, eax

; 473  : 			add rdi, rax;

	add	edi, eax

; 474  : 			mov rax, pitch_;

	mov	eax, DWORD PTR _pitch$[ebp]

; 475  : 			add rsi, rax;

	add	esi, eax

; 476  : 			add rdx, rax;

	add	edx, eax

; 477  : 			dec ebx;

	dec	ebx

; 478  : 			cmp ebx, 0;

	cmp	ebx, 0

; 479  : 			jg looph1;

	jg	SHORT $looph1$14

; 480  : 
; 481  : 			mov rdi, pel2Plane;

	mov	edi, DWORD PTR _pel2Plane$[ebp]

; 482  : 			mov rsi, pPlane2;

	mov	esi, DWORD PTR _pPlane2$[ebp]

; 483  : 			mov rdx, pPlane3;

	mov	edx, DWORD PTR _pPlane3$[ebp]

; 484  : 
; 485  : 			mov rax, pel2Pitch_;

	mov	eax, DWORD PTR _pel2Pitch$[ebp]

; 486  : 			add rdi, rax;

	add	edi, eax

; 487  : 
; 488  : 			mov ebx, height;

	mov	ebx, DWORD PTR _height$[ebp]
$looph2$16:

; 489  : looph2:
; 490  : 			mov ecx, width;

	mov	ecx, DWORD PTR _width$[ebp]

; 491  : 			mov eax, 0;

	mov	eax, 0
	npad	9
$loopw2$17:

; 492  : align 16
; 493  : loopw2:
; 494  : 			movd mm0, [rsi+rax];

	movd	mm0, DWORD PTR [esi+eax]

; 495  : 			movd mm1, [rdx+rax];

	movd	mm1, DWORD PTR [edx+eax]

; 496  : 			punpcklbw mm0, mm1;

	punpcklbw mm0, mm1

; 497  : 			shl eax, 1;

	shl	eax, 1

; 498  : 			movq [rdi+rax], mm0;

	movq	MMWORD PTR [edi+eax], mm0

; 499  : 			shr eax, 1;

	shr	eax, 1

; 500  : 			add eax, 4;

	add	eax, 4

; 501  : 			cmp eax, ecx;

	cmp	eax, ecx

; 502  : 			jl loopw2;

	jl	SHORT $loopw2$17

; 503  : 
; 504  : 			mov rax, pel2Pitch_;

	mov	eax, DWORD PTR _pel2Pitch$[ebp]

; 505  : 			add rdi, rax;

	add	edi, eax

; 506  : 			add rdi, rax;

	add	edi, eax

; 507  : 			mov rax, pitch_;

	mov	eax, DWORD PTR _pitch$[ebp]

; 508  : 			add rsi, rax;

	add	esi, eax

; 509  : 			add rdx, rax;

	add	edx, eax

; 510  : 			dec ebx;

	dec	ebx

; 511  : 			cmp ebx, 0;

	cmp	ebx, 0

; 512  : 			jg looph2;

	jg	SHORT $looph2$16

; 513  : 
; 514  : 		//	pop edi;
; 515  : 		//	pop esi;
; 516  : 		//	pop ebx;
; 517  : 			emms;

	emms

; 432  : 	}
; 433  : #if !(defined(_M_X64) && defined(_MSC_VER))
; 434  :   else // isse - not very optimized
; 435  : 	{
; 436  :     // todo SIMD intrinsic
; 437  : 		_asm

	pop	edi
	pop	esi
	pop	ebx

; 518  : #undef src_pitch_
; 519  : #undef pel2Pitch_
; 520  : 		}
; 521  : 	}
; 522  : #endif // inline assembly MSVC X64 ignore
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@Merge4Plan:

; 425  : 	{
; 426  :     if(pixelsize==1)

	cmp	eax, 1
	jne	SHORT $LN5@Merge4Plan

; 427  :       Merge4PlanesToBig_c<uint8_t>(pel2Plane, pel2Pitch, pPlane0, pPlane1, pPlane2, pPlane3, width, height, pitch, pixelsize);

	push	ecx
	push	DWORD PTR _pitch$[ebp]
	push	DWORD PTR _height$[ebp]
	push	DWORD PTR _width$[ebp]
	push	DWORD PTR _pPlane3$[ebp]
	push	DWORD PTR _pPlane2$[ebp]
	push	DWORD PTR _pPlane1$[ebp]
	push	DWORD PTR _pPlane0$[ebp]
	call	??$Merge4PlanesToBig_c@E@@YAXPAEHPBE111HHHH@Z ; Merge4PlanesToBig_c<unsigned char>

; 431  :       Merge4PlanesToBig_c<float>(pel2Plane, pel2Pitch, pPlane0, pPlane1, pPlane2, pPlane3, width, height, pitch, pixelsize);

	add	esp, 32					; 00000020H

; 518  : #undef src_pitch_
; 519  : #undef pel2Pitch_
; 520  : 		}
; 521  : 	}
; 522  : #endif // inline assembly MSVC X64 ignore
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Merge4Plan:

; 428  :     else if(pixelsize==2)

	cmp	eax, 2
	jne	SHORT $LN7@Merge4Plan

; 429  :       Merge4PlanesToBig_c<uint16_t>(pel2Plane, pel2Pitch, pPlane0, pPlane1, pPlane2, pPlane3, width, height, pitch, pixelsize);

	push	ecx
	push	DWORD PTR _pitch$[ebp]
	push	DWORD PTR _height$[ebp]
	push	DWORD PTR _width$[ebp]
	push	DWORD PTR _pPlane3$[ebp]
	push	DWORD PTR _pPlane2$[ebp]
	push	DWORD PTR _pPlane1$[ebp]
	push	DWORD PTR _pPlane0$[ebp]
	call	??$Merge4PlanesToBig_c@G@@YAXPAEHPBE111HHHH@Z ; Merge4PlanesToBig_c<unsigned short>

; 431  :       Merge4PlanesToBig_c<float>(pel2Plane, pel2Pitch, pPlane0, pPlane1, pPlane2, pPlane3, width, height, pitch, pixelsize);

	add	esp, 32					; 00000020H

; 518  : #undef src_pitch_
; 519  : #undef pel2Pitch_
; 520  : 		}
; 521  : 	}
; 522  : #endif // inline assembly MSVC X64 ignore
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@Merge4Plan:

; 430  :     else if(pixelsize==4)

	cmp	eax, 4
	jne	SHORT $LN9@Merge4Plan

; 431  :       Merge4PlanesToBig_c<float>(pel2Plane, pel2Pitch, pPlane0, pPlane1, pPlane2, pPlane3, width, height, pitch, pixelsize);

	push	ecx
	push	DWORD PTR _pitch$[ebp]
	push	DWORD PTR _height$[ebp]
	push	DWORD PTR _width$[ebp]
	push	DWORD PTR _pPlane3$[ebp]
	push	DWORD PTR _pPlane2$[ebp]
	push	DWORD PTR _pPlane1$[ebp]
	push	DWORD PTR _pPlane0$[ebp]
	call	??$Merge4PlanesToBig_c@M@@YAXPAEHPBE111HHHH@Z ; Merge4PlanesToBig_c<float>
	add	esp, 32					; 00000020H
$LN9@Merge4Plan:

; 518  : #undef src_pitch_
; 519  : #undef pel2Pitch_
; 520  : 		}
; 521  : 	}
; 522  : #endif // inline assembly MSVC X64 ignore
; 523  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Merge4PlanesToBig@@YAXPAEHPBE111HHHH_N@Z ENDP		; Merge4PlanesToBig
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ?Merge16PlanesToBig@@YAXPAEHPBE111111111111111HHHH_N@Z
_TEXT	SEGMENT
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_pPlane4$ = 24						; size = 4
_pPlane5$ = 28						; size = 4
_pPlane6$ = 32						; size = 4
_pPlane7$ = 36						; size = 4
_pPlane8$ = 40						; size = 4
_pPlane9$ = 44						; size = 4
_pPlane10$ = 48						; size = 4
_pPlane11$ = 52						; size = 4
_pPlane12$ = 56						; size = 4
_pPlane13$ = 60						; size = 4
_pPlane14$ = 64						; size = 4
_pPlane15$ = 68						; size = 4
_width$ = 72						; size = 4
_height$ = 76						; size = 4
_pitch$ = 80						; size = 4
_pixelsize$ = 84					; size = 4
_isse$dead$ = 88					; size = 1
?Merge16PlanesToBig@@YAXPAEHPBE111111111111111HHHH_N@Z PROC ; Merge16PlanesToBig, COMDAT
; _pel4Plane$ = ecx
; _pel4Pitch$ = edx

; 601  :   // no SSE2 here
; 602  :   if (pixelsize == 1)

	mov	eax, DWORD PTR _pixelsize$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@Merge16Pla

; 603  :     Merge16PlanesToBig_c<uint8_t>(pel4Plane, pel4Pitch,

	push	DWORD PTR _pitch$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _pPlane15$[esp+8]
	push	DWORD PTR _pPlane14$[esp+12]
	push	DWORD PTR _pPlane13$[esp+16]
	push	DWORD PTR _pPlane12$[esp+20]
	push	DWORD PTR _pPlane11$[esp+24]
	push	DWORD PTR _pPlane10$[esp+28]
	push	DWORD PTR _pPlane9$[esp+32]
	push	DWORD PTR _pPlane8$[esp+36]
	push	DWORD PTR _pPlane7$[esp+40]
	push	DWORD PTR _pPlane6$[esp+44]
	push	DWORD PTR _pPlane5$[esp+48]
	push	DWORD PTR _pPlane4$[esp+52]
	push	DWORD PTR _pPlane3$[esp+56]
	push	DWORD PTR _pPlane2$[esp+60]
	push	DWORD PTR _pPlane1$[esp+64]
	push	DWORD PTR _pPlane0$[esp+68]
	call	??$Merge16PlanesToBig_c@E@@YAXPAEHPBE111111111111111HHH@Z ; Merge16PlanesToBig_c<unsigned char>

; 617  :     Merge16PlanesToBig_c<float>(pel4Plane, pel4Pitch,

	add	esp, 76					; 0000004cH

; 618  :       pPlane0, pPlane1, pPlane2, pPlane3,
; 619  :       pPlane4, pPlane5, pPlane6, pPlane7,
; 620  :       pPlane8, pPlane9, pPlane10, pPlane11,
; 621  :       pPlane12, pPlane13, pPlane14, pPlane15,
; 622  :       width, height, pitch);
; 623  : }

	ret	0
$LN2@Merge16Pla:

; 604  :       pPlane0, pPlane1, pPlane2, pPlane3,
; 605  :       pPlane4, pPlane5, pPlane6, pPlane7,
; 606  :       pPlane8, pPlane9, pPlane10, pPlane11,
; 607  :       pPlane12, pPlane13, pPlane14, pPlane15,
; 608  :       width, height, pitch);
; 609  :   else if(pixelsize==2)

	cmp	eax, 2
	jne	SHORT $LN4@Merge16Pla

; 610  :     Merge16PlanesToBig_c<uint16_t>(pel4Plane, pel4Pitch,

	push	DWORD PTR _pitch$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _pPlane15$[esp+8]
	push	DWORD PTR _pPlane14$[esp+12]
	push	DWORD PTR _pPlane13$[esp+16]
	push	DWORD PTR _pPlane12$[esp+20]
	push	DWORD PTR _pPlane11$[esp+24]
	push	DWORD PTR _pPlane10$[esp+28]
	push	DWORD PTR _pPlane9$[esp+32]
	push	DWORD PTR _pPlane8$[esp+36]
	push	DWORD PTR _pPlane7$[esp+40]
	push	DWORD PTR _pPlane6$[esp+44]
	push	DWORD PTR _pPlane5$[esp+48]
	push	DWORD PTR _pPlane4$[esp+52]
	push	DWORD PTR _pPlane3$[esp+56]
	push	DWORD PTR _pPlane2$[esp+60]
	push	DWORD PTR _pPlane1$[esp+64]
	push	DWORD PTR _pPlane0$[esp+68]
	call	??$Merge16PlanesToBig_c@G@@YAXPAEHPBE111111111111111HHH@Z ; Merge16PlanesToBig_c<unsigned short>

; 617  :     Merge16PlanesToBig_c<float>(pel4Plane, pel4Pitch,

	add	esp, 76					; 0000004cH

; 618  :       pPlane0, pPlane1, pPlane2, pPlane3,
; 619  :       pPlane4, pPlane5, pPlane6, pPlane7,
; 620  :       pPlane8, pPlane9, pPlane10, pPlane11,
; 621  :       pPlane12, pPlane13, pPlane14, pPlane15,
; 622  :       width, height, pitch);
; 623  : }

	ret	0
$LN4@Merge16Pla:

; 611  :       pPlane0, pPlane1, pPlane2, pPlane3,
; 612  :       pPlane4, pPlane5, pPlane6, pPlane7,
; 613  :       pPlane8, pPlane9, pPlane10, pPlane11,
; 614  :       pPlane12, pPlane13, pPlane14, pPlane15,
; 615  :       width, height, pitch);
; 616  :   else if(pixelsize==4)

	cmp	eax, 4
	jne	SHORT $LN6@Merge16Pla

; 617  :     Merge16PlanesToBig_c<float>(pel4Plane, pel4Pitch,

	push	DWORD PTR _pitch$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _pPlane15$[esp+8]
	push	DWORD PTR _pPlane14$[esp+12]
	push	DWORD PTR _pPlane13$[esp+16]
	push	DWORD PTR _pPlane12$[esp+20]
	push	DWORD PTR _pPlane11$[esp+24]
	push	DWORD PTR _pPlane10$[esp+28]
	push	DWORD PTR _pPlane9$[esp+32]
	push	DWORD PTR _pPlane8$[esp+36]
	push	DWORD PTR _pPlane7$[esp+40]
	push	DWORD PTR _pPlane6$[esp+44]
	push	DWORD PTR _pPlane5$[esp+48]
	push	DWORD PTR _pPlane4$[esp+52]
	push	DWORD PTR _pPlane3$[esp+56]
	push	DWORD PTR _pPlane2$[esp+60]
	push	DWORD PTR _pPlane1$[esp+64]
	push	DWORD PTR _pPlane0$[esp+68]
	call	??$Merge16PlanesToBig_c@M@@YAXPAEHPBE111111111111111HHH@Z ; Merge16PlanesToBig_c<float>
	add	esp, 76					; 0000004cH
$LN6@Merge16Pla:

; 618  :       pPlane0, pPlane1, pPlane2, pPlane3,
; 619  :       pPlane4, pPlane5, pPlane6, pPlane7,
; 620  :       pPlane8, pPlane9, pPlane10, pPlane11,
; 621  :       pPlane12, pPlane13, pPlane14, pPlane15,
; 622  :       width, height, pitch);
; 623  : }

	ret	0
?Merge16PlanesToBig@@YAXPAEHPBE111111111111111HHHH_N@Z ENDP ; Merge16PlanesToBig
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Merge4PlanesToBig_c@E@@YAXPAEHPBE111HHHH@Z
_TEXT	SEGMENT
_pel2Pitch$1$ = -4					; size = 4
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_width$ = 24						; size = 4
_height$ = 28						; size = 4
_pitch$ = 32						; size = 4
_bits_per_pixel$dead$ = 36				; size = 4
??$Merge4PlanesToBig_c@E@@YAXPAEHPBE111HHHH@Z PROC	; Merge4PlanesToBig_c<unsigned char>, COMDAT
; _pel2Plane$ = ecx
; _pel2Pitch$ = edx

; 360  : {

	push	ecx

; 361  :   
; 362  :   for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp], 0
	mov	DWORD PTR _pel2Pitch$1$[esp+4], edx
	jle	$LN3@Merge4Plan
	mov	eax, DWORD PTR _pPlane1$[esp]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _pitch$[esp+8]
	push	esi
	push	edi
	mov	edi, DWORD PTR _width$[esp+16]
	npad	1
$LL4@Merge4Plan:

; 363  :   {
; 364  :     for (int w=0; w<width; w++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN6@Merge4Plan
	mov	ebx, DWORD PTR _pPlane0$[esp+16]
	mov	esi, eax
	sub	ebx, eax
	npad	2
$LL7@Merge4Plan:

; 365  :     {
; 366  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane0)[w];

	movzx	eax, BYTE PTR [ebx+esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+edx*2], al

; 367  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane1)[w];

	movzx	eax, BYTE PTR [esi-1]
	mov	BYTE PTR [ecx+edx*2+1], al
	inc	edx
	cmp	edx, edi
	jl	SHORT $LL7@Merge4Plan
$LN6@Merge4Plan:

; 368  :     }
; 369  :     pel2Plane += pel2Pitch;

	mov	eax, DWORD PTR _pel2Pitch$1$[esp+20]

; 370  :     for (int w=0; w<width; w++)

	xor	edx, edx
	add	ecx, eax
	test	edi, edi
	jle	SHORT $LN9@Merge4Plan
	mov	ebx, DWORD PTR _pPlane2$[esp+16]
	mov	esi, DWORD PTR _pPlane3$[esp+16]
	sub	ebx, esi
	npad	3
$LL10@Merge4Plan:

; 371  :     {
; 372  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane2)[w];

	movzx	eax, BYTE PTR [ebx+esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+edx*2], al

; 373  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane3)[w];

	movzx	eax, BYTE PTR [esi-1]
	mov	BYTE PTR [ecx+edx*2+1], al
	inc	edx
	cmp	edx, edi
	jl	SHORT $LL10@Merge4Plan
	mov	eax, DWORD PTR _pel2Pitch$1$[esp+20]
$LN9@Merge4Plan:

; 374  :     }
; 375  :     pel2Plane += pel2Pitch;
; 376  :     pPlane0 += pitch;
; 377  :     pPlane1 += pitch;
; 378  :     pPlane2 += pitch;

	add	DWORD PTR _pPlane2$[esp+16], ebp
	add	ecx, eax
	mov	eax, DWORD PTR _pPlane1$[esp+16]
	add	DWORD PTR _pPlane0$[esp+16], ebp
	add	eax, ebp
	add	DWORD PTR _pPlane3$[esp+16], ebp
	sub	DWORD PTR _height$[esp+16], 1
	mov	DWORD PTR _pPlane1$[esp+16], eax
	jne	SHORT $LL4@Merge4Plan
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Merge4Plan:

; 379  :     pPlane3 += pitch;
; 380  :   }
; 381  : }

	pop	ecx
	ret	0
??$Merge4PlanesToBig_c@E@@YAXPAEHPBE111HHHH@Z ENDP	; Merge4PlanesToBig_c<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Merge4PlanesToBig_c@G@@YAXPAEHPBE111HHHH@Z
_TEXT	SEGMENT
_pel2Pitch$1$ = -4					; size = 4
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_width$ = 24						; size = 4
_height$ = 28						; size = 4
_pitch$ = 32						; size = 4
_bits_per_pixel$dead$ = 36				; size = 4
??$Merge4PlanesToBig_c@G@@YAXPAEHPBE111HHHH@Z PROC	; Merge4PlanesToBig_c<unsigned short>, COMDAT
; _pel2Plane$ = ecx
; _pel2Pitch$ = edx

; 360  : {

	push	ecx

; 361  :   
; 362  :   for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp], 0
	mov	DWORD PTR _pel2Pitch$1$[esp+4], edx
	jle	$LN3@Merge4Plan
	mov	eax, DWORD PTR _pPlane1$[esp]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _pitch$[esp+8]
	push	esi
	push	edi
	mov	edi, DWORD PTR _width$[esp+16]
	npad	1
$LL4@Merge4Plan:

; 363  :   {
; 364  :     for (int w=0; w<width; w++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN6@Merge4Plan
	mov	ebx, DWORD PTR _pPlane0$[esp+16]
	mov	esi, eax
	sub	ebx, eax
	npad	2
$LL7@Merge4Plan:

; 365  :     {
; 366  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane0)[w];

	movzx	eax, WORD PTR [ebx+esi]
	lea	esi, DWORD PTR [esi+2]
	mov	WORD PTR [ecx+edx*4], ax

; 367  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane1)[w];

	movzx	eax, WORD PTR [esi-2]
	mov	WORD PTR [ecx+edx*4+2], ax
	inc	edx
	cmp	edx, edi
	jl	SHORT $LL7@Merge4Plan
$LN6@Merge4Plan:

; 368  :     }
; 369  :     pel2Plane += pel2Pitch;

	mov	eax, DWORD PTR _pel2Pitch$1$[esp+20]

; 370  :     for (int w=0; w<width; w++)

	xor	edx, edx
	add	ecx, eax
	test	edi, edi
	jle	SHORT $LN9@Merge4Plan
	mov	ebx, DWORD PTR _pPlane2$[esp+16]
	mov	esi, DWORD PTR _pPlane3$[esp+16]
	sub	ebx, esi
	npad	1
$LL10@Merge4Plan:

; 371  :     {
; 372  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane2)[w];

	movzx	eax, WORD PTR [ebx+esi]
	lea	esi, DWORD PTR [esi+2]
	mov	WORD PTR [ecx+edx*4], ax

; 373  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane3)[w];

	movzx	eax, WORD PTR [esi-2]
	mov	WORD PTR [ecx+edx*4+2], ax
	inc	edx
	cmp	edx, edi
	jl	SHORT $LL10@Merge4Plan
	mov	eax, DWORD PTR _pel2Pitch$1$[esp+20]
$LN9@Merge4Plan:

; 374  :     }
; 375  :     pel2Plane += pel2Pitch;
; 376  :     pPlane0 += pitch;
; 377  :     pPlane1 += pitch;
; 378  :     pPlane2 += pitch;

	add	DWORD PTR _pPlane2$[esp+16], ebp
	add	ecx, eax
	mov	eax, DWORD PTR _pPlane1$[esp+16]
	add	DWORD PTR _pPlane0$[esp+16], ebp
	add	eax, ebp
	add	DWORD PTR _pPlane3$[esp+16], ebp
	sub	DWORD PTR _height$[esp+16], 1
	mov	DWORD PTR _pPlane1$[esp+16], eax
	jne	SHORT $LL4@Merge4Plan
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Merge4Plan:

; 379  :     pPlane3 += pitch;
; 380  :   }
; 381  : }

	pop	ecx
	ret	0
??$Merge4PlanesToBig_c@G@@YAXPAEHPBE111HHHH@Z ENDP	; Merge4PlanesToBig_c<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Merge4PlanesToBig_c@M@@YAXPAEHPBE111HHHH@Z
_TEXT	SEGMENT
tv2196 = -20						; size = 4
_pel2Plane$1$ = -16					; size = 4
_pel2Pitch$1$ = -12					; size = 4
tv2205 = -8						; size = 4
tv2191 = -8						; size = 4
tv2200 = -4						; size = 4
tv2193 = -4						; size = 4
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_width$ = 24						; size = 4
_height$ = 28						; size = 4
_pitch$ = 32						; size = 4
_bits_per_pixel$dead$ = 36				; size = 4
??$Merge4PlanesToBig_c@M@@YAXPAEHPBE111HHHH@Z PROC	; Merge4PlanesToBig_c<float>, COMDAT
; _pel2Plane$ = ecx
; _pel2Pitch$ = edx

; 360  : {

	sub	esp, 20					; 00000014H

; 361  :   
; 362  :   for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+16], 0
	push	esi
	mov	DWORD PTR _pel2Pitch$1$[esp+24], edx
	mov	esi, ecx
	mov	DWORD PTR _pel2Plane$1$[esp+24], ecx
	jle	$LN3@Merge4Plan
	mov	eax, DWORD PTR _pPlane1$[esp+20]
	push	ebx
	push	ebp
	lea	ebp, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR _width$[esp+32]
	mov	DWORD PTR tv2196[esp+36], ebp
	npad	5
$LL4@Merge4Plan:

; 363  :   {
; 364  :     for (int w=0; w<width; w++)

	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LC22@Merge4Plan
	mov	ecx, DWORD PTR _pPlane0$[esp+32]
	lea	ebx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR tv2196[esp+36]
	lea	eax, DWORD PTR [edi-4]
	shr	eax, 2
	lea	ebp, DWORD PTR [ecx+12]
	sub	ecx, DWORD PTR _pPlane1$[esp+32]
	inc	eax
	mov	DWORD PTR tv2193[esp+36], ecx
	mov	esi, ecx
	mov	edi, eax
	mov	DWORD PTR tv2205[esp+36], eax
	lea	ecx, DWORD PTR [eax*4]
$LL23@Merge4Plan:

; 365  :     {
; 366  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane0)[w];

	mov	eax, DWORD PTR [ebp-12]

; 367  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane1)[w];

	lea	ebx, DWORD PTR [ebx+16]
	mov	DWORD PTR [edx-8], eax
	lea	ebp, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebx-20]
	lea	edx, DWORD PTR [edx+32]
	mov	DWORD PTR [edx-36], eax
	mov	eax, DWORD PTR [esi+ebx-16]
	mov	DWORD PTR [edx-32], eax
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR [edx-28], eax
	mov	eax, DWORD PTR [ebp-20]
	mov	DWORD PTR [edx-24], eax
	mov	eax, DWORD PTR [ebx-12]
	mov	DWORD PTR [edx-20], eax
	mov	eax, DWORD PTR [ebp-16]
	mov	DWORD PTR [edx-16], eax
	mov	eax, DWORD PTR [ebx-8]
	mov	DWORD PTR [edx-12], eax
	sub	edi, 1
	jne	SHORT $LL23@Merge4Plan
	mov	esi, DWORD PTR _pel2Plane$1$[esp+36]
	mov	edi, DWORD PTR _width$[esp+32]
	mov	ebp, DWORD PTR tv2196[esp+36]
$LC22@Merge4Plan:

; 363  :   {
; 364  :     for (int w=0; w<width; w++)

	cmp	ecx, edi
	jge	SHORT $LN21@Merge4Plan
	mov	eax, DWORD PTR _pPlane1$[esp+32]
	mov	ebx, DWORD PTR _pPlane0$[esp+32]
	sub	ebx, eax
	lea	edx, DWORD PTR [eax+ecx*4]
	npad	1
$LC7@Merge4Plan:

; 365  :     {
; 366  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane0)[w];

	mov	eax, DWORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+ecx*8], eax

; 367  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane1)[w];

	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [esi+ecx*8+4], eax
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LC7@Merge4Plan
$LN21@Merge4Plan:

; 368  :     }
; 369  :     pel2Plane += pel2Pitch;

	add	esi, DWORD PTR _pel2Pitch$1$[esp+36]

; 370  :     for (int w=0; w<width; w++)

	xor	ecx, ecx
	add	ebp, DWORD PTR _pel2Pitch$1$[esp+36]
	mov	DWORD PTR _pel2Plane$1$[esp+36], esi
	mov	DWORD PTR tv2196[esp+36], ebp
	cmp	edi, 4
	jl	$LC25@Merge4Plan

; 368  :     }
; 369  :     pel2Plane += pel2Pitch;

	mov	eax, DWORD PTR _pPlane2$[esp+32]
	mov	ecx, DWORD PTR _pPlane3$[esp+32]
	mov	edx, DWORD PTR tv2196[esp+36]
	lea	ebp, DWORD PTR [eax+12]
	sub	eax, ecx
	mov	DWORD PTR tv2191[esp+36], eax
	lea	ebx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR tv2191[esp+36]
	lea	eax, DWORD PTR [edi-4]
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv2200[esp+36], eax
	mov	edi, eax
	lea	ecx, DWORD PTR [eax*4]

; 370  :     for (int w=0; w<width; w++)

$LL26@Merge4Plan:

; 371  :     {
; 372  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane2)[w];

	mov	eax, DWORD PTR [ebp-12]

; 373  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane3)[w];

	lea	ebx, DWORD PTR [ebx+16]
	mov	DWORD PTR [edx-8], eax
	lea	ebp, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebx-20]
	lea	edx, DWORD PTR [edx+32]
	mov	DWORD PTR [edx-36], eax
	mov	eax, DWORD PTR [esi+ebx-16]
	mov	DWORD PTR [edx-32], eax
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR [edx-28], eax
	mov	eax, DWORD PTR [ebp-20]
	mov	DWORD PTR [edx-24], eax
	mov	eax, DWORD PTR [ebx-12]
	mov	DWORD PTR [edx-20], eax
	mov	eax, DWORD PTR [ebp-16]
	mov	DWORD PTR [edx-16], eax
	mov	eax, DWORD PTR [ebx-8]
	mov	DWORD PTR [edx-12], eax
	sub	edi, 1
	jne	SHORT $LL26@Merge4Plan
	mov	esi, DWORD PTR _pel2Plane$1$[esp+36]
	mov	edi, DWORD PTR _width$[esp+32]
	mov	ebp, DWORD PTR tv2196[esp+36]
$LC25@Merge4Plan:

; 370  :     for (int w=0; w<width; w++)

	cmp	ecx, edi
	jge	SHORT $LN24@Merge4Plan
	mov	eax, DWORD PTR _pPlane3$[esp+32]
	mov	ebx, DWORD PTR _pPlane2$[esp+32]
	sub	ebx, eax
	lea	edx, DWORD PTR [eax+ecx*4]
	npad	4
$LC10@Merge4Plan:

; 371  :     {
; 372  :       reinterpret_cast<pixel_t *>(pel2Plane)[w<<1] = reinterpret_cast<const pixel_t *>(pPlane2)[w];

	mov	eax, DWORD PTR [ebx+edx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+ecx*8], eax

; 373  :       reinterpret_cast<pixel_t *>(pel2Plane)[(w<<1) +1] = reinterpret_cast<const pixel_t *>(pPlane3)[w];

	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [esi+ecx*8+4], eax
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LC10@Merge4Plan
$LN24@Merge4Plan:

; 374  :     }
; 375  :     pel2Plane += pel2Pitch;
; 376  :     pPlane0 += pitch;
; 377  :     pPlane1 += pitch;
; 378  :     pPlane2 += pitch;

	mov	ecx, DWORD PTR _pitch$[esp+32]
	mov	eax, DWORD PTR _pPlane1$[esp+32]
	add	esi, DWORD PTR _pel2Pitch$1$[esp+36]
	add	eax, ecx
	add	ebp, DWORD PTR _pel2Pitch$1$[esp+36]
	add	DWORD PTR _pPlane2$[esp+32], ecx
	add	DWORD PTR _pPlane0$[esp+32], ecx
	add	DWORD PTR _pPlane3$[esp+32], ecx
	sub	DWORD PTR _height$[esp+32], 1
	mov	DWORD PTR _pel2Plane$1$[esp+36], esi
	mov	DWORD PTR tv2196[esp+36], ebp
	mov	DWORD PTR _pPlane1$[esp+32], eax
	jne	$LL4@Merge4Plan
	pop	edi
	pop	ebp
	pop	ebx
$LN3@Merge4Plan:
	pop	esi

; 379  :     pPlane3 += pitch;
; 380  :   }
; 381  : }

	add	esp, 20					; 00000014H
	ret	0
??$Merge4PlanesToBig_c@M@@YAXPAEHPBE111HHHH@Z ENDP	; Merge4PlanesToBig_c<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Merge16PlanesToBig_c@E@@YAXPAEHPBE111111111111111HHH@Z
_TEXT	SEGMENT
tv2254 = -12						; size = 4
_pel4Pitch$1$ = -8					; size = 4
tv2242 = -4						; size = 4
tv2239 = -4						; size = 4
tv2236 = -4						; size = 4
tv2233 = -4						; size = 4
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_pPlane4$ = 24						; size = 4
_pPlane5$ = 28						; size = 4
_pPlane6$ = 32						; size = 4
_pPlane7$ = 36						; size = 4
_pPlane8$ = 40						; size = 4
_pPlane9$ = 44						; size = 4
_pPlane10$ = 48						; size = 4
_pPlane11$ = 52						; size = 4
_pPlane12$ = 56						; size = 4
_pPlane13$ = 60						; size = 4
_pPlane14$ = 64						; size = 4
_pPlane15$ = 68						; size = 4
_width$ = 72						; size = 4
_height$ = 76						; size = 4
_pitch$ = 80						; size = 4
??$Merge16PlanesToBig_c@E@@YAXPAEHPBE111111111111111HHH@Z PROC ; Merge16PlanesToBig_c<unsigned char>, COMDAT
; _pel4Plane$ = ecx
; _pel4Pitch$ = edx

; 535  : {

	sub	esp, 12					; 0000000cH

; 536  :   // copy refined planes to big one plane
; 537  : //	if (!isse)
; 538  :   {
; 539  :     for (int h = 0; h < height; h++)

	cmp	DWORD PTR _height$[esp+8], 0
	mov	DWORD PTR _pel4Pitch$1$[esp+12], edx
	jle	$LN3@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _pPlane0$[esp+12]
	push	ebp
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+2]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	DWORD PTR tv2254[esp+28], edi
	npad	7
$LL4@Merge16Pla:

; 540  :     {
; 541  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN6@Merge16Pla
	mov	eax, DWORD PTR _pPlane1$[esp+24]
	mov	esi, edi
	mov	ebp, DWORD PTR _pPlane2$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane3$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	edx, eax
	mov	DWORD PTR tv2242[esp+28], ecx
	mov	eax, ecx
$LL7@Merge16Pla:

; 542  :       {
; 543  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane0)[w];

	movzx	ecx, BYTE PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [esi-2], cl
	lea	esi, DWORD PTR [esi+4]

; 544  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane1)[w];

	movzx	ecx, BYTE PTR [edx-1]
	mov	BYTE PTR [esi-5], cl

; 545  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane2)[w];

	movzx	ecx, BYTE PTR [edx+ebp-1]
	mov	BYTE PTR [esi-4], cl

; 546  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane3)[w];

	movzx	ecx, BYTE PTR [edx+eax-1]
	mov	BYTE PTR [esi-3], cl
	sub	edi, 1
	jne	SHORT $LL7@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2254[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN6@Merge16Pla:

; 547  :       }
; 548  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2254[esp+28], edi

; 549  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN9@Merge16Pla

; 547  :       }
; 548  :       pel4Plane += pel4Pitch;

	mov	eax, DWORD PTR _pPlane5$[esp+24]
	mov	esi, edi

; 549  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane4$[esp+24]
	mov	edx, eax
	mov	ebp, DWORD PTR _pPlane6$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane7$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	DWORD PTR tv2239[esp+28], ecx
	mov	eax, ecx
	npad	5
$LL10@Merge16Pla:

; 550  :       {
; 551  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane4)[w];

	movzx	ecx, BYTE PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [esi-2], cl
	lea	esi, DWORD PTR [esi+4]

; 552  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane5)[w];

	movzx	ecx, BYTE PTR [edx-1]
	mov	BYTE PTR [esi-5], cl

; 553  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane6)[w];

	movzx	ecx, BYTE PTR [edx+ebp-1]
	mov	BYTE PTR [esi-4], cl

; 554  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane7)[w];

	movzx	ecx, BYTE PTR [edx+eax-1]
	mov	BYTE PTR [esi-3], cl
	sub	edi, 1
	jne	SHORT $LL10@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2254[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN9@Merge16Pla:

; 555  :       }
; 556  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2254[esp+28], edi

; 557  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN12@Merge16Pla

; 555  :       }
; 556  :       pel4Plane += pel4Pitch;

	mov	eax, DWORD PTR _pPlane9$[esp+24]
	mov	esi, edi

; 557  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane8$[esp+24]
	mov	edx, eax
	mov	ebp, DWORD PTR _pPlane10$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane11$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	DWORD PTR tv2236[esp+28], ecx
	mov	eax, ecx
	npad	9
$LL13@Merge16Pla:

; 558  :       {
; 559  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane8)[w];

	movzx	ecx, BYTE PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [esi-2], cl
	lea	esi, DWORD PTR [esi+4]

; 560  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane9)[w];

	movzx	ecx, BYTE PTR [edx-1]
	mov	BYTE PTR [esi-5], cl

; 561  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane10)[w];

	movzx	ecx, BYTE PTR [edx+ebp-1]
	mov	BYTE PTR [esi-4], cl

; 562  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane11)[w];

	movzx	ecx, BYTE PTR [edx+eax-1]
	mov	BYTE PTR [esi-3], cl
	sub	edi, 1
	jne	SHORT $LL13@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2254[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN12@Merge16Pla:

; 563  :       }
; 564  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2254[esp+28], edi

; 565  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN15@Merge16Pla

; 563  :       }
; 564  :       pel4Plane += pel4Pitch;

	mov	eax, DWORD PTR _pPlane13$[esp+24]
	mov	esi, edi

; 565  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane12$[esp+24]
	mov	edx, eax
	mov	ebp, DWORD PTR _pPlane14$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane15$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	DWORD PTR tv2233[esp+28], ecx
	mov	eax, ecx
	npad	9
$LL16@Merge16Pla:

; 566  :       {
; 567  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane12)[w];

	movzx	ecx, BYTE PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [esi-2], cl
	lea	esi, DWORD PTR [esi+4]

; 568  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane13)[w];

	movzx	ecx, BYTE PTR [edx-1]
	mov	BYTE PTR [esi-5], cl

; 569  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane14)[w];

	movzx	ecx, BYTE PTR [edx+ebp-1]
	mov	BYTE PTR [esi-4], cl

; 570  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane15)[w];

	movzx	ecx, BYTE PTR [edx+eax-1]
	mov	BYTE PTR [esi-3], cl
	sub	edi, 1
	jne	SHORT $LL16@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2254[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN15@Merge16Pla:

; 571  :       }
; 572  :       pel4Plane += pel4Pitch;
; 573  :       pPlane0 += pitch;
; 574  :       pPlane1 += pitch;
; 575  :       pPlane2 += pitch;

	mov	ebx, DWORD PTR _pPlane0$[esp+24]
	add	edi, edx
	add	DWORD PTR _pPlane1$[esp+24], eax
	add	ebx, eax
	add	DWORD PTR _pPlane4$[esp+24], eax
	add	DWORD PTR _pPlane6$[esp+24], eax
	add	DWORD PTR _pPlane5$[esp+24], eax
	add	DWORD PTR _pPlane7$[esp+24], eax
	add	DWORD PTR _pPlane8$[esp+24], eax
	add	DWORD PTR _pPlane10$[esp+24], eax
	add	DWORD PTR _pPlane9$[esp+24], eax
	add	DWORD PTR _pPlane11$[esp+24], eax
	add	DWORD PTR _pPlane12$[esp+24], eax
	add	DWORD PTR _pPlane14$[esp+24], eax
	add	DWORD PTR _pPlane13$[esp+24], eax
	add	DWORD PTR _pPlane15$[esp+24], eax
	add	DWORD PTR _pPlane2$[esp+24], eax
	add	DWORD PTR _pPlane3$[esp+24], eax
	sub	DWORD PTR _height$[esp+24], 1
	mov	DWORD PTR tv2254[esp+28], edi
	mov	DWORD PTR _pPlane0$[esp+24], ebx
	jne	$LL4@Merge16Pla
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Merge16Pla:

; 576  :       pPlane3 += pitch;
; 577  :       pPlane4 += pitch;
; 578  :       pPlane5 += pitch;
; 579  :       pPlane6 += pitch;
; 580  :       pPlane7 += pitch;
; 581  :       pPlane8 += pitch;
; 582  :       pPlane9 += pitch;
; 583  :       pPlane10 += pitch;
; 584  :       pPlane11 += pitch;
; 585  :       pPlane12 += pitch;
; 586  :       pPlane13 += pitch;
; 587  :       pPlane14 += pitch;
; 588  :       pPlane15 += pitch;
; 589  :     }
; 590  :   }
; 591  : }

	add	esp, 12					; 0000000cH
	ret	0
??$Merge16PlanesToBig_c@E@@YAXPAEHPBE111111111111111HHH@Z ENDP ; Merge16PlanesToBig_c<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Merge16PlanesToBig_c@G@@YAXPAEHPBE111111111111111HHH@Z
_TEXT	SEGMENT
tv2354 = -12						; size = 4
_pel4Pitch$1$ = -8					; size = 4
tv2342 = -4						; size = 4
tv2339 = -4						; size = 4
tv2336 = -4						; size = 4
tv2333 = -4						; size = 4
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_pPlane4$ = 24						; size = 4
_pPlane5$ = 28						; size = 4
_pPlane6$ = 32						; size = 4
_pPlane7$ = 36						; size = 4
_pPlane8$ = 40						; size = 4
_pPlane9$ = 44						; size = 4
_pPlane10$ = 48						; size = 4
_pPlane11$ = 52						; size = 4
_pPlane12$ = 56						; size = 4
_pPlane13$ = 60						; size = 4
_pPlane14$ = 64						; size = 4
_pPlane15$ = 68						; size = 4
_width$ = 72						; size = 4
_height$ = 76						; size = 4
_pitch$ = 80						; size = 4
??$Merge16PlanesToBig_c@G@@YAXPAEHPBE111111111111111HHH@Z PROC ; Merge16PlanesToBig_c<unsigned short>, COMDAT
; _pel4Plane$ = ecx
; _pel4Pitch$ = edx

; 535  : {

	sub	esp, 12					; 0000000cH

; 536  :   // copy refined planes to big one plane
; 537  : //	if (!isse)
; 538  :   {
; 539  :     for (int h = 0; h < height; h++)

	cmp	DWORD PTR _height$[esp+8], 0
	mov	DWORD PTR _pel4Pitch$1$[esp+12], edx
	jle	$LN3@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _pPlane0$[esp+12]
	push	ebp
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	DWORD PTR tv2354[esp+28], edi
	npad	7
$LL4@Merge16Pla:

; 540  :     {
; 541  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN6@Merge16Pla
	mov	eax, DWORD PTR _pPlane1$[esp+24]
	mov	esi, edi
	mov	ebp, DWORD PTR _pPlane2$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane3$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	edx, eax
	mov	DWORD PTR tv2342[esp+28], ecx
	mov	eax, ecx
$LL7@Merge16Pla:

; 542  :       {
; 543  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane0)[w];

	movzx	ecx, WORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+2]
	mov	WORD PTR [esi-4], cx
	lea	esi, DWORD PTR [esi+8]

; 544  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane1)[w];

	movzx	ecx, WORD PTR [edx-2]
	mov	WORD PTR [esi-10], cx

; 545  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane2)[w];

	movzx	ecx, WORD PTR [edx+ebp-2]
	mov	WORD PTR [esi-8], cx

; 546  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane3)[w];

	movzx	ecx, WORD PTR [edx+eax-2]
	mov	WORD PTR [esi-6], cx
	sub	edi, 1
	jne	SHORT $LL7@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN6@Merge16Pla:

; 547  :       }
; 548  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2354[esp+28], edi

; 549  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN9@Merge16Pla

; 547  :       }
; 548  :       pel4Plane += pel4Pitch;

	mov	eax, DWORD PTR _pPlane5$[esp+24]
	mov	esi, edi

; 549  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane4$[esp+24]
	mov	edx, eax
	mov	ebp, DWORD PTR _pPlane6$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane7$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	DWORD PTR tv2339[esp+28], ecx
	mov	eax, ecx
	npad	1
$LL10@Merge16Pla:

; 550  :       {
; 551  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane4)[w];

	movzx	ecx, WORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+2]
	mov	WORD PTR [esi-4], cx
	lea	esi, DWORD PTR [esi+8]

; 552  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane5)[w];

	movzx	ecx, WORD PTR [edx-2]
	mov	WORD PTR [esi-10], cx

; 553  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane6)[w];

	movzx	ecx, WORD PTR [edx+ebp-2]
	mov	WORD PTR [esi-8], cx

; 554  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane7)[w];

	movzx	ecx, WORD PTR [edx+eax-2]
	mov	WORD PTR [esi-6], cx
	sub	edi, 1
	jne	SHORT $LL10@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN9@Merge16Pla:

; 555  :       }
; 556  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2354[esp+28], edi

; 557  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN12@Merge16Pla

; 555  :       }
; 556  :       pel4Plane += pel4Pitch;

	mov	eax, DWORD PTR _pPlane9$[esp+24]
	mov	esi, edi

; 557  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane8$[esp+24]
	mov	edx, eax
	mov	ebp, DWORD PTR _pPlane10$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane11$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	DWORD PTR tv2336[esp+28], ecx
	mov	eax, ecx
	npad	5
$LL13@Merge16Pla:

; 558  :       {
; 559  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane8)[w];

	movzx	ecx, WORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+2]
	mov	WORD PTR [esi-4], cx
	lea	esi, DWORD PTR [esi+8]

; 560  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane9)[w];

	movzx	ecx, WORD PTR [edx-2]
	mov	WORD PTR [esi-10], cx

; 561  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane10)[w];

	movzx	ecx, WORD PTR [edx+ebp-2]
	mov	WORD PTR [esi-8], cx

; 562  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane11)[w];

	movzx	ecx, WORD PTR [edx+eax-2]
	mov	WORD PTR [esi-6], cx
	sub	edi, 1
	jne	SHORT $LL13@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN12@Merge16Pla:

; 563  :       }
; 564  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2354[esp+28], edi

; 565  :       for (int w = 0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN15@Merge16Pla

; 563  :       }
; 564  :       pel4Plane += pel4Pitch;

	mov	eax, DWORD PTR _pPlane13$[esp+24]
	mov	esi, edi

; 565  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane12$[esp+24]
	mov	edx, eax
	mov	ebp, DWORD PTR _pPlane14$[esp+24]
	sub	ebx, eax
	mov	ecx, DWORD PTR _pPlane15$[esp+24]
	sub	ebp, eax
	mov	edi, DWORD PTR _width$[esp+24]
	sub	ecx, eax
	mov	DWORD PTR tv2333[esp+28], ecx
	mov	eax, ecx
	npad	5
$LL16@Merge16Pla:

; 566  :       {
; 567  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane12)[w];

	movzx	ecx, WORD PTR [ebx+edx]
	lea	edx, DWORD PTR [edx+2]
	mov	WORD PTR [esi-4], cx
	lea	esi, DWORD PTR [esi+8]

; 568  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane13)[w];

	movzx	ecx, WORD PTR [edx-2]
	mov	WORD PTR [esi-10], cx

; 569  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane14)[w];

	movzx	ecx, WORD PTR [edx+ebp-2]
	mov	WORD PTR [esi-8], cx

; 570  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane15)[w];

	movzx	ecx, WORD PTR [eax+edx-2]
	mov	WORD PTR [esi-6], cx
	sub	edi, 1
	jne	SHORT $LL16@Merge16Pla
	mov	eax, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	ecx, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN15@Merge16Pla:

; 571  :       }
; 572  :       pel4Plane += pel4Pitch;
; 573  :       pPlane0 += pitch;
; 574  :       pPlane1 += pitch;
; 575  :       pPlane2 += pitch;

	mov	ebx, DWORD PTR _pPlane0$[esp+24]
	add	edi, edx
	add	DWORD PTR _pPlane1$[esp+24], eax
	add	ebx, eax
	add	DWORD PTR _pPlane4$[esp+24], eax
	add	DWORD PTR _pPlane6$[esp+24], eax
	add	DWORD PTR _pPlane5$[esp+24], eax
	add	DWORD PTR _pPlane7$[esp+24], eax
	add	DWORD PTR _pPlane8$[esp+24], eax
	add	DWORD PTR _pPlane10$[esp+24], eax
	add	DWORD PTR _pPlane9$[esp+24], eax
	add	DWORD PTR _pPlane11$[esp+24], eax
	add	DWORD PTR _pPlane12$[esp+24], eax
	add	DWORD PTR _pPlane14$[esp+24], eax
	add	DWORD PTR _pPlane13$[esp+24], eax
	add	DWORD PTR _pPlane15$[esp+24], eax
	add	DWORD PTR _pPlane2$[esp+24], eax
	add	DWORD PTR _pPlane3$[esp+24], eax
	sub	DWORD PTR _height$[esp+24], 1
	mov	DWORD PTR tv2354[esp+28], edi
	mov	DWORD PTR _pPlane0$[esp+24], ebx
	jne	$LL4@Merge16Pla
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Merge16Pla:

; 576  :       pPlane3 += pitch;
; 577  :       pPlane4 += pitch;
; 578  :       pPlane5 += pitch;
; 579  :       pPlane6 += pitch;
; 580  :       pPlane7 += pitch;
; 581  :       pPlane8 += pitch;
; 582  :       pPlane9 += pitch;
; 583  :       pPlane10 += pitch;
; 584  :       pPlane11 += pitch;
; 585  :       pPlane12 += pitch;
; 586  :       pPlane13 += pitch;
; 587  :       pPlane14 += pitch;
; 588  :       pPlane15 += pitch;
; 589  :     }
; 590  :   }
; 591  : }

	add	esp, 12					; 0000000cH
	ret	0
??$Merge16PlanesToBig_c@G@@YAXPAEHPBE111111111111111HHH@Z ENDP ; Merge16PlanesToBig_c<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Merge16PlanesToBig_c@M@@YAXPAEHPBE111111111111111HHH@Z
_TEXT	SEGMENT
tv2354 = -12						; size = 4
_pel4Pitch$1$ = -8					; size = 4
tv2342 = -4						; size = 4
tv2339 = -4						; size = 4
tv2336 = -4						; size = 4
tv2333 = -4						; size = 4
_pPlane0$ = 8						; size = 4
_pPlane1$ = 12						; size = 4
_pPlane2$ = 16						; size = 4
_pPlane3$ = 20						; size = 4
_pPlane4$ = 24						; size = 4
_pPlane5$ = 28						; size = 4
_pPlane6$ = 32						; size = 4
_pPlane7$ = 36						; size = 4
_pPlane8$ = 40						; size = 4
_pPlane9$ = 44						; size = 4
_pPlane10$ = 48						; size = 4
_pPlane11$ = 52						; size = 4
_pPlane12$ = 56						; size = 4
_pPlane13$ = 60						; size = 4
_pPlane14$ = 64						; size = 4
_pPlane15$ = 68						; size = 4
_width$ = 72						; size = 4
_height$ = 76						; size = 4
_pitch$ = 80						; size = 4
??$Merge16PlanesToBig_c@M@@YAXPAEHPBE111111111111111HHH@Z PROC ; Merge16PlanesToBig_c<float>, COMDAT
; _pel4Plane$ = ecx
; _pel4Pitch$ = edx

; 535  : {

	sub	esp, 12					; 0000000cH

; 536  :   // copy refined planes to big one plane
; 537  : //	if (!isse)
; 538  :   {
; 539  :     for (int h = 0; h < height; h++)

	cmp	DWORD PTR _height$[esp+8], 0
	mov	DWORD PTR _pel4Pitch$1$[esp+12], edx
	jle	$LN3@Merge16Pla
	mov	eax, DWORD PTR _width$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR _pPlane0$[esp+12]
	push	ebp
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _pitch$[esp+24]
	mov	DWORD PTR tv2354[esp+28], edi
	npad	7
$LL4@Merge16Pla:

; 540  :     {
; 541  :       for (int w = 0; w < width; w++)

	test	eax, eax
	jle	SHORT $LN6@Merge16Pla
	mov	ecx, DWORD PTR _pPlane1$[esp+24]
	mov	esi, edi
	mov	ebp, DWORD PTR _pPlane2$[esp+24]
	sub	ebx, ecx
	mov	eax, DWORD PTR _pPlane3$[esp+24]
	sub	ebp, ecx
	mov	edi, DWORD PTR _width$[esp+24]
	sub	eax, ecx
	mov	edx, ecx
	mov	DWORD PTR tv2342[esp+28], eax
	mov	ecx, eax
$LL7@Merge16Pla:

; 542  :       {
; 543  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane0)[w];

	mov	eax, DWORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi-8], eax
	lea	esi, DWORD PTR [esi+16]

; 544  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane1)[w];

	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [esi-20], eax

; 545  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane2)[w];

	mov	eax, DWORD PTR [edx+ebp-4]
	mov	DWORD PTR [esi-16], eax

; 546  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane3)[w];

	mov	eax, DWORD PTR [edx+ecx-4]
	mov	DWORD PTR [esi-12], eax
	sub	edi, 1
	jne	SHORT $LL7@Merge16Pla
	mov	ecx, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	eax, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN6@Merge16Pla:

; 547  :       }
; 548  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2354[esp+28], edi

; 549  :       for (int w = 0; w < width; w++)

	test	eax, eax
	jle	SHORT $LN9@Merge16Pla

; 547  :       }
; 548  :       pel4Plane += pel4Pitch;

	mov	ecx, DWORD PTR _pPlane5$[esp+24]
	mov	esi, edi

; 549  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane4$[esp+24]
	mov	edx, ecx
	mov	ebp, DWORD PTR _pPlane6$[esp+24]
	sub	ebx, ecx
	mov	eax, DWORD PTR _pPlane7$[esp+24]
	sub	ebp, ecx
	mov	edi, DWORD PTR _width$[esp+24]
	sub	eax, ecx
	mov	DWORD PTR tv2339[esp+28], eax
	mov	ecx, eax
$LL10@Merge16Pla:

; 550  :       {
; 551  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane4)[w];

	mov	eax, DWORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi-8], eax
	lea	esi, DWORD PTR [esi+16]

; 552  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane5)[w];

	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [esi-20], eax

; 553  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane6)[w];

	mov	eax, DWORD PTR [edx+ebp-4]
	mov	DWORD PTR [esi-16], eax

; 554  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane7)[w];

	mov	eax, DWORD PTR [edx+ecx-4]
	mov	DWORD PTR [esi-12], eax
	sub	edi, 1
	jne	SHORT $LL10@Merge16Pla
	mov	ecx, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	eax, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN9@Merge16Pla:

; 555  :       }
; 556  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2354[esp+28], edi

; 557  :       for (int w = 0; w < width; w++)

	test	eax, eax
	jle	SHORT $LN12@Merge16Pla

; 555  :       }
; 556  :       pel4Plane += pel4Pitch;

	mov	ecx, DWORD PTR _pPlane9$[esp+24]
	mov	esi, edi

; 557  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane8$[esp+24]
	mov	edx, ecx
	mov	ebp, DWORD PTR _pPlane10$[esp+24]
	sub	ebx, ecx
	mov	eax, DWORD PTR _pPlane11$[esp+24]
	sub	ebp, ecx
	mov	edi, DWORD PTR _width$[esp+24]
	sub	eax, ecx
	mov	DWORD PTR tv2336[esp+28], eax
	mov	ecx, eax
	npad	6
$LL13@Merge16Pla:

; 558  :       {
; 559  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane8)[w];

	mov	eax, DWORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi-8], eax
	lea	esi, DWORD PTR [esi+16]

; 560  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane9)[w];

	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [esi-20], eax

; 561  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane10)[w];

	mov	eax, DWORD PTR [edx+ebp-4]
	mov	DWORD PTR [esi-16], eax

; 562  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane11)[w];

	mov	eax, DWORD PTR [edx+ecx-4]
	mov	DWORD PTR [esi-12], eax
	sub	edi, 1
	jne	SHORT $LL13@Merge16Pla
	mov	ecx, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	eax, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN12@Merge16Pla:

; 563  :       }
; 564  :       pel4Plane += pel4Pitch;

	add	edi, edx
	mov	DWORD PTR tv2354[esp+28], edi

; 565  :       for (int w = 0; w < width; w++)

	test	eax, eax
	jle	SHORT $LN15@Merge16Pla

; 563  :       }
; 564  :       pel4Plane += pel4Pitch;

	mov	ecx, DWORD PTR _pPlane13$[esp+24]
	mov	esi, edi

; 565  :       for (int w = 0; w < width; w++)

	mov	ebx, DWORD PTR _pPlane12$[esp+24]
	mov	edx, ecx
	mov	ebp, DWORD PTR _pPlane14$[esp+24]
	sub	ebx, ecx
	mov	eax, DWORD PTR _pPlane15$[esp+24]
	sub	ebp, ecx
	mov	edi, DWORD PTR _width$[esp+24]
	sub	eax, ecx
	mov	DWORD PTR tv2333[esp+28], eax
	mov	ecx, eax
$LL16@Merge16Pla:

; 566  :       {
; 567  :         reinterpret_cast<pixel_t *>(pel4Plane)[w << 2] = reinterpret_cast<const pixel_t *>(pPlane12)[w];

	mov	eax, DWORD PTR [ebx+edx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi-8], eax
	lea	esi, DWORD PTR [esi+16]

; 568  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 1] = reinterpret_cast<const pixel_t *>(pPlane13)[w];

	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [esi-20], eax

; 569  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 2] = reinterpret_cast<const pixel_t *>(pPlane14)[w];

	mov	eax, DWORD PTR [edx+ebp-4]
	mov	DWORD PTR [esi-16], eax

; 570  :         reinterpret_cast<pixel_t *>(pel4Plane)[(w << 2) + 3] = reinterpret_cast<const pixel_t *>(pPlane15)[w];

	mov	eax, DWORD PTR [ecx+edx-4]
	mov	DWORD PTR [esi-12], eax
	sub	edi, 1
	jne	SHORT $LL16@Merge16Pla
	mov	ecx, DWORD PTR _pitch$[esp+24]
	mov	edi, DWORD PTR tv2354[esp+28]
	mov	eax, DWORD PTR _width$[esp+24]
	mov	edx, DWORD PTR _pel4Pitch$1$[esp+28]
$LN15@Merge16Pla:

; 571  :       }
; 572  :       pel4Plane += pel4Pitch;
; 573  :       pPlane0 += pitch;
; 574  :       pPlane1 += pitch;
; 575  :       pPlane2 += pitch;

	mov	ebx, DWORD PTR _pPlane0$[esp+24]
	add	edi, edx
	add	DWORD PTR _pPlane1$[esp+24], ecx
	add	ebx, ecx
	add	DWORD PTR _pPlane4$[esp+24], ecx
	add	DWORD PTR _pPlane6$[esp+24], ecx
	add	DWORD PTR _pPlane5$[esp+24], ecx
	add	DWORD PTR _pPlane7$[esp+24], ecx
	add	DWORD PTR _pPlane8$[esp+24], ecx
	add	DWORD PTR _pPlane10$[esp+24], ecx
	add	DWORD PTR _pPlane9$[esp+24], ecx
	add	DWORD PTR _pPlane11$[esp+24], ecx
	add	DWORD PTR _pPlane12$[esp+24], ecx
	add	DWORD PTR _pPlane14$[esp+24], ecx
	add	DWORD PTR _pPlane13$[esp+24], ecx
	add	DWORD PTR _pPlane15$[esp+24], ecx
	add	DWORD PTR _pPlane2$[esp+24], ecx
	add	DWORD PTR _pPlane3$[esp+24], ecx
	sub	DWORD PTR _height$[esp+24], 1
	mov	DWORD PTR tv2354[esp+28], edi
	mov	DWORD PTR _pPlane0$[esp+24], ebx
	jne	$LL4@Merge16Pla
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@Merge16Pla:

; 576  :       pPlane3 += pitch;
; 577  :       pPlane4 += pitch;
; 578  :       pPlane5 += pitch;
; 579  :       pPlane6 += pitch;
; 580  :       pPlane7 += pitch;
; 581  :       pPlane8 += pitch;
; 582  :       pPlane9 += pitch;
; 583  :       pPlane10 += pitch;
; 584  :       pPlane11 += pitch;
; 585  :       pPlane12 += pitch;
; 586  :       pPlane13 += pitch;
; 587  :       pPlane14 += pitch;
; 588  :       pPlane15 += pitch;
; 589  :     }
; 590  :   }
; 591  : }

	add	esp, 12					; 0000000cH
	ret	0
??$Merge16PlanesToBig_c@M@@YAXPAEHPBE111111111111111HHH@Z ENDP ; Merge16PlanesToBig_c<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z
_TEXT	SEGMENT
_pdst$1$ = -8						; size = 4
_psrc$1$ = -4						; size = 4
_pref8$ = 8						; size = 4
_height$ = 12						; size = 4
_width$ = 16						; size = 4
_dst_pitch$ = 20					; size = 4
_src_pitch$ = 24					; size = 4
_ref_pitch$ = 28					; size = 4
_time256$ = 32						; size = 4
_isse$dead$ = 36					; size = 1
??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z PROC			; Blend<unsigned char>, COMDAT
; _pdst8$ = ecx
; _psrc8$ = edx

; 649  : {

	sub	esp, 8

; 651  :   const pixel_t *psrc = reinterpret_cast<const pixel_t *>(psrc8);
; 652  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 653  :   dst_pitch /= sizeof(pixel_t);
; 654  :   src_pitch /= sizeof(pixel_t);
; 655  :   ref_pitch /= sizeof(pixel_t);
; 656  :   // add isse
; 657  :   int h, w;
; 658  :   for (h = 0; h<height; h++)

	mov	eax, DWORD PTR _height$[esp+4]
	mov	DWORD PTR _pdst$1$[esp+8], ecx
	push	ebx
	mov	ebx, edx
	mov	edx, ecx
	mov	DWORD PTR _psrc$1$[esp+12], ebx
	test	eax, eax
	jle	$LN3@Blend

; 650  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);

	mov	ecx, DWORD PTR _pref8$[esp+8]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _width$[esp+16]
	push	edi
$LL4@Blend:

; 659  :   {
; 660  :     for (w = 0; w<width; w++)

	test	esi, esi
	jle	SHORT $LN6@Blend
	mov	edi, 256				; 00000100H
	mov	ebp, edx
	sub	edi, DWORD PTR _time256$[esp+20]
	sub	ebx, ecx
	mov	eax, ecx
	sub	ebp, ecx
	npad	5
$LL7@Blend:

; 661  :     {
; 662  :       //const int		time256 = t256_provider.get_t (w);
; 663  :       pdst[w] =(pixel_t)( (psrc[w] * (256 - time256) + pref[w] * time256) >> 8);

	movzx	edx, BYTE PTR [ebx+eax]
	lea	eax, DWORD PTR [eax+1]
	movzx	ecx, BYTE PTR [eax-1]
	imul	ecx, DWORD PTR _time256$[esp+20]
	imul	edx, edi
	add	edx, ecx
	sar	edx, 8
	mov	BYTE PTR [eax+ebp-1], dl
	sub	esi, 1
	jne	SHORT $LL7@Blend
	mov	ecx, DWORD PTR _pref8$[esp+20]
	mov	edx, DWORD PTR _pdst$1$[esp+24]
	mov	ebx, DWORD PTR _psrc$1$[esp+24]
	mov	eax, DWORD PTR _height$[esp+20]
	mov	esi, DWORD PTR _width$[esp+20]
$LN6@Blend:

; 664  :     }
; 665  :     pdst += dst_pitch;

	add	edx, DWORD PTR _dst_pitch$[esp+20]

; 666  :     psrc += src_pitch;

	add	ebx, DWORD PTR _src_pitch$[esp+20]

; 667  :     pref += ref_pitch;

	add	ecx, DWORD PTR _ref_pitch$[esp+20]
	sub	eax, 1
	mov	DWORD PTR _pdst$1$[esp+24], edx
	mov	DWORD PTR _psrc$1$[esp+24], ebx
	mov	DWORD PTR _pref8$[esp+20], ecx
	mov	DWORD PTR _height$[esp+20], eax
	jne	SHORT $LL4@Blend
	pop	edi
	pop	esi
	pop	ebp
$LN3@Blend:
	pop	ebx

; 668  :     //t256_provider.jump_to_next_row ();
; 669  :   }
; 670  : }

	add	esp, 8
	ret	0
??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z ENDP			; Blend<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z
_TEXT	SEGMENT
_pdst$1$ = -24						; size = 4
_psrc$1$ = -20						; size = 4
tv787 = -16						; size = 4
tv802 = -12						; size = 4
tv801 = -8						; size = 4
tv800 = -4						; size = 4
_pref8$ = 8						; size = 4
_height$ = 12						; size = 4
_width$ = 16						; size = 4
tv795 = 20						; size = 4
tv794 = 20						; size = 4
_dst_pitch$ = 20					; size = 4
tv793 = 24						; size = 4
tv792 = 24						; size = 4
_src_pitch$ = 24					; size = 4
tv791 = 28						; size = 4
_ref_pitch$ = 28					; size = 4
_time256$ = 32						; size = 4
_isse$dead$ = 36					; size = 1
??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z PROC			; Blend<unsigned short>, COMDAT
; _pdst8$ = ecx
; _psrc8$ = edx

; 649  : {

	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR _time256$[esp+20]
	push	ebx
	push	ebp

; 650  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 651  :   const pixel_t *psrc = reinterpret_cast<const pixel_t *>(psrc8);
; 652  :   const pixel_t *pref = reinterpret_cast<const pixel_t *>(pref8);
; 653  :   dst_pitch /= sizeof(pixel_t);
; 654  :   src_pitch /= sizeof(pixel_t);
; 655  :   ref_pitch /= sizeof(pixel_t);

	mov	ebp, DWORD PTR _ref_pitch$[esp+28]
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR _src_pitch$[esp+32]
	mov	DWORD PTR _pdst$1$[esp+36], ecx
	mov	ecx, DWORD PTR _dst_pitch$[esp+32]
	movd	xmm0, eax
	shr	ecx, 1
	shr	esi, 1
	shr	ebp, 1

; 656  :   // add isse
; 657  :   int h, w;
; 658  :   for (h = 0; h<height; h++)

	cmp	DWORD PTR _height$[esp+32], 0
	push	edi
	mov	edi, DWORD PTR _pref8$[esp+36]
	mov	DWORD PTR _psrc$1$[esp+40], edx
	pshufd	xmm4, xmm0, 0
	jle	$LN3@Blend
	add	ecx, ecx
	mov	DWORD PTR tv802[esp+40], ecx
	lea	ecx, DWORD PTR [esi+esi]
	mov	esi, DWORD PTR _width$[esp+36]
	mov	DWORD PTR tv801[esp+40], ecx
	lea	ecx, DWORD PTR [ebp*2]
	mov	ebp, DWORD PTR ___isa_available
	mov	DWORD PTR tv800[esp+40], ecx
$LL4@Blend:

; 659  :   {
; 660  :     for (w = 0; w<width; w++)

	xor	ecx, ecx
	test	esi, esi
	jle	$LN6@Blend
	cmp	esi, 8
	jb	$LN14@Blend

; 661  :     {
; 662  :       //const int		time256 = t256_provider.get_t (w);
; 663  :       pdst[w] =(pixel_t)( (psrc[w] * (256 - time256) + pref[w] * time256) >> 8);

	cmp	ebp, 2
	jl	$LN14@Blend
	lea	eax, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [edi+eax*2]
	lea	ebp, DWORD PTR [esi-1]
	lea	ebp, DWORD PTR [ebx+ebp*2]
	cmp	ebx, eax
	ja	SHORT $LN15@Blend
	cmp	ebp, edi
	jae	$LN25@Blend
$LN15@Blend:
	lea	eax, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [edx+eax*2]
	cmp	ebx, eax
	ja	SHORT $LN16@Blend
	cmp	ebp, edx
	jae	$LN25@Blend
$LN16@Blend:
	mov	eax, esi
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN26@Blend
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN26@Blend:
	movaps	xmm2, XMMWORD PTR __xmm@00000100000001000000010000000100
	mov	ebp, esi
	mov	esi, edx
	sub	ebp, eax
	sub	esi, edi
	mov	DWORD PTR tv787[esp+40], ebp
	mov	DWORD PTR tv795[esp+36], esi
	mov	eax, 8
	mov	esi, ebx
	mov	ebp, ebx
	sub	esi, edi
	psubd	xmm2, xmm4
	mov	DWORD PTR tv793[esp+36], esi
	mov	esi, edx
	mov	edx, DWORD PTR tv793[esp+36]
	sub	esi, ebx
	mov	ebx, DWORD PTR tv795[esp+36]
	mov	DWORD PTR tv791[esp+36], esi
	mov	esi, DWORD PTR _width$[esp+36]
	movd	xmm3, eax
	lea	eax, DWORD PTR [edi+8]
	mov	edi, DWORD PTR tv791[esp+36]
	npad	2
$LL7@Blend:

; 659  :   {
; 660  :     for (w = 0; w<width; w++)

	movq	xmm0, QWORD PTR [edi+ebp]
	lea	ebp, DWORD PTR [ebp+16]

; 661  :     {
; 662  :       //const int		time256 = t256_provider.get_t (w);
; 663  :       pdst[w] =(pixel_t)( (psrc[w] * (256 - time256) + pref[w] * time256) >> 8);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-8]
	lea	eax, DWORD PTR [eax+16]
	pmovzxwd xmm0, xmm0
	pmulld	xmm0, xmm4
	pmulld	xmm1, xmm2
	paddd	xmm1, xmm0
	add	ecx, 8
	psrad	xmm1, xmm3
	pshuflw	xmm0, xmm1, 216				; 000000d8H
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [ebp-16], xmm0
	movq	xmm0, QWORD PTR [ebx+eax-16]
	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	pmulld	xmm0, xmm4
	pmulld	xmm1, xmm2
	paddd	xmm1, xmm0
	psrad	xmm1, xmm3
	pshuflw	xmm0, xmm1, 216				; 000000d8H
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [edx+eax-16], xmm0
	cmp	ecx, DWORD PTR tv787[esp+40]
	jl	$LL7@Blend
	mov	edi, DWORD PTR _pref8$[esp+36]
	mov	ebx, DWORD PTR _pdst$1$[esp+40]
	mov	edx, DWORD PTR _psrc$1$[esp+40]
$LN25@Blend:
	mov	eax, DWORD PTR _time256$[esp+36]
$LN14@Blend:

; 659  :   {
; 660  :     for (w = 0; w<width; w++)

	cmp	ecx, esi
	jge	SHORT $LN6@Blend
	mov	ebp, 256				; 00000100H
	sub	edx, edi
	sub	ebx, edi
	mov	DWORD PTR tv794[esp+36], edx
	sub	ebp, eax
	mov	DWORD PTR tv792[esp+36], ebx
	lea	eax, DWORD PTR [edi+ecx*2]
	sub	esi, ecx
	mov	edi, edx
	npad	9
$LL13@Blend:

; 661  :     {
; 662  :       //const int		time256 = t256_provider.get_t (w);
; 663  :       pdst[w] =(pixel_t)( (psrc[w] * (256 - time256) + pref[w] * time256) >> 8);

	movzx	edx, WORD PTR [eax+edi]
	lea	eax, DWORD PTR [eax+2]
	movzx	ecx, WORD PTR [eax-2]
	imul	ecx, DWORD PTR _time256$[esp+36]
	imul	edx, ebp
	add	edx, ecx
	sar	edx, 8
	mov	WORD PTR [eax+ebx-2], dx
	sub	esi, 1
	jne	SHORT $LL13@Blend
	mov	edi, DWORD PTR _pref8$[esp+36]
	mov	ebx, DWORD PTR _pdst$1$[esp+40]
	mov	esi, DWORD PTR _width$[esp+36]
	mov	edx, DWORD PTR _psrc$1$[esp+40]
$LN6@Blend:

; 664  :     }
; 665  :     pdst += dst_pitch;

	add	ebx, DWORD PTR tv802[esp+40]

; 666  :     psrc += src_pitch;

	add	edx, DWORD PTR tv801[esp+40]

; 667  :     pref += ref_pitch;

	add	edi, DWORD PTR tv800[esp+40]
	sub	DWORD PTR _height$[esp+36], 1
	mov	eax, DWORD PTR _time256$[esp+36]
	mov	ebp, DWORD PTR ___isa_available
	mov	DWORD PTR _pdst$1$[esp+40], ebx
	mov	DWORD PTR _psrc$1$[esp+40], edx
	mov	DWORD PTR _pref8$[esp+36], edi
	jne	$LL4@Blend
$LN3@Blend:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 668  :     //t256_provider.jump_to_next_row ();
; 669  :   }
; 670  : }

	add	esp, 24					; 00000018H
	ret	0
??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z ENDP			; Blend<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$FlowInterSimple@E@@YAXPAEHPBE1HPAF22200HHHHH@Z
_TEXT	SEGMENT
_prefB$ = 8						; size = 4
_prefF$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_nPel$ = 60						; size = 4
??$FlowInterSimple@E@@YAXPAEHPBE1HPAF22200HHHHH@Z PROC	; FlowInterSimple<unsigned char>, COMDAT
; _pdst$ = ecx
; _dst_pitch$ = edx

; 762  :   if (nPel == 1)

	mov	eax, DWORD PTR _nPel$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@FlowInterS

; 763  :   {
; 764  :     FlowInterSimple_Pel1<pixel_t>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInterSimple_Pel1@E@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInterSimple_Pel1<unsigned char>

; 779  :   {
; 780  :     FlowInterSimple_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 781  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 782  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 783  :       VPitch, width, height, time256 /* t256_provider*/
; 784  :       );
; 785  :   }
; 786  : }

	ret	0
$LN2@FlowInterS:

; 765  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 766  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 767  :       VPitch, width, height, time256 /*t256_provider*/
; 768  :       );
; 769  :   }
; 770  :   else if (nPel == 2)

	cmp	eax, 2
	jne	SHORT $LN4@FlowInterS

; 771  :   {
; 772  :     FlowInterSimple_NPel <pixel_t,/*T256P, */1>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInterSimple_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInterSimple_NPel<unsigned char,1>

; 779  :   {
; 780  :     FlowInterSimple_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 781  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 782  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 783  :       VPitch, width, height, time256 /* t256_provider*/
; 784  :       );
; 785  :   }
; 786  : }

	ret	0
$LN4@FlowInterS:

; 773  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 774  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 775  :       VPitch, width, height, time256 /* t256_provider*/
; 776  :       );
; 777  :   }
; 778  :   else if (nPel == 4)

	cmp	eax, 4
	jne	SHORT $LN6@FlowInterS

; 779  :   {
; 780  :     FlowInterSimple_NPel <pixel_t,/*T256P,*/ 2>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInterSimple_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInterSimple_NPel<unsigned char,2>
	add	esp, 52					; 00000034H
$LN6@FlowInterS:

; 781  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 782  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 783  :       VPitch, width, height, time256 /* t256_provider*/
; 784  :       );
; 785  :   }
; 786  : }

	ret	0
??$FlowInterSimple@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ENDP	; FlowInterSimple<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$FlowInterSimple@G@@YAXPAEHPBE1HPAF22200HHHHH@Z
_TEXT	SEGMENT
_prefB$ = 8						; size = 4
_prefF$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_nPel$ = 60						; size = 4
??$FlowInterSimple@G@@YAXPAEHPBE1HPAF22200HHHHH@Z PROC	; FlowInterSimple<unsigned short>, COMDAT
; _pdst$ = ecx
; _dst_pitch$ = edx

; 762  :   if (nPel == 1)

	mov	eax, DWORD PTR _nPel$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@FlowInterS

; 763  :   {
; 764  :     FlowInterSimple_Pel1<pixel_t>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInterSimple_Pel1@G@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInterSimple_Pel1<unsigned short>

; 779  :   {
; 780  :     FlowInterSimple_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 781  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 782  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 783  :       VPitch, width, height, time256 /* t256_provider*/
; 784  :       );
; 785  :   }
; 786  : }

	ret	0
$LN2@FlowInterS:

; 765  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 766  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 767  :       VPitch, width, height, time256 /*t256_provider*/
; 768  :       );
; 769  :   }
; 770  :   else if (nPel == 2)

	cmp	eax, 2
	jne	SHORT $LN4@FlowInterS

; 771  :   {
; 772  :     FlowInterSimple_NPel <pixel_t,/*T256P, */1>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInterSimple_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInterSimple_NPel<unsigned short,1>

; 779  :   {
; 780  :     FlowInterSimple_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 781  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 782  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 783  :       VPitch, width, height, time256 /* t256_provider*/
; 784  :       );
; 785  :   }
; 786  : }

	ret	0
$LN4@FlowInterS:

; 773  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 774  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 775  :       VPitch, width, height, time256 /* t256_provider*/
; 776  :       );
; 777  :   }
; 778  :   else if (nPel == 4)

	cmp	eax, 4
	jne	SHORT $LN6@FlowInterS

; 779  :   {
; 780  :     FlowInterSimple_NPel <pixel_t,/*T256P,*/ 2>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInterSimple_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInterSimple_NPel<unsigned short,2>
	add	esp, 52					; 00000034H
$LN6@FlowInterS:

; 781  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 782  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 783  :       VPitch, width, height, time256 /* t256_provider*/
; 784  :       );
; 785  :   }
; 786  : }

	ret	0
??$FlowInterSimple@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ENDP	; FlowInterSimple<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z
_TEXT	SEGMENT
_prefB$ = 8						; size = 4
_prefF$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_nPel$ = 60						; size = 4
??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z PROC	; FlowInter<unsigned char>, COMDAT
; _pdst$ = ecx
; _dst_pitch$ = edx

; 690  :   if (nPel == 1)

	mov	eax, DWORD PTR _nPel$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@FlowInter

; 691  :   {
; 692  :     FlowInter_NPel <pixel_t,/*T256P,*/ 0>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInter_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInter_NPel<unsigned char,0>

; 707  :   {
; 708  :     FlowInter_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 709  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 710  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 711  :       VPitch, width, height, time256 /*t256_provider*/
; 712  :       );
; 713  :   }
; 714  : }

	ret	0
$LN2@FlowInter:

; 693  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 694  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 695  :       VPitch, width, height, time256 /*t256_provider*/
; 696  :       );
; 697  :   }
; 698  :   else if (nPel == 2)

	cmp	eax, 2
	jne	SHORT $LN4@FlowInter

; 699  :   {
; 700  :     FlowInter_NPel <pixel_t,/*T256P,*/ 1>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInter_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInter_NPel<unsigned char,1>

; 707  :   {
; 708  :     FlowInter_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 709  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 710  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 711  :       VPitch, width, height, time256 /*t256_provider*/
; 712  :       );
; 713  :   }
; 714  : }

	ret	0
$LN4@FlowInter:

; 701  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 702  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 703  :       VPitch, width, height, time256 /*t256_provider*/
; 704  :       );
; 705  :   }
; 706  :   else if (nPel == 4)

	cmp	eax, 4
	jne	SHORT $LN6@FlowInter

; 707  :   {
; 708  :     FlowInter_NPel <pixel_t,/*T256P,*/ 2>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInter_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInter_NPel<unsigned char,2>
	add	esp, 52					; 00000034H
$LN6@FlowInter:

; 709  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 710  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 711  :       VPitch, width, height, time256 /*t256_provider*/
; 712  :       );
; 713  :   }
; 714  : }

	ret	0
??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ENDP	; FlowInter<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z
_TEXT	SEGMENT
_prefB$ = 8						; size = 4
_prefF$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_nPel$ = 60						; size = 4
??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z PROC	; FlowInter<unsigned short>, COMDAT
; _pdst$ = ecx
; _dst_pitch$ = edx

; 690  :   if (nPel == 1)

	mov	eax, DWORD PTR _nPel$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@FlowInter

; 691  :   {
; 692  :     FlowInter_NPel <pixel_t,/*T256P,*/ 0>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInter_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInter_NPel<unsigned short,0>

; 707  :   {
; 708  :     FlowInter_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 709  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 710  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 711  :       VPitch, width, height, time256 /*t256_provider*/
; 712  :       );
; 713  :   }
; 714  : }

	ret	0
$LN2@FlowInter:

; 693  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 694  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 695  :       VPitch, width, height, time256 /*t256_provider*/
; 696  :       );
; 697  :   }
; 698  :   else if (nPel == 2)

	cmp	eax, 2
	jne	SHORT $LN4@FlowInter

; 699  :   {
; 700  :     FlowInter_NPel <pixel_t,/*T256P,*/ 1>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInter_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInter_NPel<unsigned short,1>

; 707  :   {
; 708  :     FlowInter_NPel <pixel_t,/*T256P,*/ 2>(

	add	esp, 52					; 00000034H

; 709  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 710  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 711  :       VPitch, width, height, time256 /*t256_provider*/
; 712  :       );
; 713  :   }
; 714  : }

	ret	0
$LN4@FlowInter:

; 701  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 702  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 703  :       VPitch, width, height, time256 /*t256_provider*/
; 704  :       );
; 705  :   }
; 706  :   else if (nPel == 4)

	cmp	eax, 4
	jne	SHORT $LN6@FlowInter

; 707  :   {
; 708  :     FlowInter_NPel <pixel_t,/*T256P,*/ 2>(

	push	DWORD PTR _time256$[esp-4]
	push	DWORD PTR _height$[esp]
	push	DWORD PTR _width$[esp+4]
	push	DWORD PTR _VPitch$[esp+8]
	push	DWORD PTR _MaskF$[esp+12]
	push	DWORD PTR _MaskB$[esp+16]
	push	DWORD PTR _VYFullF$[esp+20]
	push	DWORD PTR _VYFullB$[esp+24]
	push	DWORD PTR _VXFullF$[esp+28]
	push	DWORD PTR _VXFullB$[esp+32]
	push	DWORD PTR _ref_pitch$[esp+36]
	push	DWORD PTR _prefF$[esp+40]
	push	DWORD PTR _prefB$[esp+44]
	call	??$FlowInter_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z ; FlowInter_NPel<unsigned short,2>
	add	esp, 52					; 00000034H
$LN6@FlowInter:

; 709  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 710  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 711  :       VPitch, width, height, time256 /*t256_provider*/
; 712  :       );
; 713  :   }
; 714  : }

	ret	0
??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ENDP	; FlowInter<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z
_TEXT	SEGMENT
_prefB$ = 8						; size = 4
_prefF$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_nPel$ = 60						; size = 4
_VXFullBB$ = 64						; size = 4
_VXFullFF$ = 68						; size = 4
_VYFullBB$ = 72						; size = 4
_VYFullFF$ = 76						; size = 4
??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z PROC ; FlowInterExtra<unsigned char>, COMDAT
; _pdst$ = ecx
; _dst_pitch$ = edx

; 725  :   if (nPel == 1)

	mov	eax, DWORD PTR _nPel$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@FlowInterE

; 726  :   {
; 727  :     FlowInterExtra_NPel <pixel_t,/*T256P,*/ 0>(

	push	DWORD PTR _VYFullFF$[esp-4]
	push	DWORD PTR _VYFullBB$[esp]
	push	DWORD PTR _VXFullFF$[esp+4]
	push	DWORD PTR _VXFullBB$[esp+8]
	push	DWORD PTR _time256$[esp+12]
	push	DWORD PTR _height$[esp+16]
	push	DWORD PTR _width$[esp+20]
	push	DWORD PTR _VPitch$[esp+24]
	push	DWORD PTR _MaskF$[esp+28]
	push	DWORD PTR _MaskB$[esp+32]
	push	DWORD PTR _VYFullF$[esp+36]
	push	DWORD PTR _VYFullB$[esp+40]
	push	DWORD PTR _VXFullF$[esp+44]
	push	DWORD PTR _VXFullB$[esp+48]
	push	DWORD PTR _ref_pitch$[esp+52]
	push	DWORD PTR _prefF$[esp+56]
	push	DWORD PTR _prefB$[esp+60]
	call	??$FlowInterExtra_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z ; FlowInterExtra_NPel<unsigned char,0>

; 744  :   {
; 745  :     FlowInterExtra_NPel <pixel_t,/*T256P,9*/ 2>(

	add	esp, 68					; 00000044H

; 746  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 747  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 748  :       VPitch, width, height, time256 /*t256_provider*/,
; 749  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 750  :       );
; 751  :   }
; 752  : }

	ret	0
$LN2@FlowInterE:

; 728  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 729  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 730  :       VPitch, width, height, time256 /*t256_provider*/,
; 731  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 732  :       );
; 733  :   }
; 734  :   else if (nPel == 2)

	cmp	eax, 2
	jne	SHORT $LN4@FlowInterE

; 735  :   {
; 736  :     FlowInterExtra_NPel <pixel_t,/*T256P,*/ 1>(

	push	DWORD PTR _VYFullFF$[esp-4]
	push	DWORD PTR _VYFullBB$[esp]
	push	DWORD PTR _VXFullFF$[esp+4]
	push	DWORD PTR _VXFullBB$[esp+8]
	push	DWORD PTR _time256$[esp+12]
	push	DWORD PTR _height$[esp+16]
	push	DWORD PTR _width$[esp+20]
	push	DWORD PTR _VPitch$[esp+24]
	push	DWORD PTR _MaskF$[esp+28]
	push	DWORD PTR _MaskB$[esp+32]
	push	DWORD PTR _VYFullF$[esp+36]
	push	DWORD PTR _VYFullB$[esp+40]
	push	DWORD PTR _VXFullF$[esp+44]
	push	DWORD PTR _VXFullB$[esp+48]
	push	DWORD PTR _ref_pitch$[esp+52]
	push	DWORD PTR _prefF$[esp+56]
	push	DWORD PTR _prefB$[esp+60]
	call	??$FlowInterExtra_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z ; FlowInterExtra_NPel<unsigned char,1>

; 744  :   {
; 745  :     FlowInterExtra_NPel <pixel_t,/*T256P,9*/ 2>(

	add	esp, 68					; 00000044H

; 746  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 747  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 748  :       VPitch, width, height, time256 /*t256_provider*/,
; 749  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 750  :       );
; 751  :   }
; 752  : }

	ret	0
$LN4@FlowInterE:

; 737  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 738  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 739  :       VPitch, width, height, time256 /*t256_provider*/,
; 740  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 741  :       );
; 742  :   }
; 743  :   else if (nPel == 4)

	cmp	eax, 4
	jne	SHORT $LN6@FlowInterE

; 744  :   {
; 745  :     FlowInterExtra_NPel <pixel_t,/*T256P,9*/ 2>(

	push	DWORD PTR _VYFullFF$[esp-4]
	push	DWORD PTR _VYFullBB$[esp]
	push	DWORD PTR _VXFullFF$[esp+4]
	push	DWORD PTR _VXFullBB$[esp+8]
	push	DWORD PTR _time256$[esp+12]
	push	DWORD PTR _height$[esp+16]
	push	DWORD PTR _width$[esp+20]
	push	DWORD PTR _VPitch$[esp+24]
	push	DWORD PTR _MaskF$[esp+28]
	push	DWORD PTR _MaskB$[esp+32]
	push	DWORD PTR _VYFullF$[esp+36]
	push	DWORD PTR _VYFullB$[esp+40]
	push	DWORD PTR _VXFullF$[esp+44]
	push	DWORD PTR _VXFullB$[esp+48]
	push	DWORD PTR _ref_pitch$[esp+52]
	push	DWORD PTR _prefF$[esp+56]
	push	DWORD PTR _prefB$[esp+60]
	call	??$FlowInterExtra_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z ; FlowInterExtra_NPel<unsigned char,2>
	add	esp, 68					; 00000044H
$LN6@FlowInterE:

; 746  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 747  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 748  :       VPitch, width, height, time256 /*t256_provider*/,
; 749  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 750  :       );
; 751  :   }
; 752  : }

	ret	0
??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ENDP ; FlowInterExtra<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.cpp
;	COMDAT ??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z
_TEXT	SEGMENT
_prefB$ = 8						; size = 4
_prefF$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_nPel$ = 60						; size = 4
_VXFullBB$ = 64						; size = 4
_VXFullFF$ = 68						; size = 4
_VYFullBB$ = 72						; size = 4
_VYFullFF$ = 76						; size = 4
??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z PROC ; FlowInterExtra<unsigned short>, COMDAT
; _pdst$ = ecx
; _dst_pitch$ = edx

; 725  :   if (nPel == 1)

	mov	eax, DWORD PTR _nPel$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@FlowInterE

; 726  :   {
; 727  :     FlowInterExtra_NPel <pixel_t,/*T256P,*/ 0>(

	push	DWORD PTR _VYFullFF$[esp-4]
	push	DWORD PTR _VYFullBB$[esp]
	push	DWORD PTR _VXFullFF$[esp+4]
	push	DWORD PTR _VXFullBB$[esp+8]
	push	DWORD PTR _time256$[esp+12]
	push	DWORD PTR _height$[esp+16]
	push	DWORD PTR _width$[esp+20]
	push	DWORD PTR _VPitch$[esp+24]
	push	DWORD PTR _MaskF$[esp+28]
	push	DWORD PTR _MaskB$[esp+32]
	push	DWORD PTR _VYFullF$[esp+36]
	push	DWORD PTR _VYFullB$[esp+40]
	push	DWORD PTR _VXFullF$[esp+44]
	push	DWORD PTR _VXFullB$[esp+48]
	push	DWORD PTR _ref_pitch$[esp+52]
	push	DWORD PTR _prefF$[esp+56]
	push	DWORD PTR _prefB$[esp+60]
	call	??$FlowInterExtra_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z ; FlowInterExtra_NPel<unsigned short,0>

; 744  :   {
; 745  :     FlowInterExtra_NPel <pixel_t,/*T256P,9*/ 2>(

	add	esp, 68					; 00000044H

; 746  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 747  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 748  :       VPitch, width, height, time256 /*t256_provider*/,
; 749  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 750  :       );
; 751  :   }
; 752  : }

	ret	0
$LN2@FlowInterE:

; 728  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 729  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 730  :       VPitch, width, height, time256 /*t256_provider*/,
; 731  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 732  :       );
; 733  :   }
; 734  :   else if (nPel == 2)

	cmp	eax, 2
	jne	SHORT $LN4@FlowInterE

; 735  :   {
; 736  :     FlowInterExtra_NPel <pixel_t,/*T256P,*/ 1>(

	push	DWORD PTR _VYFullFF$[esp-4]
	push	DWORD PTR _VYFullBB$[esp]
	push	DWORD PTR _VXFullFF$[esp+4]
	push	DWORD PTR _VXFullBB$[esp+8]
	push	DWORD PTR _time256$[esp+12]
	push	DWORD PTR _height$[esp+16]
	push	DWORD PTR _width$[esp+20]
	push	DWORD PTR _VPitch$[esp+24]
	push	DWORD PTR _MaskF$[esp+28]
	push	DWORD PTR _MaskB$[esp+32]
	push	DWORD PTR _VYFullF$[esp+36]
	push	DWORD PTR _VYFullB$[esp+40]
	push	DWORD PTR _VXFullF$[esp+44]
	push	DWORD PTR _VXFullB$[esp+48]
	push	DWORD PTR _ref_pitch$[esp+52]
	push	DWORD PTR _prefF$[esp+56]
	push	DWORD PTR _prefB$[esp+60]
	call	??$FlowInterExtra_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z ; FlowInterExtra_NPel<unsigned short,1>

; 744  :   {
; 745  :     FlowInterExtra_NPel <pixel_t,/*T256P,9*/ 2>(

	add	esp, 68					; 00000044H

; 746  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 747  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 748  :       VPitch, width, height, time256 /*t256_provider*/,
; 749  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 750  :       );
; 751  :   }
; 752  : }

	ret	0
$LN4@FlowInterE:

; 737  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 738  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 739  :       VPitch, width, height, time256 /*t256_provider*/,
; 740  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 741  :       );
; 742  :   }
; 743  :   else if (nPel == 4)

	cmp	eax, 4
	jne	SHORT $LN6@FlowInterE

; 744  :   {
; 745  :     FlowInterExtra_NPel <pixel_t,/*T256P,9*/ 2>(

	push	DWORD PTR _VYFullFF$[esp-4]
	push	DWORD PTR _VYFullBB$[esp]
	push	DWORD PTR _VXFullFF$[esp+4]
	push	DWORD PTR _VXFullBB$[esp+8]
	push	DWORD PTR _time256$[esp+12]
	push	DWORD PTR _height$[esp+16]
	push	DWORD PTR _width$[esp+20]
	push	DWORD PTR _VPitch$[esp+24]
	push	DWORD PTR _MaskF$[esp+28]
	push	DWORD PTR _MaskB$[esp+32]
	push	DWORD PTR _VYFullF$[esp+36]
	push	DWORD PTR _VYFullB$[esp+40]
	push	DWORD PTR _VXFullF$[esp+44]
	push	DWORD PTR _VXFullB$[esp+48]
	push	DWORD PTR _ref_pitch$[esp+52]
	push	DWORD PTR _prefF$[esp+56]
	push	DWORD PTR _prefB$[esp+60]
	call	??$FlowInterExtra_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z ; FlowInterExtra_NPel<unsigned short,2>
	add	esp, 68					; 00000044H
$LN6@FlowInterE:

; 746  :       pdst, dst_pitch, prefB, prefF, ref_pitch,
; 747  :       VXFullB, VXFullF, VYFullB, VYFullF, MaskB, MaskF,
; 748  :       VPitch, width, height, time256 /*t256_provider*/,
; 749  :       VXFullBB, VXFullFF, VYFullBB, VYFullFF
; 750  :       );
; 751  :   }
; 752  : }

	ret	0
??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ENDP ; FlowInterExtra<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterSimple_Pel1@E@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
_prefF8$2$ = -88					; size = 4
_prefF8$1$ = -88					; size = 4
tv1804 = -84						; size = 4
_MaskB$1$ = -84						; size = 4
tv1806 = -80						; size = 4
_MaskF$1$ = -80						; size = 4
tv1829 = -76						; size = 4
_MaskB$2$ = -76						; size = 4
_VXFullF$2$ = -72					; size = 4
_VYFullB$1$ = -72					; size = 4
tv1834 = -68						; size = 4
_VXFullF$1$ = -68					; size = 4
_dstF1$1$ = -64						; size = 4
_height$1$ = -64					; size = 4
_dst_pitch$1$ = -60					; size = 4
tv1809 = -56						; size = 4
_VYFullF$1$ = -56					; size = 4
tv1812 = -52						; size = 4
_MaskF$2$ = -52						; size = 4
tv1810 = -48						; size = 4
_height$2$ = -48					; size = 4
tv1817 = -44						; size = 4
tv1801 = -44						; size = 4
tv1825 = -40						; size = 4
tv1799 = -40						; size = 4
tv1811 = -36						; size = 4
tv1803 = -36						; size = 4
tv1827 = -32						; size = 4
tv1823 = -32						; size = 4
tv1821 = -28						; size = 4
tv1802 = -28						; size = 4
tv1819 = -24						; size = 4
tv1800 = -24						; size = 4
tv1836 = -20						; size = 4
tv1816 = -20						; size = 4
tv1822 = -16						; size = 4
tv1820 = -12						; size = 4
tv1818 = -8						; size = 4
tv1835 = -4						; size = 4
_w$1$ = 8						; size = 4
tv1814 = 8						; size = 4
_prefB8$ = 8						; size = 4
_w$1$ = 12						; size = 4
tv1807 = 12						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
tv1830 = 56						; size = 4
_time256$ = 56						; size = 4
??$FlowInterSimple_Pel1@E@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInterSimple_Pel1<unsigned char>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 405  : {

	sub	esp, 88					; 00000058H

; 406  :   dst_pitch /= sizeof(pixel_t);
; 407  :   ref_pitch /= sizeof(pixel_t);
; 408  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 409  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 410  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 411  : 
; 412  : 	if (time256 == 128 /*t256_provider.is_half ()*/) // special case double fps - fastest

	cmp	DWORD PTR _time256$[esp+84], 128	; 00000080H

; 413  : 	{
; 414  : 		for (int h=0; h<height; h++)

	mov	eax, DWORD PTR _height$[esp+84]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	DWORD PTR _dst_pitch$1$[esp+104], edx
	jne	$LN14@FlowInterS
	mov	DWORD PTR _height$1$[esp+104], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	eax, DWORD PTR _VPitch$[esp+100]
	mov	edx, DWORD PTR _prefF8$[esp+100]
	add	eax, eax
	mov	ebp, DWORD PTR _VYFullB$[esp+100]
	mov	esi, DWORD PTR _MaskF$[esp+100]
	mov	DWORD PTR tv1836[esp+104], eax
	mov	eax, DWORD PTR _prefB8$[esp+100]
	mov	DWORD PTR _prefF8$1$[esp+104], edx
	sub	edx, eax
	mov	DWORD PTR tv1817[esp+104], edx
	mov	edx, DWORD PTR _MaskB$[esp+100]
	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR _MaskB$1$[esp+104], edx
	mov	eax, DWORD PTR _VXFullB$[esp+100]
	mov	edx, DWORD PTR _VXFullF$[esp+100]
	sub	eax, ebp
	mov	DWORD PTR tv1812[esp+104], eax
	mov	eax, DWORD PTR _VYFullF$[esp+100]
	sub	eax, ebp
	mov	DWORD PTR tv1814[esp+100], edi
	mov	DWORD PTR tv1810[esp+104], eax
	mov	eax, DWORD PTR _ref_pitch$[esp+100]
	mov	DWORD PTR _VYFullB$1$[esp+104], ebp
	mov	DWORD PTR _MaskF$1$[esp+104], esi
	mov	DWORD PTR _VXFullF$1$[esp+104], edx
	npad	7
$LL4@FlowInterS:

; 415  : 		{
; 416  : 			for (int w=0; w<width; w+=2) // paired for speed

	xor	ebx, ebx
	mov	DWORD PTR _w$1$[esp+100], ebx
	cmp	DWORD PTR _width$[esp+100], ebx
	jle	$LN6@FlowInterS
	mov	eax, DWORD PTR tv1810[esp+104]
	sub	eax, edx
	mov	DWORD PTR tv1830[esp+100], esi
	add	eax, ebp
	mov	esi, edx
	mov	DWORD PTR tv1809[esp+104], eax
	mov	eax, ebp
	sub	eax, edx
	mov	DWORD PTR tv1829[esp+104], esi
	mov	DWORD PTR tv1825[esp+104], eax
	mov	eax, DWORD PTR tv1812[esp+104]
	sub	eax, edx
	mov	edx, DWORD PTR _MaskB$1$[esp+104]
	sub	edx, DWORD PTR _MaskF$1$[esp+104]
	add	eax, ebp
	mov	DWORD PTR tv1823[esp+104], edx
	mov	edx, ecx
	sub	edx, DWORD PTR _MaskF$1$[esp+104]
	mov	DWORD PTR tv1811[esp+104], eax
	mov	eax, DWORD PTR _MaskB$1$[esp+104]
	sub	eax, ecx
	mov	DWORD PTR tv1821[esp+104], edx
	mov	DWORD PTR tv1819[esp+104], eax
$LL7@FlowInterS:

; 417  : 			{
; 418  : 				//int vxF = (VXFullF[w]-128)>>1;
; 419  : 				//int vyF = (VYFullF[w]-128)>>1;
; 420  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 421  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 422  :         int addrF = vyF*ref_pitch + vxF + w;

	mov	eax, DWORD PTR tv1809[esp+104]
	movsx	edx, WORD PTR [esi]
	sar	edx, 1
	movsx	eax, WORD PTR [esi+eax]
	sar	eax, 1
	imul	eax, DWORD PTR _ref_pitch$[esp+100]
	add	eax, ebx
	add	edx, eax

; 423  : 				int dstF = prefF[addrF];

	mov	eax, DWORD PTR _prefF8$1$[esp+104]
	movzx	ebx, BYTE PTR [eax+edx]

; 424  : 				int dstF1 = prefF[addrF+1]; // approximation for speed

	mov	eax, DWORD PTR tv1817[esp+104]
	add	eax, edi
	movzx	ebp, BYTE PTR [eax+edx]

; 425  : 				//int vxB = (VXFullB[w]-128)>>1;
; 426  : 				//int vyB = (VYFullB[w]-128)>>1;
; 427  :         int vxB = (VXFullB[w]) >> 1; // 2.5.11.22
; 428  :         int vyB = (VYFullB[w]) >> 1; // 2.5.11.22
; 429  :         int addrB = vyB*ref_pitch + vxB + w;

	mov	eax, DWORD PTR tv1825[esp+104]
	mov	edx, DWORD PTR tv1811[esp+104]
	movsx	eax, WORD PTR [eax+esi]
	movsx	edx, WORD PTR [esi+edx]
	sar	eax, 1
	imul	eax, DWORD PTR _ref_pitch$[esp+100]
	sar	edx, 1
	add	eax, DWORD PTR _w$1$[esp+100]
	add	edx, eax

; 430  : 				int dstB = prefB[addrB];
; 431  : 				int dstB1 = prefB[addrB+1];
; 432  : 				pdst[w  ] = ( ((dstF  + dstB )<<8) + (dstB  - dstF )*(MaskF[w  ] - MaskB[w  ]) )>>9;

	mov	eax, DWORD PTR tv1823[esp+104]
	movzx	esi, BYTE PTR [edi+edx-1]
	movzx	edi, BYTE PTR [edi+edx]
	mov	edx, DWORD PTR tv1830[esp+100]
	movzx	eax, BYTE PTR [eax+edx]
	movzx	edx, BYTE PTR [edx]
	sub	edx, eax
	mov	eax, esi
	sub	eax, ebx
	imul	edx, eax
	lea	eax, DWORD PTR [esi+ebx]
	mov	ebx, DWORD PTR tv1821[esp+104]
	shl	eax, 8
	add	edx, eax
	mov	eax, DWORD PTR tv1830[esp+100]
	sar	edx, 9
	mov	BYTE PTR [ebx+eax], dl

; 433  : 				pdst[w+1] = ( ((dstF1 + dstB1)<<8) + (dstB1 - dstF1)*(MaskF[w+1] - MaskB[w+1]) )>>9;

	mov	ebx, DWORD PTR _w$1$[esp+100]
	mov	edx, DWORD PTR tv1830[esp+100]
	lea	esi, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR tv1819[esp+104]
	add	ebx, 2
	add	DWORD PTR tv1830[esp+100], 2
	mov	DWORD PTR _w$1$[esp+100], ebx
	movzx	edx, BYTE PTR [edx+1]
	movzx	eax, BYTE PTR [eax+esi+1]
	sub	edx, eax
	mov	eax, edi
	sub	eax, ebp
	imul	edx, eax
	lea	eax, DWORD PTR [edi+ebp]
	mov	edi, DWORD PTR tv1814[esp+100]
	shl	eax, 8
	add	edx, eax
	sar	edx, 9
	mov	BYTE PTR [esi+1], dl
	mov	esi, DWORD PTR tv1829[esp+104]
	add	esi, 4
	mov	DWORD PTR tv1829[esp+104], esi
	cmp	ebx, DWORD PTR _width$[esp+100]
	jl	$LL7@FlowInterS
	mov	edx, DWORD PTR _VXFullF$1$[esp+104]
	mov	ebp, DWORD PTR _VYFullB$1$[esp+104]
	mov	eax, DWORD PTR _ref_pitch$[esp+100]
	mov	esi, DWORD PTR _MaskF$1$[esp+104]
$LN6@FlowInterS:

; 434  : 			}
; 435  : 			pdst += dst_pitch;
; 436  : 			prefB += ref_pitch;
; 437  : 			prefF += ref_pitch;
; 438  : 			VXFullB += VPitch;
; 439  : 			VYFullB += VPitch;
; 440  : 			VXFullF += VPitch;
; 441  : 			VYFullF += VPitch;
; 442  : 			MaskB += VPitch;

	mov	ebx, DWORD PTR _VPitch$[esp+100]
	add	edi, eax
	add	ebp, DWORD PTR tv1836[esp+104]

; 443  : 			MaskF += VPitch;

	add	esi, ebx
	add	edx, DWORD PTR tv1836[esp+104]
	add	ecx, DWORD PTR _dst_pitch$1$[esp+104]
	add	DWORD PTR _prefF8$1$[esp+104], eax
	add	DWORD PTR _MaskB$1$[esp+104], ebx
	sub	DWORD PTR _height$1$[esp+104], 1
	mov	DWORD PTR tv1814[esp+100], edi
	mov	DWORD PTR _VYFullB$1$[esp+104], ebp
	mov	DWORD PTR _VXFullF$1$[esp+104], edx
	mov	DWORD PTR _MaskF$1$[esp+104], esi
	jne	$LL4@FlowInterS
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 488  : 		}
; 489  : 	}
; 490  : }

	add	esp, 88					; 00000058H
	ret	0
$LN14@FlowInterS:

; 444  : 		}
; 445  : 	}
; 446  : 
; 447  : 	else // general case
; 448  : 	{
; 449  :     // avoid "uint16*uint16 can't get into int32" overflows
; 450  :     typedef std::conditional < sizeof(pixel_t) == 1, int, typename std::conditional < sizeof(pixel_t) == 2, __int64, float>::type >::type result_t;
; 451  : 
; 452  : 		for (int h=0; h<height; h++)

	mov	DWORD PTR _height$2$[esp+104], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	eax, DWORD PTR _VPitch$[esp+100]
	mov	edx, DWORD PTR _prefF8$[esp+100]
	add	eax, eax
	mov	ebx, DWORD PTR _VYFullF$[esp+100]
	mov	ebp, DWORD PTR _MaskF$[esp+100]
	mov	DWORD PTR tv1835[esp+104], eax
	mov	eax, DWORD PTR _prefB8$[esp+100]
	mov	DWORD PTR _prefF8$2$[esp+104], edx
	sub	edx, eax
	mov	DWORD PTR tv1816[esp+104], edx
	mov	edx, DWORD PTR _VXFullF$[esp+100]
	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR _VYFullF$1$[esp+104], ebx
	mov	eax, DWORD PTR _VXFullB$[esp+100]
	sub	eax, ebx
	mov	DWORD PTR tv1804[esp+104], esi
	mov	DWORD PTR tv1802[esp+104], eax
	mov	eax, DWORD PTR _VYFullB$[esp+100]
	sub	eax, ebx
	mov	DWORD PTR _MaskF$2$[esp+104], ebp
	mov	DWORD PTR tv1800[esp+104], eax
	mov	eax, DWORD PTR _MaskB$[esp+100]
	mov	DWORD PTR _MaskB$2$[esp+104], eax
	mov	DWORD PTR _VXFullF$2$[esp+104], edx
	npad	9
$LL10@FlowInterS:

; 453  : 		{
; 454  : 			for (int w=0; w<width; w+=2) // paired for speed

	xor	edi, edi
	mov	DWORD PTR _w$1$[esp+100], edi
	cmp	DWORD PTR _width$[esp+100], edi
	jle	$LN12@FlowInterS

; 444  : 		}
; 445  : 	}
; 446  : 
; 447  : 	else // general case
; 448  : 	{
; 449  :     // avoid "uint16*uint16 can't get into int32" overflows
; 450  :     typedef std::conditional < sizeof(pixel_t) == 1, int, typename std::conditional < sizeof(pixel_t) == 2, __int64, float>::type >::type result_t;
; 451  : 
; 452  : 		for (int h=0; h<height; h++)

	mov	eax, DWORD PTR tv1816[esp+104]
	add	eax, esi

; 453  : 		{
; 454  : 			for (int w=0; w<width; w+=2) // paired for speed

	mov	DWORD PTR tv1806[esp+104], edx
	mov	DWORD PTR tv1803[esp+104], eax
	mov	esi, 256				; 00000100H
	sub	esi, DWORD PTR _time256$[esp+100]
	mov	eax, ebx
	sub	eax, edx
	mov	DWORD PTR tv1834[esp+104], esi
	mov	DWORD PTR tv1827[esp+104], eax
	mov	eax, DWORD PTR tv1800[esp+104]
	sub	eax, edx
	mov	DWORD PTR tv1807[esp+100], ebp
	add	eax, ebx
	mov	DWORD PTR tv1799[esp+104], eax
	mov	eax, DWORD PTR tv1802[esp+104]
	sub	eax, edx
	add	eax, ebx
	mov	ebx, DWORD PTR tv1806[esp+104]
	mov	DWORD PTR tv1801[esp+104], eax
	mov	eax, DWORD PTR _MaskB$2$[esp+104]
	mov	edx, eax
	sub	edx, ebp
	mov	DWORD PTR tv1822[esp+104], edx
	mov	edx, ecx
	sub	edx, ebp
	sub	eax, ecx
	mov	DWORD PTR tv1820[esp+104], edx
	mov	DWORD PTR tv1818[esp+104], eax
$LL13@FlowInterS:

; 455  : 			{
; 456  : 				//const int		time256 = t256_provider.get_t (w);
; 457  : 
; 458  : 				//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]);
; 459  : 				//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]);
; 460  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 461  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 462  :         int addrF = vyF*ref_pitch + vxF + w;

	movsx	edx, WORD PTR [ebx]
	mov	eax, DWORD PTR tv1827[esp+104]
	sar	edx, 1
	movsx	eax, WORD PTR [eax+ebx]
	sar	eax, 1
	imul	eax, DWORD PTR _ref_pitch$[esp+100]
	add	eax, edi
	add	edx, eax

; 463  : 				int dstF = prefF[addrF];

	mov	eax, DWORD PTR _prefF8$2$[esp+104]
	movzx	edi, BYTE PTR [eax+edx]

; 464  : 				int dstF1 = prefF[addrF+1]; // approximation for speed

	mov	eax, DWORD PTR tv1803[esp+104]
	movzx	eax, BYTE PTR [eax+edx]

; 465  : 				//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]);
; 466  : 				//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]);
; 467  :         int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	edx, DWORD PTR tv1801[esp+104]
	mov	DWORD PTR _dstF1$1$[esp+104], eax

; 468  :         int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1799[esp+104]
	movsx	edx, WORD PTR [edx+ebx]
	imul	edx, esi
	movsx	eax, WORD PTR [eax+ebx]
	imul	eax, esi

; 469  :         int addrB = vyB*ref_pitch + vxB + w;
; 470  : 				int dstB = prefB[addrB];

	mov	ebx, DWORD PTR tv1804[esp+104]
	sar	edx, 8
	sar	eax, 8
	imul	eax, DWORD PTR _ref_pitch$[esp+100]
	add	eax, DWORD PTR _w$1$[esp+100]
	add	edx, eax

; 471  : 				int dstB1 = prefB[addrB+1];

	movzx	ebp, BYTE PTR [ebx+edx]
	movzx	eax, BYTE PTR [ebx+edx-1]

; 472  :         // possible overflow for 16 bit
; 473  : 				pdst[w  ] = ( ( (result_t)(dstF *255 + (dstB -dstF )*MaskF[w  ] + 255) )*(256-time256) +

	mov	edx, DWORD PTR tv1807[esp+100]
	mov	esi, eax
	mov	ebx, DWORD PTR tv1822[esp+104]
	inc	eax
	sub	esi, edi
	movzx	edx, BYTE PTR [ebx+edx]
	imul	edx, esi
	imul	ebx, eax, 255
	mov	eax, DWORD PTR tv1807[esp+100]
	sub	ebx, edx
	movzx	edx, BYTE PTR [eax]
	imul	ebx, DWORD PTR _time256$[esp+100]
	lea	eax, DWORD PTR [edi+1]

; 474  : 				              ( (result_t)(dstB *255 - (dstB -dstF )*MaskB[w  ] + 255) )*     time256   )>>16;
; 475  : 				pdst[w+1] = ( ( (result_t)(dstF1*255 + (dstB1-dstF1)*MaskF[w+1] + 255) )*(256-time256) +

	mov	edi, DWORD PTR _w$1$[esp+100]
	imul	edx, esi
	add	edi, ecx
	imul	eax, eax, 255
	mov	esi, ebp
	sub	esi, DWORD PTR _dstF1$1$[esp+104]
	add	edx, eax
	mov	eax, DWORD PTR tv1807[esp+100]
	imul	edx, DWORD PTR tv1834[esp+104]
	add	ebx, edx
	mov	edx, DWORD PTR tv1820[esp+104]
	sar	ebx, 16					; 00000010H
	mov	BYTE PTR [edx+eax], bl
	mov	eax, DWORD PTR tv1818[esp+104]
	movzx	edx, BYTE PTR [eax+edi+1]
	lea	eax, DWORD PTR [ebp+1]
	mov	ebp, DWORD PTR tv1807[esp+100]
	imul	edx, esi
	imul	ebx, eax, 255
	mov	eax, DWORD PTR _dstF1$1$[esp+104]
	inc	eax
	imul	eax, eax, 255
	sub	ebx, edx
	movzx	edx, BYTE PTR [ebp+1]
	imul	ebx, DWORD PTR _time256$[esp+100]
	add	ebp, 2
	imul	edx, esi
	mov	esi, DWORD PTR tv1834[esp+104]
	mov	DWORD PTR tv1807[esp+100], ebp
	add	edx, eax
	imul	edx, esi
	add	ebx, edx
	sar	ebx, 16					; 00000010H
	mov	BYTE PTR [edi+1], bl
	mov	edi, DWORD PTR _w$1$[esp+100]
	mov	ebx, DWORD PTR tv1806[esp+104]
	add	edi, 2
	add	ebx, 4
	mov	DWORD PTR _w$1$[esp+100], edi
	cmp	edi, DWORD PTR _width$[esp+100]
	mov	DWORD PTR tv1806[esp+104], ebx

; 453  : 		{
; 454  : 			for (int w=0; w<width; w+=2) // paired for speed

	jl	$LL13@FlowInterS
	mov	edx, DWORD PTR _VXFullF$2$[esp+104]
	mov	ebx, DWORD PTR _VYFullF$1$[esp+104]
	mov	ebp, DWORD PTR _MaskF$2$[esp+104]
	mov	esi, DWORD PTR tv1804[esp+104]
	mov	eax, DWORD PTR _MaskB$2$[esp+104]
$LN12@FlowInterS:

; 476  : 				              ( (result_t)(dstB1*255 - (dstB1-dstF1)*MaskB[w+1] + 255) )*     time256   )>>16;
; 477  : 			}
; 478  : 			pdst += dst_pitch;
; 479  : 			prefB += ref_pitch;

	mov	edi, DWORD PTR _ref_pitch$[esp+100]
	add	esi, edi

; 480  : 			prefF += ref_pitch;
; 481  : 			//t256_provider.jump_to_next_row ();
; 482  : 			VXFullB += VPitch;
; 483  : 			VYFullB += VPitch;
; 484  : 			VXFullF += VPitch;

	add	edx, DWORD PTR tv1835[esp+104]

; 485  : 			VYFullF += VPitch;

	add	ebx, DWORD PTR tv1835[esp+104]

; 486  : 			MaskB += VPitch;

	add	eax, DWORD PTR _VPitch$[esp+100]

; 487  : 			MaskF += VPitch;

	add	ebp, DWORD PTR _VPitch$[esp+100]
	add	ecx, DWORD PTR _dst_pitch$1$[esp+104]
	add	DWORD PTR _prefF8$2$[esp+104], edi
	sub	DWORD PTR _height$2$[esp+104], 1
	mov	DWORD PTR tv1804[esp+104], esi
	mov	DWORD PTR _VXFullF$2$[esp+104], edx
	mov	DWORD PTR _VYFullF$1$[esp+104], ebx
	mov	DWORD PTR _MaskB$2$[esp+104], eax
	mov	DWORD PTR _MaskF$2$[esp+104], ebp
	jne	$LL10@FlowInterS
$LN9@FlowInterS:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 488  : 		}
; 489  : 	}
; 490  : }

	add	esp, 88					; 00000058H
	ret	0
??$FlowInterSimple_Pel1@E@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInterSimple_Pel1<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterSimple_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
_pdst$1$ = -76						; size = 4
tv1365 = -72						; size = 4
_MaskF$2$ = -72						; size = 4
_VXFullF$2$ = -68					; size = 4
_VYFullB$1$ = -68					; size = 4
tv1351 = -64						; size = 4
_VXFullF$1$ = -64					; size = 4
tv1366 = -60						; size = 4
_height$1$ = -60					; size = 4
_dst_pitch$1$ = -56					; size = 4
tv1369 = -52						; size = 4
tv1359 = -52						; size = 4
tv1354 = -48						; size = 4
_VYFullF$1$ = -48					; size = 4
tv1357 = -44						; size = 4
_MaskB$2$ = -44						; size = 4
tv1355 = -40						; size = 4
_height$2$ = -40					; size = 4
tv1362 = -36						; size = 4
tv1346 = -36						; size = 4
tv1356 = -32						; size = 4
tv1343 = -32						; size = 4
tv1360 = -28						; size = 4
tv1358 = -28						; size = 4
tv1363 = -24						; size = 4
tv1361 = -24						; size = 4
tv1380 = -20						; size = 4
tv1347 = -20						; size = 4
tv1376 = -16						; size = 4
tv1344 = -16						; size = 4
tv1350 = -12						; size = 4
tv1349 = -8						; size = 4
tv1378 = -4						; size = 4
tv1353 = 8						; size = 4
_w$1$ = 8						; size = 4
_prefB8$ = 8						; size = 4
_w$1$ = 12						; size = 4
_MaskF$1$ = 12						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_MaskB$1$ = 56						; size = 4
_time256$ = 56						; size = 4
??$FlowInterSimple_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInterSimple_NPel<unsigned char,1>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 314  : {

	sub	esp, 76					; 0000004cH

; 315  :   dst_pitch /= sizeof(pixel_t);
; 316  :   ref_pitch /= sizeof(pixel_t);
; 317  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 318  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 319  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 320  : 
; 321  : 	if (time256 == 128 /*t256_provider.is_half ()*/) // special case double fps - fastest
; 322  : 	{
; 323  : 		for (int h=0; h<height; h++)

	mov	eax, DWORD PTR _height$[esp+72]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _prefB8$[esp+80]
	push	esi
	mov	esi, DWORD PTR _time256$[esp+84]
	mov	DWORD PTR _dst_pitch$1$[esp+88], edx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _pdst$1$[esp+92], edi
	cmp	esi, 128				; 00000080H
	jne	$LN14@FlowInterS
	mov	DWORD PTR _height$1$[esp+92], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	eax, DWORD PTR _ref_pitch$[esp+88]
	mov	esi, DWORD PTR _VYFullB$[esp+88]
	add	eax, eax
	mov	edx, DWORD PTR _MaskB$[esp+88]
	mov	ebx, DWORD PTR _VXFullF$[esp+88]
	mov	ecx, DWORD PTR _width$[esp+88]
	mov	DWORD PTR tv1380[esp+92], eax
	mov	eax, DWORD PTR _VPitch$[esp+88]
	add	eax, eax
	mov	DWORD PTR _VYFullB$1$[esp+92], esi
	mov	DWORD PTR tv1376[esp+92], eax
	mov	eax, DWORD PTR _prefF8$[esp+88]
	sub	eax, ebp
	mov	DWORD PTR _MaskB$1$[esp+88], edx
	mov	DWORD PTR tv1359[esp+92], eax
	mov	eax, DWORD PTR _VXFullB$[esp+88]
	sub	eax, esi
	mov	DWORD PTR _VXFullF$1$[esp+92], ebx
	mov	DWORD PTR tv1357[esp+92], eax
	mov	eax, DWORD PTR _VYFullF$[esp+88]
	sub	eax, esi
	mov	DWORD PTR tv1355[esp+92], eax
	mov	eax, DWORD PTR _MaskF$[esp+88]
	mov	DWORD PTR _MaskF$1$[esp+88], eax
	npad	6
$LL4@FlowInterS:

; 324  : 		{
; 325  : 			for (int w=0; w<width; w+=1)

	xor	edx, edx
	mov	DWORD PTR _w$1$[esp+88], edx
	test	ecx, ecx
	jle	$LN6@FlowInterS
	mov	ecx, DWORD PTR tv1355[esp+92]
	sub	ecx, ebx
	mov	DWORD PTR tv1365[esp+92], eax
	add	ecx, esi
	mov	eax, ebx
	mov	DWORD PTR tv1354[esp+92], ecx
	mov	ecx, esi
	sub	ecx, ebx
	mov	DWORD PTR tv1362[esp+92], ecx
	mov	ecx, DWORD PTR tv1357[esp+92]
	sub	ecx, ebx
	mov	ebx, DWORD PTR _MaskB$1$[esp+88]
	sub	ebx, DWORD PTR _MaskF$1$[esp+88]
	add	ecx, esi
	mov	esi, edi
	mov	DWORD PTR tv1356[esp+92], ecx
	sub	esi, DWORD PTR _MaskF$1$[esp+88]
	mov	DWORD PTR tv1361[esp+92], ebx
	mov	DWORD PTR tv1360[esp+92], esi
	npad	3
$LL7@FlowInterS:

; 326  : 			{
; 327  : //				const int		time256 = t256_provider.get_t (w);
; 328  : 
; 329  : 				//int vxF = (VXFullF[w]-128)>>1;
; 330  : 				//int vyF = (VYFullF[w]-128)>>1;
; 331  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 332  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 333  :         //				int vxF = t256_provider.get_vect_f (time256, VXFullF[w]);
; 334  : //				int vyF = t256_provider.get_vect_f (time256, VYFullF[w]);
; 335  : 				int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 336  : 				int dstF = prefF[adrF];

	mov	ecx, DWORD PTR tv1354[esp+92]
	lea	esi, DWORD PTR [edx+edx]
	lea	eax, DWORD PTR [eax+2]
	movsx	edx, WORD PTR [ecx+eax-2]
	movsx	ecx, WORD PTR [eax-2]
	sar	edx, 1
	imul	edx, DWORD PTR _ref_pitch$[esp+88]
	sar	ecx, 1
	add	edx, DWORD PTR tv1359[esp+92]
	add	ecx, edx
	add	ecx, esi
	movzx	edi, BYTE PTR [ecx+ebp]

; 337  : 				//int vxB = (VXFullB[w]-128)>>1;
; 338  : 				//int vyB = (VYFullB[w]-128)>>1;
; 339  :         int vxB = (VXFullB[w]) >> 1; // 2.5.11.22
; 340  :         int vyB = (VYFullB[w]) >> 1; // 2.5.11.22
; 341  :         //				int vxB = t256_provider.get_vect_b (time256, VXFullB[w]);
; 342  : //				int vyB = t256_provider.get_vect_b (time256, VYFullB[w]);
; 343  : 				int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 344  : 				int dstB = prefB[adrB];

	mov	ecx, DWORD PTR tv1362[esp+92]
	movsx	edx, WORD PTR [ecx+eax-2]
	mov	ecx, DWORD PTR tv1356[esp+92]
	sar	edx, 1
	imul	edx, DWORD PTR _ref_pitch$[esp+88]
	movsx	ecx, WORD PTR [ecx+eax-2]
	sar	ecx, 1
	add	edx, esi

; 345  : 				pdst[w] = ( ((dstF + dstB)<<8) + (dstB - dstF)*(MaskF[w] - MaskB[w]) )>>9;

	mov	esi, DWORD PTR tv1365[esp+92]
	add	ecx, edx
	movzx	edx, BYTE PTR [ecx+ebp]
	movzx	ecx, BYTE PTR [ebx+esi]
	movzx	ebx, BYTE PTR [esi]
	sub	ebx, ecx
	mov	ecx, edx
	sub	ecx, edi
	imul	ebx, ecx
	lea	ecx, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR _w$1$[esp+88]
	shl	ecx, 8
	inc	edx
	mov	DWORD PTR _w$1$[esp+88], edx
	add	ebx, ecx
	mov	ecx, DWORD PTR tv1360[esp+92]
	sar	ebx, 9
	mov	BYTE PTR [ecx+esi], bl
	inc	esi
	mov	ecx, DWORD PTR _width$[esp+88]
	mov	ebx, DWORD PTR tv1361[esp+92]
	mov	DWORD PTR tv1365[esp+92], esi
	cmp	edx, ecx
	jl	$LL7@FlowInterS
	mov	ebx, DWORD PTR _VXFullF$1$[esp+92]
	mov	esi, DWORD PTR _VYFullB$1$[esp+92]
	mov	edi, DWORD PTR _pdst$1$[esp+92]
	mov	eax, DWORD PTR _MaskF$1$[esp+88]
$LN6@FlowInterS:

; 346  : 			}
; 347  : 			pdst += dst_pitch;
; 348  : 			prefB += ref_pitch<<NPELL2;
; 349  : 			prefF += ref_pitch<<NPELL2;
; 350  : //			t256_provider.jump_to_next_row ();
; 351  : 			VXFullB += VPitch;
; 352  : 			VYFullB += VPitch;
; 353  : 			VXFullF += VPitch;
; 354  : 			VYFullF += VPitch;
; 355  : 			MaskB += VPitch;

	mov	edx, DWORD PTR _VPitch$[esp+88]

; 356  : 			MaskF += VPitch;

	add	eax, edx
	add	edi, DWORD PTR _dst_pitch$1$[esp+92]
	add	esi, DWORD PTR tv1376[esp+92]
	add	ebx, DWORD PTR tv1376[esp+92]
	add	ebp, DWORD PTR tv1380[esp+92]
	add	DWORD PTR _MaskB$1$[esp+88], edx
	sub	DWORD PTR _height$1$[esp+92], 1
	mov	DWORD PTR _pdst$1$[esp+92], edi
	mov	DWORD PTR _VYFullB$1$[esp+92], esi
	mov	DWORD PTR _VXFullF$1$[esp+92], ebx
	mov	DWORD PTR _MaskF$1$[esp+88], eax
	jne	$LL4@FlowInterS
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 76					; 0000004cH
	ret	0
$LN14@FlowInterS:

; 357  : 		}
; 358  : 	}
; 359  : 
; 360  : 	else // general case
; 361  : 	{
; 362  : 		for (int h=0; h<height; h++)

	mov	DWORD PTR _height$2$[esp+92], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	eax, DWORD PTR _ref_pitch$[esp+88]
	mov	edx, DWORD PTR _VYFullF$[esp+88]
	add	eax, eax
	mov	ebx, DWORD PTR _MaskB$[esp+88]
	mov	ecx, DWORD PTR _VXFullF$[esp+88]
	mov	DWORD PTR tv1378[esp+92], eax
	mov	eax, DWORD PTR _VPitch$[esp+88]
	add	eax, eax
	mov	DWORD PTR _VYFullF$1$[esp+92], edx
	mov	DWORD PTR tv1369[esp+92], eax
	mov	eax, DWORD PTR _prefF8$[esp+88]
	sub	eax, ebp
	mov	DWORD PTR _MaskB$2$[esp+92], ebx
	mov	DWORD PTR tv1358[esp+92], eax
	mov	eax, DWORD PTR _VXFullB$[esp+88]
	sub	eax, edx
	mov	DWORD PTR _VXFullF$2$[esp+92], ecx
	mov	DWORD PTR tv1347[esp+92], eax
	mov	eax, DWORD PTR _VYFullB$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1344[esp+92], eax
	mov	eax, DWORD PTR _MaskF$[esp+88]
	mov	DWORD PTR _MaskF$2$[esp+92], eax
	npad	7
$LL10@FlowInterS:

; 363  : 		{
; 364  : 			for (int w=0; w<width; w+=1)

	cmp	DWORD PTR _width$[esp+88], 0
	mov	DWORD PTR _w$1$[esp+88], 0
	jle	$LN12@FlowInterS
	mov	eax, 256				; 00000100H
	mov	DWORD PTR tv1353[esp+88], ebx
	sub	eax, esi
	mov	esi, ecx
	mov	DWORD PTR tv1366[esp+92], eax
	mov	eax, edx
	sub	eax, ecx
	mov	DWORD PTR tv1351[esp+92], esi
	mov	DWORD PTR tv1363[esp+92], eax
	mov	eax, DWORD PTR tv1344[esp+92]
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR tv1343[esp+92], eax
	mov	eax, DWORD PTR tv1347[esp+92]
	sub	eax, ecx
	mov	ecx, DWORD PTR _w$1$[esp+88]
	add	eax, edx
	mov	DWORD PTR tv1346[esp+92], eax
	mov	eax, DWORD PTR _MaskF$2$[esp+92]
	sub	eax, ebx
	sub	edi, ebx
	mov	DWORD PTR tv1349[esp+92], edi
	mov	edi, DWORD PTR tv1366[esp+92]
	mov	DWORD PTR tv1350[esp+92], eax
$LL13@FlowInterS:

; 365  : 			{
; 366  : 				//const int		time256 = t256_provider.get_t (w);
; 367  : 
; 368  : //				int vxF = ((VXFullF[w]-128)*time256)/256;
; 369  : //				int vyF = ((VYFullF[w]-128)*time256)/256;
; 370  : 				//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 371  : 				//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 372  :         int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 373  :         int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1363[esp+92]
	lea	edx, DWORD PTR [ecx+ecx]
	movsx	ecx, WORD PTR [eax+esi]
	imul	ecx, DWORD PTR _time256$[esp+88]
	movsx	eax, WORD PTR [esi]
	imul	eax, DWORD PTR _time256$[esp+88]
	sar	ecx, 8

; 374  :         int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+88]
	sar	eax, 8

; 375  : 				int dstF = prefF[adrF];

	add	ecx, DWORD PTR tv1358[esp+92]
	add	eax, ecx
	add	eax, edx
	movzx	ebx, BYTE PTR [eax+ebp]

; 376  : 				//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 377  : 				//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 378  :         int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 379  :         int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1343[esp+92]
	movsx	ecx, WORD PTR [eax+esi]
	mov	eax, DWORD PTR tv1346[esp+92]
	imul	ecx, edi
	movsx	eax, WORD PTR [eax+esi]
	imul	eax, edi
	sar	ecx, 8

; 380  :         int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+88]
	sar	eax, 8

; 381  : 				int dstB = prefB[adrB];

	add	ecx, edx

; 382  : 				pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +

	mov	edx, 255				; 000000ffH
	add	eax, ecx
	mov	ecx, DWORD PTR tv1350[esp+92]
	movzx	edi, BYTE PTR [eax+ebp]
	mov	eax, DWORD PTR tv1353[esp+88]
	movzx	esi, BYTE PTR [eax+ecx]
	movzx	ecx, BYTE PTR [eax]
	mov	eax, 255				; 000000ffH
	sub	edx, ecx
	sub	eax, esi
	imul	ecx, ebx
	imul	esi, edi
	imul	edx, edi
	mov	edi, DWORD PTR tv1366[esp+92]
	imul	eax, ebx
	add	esi, 255				; 000000ffH
	add	edx, 255				; 000000ffH
	add	ecx, edx
	mov	edx, DWORD PTR tv1349[esp+92]
	add	eax, esi
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[esp+88]
	mov	esi, DWORD PTR tv1351[esp+92]
	sar	eax, 8
	add	esi, 2
	imul	eax, edi
	mov	DWORD PTR tv1351[esp+92], esi
	add	ecx, eax
	mov	eax, DWORD PTR tv1353[esp+88]
	sar	ecx, 8
	mov	BYTE PTR [eax+edx], cl
	inc	eax
	mov	ecx, DWORD PTR _w$1$[esp+88]
	inc	ecx
	mov	DWORD PTR tv1353[esp+88], eax
	mov	DWORD PTR _w$1$[esp+88], ecx
	cmp	ecx, DWORD PTR _width$[esp+88]
	jl	$LL13@FlowInterS
	mov	edi, DWORD PTR _pdst$1$[esp+92]
	mov	ecx, DWORD PTR _VXFullF$2$[esp+92]
	mov	edx, DWORD PTR _VYFullF$1$[esp+92]
	mov	ebx, DWORD PTR _MaskB$2$[esp+92]
	mov	esi, DWORD PTR _time256$[esp+88]
	mov	eax, DWORD PTR _MaskF$2$[esp+92]
$LN12@FlowInterS:

; 383  : 				            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*     time256   )>>8;
; 384  : 			}
; 385  : 			pdst += dst_pitch;

	add	edi, DWORD PTR _dst_pitch$1$[esp+92]

; 386  : 			prefB += ref_pitch<<NPELL2;
; 387  : 			prefF += ref_pitch<<NPELL2;
; 388  : 			//t256_provider.jump_to_next_row ();
; 389  : 			VXFullB += VPitch;
; 390  : 			VYFullB += VPitch;
; 391  : 			VXFullF += VPitch;

	add	ecx, DWORD PTR tv1369[esp+92]

; 392  : 			VYFullF += VPitch;

	add	edx, DWORD PTR tv1369[esp+92]

; 393  : 			MaskB += VPitch;

	add	ebx, DWORD PTR _VPitch$[esp+88]

; 394  : 			MaskF += VPitch;

	add	eax, DWORD PTR _VPitch$[esp+88]
	add	ebp, DWORD PTR tv1378[esp+92]
	sub	DWORD PTR _height$2$[esp+92], 1
	mov	DWORD PTR _pdst$1$[esp+92], edi
	mov	DWORD PTR _VXFullF$2$[esp+92], ecx
	mov	DWORD PTR _VYFullF$1$[esp+92], edx
	mov	DWORD PTR _MaskB$2$[esp+92], ebx
	mov	DWORD PTR _MaskF$2$[esp+92], eax
	jne	$LL10@FlowInterS
$LN9@FlowInterS:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 76					; 0000004cH
	ret	0
??$FlowInterSimple_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInterSimple_NPel<unsigned char,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterSimple_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
_pdst$1$ = -76						; size = 4
tv1365 = -72						; size = 4
_MaskF$2$ = -72						; size = 4
_VXFullF$2$ = -68					; size = 4
_VYFullB$1$ = -68					; size = 4
tv1351 = -64						; size = 4
_VXFullF$1$ = -64					; size = 4
tv1366 = -60						; size = 4
_height$1$ = -60					; size = 4
_dst_pitch$1$ = -56					; size = 4
tv1368 = -52						; size = 4
tv1359 = -52						; size = 4
tv1354 = -48						; size = 4
_VYFullF$1$ = -48					; size = 4
tv1357 = -44						; size = 4
_MaskB$2$ = -44						; size = 4
tv1355 = -40						; size = 4
_height$2$ = -40					; size = 4
tv1362 = -36						; size = 4
tv1346 = -36						; size = 4
tv1356 = -32						; size = 4
tv1344 = -32						; size = 4
tv1360 = -28						; size = 4
tv1358 = -28						; size = 4
tv1363 = -24						; size = 4
tv1361 = -24						; size = 4
tv1371 = -20						; size = 4
tv1347 = -20						; size = 4
tv1369 = -16						; size = 4
tv1345 = -16						; size = 4
tv1350 = -12						; size = 4
tv1349 = -8						; size = 4
tv1370 = -4						; size = 4
tv1353 = 8						; size = 4
_w$1$ = 8						; size = 4
_prefB8$ = 8						; size = 4
_w$1$ = 12						; size = 4
_MaskF$1$ = 12						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_MaskB$1$ = 56						; size = 4
_time256$ = 56						; size = 4
??$FlowInterSimple_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInterSimple_NPel<unsigned char,2>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 314  : {

	sub	esp, 76					; 0000004cH

; 315  :   dst_pitch /= sizeof(pixel_t);
; 316  :   ref_pitch /= sizeof(pixel_t);
; 317  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 318  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 319  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 320  : 
; 321  : 	if (time256 == 128 /*t256_provider.is_half ()*/) // special case double fps - fastest
; 322  : 	{
; 323  : 		for (int h=0; h<height; h++)

	mov	eax, DWORD PTR _height$[esp+72]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _prefB8$[esp+80]
	push	esi
	mov	esi, DWORD PTR _time256$[esp+84]
	mov	DWORD PTR _dst_pitch$1$[esp+88], edx
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _pdst$1$[esp+92], edi
	cmp	esi, 128				; 00000080H
	jne	$LN14@FlowInterS
	mov	DWORD PTR _height$1$[esp+92], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	eax, DWORD PTR _ref_pitch$[esp+88]
	mov	esi, DWORD PTR _VYFullB$[esp+88]
	shl	eax, 2
	mov	edx, DWORD PTR _MaskB$[esp+88]
	mov	ebx, DWORD PTR _VXFullF$[esp+88]
	mov	ecx, DWORD PTR _width$[esp+88]
	mov	DWORD PTR tv1371[esp+92], eax
	mov	eax, DWORD PTR _VPitch$[esp+88]
	add	eax, eax
	mov	DWORD PTR _VYFullB$1$[esp+92], esi
	mov	DWORD PTR tv1369[esp+92], eax
	mov	eax, DWORD PTR _prefF8$[esp+88]
	sub	eax, ebp
	mov	DWORD PTR _MaskB$1$[esp+88], edx
	mov	DWORD PTR tv1359[esp+92], eax
	mov	eax, DWORD PTR _VXFullB$[esp+88]
	sub	eax, esi
	mov	DWORD PTR _VXFullF$1$[esp+92], ebx
	mov	DWORD PTR tv1357[esp+92], eax
	mov	eax, DWORD PTR _VYFullF$[esp+88]
	sub	eax, esi
	mov	DWORD PTR tv1355[esp+92], eax
	mov	eax, DWORD PTR _MaskF$[esp+88]
	mov	DWORD PTR _MaskF$1$[esp+88], eax
	npad	5
$LL4@FlowInterS:

; 324  : 		{
; 325  : 			for (int w=0; w<width; w+=1)

	xor	edx, edx
	mov	DWORD PTR _w$1$[esp+88], edx
	test	ecx, ecx
	jle	$LN6@FlowInterS
	mov	ecx, DWORD PTR tv1355[esp+92]
	sub	ecx, ebx
	mov	DWORD PTR tv1365[esp+92], eax
	add	ecx, esi
	mov	eax, ebx
	mov	DWORD PTR tv1354[esp+92], ecx
	mov	ecx, esi
	sub	ecx, ebx
	mov	DWORD PTR tv1362[esp+92], ecx
	mov	ecx, DWORD PTR tv1357[esp+92]
	sub	ecx, ebx
	mov	ebx, DWORD PTR _MaskB$1$[esp+88]
	sub	ebx, DWORD PTR _MaskF$1$[esp+88]
	add	ecx, esi
	mov	esi, edi
	mov	DWORD PTR tv1356[esp+92], ecx
	sub	esi, DWORD PTR _MaskF$1$[esp+88]
	mov	DWORD PTR tv1361[esp+92], ebx
	mov	DWORD PTR tv1360[esp+92], esi
	npad	3
$LL7@FlowInterS:

; 326  : 			{
; 327  : //				const int		time256 = t256_provider.get_t (w);
; 328  : 
; 329  : 				//int vxF = (VXFullF[w]-128)>>1;
; 330  : 				//int vyF = (VYFullF[w]-128)>>1;
; 331  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 332  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 333  :         //				int vxF = t256_provider.get_vect_f (time256, VXFullF[w]);
; 334  : //				int vyF = t256_provider.get_vect_f (time256, VYFullF[w]);
; 335  : 				int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 336  : 				int dstF = prefF[adrF];

	mov	ecx, DWORD PTR tv1354[esp+92]
	lea	esi, DWORD PTR [edx*4]
	lea	eax, DWORD PTR [eax+2]
	movsx	edx, WORD PTR [ecx+eax-2]
	movsx	ecx, WORD PTR [eax-2]
	sar	edx, 1
	imul	edx, DWORD PTR _ref_pitch$[esp+88]
	sar	ecx, 1
	add	edx, DWORD PTR tv1359[esp+92]
	add	ecx, edx
	add	ecx, esi
	movzx	edi, BYTE PTR [ecx+ebp]

; 337  : 				//int vxB = (VXFullB[w]-128)>>1;
; 338  : 				//int vyB = (VYFullB[w]-128)>>1;
; 339  :         int vxB = (VXFullB[w]) >> 1; // 2.5.11.22
; 340  :         int vyB = (VYFullB[w]) >> 1; // 2.5.11.22
; 341  :         //				int vxB = t256_provider.get_vect_b (time256, VXFullB[w]);
; 342  : //				int vyB = t256_provider.get_vect_b (time256, VYFullB[w]);
; 343  : 				int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 344  : 				int dstB = prefB[adrB];

	mov	ecx, DWORD PTR tv1362[esp+92]
	movsx	edx, WORD PTR [ecx+eax-2]
	mov	ecx, DWORD PTR tv1356[esp+92]
	sar	edx, 1
	imul	edx, DWORD PTR _ref_pitch$[esp+88]
	movsx	ecx, WORD PTR [ecx+eax-2]
	sar	ecx, 1
	add	edx, esi

; 345  : 				pdst[w] = ( ((dstF + dstB)<<8) + (dstB - dstF)*(MaskF[w] - MaskB[w]) )>>9;

	mov	esi, DWORD PTR tv1365[esp+92]
	add	ecx, edx
	movzx	edx, BYTE PTR [ecx+ebp]
	movzx	ecx, BYTE PTR [ebx+esi]
	movzx	ebx, BYTE PTR [esi]
	sub	ebx, ecx
	mov	ecx, edx
	sub	ecx, edi
	imul	ebx, ecx
	lea	ecx, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR _w$1$[esp+88]
	shl	ecx, 8
	inc	edx
	mov	DWORD PTR _w$1$[esp+88], edx
	add	ebx, ecx
	mov	ecx, DWORD PTR tv1360[esp+92]
	sar	ebx, 9
	mov	BYTE PTR [ecx+esi], bl
	inc	esi
	mov	ecx, DWORD PTR _width$[esp+88]
	mov	ebx, DWORD PTR tv1361[esp+92]
	mov	DWORD PTR tv1365[esp+92], esi
	cmp	edx, ecx
	jl	$LL7@FlowInterS
	mov	ebx, DWORD PTR _VXFullF$1$[esp+92]
	mov	esi, DWORD PTR _VYFullB$1$[esp+92]
	mov	edi, DWORD PTR _pdst$1$[esp+92]
	mov	eax, DWORD PTR _MaskF$1$[esp+88]
$LN6@FlowInterS:

; 346  : 			}
; 347  : 			pdst += dst_pitch;
; 348  : 			prefB += ref_pitch<<NPELL2;
; 349  : 			prefF += ref_pitch<<NPELL2;
; 350  : //			t256_provider.jump_to_next_row ();
; 351  : 			VXFullB += VPitch;
; 352  : 			VYFullB += VPitch;
; 353  : 			VXFullF += VPitch;
; 354  : 			VYFullF += VPitch;
; 355  : 			MaskB += VPitch;

	mov	edx, DWORD PTR _VPitch$[esp+88]

; 356  : 			MaskF += VPitch;

	add	eax, edx
	add	edi, DWORD PTR _dst_pitch$1$[esp+92]
	add	esi, DWORD PTR tv1369[esp+92]
	add	ebx, DWORD PTR tv1369[esp+92]
	add	ebp, DWORD PTR tv1371[esp+92]
	add	DWORD PTR _MaskB$1$[esp+88], edx
	sub	DWORD PTR _height$1$[esp+92], 1
	mov	DWORD PTR _pdst$1$[esp+92], edi
	mov	DWORD PTR _VYFullB$1$[esp+92], esi
	mov	DWORD PTR _VXFullF$1$[esp+92], ebx
	mov	DWORD PTR _MaskF$1$[esp+88], eax
	jne	$LL4@FlowInterS
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 76					; 0000004cH
	ret	0
$LN14@FlowInterS:

; 357  : 		}
; 358  : 	}
; 359  : 
; 360  : 	else // general case
; 361  : 	{
; 362  : 		for (int h=0; h<height; h++)

	mov	DWORD PTR _height$2$[esp+92], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	eax, DWORD PTR _ref_pitch$[esp+88]
	mov	edx, DWORD PTR _VYFullF$[esp+88]
	shl	eax, 2
	mov	ebx, DWORD PTR _MaskB$[esp+88]
	mov	ecx, DWORD PTR _VXFullF$[esp+88]
	mov	DWORD PTR tv1370[esp+92], eax
	mov	eax, DWORD PTR _VPitch$[esp+88]
	add	eax, eax
	mov	DWORD PTR _VYFullF$1$[esp+92], edx
	mov	DWORD PTR tv1368[esp+92], eax
	mov	eax, DWORD PTR _prefF8$[esp+88]
	sub	eax, ebp
	mov	DWORD PTR _MaskB$2$[esp+92], ebx
	mov	DWORD PTR tv1358[esp+92], eax
	mov	eax, DWORD PTR _VXFullB$[esp+88]
	sub	eax, edx
	mov	DWORD PTR _VXFullF$2$[esp+92], ecx
	mov	DWORD PTR tv1347[esp+92], eax
	mov	eax, DWORD PTR _VYFullB$[esp+88]
	sub	eax, edx
	mov	DWORD PTR tv1345[esp+92], eax
	mov	eax, DWORD PTR _MaskF$[esp+88]
	mov	DWORD PTR _MaskF$2$[esp+92], eax
	npad	2
$LL10@FlowInterS:

; 363  : 		{
; 364  : 			for (int w=0; w<width; w+=1)

	cmp	DWORD PTR _width$[esp+88], 0
	mov	DWORD PTR _w$1$[esp+88], 0
	jle	$LN12@FlowInterS
	mov	eax, 256				; 00000100H
	mov	DWORD PTR tv1353[esp+88], ebx
	sub	eax, esi
	mov	esi, ecx
	mov	DWORD PTR tv1366[esp+92], eax
	mov	eax, edx
	sub	eax, ecx
	mov	DWORD PTR tv1351[esp+92], esi
	mov	DWORD PTR tv1363[esp+92], eax
	mov	eax, DWORD PTR tv1345[esp+92]
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR tv1344[esp+92], eax
	mov	eax, DWORD PTR tv1347[esp+92]
	sub	eax, ecx
	mov	ecx, DWORD PTR _w$1$[esp+88]
	add	eax, edx
	mov	DWORD PTR tv1346[esp+92], eax
	mov	eax, DWORD PTR _MaskF$2$[esp+92]
	sub	eax, ebx
	sub	edi, ebx
	mov	DWORD PTR tv1349[esp+92], edi
	mov	edi, DWORD PTR tv1366[esp+92]
	mov	DWORD PTR tv1350[esp+92], eax
	npad	13
$LL13@FlowInterS:

; 365  : 			{
; 366  : 				//const int		time256 = t256_provider.get_t (w);
; 367  : 
; 368  : //				int vxF = ((VXFullF[w]-128)*time256)/256;
; 369  : //				int vyF = ((VYFullF[w]-128)*time256)/256;
; 370  : 				//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 371  : 				//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 372  :         int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 373  :         int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1363[esp+92]
	lea	edx, DWORD PTR [ecx*4]
	movsx	ecx, WORD PTR [eax+esi]
	imul	ecx, DWORD PTR _time256$[esp+88]
	movsx	eax, WORD PTR [esi]
	imul	eax, DWORD PTR _time256$[esp+88]
	sar	ecx, 8

; 374  :         int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+88]
	sar	eax, 8

; 375  : 				int dstF = prefF[adrF];

	add	ecx, DWORD PTR tv1358[esp+92]
	add	eax, ecx
	add	eax, edx
	movzx	ebx, BYTE PTR [eax+ebp]

; 376  : 				//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 377  : 				//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 378  :         int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 379  :         int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1344[esp+92]
	movsx	ecx, WORD PTR [eax+esi]
	mov	eax, DWORD PTR tv1346[esp+92]
	imul	ecx, edi
	movsx	eax, WORD PTR [eax+esi]
	imul	eax, edi
	sar	ecx, 8

; 380  :         int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+88]
	sar	eax, 8

; 381  : 				int dstB = prefB[adrB];

	add	ecx, edx

; 382  : 				pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +

	mov	edx, 255				; 000000ffH
	add	eax, ecx
	mov	ecx, DWORD PTR tv1350[esp+92]
	movzx	edi, BYTE PTR [eax+ebp]
	mov	eax, DWORD PTR tv1353[esp+88]
	movzx	esi, BYTE PTR [eax+ecx]
	movzx	ecx, BYTE PTR [eax]
	mov	eax, 255				; 000000ffH
	sub	edx, ecx
	sub	eax, esi
	imul	ecx, ebx
	imul	esi, edi
	imul	edx, edi
	mov	edi, DWORD PTR tv1366[esp+92]
	imul	eax, ebx
	add	esi, 255				; 000000ffH
	add	edx, 255				; 000000ffH
	add	ecx, edx
	mov	edx, DWORD PTR tv1349[esp+92]
	add	eax, esi
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[esp+88]
	mov	esi, DWORD PTR tv1351[esp+92]
	sar	eax, 8
	add	esi, 2
	imul	eax, edi
	mov	DWORD PTR tv1351[esp+92], esi
	add	ecx, eax
	mov	eax, DWORD PTR tv1353[esp+88]
	sar	ecx, 8
	mov	BYTE PTR [eax+edx], cl
	inc	eax
	mov	ecx, DWORD PTR _w$1$[esp+88]
	inc	ecx
	mov	DWORD PTR tv1353[esp+88], eax
	mov	DWORD PTR _w$1$[esp+88], ecx
	cmp	ecx, DWORD PTR _width$[esp+88]
	jl	$LL13@FlowInterS
	mov	edi, DWORD PTR _pdst$1$[esp+92]
	mov	ecx, DWORD PTR _VXFullF$2$[esp+92]
	mov	edx, DWORD PTR _VYFullF$1$[esp+92]
	mov	ebx, DWORD PTR _MaskB$2$[esp+92]
	mov	esi, DWORD PTR _time256$[esp+88]
	mov	eax, DWORD PTR _MaskF$2$[esp+92]
$LN12@FlowInterS:

; 383  : 				            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*     time256   )>>8;
; 384  : 			}
; 385  : 			pdst += dst_pitch;

	add	edi, DWORD PTR _dst_pitch$1$[esp+92]

; 386  : 			prefB += ref_pitch<<NPELL2;
; 387  : 			prefF += ref_pitch<<NPELL2;
; 388  : 			//t256_provider.jump_to_next_row ();
; 389  : 			VXFullB += VPitch;
; 390  : 			VYFullB += VPitch;
; 391  : 			VXFullF += VPitch;

	add	ecx, DWORD PTR tv1368[esp+92]

; 392  : 			VYFullF += VPitch;

	add	edx, DWORD PTR tv1368[esp+92]

; 393  : 			MaskB += VPitch;

	add	ebx, DWORD PTR _VPitch$[esp+88]

; 394  : 			MaskF += VPitch;

	add	eax, DWORD PTR _VPitch$[esp+88]
	add	ebp, DWORD PTR tv1370[esp+92]
	sub	DWORD PTR _height$2$[esp+92], 1
	mov	DWORD PTR _pdst$1$[esp+92], edi
	mov	DWORD PTR _VXFullF$2$[esp+92], ecx
	mov	DWORD PTR _VYFullF$1$[esp+92], edx
	mov	DWORD PTR _MaskB$2$[esp+92], ebx
	mov	DWORD PTR _MaskF$2$[esp+92], eax
	jne	$LL10@FlowInterS
$LN9@FlowInterS:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 76					; 0000004cH
	ret	0
??$FlowInterSimple_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInterSimple_NPel<unsigned char,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterSimple_Pel1@G@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
_MaskF$2$ = -84						; size = 4
_height$1$ = -84					; size = 4
tv1647 = -80						; size = 4
_MaskF$1$ = -80						; size = 4
_pdst$1$ = -76						; size = 4
tv1662 = -72						; size = 4
_MaskB$2$ = -72						; size = 4
tv1667 = -68						; size = 4
_VXFullF$1$ = -68					; size = 4
tv1660 = -64						; size = 4
tv1658 = -64						; size = 4
tv1654 = -60						; size = 4
_VXFullF$2$ = -60					; size = 4
tv1668 = -56						; size = 4
tv1648 = -56						; size = 4
tv1651 = -52						; size = 4
_VYFullF$1$ = -52					; size = 4
tv1649 = -48						; size = 4
_height$2$ = -48					; size = 4
tv1650 = -44						; size = 4
tv1643 = -44						; size = 4
tv1656 = -40						; size = 4
tv1641 = -40						; size = 4
tv1659 = -36						; size = 4
tv1653 = -36						; size = 4
_dstF1$1$ = -32						; size = 4
tv1661 = -32						; size = 4
tv1673 = -28						; size = 4
tv1644 = -28						; size = 4
tv1669 = -24						; size = 4
tv1642 = -24						; size = 4
tv1655 = -20						; size = 4
_dstB1$1$ = -16						; size = 4
_dstF1$1$ = -12						; size = 4
tv1672 = -8						; size = 4
tv1670 = -4						; size = 4
_prefB8$ = 8						; size = 4
_w$1$ = 12						; size = 4
_MaskB$1$ = 12						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_VYFullB$1$ = 56					; size = 4
_time256$ = 56						; size = 4
??$FlowInterSimple_Pel1@G@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInterSimple_Pel1<unsigned short>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 405  : {

	sub	esp, 84					; 00000054H

; 406  :   dst_pitch /= sizeof(pixel_t);
; 407  :   ref_pitch /= sizeof(pixel_t);
; 408  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 409  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 410  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 411  : 
; 412  : 	if (time256 == 128 /*t256_provider.is_half ()*/) // special case double fps - fastest
; 413  : 	{
; 414  : 		for (int h=0; h<height; h++)

	mov	eax, DWORD PTR _height$[esp+80]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _ref_pitch$[esp+92]
	push	edi
	mov	edi, edx
	shr	esi, 1
	mov	edx, ecx
	shr	edi, 1
	cmp	DWORD PTR _time256$[esp+96], 128	; 00000080H
	mov	DWORD PTR _pdst$1$[esp+100], edx
	mov	DWORD PTR _ref_pitch$[esp+96], esi
	jne	$LN14@FlowInterS
	mov	DWORD PTR _height$1$[esp+100], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	ebx, DWORD PTR _VYFullB$[esp+96]
	lea	eax, DWORD PTR [edi+edi]
	mov	edi, DWORD PTR _prefB8$[esp+96]
	mov	ebp, DWORD PTR _MaskF$[esp+96]
	mov	ecx, DWORD PTR _MaskB$[esp+96]
	mov	edx, DWORD PTR _VXFullF$[esp+96]
	mov	DWORD PTR tv1673[esp+100], eax
	mov	eax, DWORD PTR _VPitch$[esp+96]
	add	eax, eax
	mov	DWORD PTR _VYFullB$1$[esp+96], ebx
	mov	DWORD PTR tv1669[esp+100], eax
	mov	eax, DWORD PTR _prefF8$[esp+96]
	sub	eax, edi
	mov	DWORD PTR _MaskF$1$[esp+100], ebp
	mov	DWORD PTR tv1654[esp+100], eax
	mov	eax, DWORD PTR _VXFullB$[esp+96]
	sub	eax, ebx
	mov	DWORD PTR _MaskB$1$[esp+96], ecx
	mov	DWORD PTR tv1651[esp+100], eax
	mov	eax, DWORD PTR _VYFullF$[esp+96]
	sub	eax, ebx
	mov	DWORD PTR _VXFullF$1$[esp+100], edx
	mov	DWORD PTR tv1649[esp+100], eax
$LL4@FlowInterS:

; 415  : 		{
; 416  : 			for (int w=0; w<width; w+=2) // paired for speed

	xor	eax, eax
	cmp	DWORD PTR _width$[esp+96], eax
	jle	$LN6@FlowInterS
	mov	ecx, DWORD PTR tv1649[esp+100]
	mov	ebx, edx
	sub	ecx, edx
	mov	edi, DWORD PTR _prefB8$[esp+96]
	add	ecx, DWORD PTR _VYFullB$1$[esp+96]
	mov	DWORD PTR tv1648[esp+100], ecx
	mov	ecx, DWORD PTR _VYFullB$1$[esp+96]
	sub	ecx, edx
	mov	DWORD PTR tv1662[esp+100], ebx
	mov	DWORD PTR tv1660[esp+100], ecx
	mov	ecx, DWORD PTR tv1651[esp+100]
	sub	ecx, edx
	add	ecx, DWORD PTR _VYFullB$1$[esp+96]
	mov	DWORD PTR tv1650[esp+100], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+100]
	sub	ecx, edx
	mov	DWORD PTR tv1659[esp+100], ecx
	mov	ecx, DWORD PTR _MaskB$1$[esp+96]
	sub	ecx, ebp
	mov	DWORD PTR tv1656[esp+100], ecx
	npad	3
$LL7@FlowInterS:

; 417  : 			{
; 418  : 				//int vxF = (VXFullF[w]-128)>>1;
; 419  : 				//int vyF = (VYFullF[w]-128)>>1;
; 420  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 421  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 422  :         int addrF = vyF*ref_pitch + vxF + w;

	mov	ecx, DWORD PTR tv1648[esp+100]
	movsx	edx, WORD PTR [ebx+ecx]
	movsx	ecx, WORD PTR [ebx]
	sar	edx, 1
	imul	edx, esi
	sar	ecx, 1
	add	edx, eax
	add	ecx, edx

; 423  : 				int dstF = prefF[addrF];

	mov	edx, DWORD PTR tv1654[esp+100]
	lea	ecx, DWORD PTR [edx+ecx*2]
	movzx	ebp, WORD PTR [ecx+edi]

; 424  : 				int dstF1 = prefF[addrF+1]; // approximation for speed

	movzx	ecx, WORD PTR [ecx+edi+2]
	mov	DWORD PTR _dstF1$1$[esp+100], ecx

; 425  : 				//int vxB = (VXFullB[w]-128)>>1;
; 426  : 				//int vyB = (VYFullB[w]-128)>>1;
; 427  :         int vxB = (VXFullB[w]) >> 1; // 2.5.11.22
; 428  :         int vyB = (VYFullB[w]) >> 1; // 2.5.11.22
; 429  :         int addrB = vyB*ref_pitch + vxB + w;

	mov	ecx, DWORD PTR tv1660[esp+100]
	movsx	edx, WORD PTR [ebx+ecx]
	mov	ecx, DWORD PTR tv1650[esp+100]
	sar	edx, 1
	imul	edx, esi
	movsx	ecx, WORD PTR [ebx+ecx]
	sar	ecx, 1
	add	edx, eax
	add	ecx, edx

; 430  : 				int dstB = prefB[addrB];

	movzx	esi, WORD PTR [edi+ecx*2]

; 431  : 				int dstB1 = prefB[addrB+1];

	movzx	ebx, WORD PTR [edi+ecx*2+2]

; 432  : 				pdst[w  ] = ( ((dstF  + dstB )<<8) + (dstB  - dstF )*(MaskF[w  ] - MaskB[w  ]) )>>9;

	mov	edi, DWORD PTR _MaskF$1$[esp+100]
	mov	ecx, DWORD PTR tv1656[esp+100]
	add	edi, eax
	movzx	ecx, BYTE PTR [edi+ecx]
	movzx	edx, BYTE PTR [edi]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, ebp
	imul	edx, ecx
	lea	ecx, DWORD PTR [esi+ebp]
	mov	ebp, DWORD PTR tv1659[esp+100]

; 433  : 				pdst[w+1] = ( ((dstF1 + dstB1)<<8) + (dstB1 - dstF1)*(MaskF[w+1] - MaskB[w+1]) )>>9;

	mov	esi, DWORD PTR _dstF1$1$[esp+100]
	shl	ecx, 8
	add	edx, ecx
	mov	ecx, DWORD PTR tv1662[esp+100]
	sar	edx, 9
	mov	WORD PTR [ecx+ebp], dx
	mov	ecx, DWORD PTR _MaskB$1$[esp+96]
	movzx	edx, BYTE PTR [edi+1]
	mov	edi, DWORD PTR _prefB8$[esp+96]
	movzx	ecx, BYTE PTR [eax+ecx+1]
	add	eax, 2
	sub	edx, ecx
	mov	ecx, ebx
	sub	ecx, esi
	imul	edx, ecx
	lea	ecx, DWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR tv1662[esp+100]
	mov	esi, DWORD PTR _ref_pitch$[esp+96]
	shl	ecx, 8
	add	edx, ecx
	sar	edx, 9
	mov	WORD PTR [ebx+ebp+2], dx
	add	ebx, 4
	mov	DWORD PTR tv1662[esp+100], ebx
	cmp	eax, DWORD PTR _width$[esp+96]
	jl	$LL7@FlowInterS
	mov	edx, DWORD PTR _VXFullF$1$[esp+100]
	mov	ebp, DWORD PTR _MaskF$1$[esp+100]
	mov	ecx, DWORD PTR _MaskB$1$[esp+96]
	mov	ebx, DWORD PTR _VYFullB$1$[esp+96]
$LN6@FlowInterS:

; 434  : 			}
; 435  : 			pdst += dst_pitch;

	mov	eax, DWORD PTR tv1673[esp+100]

; 436  : 			prefB += ref_pitch;

	lea	edi, DWORD PTR [edi+esi*2]

; 437  : 			prefF += ref_pitch;
; 438  : 			VXFullB += VPitch;
; 439  : 			VYFullB += VPitch;

	add	ebx, DWORD PTR tv1669[esp+100]

; 440  : 			VXFullF += VPitch;

	add	edx, DWORD PTR tv1669[esp+100]

; 441  : 			VYFullF += VPitch;
; 442  : 			MaskB += VPitch;

	add	ecx, DWORD PTR _VPitch$[esp+96]

; 443  : 			MaskF += VPitch;

	add	ebp, DWORD PTR _VPitch$[esp+96]
	add	DWORD PTR _pdst$1$[esp+100], eax
	sub	DWORD PTR _height$1$[esp+100], 1
	mov	DWORD PTR _prefB8$[esp+96], edi
	mov	DWORD PTR _VYFullB$1$[esp+96], ebx
	mov	DWORD PTR _VXFullF$1$[esp+100], edx
	mov	DWORD PTR _MaskB$1$[esp+96], ecx
	mov	DWORD PTR _MaskF$1$[esp+100], ebp
	jne	$LL4@FlowInterS
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 488  : 		}
; 489  : 	}
; 490  : }

	add	esp, 84					; 00000054H
	ret	0
$LN14@FlowInterS:

; 444  : 		}
; 445  : 	}
; 446  : 
; 447  : 	else // general case
; 448  : 	{
; 449  :     // avoid "uint16*uint16 can't get into int32" overflows
; 450  :     typedef std::conditional < sizeof(pixel_t) == 1, int, typename std::conditional < sizeof(pixel_t) == 2, __int64, float>::type >::type result_t;
; 451  : 
; 452  : 		for (int h=0; h<height; h++)

	mov	DWORD PTR _height$2$[esp+100], eax
	test	eax, eax
	jle	$LN9@FlowInterS
	mov	ebx, DWORD PTR _prefB8$[esp+96]
	lea	eax, DWORD PTR [edi+edi]
	mov	ebp, DWORD PTR _VYFullF$[esp+96]
	mov	DWORD PTR tv1672[esp+100], eax
	lea	eax, DWORD PTR [esi+esi]
	mov	edi, DWORD PTR _MaskB$[esp+96]
	mov	ecx, DWORD PTR _VXFullF$[esp+96]
	mov	DWORD PTR tv1670[esp+100], eax
	mov	eax, DWORD PTR _VPitch$[esp+96]
	add	eax, eax
	mov	DWORD PTR _VYFullF$1$[esp+100], ebp
	mov	DWORD PTR tv1668[esp+100], eax
	mov	eax, DWORD PTR _prefF8$[esp+96]
	sub	eax, ebx
	mov	DWORD PTR _MaskB$2$[esp+100], edi
	mov	DWORD PTR tv1653[esp+100], eax
	mov	eax, DWORD PTR _VXFullB$[esp+96]
	sub	eax, ebp
	mov	DWORD PTR _VXFullF$2$[esp+100], ecx
	mov	DWORD PTR tv1644[esp+100], eax
	mov	eax, DWORD PTR _VYFullB$[esp+96]
	sub	eax, ebp
	mov	DWORD PTR tv1642[esp+100], eax
	mov	eax, DWORD PTR _MaskF$[esp+96]
	mov	DWORD PTR _MaskF$2$[esp+100], eax
	npad	4
$LL10@FlowInterS:

; 453  : 		{
; 454  : 			for (int w=0; w<width; w+=2) // paired for speed

	cmp	DWORD PTR _width$[esp+96], 0
	mov	DWORD PTR _w$1$[esp+96], 0
	jle	$LN12@FlowInterS
	mov	eax, ebp
	mov	DWORD PTR tv1647[esp+100], ecx
	sub	eax, ecx
	mov	edi, 256				; 00000100H
	sub	edi, DWORD PTR _time256$[esp+96]
	sub	edx, ecx
	mov	DWORD PTR tv1661[esp+100], eax
	mov	eax, DWORD PTR tv1642[esp+100]
	sub	eax, ecx
	mov	DWORD PTR tv1658[esp+100], edx
	mov	edx, DWORD PTR _w$1$[esp+96]
	add	eax, ebp
	mov	DWORD PTR tv1641[esp+100], eax
	mov	eax, DWORD PTR tv1644[esp+100]
	sub	eax, ecx
	mov	DWORD PTR tv1667[esp+100], edi
	add	eax, ebp
	mov	ebp, ecx
	mov	DWORD PTR tv1643[esp+100], eax
	mov	eax, DWORD PTR _MaskB$2$[esp+100]
	sub	eax, DWORD PTR _MaskF$2$[esp+100]
	mov	DWORD PTR tv1655[esp+100], eax
$LL13@FlowInterS:

; 455  : 			{
; 456  : 				//const int		time256 = t256_provider.get_t (w);
; 457  : 
; 458  : 				//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]);
; 459  : 				//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]);
; 460  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 461  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 462  :         int addrF = vyF*ref_pitch + vxF + w;

	mov	eax, DWORD PTR tv1661[esp+100]
	movsx	ecx, WORD PTR [eax+ebp]
	movsx	eax, WORD PTR [ebp]
	sar	eax, 1
	sar	ecx, 1
	imul	ecx, esi
	add	ecx, edx
	add	eax, ecx

; 463  : 				int dstF = prefF[addrF];

	mov	ecx, DWORD PTR tv1653[esp+100]
	lea	eax, DWORD PTR [ecx+eax*2]

; 464  : 				int dstF1 = prefF[addrF+1]; // approximation for speed
; 465  : 				//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]);
; 466  : 				//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]);
; 467  :         int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 468  :         int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1641[esp+100]
	movzx	ebp, WORD PTR [eax+ebx]
	movzx	eax, WORD PTR [eax+ebx+2]
	mov	DWORD PTR _dstF1$1$[esp+100], eax
	mov	eax, DWORD PTR tv1647[esp+100]
	movsx	ecx, WORD PTR [ecx+eax]
	imul	ecx, edi
	sar	ecx, 8

; 469  :         int addrB = vyB*ref_pitch + vxB + w;

	imul	ecx, esi
	mov	esi, DWORD PTR tv1643[esp+100]
	movsx	eax, WORD PTR [esi+eax]
	add	ecx, edx
	imul	eax, edi
	sar	eax, 8
	add	eax, ecx

; 470  : 				int dstB = prefB[addrB];
; 471  : 				int dstB1 = prefB[addrB+1];
; 472  :         // possible overflow for 16 bit
; 473  : 				pdst[w  ] = ( ( (result_t)(dstF *255 + (dstB -dstF )*MaskF[w  ] + 255) )*(256-time256) +

	mov	ecx, DWORD PTR tv1655[esp+100]
	movzx	edx, WORD PTR [ebx+eax*2]
	movzx	eax, WORD PTR [ebx+eax*2+2]
	mov	esi, edx
	mov	DWORD PTR _dstB1$1$[esp+100], eax
	sub	esi, ebp
	mov	eax, DWORD PTR _MaskF$2$[esp+100]
	add	eax, DWORD PTR _w$1$[esp+96]
	movzx	ecx, BYTE PTR [eax+ecx]
	lea	eax, DWORD PTR [edx+1]
	imul	eax, eax, 255
	imul	ecx, esi
	sub	eax, ecx
	mov	ecx, DWORD PTR _w$1$[esp+96]
	imul	DWORD PTR _time256$[esp+96]
	mov	ebx, eax
	mov	edi, edx
	mov	eax, DWORD PTR _MaskF$2$[esp+100]
	movzx	eax, BYTE PTR [ecx+eax]
	lea	ecx, DWORD PTR [ebp+1]
	imul	eax, esi
	imul	ecx, ecx, 255

; 474  : 				              ( (result_t)(dstB *255 - (dstB -dstF )*MaskB[w  ] + 255) )*     time256   )>>16;
; 475  : 				pdst[w+1] = ( ( (result_t)(dstF1*255 + (dstB1-dstF1)*MaskF[w+1] + 255) )*(256-time256) +

	mov	ebp, DWORD PTR _dstF1$1$[esp+100]
	add	eax, ecx
	mov	ecx, DWORD PTR tv1647[esp+100]
	imul	DWORD PTR tv1667[esp+100]
	add	ebx, eax
	mov	eax, DWORD PTR tv1658[esp+100]
	adc	edi, edx
	mov	edx, DWORD PTR _w$1$[esp+96]
	shrd	ebx, edi, 16
	mov	WORD PTR [ecx+eax], bx
	mov	ecx, DWORD PTR _MaskB$2$[esp+100]
	mov	eax, DWORD PTR _dstB1$1$[esp+100]
	mov	esi, eax
	inc	eax
	sar	edi, 16					; 00000010H
	imul	eax, eax, 255
	sub	esi, ebp
	movzx	ecx, BYTE PTR [edx+ecx+1]
	imul	ecx, esi
	sub	eax, ecx
	mov	ecx, DWORD PTR _w$1$[esp+96]
	imul	DWORD PTR _time256$[esp+96]
	mov	ebx, eax
	mov	edi, edx
	mov	eax, DWORD PTR _MaskF$2$[esp+100]
	movzx	eax, BYTE PTR [ecx+eax+1]
	lea	ecx, DWORD PTR [ebp+1]
	imul	eax, esi
	imul	ecx, ecx, 255
	add	eax, ecx
	imul	DWORD PTR tv1667[esp+100]
	add	ebx, eax
	adc	edi, edx
	shrd	ebx, edi, 16
	mov	ebp, DWORD PTR tv1647[esp+100]
	mov	eax, DWORD PTR tv1658[esp+100]
	mov	edx, DWORD PTR _w$1$[esp+96]
	mov	esi, DWORD PTR _ref_pitch$[esp+96]
	add	edx, 2
	sar	edi, 16					; 00000010H
	mov	edi, DWORD PTR tv1667[esp+100]
	mov	WORD PTR [eax+ebp+2], bx
	add	ebp, 4
	mov	ebx, DWORD PTR _prefB8$[esp+96]
	mov	DWORD PTR _w$1$[esp+96], edx
	mov	DWORD PTR tv1647[esp+100], ebp
	cmp	edx, DWORD PTR _width$[esp+96]
	jl	$LL13@FlowInterS
	mov	ecx, DWORD PTR _VXFullF$2$[esp+100]
	mov	edx, DWORD PTR _pdst$1$[esp+100]
	mov	ebp, DWORD PTR _VYFullF$1$[esp+100]
	mov	eax, DWORD PTR _MaskF$2$[esp+100]
	mov	edi, DWORD PTR _MaskB$2$[esp+100]
$LN12@FlowInterS:

; 476  : 				              ( (result_t)(dstB1*255 - (dstB1-dstF1)*MaskB[w+1] + 255) )*     time256   )>>16;
; 477  : 			}
; 478  : 			pdst += dst_pitch;

	add	edx, DWORD PTR tv1672[esp+100]

; 479  : 			prefB += ref_pitch;

	add	ebx, DWORD PTR tv1670[esp+100]

; 480  : 			prefF += ref_pitch;
; 481  : 			//t256_provider.jump_to_next_row ();
; 482  : 			VXFullB += VPitch;
; 483  : 			VYFullB += VPitch;
; 484  : 			VXFullF += VPitch;

	add	ecx, DWORD PTR tv1668[esp+100]

; 485  : 			VYFullF += VPitch;

	add	ebp, DWORD PTR tv1668[esp+100]

; 486  : 			MaskB += VPitch;

	add	edi, DWORD PTR _VPitch$[esp+96]

; 487  : 			MaskF += VPitch;

	add	eax, DWORD PTR _VPitch$[esp+96]
	sub	DWORD PTR _height$2$[esp+100], 1
	mov	DWORD PTR _pdst$1$[esp+100], edx
	mov	DWORD PTR _prefB8$[esp+96], ebx
	mov	DWORD PTR _VXFullF$2$[esp+100], ecx
	mov	DWORD PTR _VYFullF$1$[esp+100], ebp
	mov	DWORD PTR _MaskB$2$[esp+100], edi
	mov	DWORD PTR _MaskF$2$[esp+100], eax
	jne	$LL10@FlowInterS
$LN9@FlowInterS:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 488  : 		}
; 489  : 	}
; 490  : }

	add	esp, 84					; 00000054H
	ret	0
??$FlowInterSimple_Pel1@G@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInterSimple_Pel1<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterSimple_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
_pdst$1$ = -72						; size = 4
_VXFullF$1$ = -68					; size = 4
_MaskB$2$ = -68						; size = 4
_VYFullB$1$ = -64					; size = 4
_MaskF$2$ = -64						; size = 4
_w$1$ = -60						; size = 4
_height$1$ = -60					; size = 4
tv1415 = -56						; size = 4
tv1407 = -56						; size = 4
tv1410 = -52						; size = 4
_VXFullF$2$ = -52					; size = 4
tv1413 = -48						; size = 4
_VYFullF$1$ = -48					; size = 4
tv1411 = -44						; size = 4
_height$2$ = -44					; size = 4
tv1419 = -40						; size = 4
tv1403 = -40						; size = 4
tv1412 = -36						; size = 4
tv1401 = -36						; size = 4
tv1416 = -32						; size = 4
tv1414 = -32						; size = 4
tv1420 = -28						; size = 4
tv1418 = -28						; size = 4
tv1430 = -24						; size = 4
tv1404 = -24						; size = 4
tv1426 = -20						; size = 4
tv1402 = -20						; size = 4
tv1406 = -16						; size = 4
tv1417 = -12						; size = 4
tv1429 = -8						; size = 4
tv1425 = -4						; size = 4
tv1409 = 8						; size = 4
_MaskF$1$ = 8						; size = 4
_prefB8$ = 8						; size = 4
tv1423 = 12						; size = 4
_MaskB$1$ = 12						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
tv1422 = 56						; size = 4
_time256$ = 56						; size = 4
??$FlowInterSimple_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInterSimple_NPel<unsigned short,1>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 314  : {

	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp

; 315  :   dst_pitch /= sizeof(pixel_t);
; 316  :   ref_pitch /= sizeof(pixel_t);
; 317  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 318  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);

	mov	ebp, DWORD PTR _prefB8$[esp+76]
	mov	eax, ecx

; 319  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 320  : 
; 321  : 	if (time256 == 128 /*t256_provider.is_half ()*/) // special case double fps - fastest
; 322  : 	{
; 323  : 		for (int h=0; h<height; h++)

	mov	ecx, DWORD PTR _height$[esp+76]
	push	esi
	push	edi
	mov	edi, DWORD PTR _ref_pitch$[esp+84]
	shr	edi, 1
	shr	edx, 1
	cmp	DWORD PTR _time256$[esp+84], 128	; 00000080H
	mov	DWORD PTR _pdst$1$[esp+88], eax
	mov	DWORD PTR _ref_pitch$[esp+84], edi
	jne	$LN14@FlowInterS
	mov	DWORD PTR _height$1$[esp+88], ecx
	test	ecx, ecx
	jle	$LN9@FlowInterS
	mov	esi, DWORD PTR _VYFullB$[esp+84]
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _MaskB$[esp+84]
	mov	DWORD PTR tv1430[esp+88], ecx
	mov	ecx, DWORD PTR _VPitch$[esp+84]
	add	ecx, ecx
	mov	DWORD PTR _VYFullB$1$[esp+88], esi
	mov	DWORD PTR tv1426[esp+88], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+84]
	sub	ecx, ebp
	mov	DWORD PTR _MaskB$1$[esp+84], edx
	mov	edx, DWORD PTR _VXFullF$[esp+84]
	mov	DWORD PTR tv1415[esp+88], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+84]
	sub	ecx, esi
	mov	DWORD PTR _VXFullF$1$[esp+88], edx
	mov	DWORD PTR tv1413[esp+88], ecx
	mov	ecx, DWORD PTR _VYFullF$[esp+84]
	sub	ecx, esi
	mov	DWORD PTR tv1411[esp+88], ecx
	mov	ecx, DWORD PTR _MaskF$[esp+84]
	mov	DWORD PTR _MaskF$1$[esp+84], ecx
	npad	13
$LL4@FlowInterS:

; 324  : 		{
; 325  : 			for (int w=0; w<width; w+=1)

	xor	ebx, ebx
	cmp	DWORD PTR _width$[esp+84], ebx
	jle	$LN6@FlowInterS
	mov	DWORD PTR tv1422[esp+84], ecx
	mov	eax, edx
	mov	ecx, DWORD PTR tv1411[esp+88]
	sub	ecx, edx
	add	ecx, esi
	mov	DWORD PTR tv1410[esp+88], ecx
	mov	ecx, esi
	sub	ecx, edx
	mov	DWORD PTR tv1419[esp+88], ecx
	mov	ecx, DWORD PTR tv1413[esp+88]
	sub	ecx, edx
	add	ecx, esi
	mov	DWORD PTR tv1412[esp+88], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+88]
	sub	ecx, edx
	mov	DWORD PTR tv1418[esp+88], ecx
	mov	ecx, DWORD PTR _MaskB$1$[esp+84]
	sub	ecx, DWORD PTR _MaskF$1$[esp+84]
	mov	DWORD PTR tv1416[esp+88], ecx
	npad	2
$LL7@FlowInterS:

; 326  : 			{
; 327  : //				const int		time256 = t256_provider.get_t (w);
; 328  : 
; 329  : 				//int vxF = (VXFullF[w]-128)>>1;
; 330  : 				//int vyF = (VYFullF[w]-128)>>1;
; 331  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 332  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 333  :         //				int vxF = t256_provider.get_vect_f (time256, VXFullF[w]);
; 334  : //				int vyF = t256_provider.get_vect_f (time256, VYFullF[w]);
; 335  : 				int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 336  : 				int dstF = prefF[adrF];

	mov	ecx, DWORD PTR tv1410[esp+88]
	lea	esi, DWORD PTR [ebx+ebx]
	inc	ebx
	lea	eax, DWORD PTR [eax+2]
	movsx	edx, WORD PTR [ecx+eax-2]
	movsx	ecx, WORD PTR [eax-2]
	sar	edx, 1
	imul	edx, edi
	sar	ecx, 1
	add	edx, esi
	add	ecx, edx
	mov	edx, DWORD PTR tv1415[esp+88]
	lea	ecx, DWORD PTR [edx+ecx*2]
	movzx	edi, WORD PTR [ecx+ebp]

; 337  : 				//int vxB = (VXFullB[w]-128)>>1;
; 338  : 				//int vyB = (VYFullB[w]-128)>>1;
; 339  :         int vxB = (VXFullB[w]) >> 1; // 2.5.11.22
; 340  :         int vyB = (VYFullB[w]) >> 1; // 2.5.11.22
; 341  :         //				int vxB = t256_provider.get_vect_b (time256, VXFullB[w]);
; 342  : //				int vyB = t256_provider.get_vect_b (time256, VYFullB[w]);
; 343  : 				int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 344  : 				int dstB = prefB[adrB];

	mov	ecx, DWORD PTR tv1419[esp+88]
	movsx	edx, WORD PTR [ecx+eax-2]
	mov	ecx, DWORD PTR tv1412[esp+88]
	sar	edx, 1
	imul	edx, DWORD PTR _ref_pitch$[esp+84]
	movsx	ecx, WORD PTR [ecx+eax-2]
	sar	ecx, 1
	add	edx, esi

; 345  : 				pdst[w] = ( ((dstF + dstB)<<8) + (dstB - dstF)*(MaskF[w] - MaskB[w]) )>>9;

	mov	esi, DWORD PTR tv1422[esp+84]
	add	ecx, edx
	inc	DWORD PTR tv1422[esp+84]
	movzx	edx, WORD PTR [ebp+ecx*2]
	mov	ecx, DWORD PTR tv1416[esp+88]
	movzx	ecx, BYTE PTR [ecx+esi]
	movzx	esi, BYTE PTR [esi]
	sub	esi, ecx
	mov	ecx, edx
	sub	ecx, edi
	imul	esi, ecx
	lea	ecx, DWORD PTR [edx+edi]
	mov	edi, DWORD PTR _ref_pitch$[esp+84]
	shl	ecx, 8
	add	esi, ecx
	mov	ecx, DWORD PTR tv1418[esp+88]
	sar	esi, 9
	mov	WORD PTR [ecx+eax-2], si
	cmp	ebx, DWORD PTR _width$[esp+84]
	jl	$LL7@FlowInterS
	mov	edx, DWORD PTR _VXFullF$1$[esp+88]
	mov	esi, DWORD PTR _VYFullB$1$[esp+88]
	mov	eax, DWORD PTR _pdst$1$[esp+88]
	mov	ecx, DWORD PTR _MaskF$1$[esp+84]
$LN6@FlowInterS:

; 346  : 			}
; 347  : 			pdst += dst_pitch;

	add	eax, DWORD PTR tv1430[esp+88]

; 348  : 			prefB += ref_pitch<<NPELL2;

	lea	ebx, DWORD PTR [edi*4]

; 349  : 			prefF += ref_pitch<<NPELL2;
; 350  : //			t256_provider.jump_to_next_row ();
; 351  : 			VXFullB += VPitch;
; 352  : 			VYFullB += VPitch;

	add	esi, DWORD PTR tv1426[esp+88]
	add	ebp, ebx

; 353  : 			VXFullF += VPitch;
; 354  : 			VYFullF += VPitch;
; 355  : 			MaskB += VPitch;

	mov	ebx, DWORD PTR _VPitch$[esp+84]

; 356  : 			MaskF += VPitch;

	add	ecx, ebx
	add	edx, DWORD PTR tv1426[esp+88]
	add	DWORD PTR _MaskB$1$[esp+84], ebx
	sub	DWORD PTR _height$1$[esp+88], 1
	mov	DWORD PTR _pdst$1$[esp+88], eax
	mov	DWORD PTR _VYFullB$1$[esp+88], esi
	mov	DWORD PTR _VXFullF$1$[esp+88], edx
	mov	DWORD PTR _MaskF$1$[esp+84], ecx
	jne	$LL4@FlowInterS
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 72					; 00000048H
	ret	0
$LN14@FlowInterS:

; 357  : 		}
; 358  : 	}
; 359  : 
; 360  : 	else // general case
; 361  : 	{
; 362  : 		for (int h=0; h<height; h++)

	mov	DWORD PTR _height$2$[esp+88], ecx
	test	ecx, ecx
	jle	$LN9@FlowInterS
	mov	esi, DWORD PTR _MaskB$[esp+84]
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _VYFullF$[esp+84]
	mov	DWORD PTR tv1429[esp+88], ecx
	mov	ecx, DWORD PTR _VPitch$[esp+84]
	add	ecx, ecx
	mov	DWORD PTR _VYFullF$1$[esp+88], edx
	mov	DWORD PTR tv1425[esp+88], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+84]
	sub	ecx, ebp
	mov	DWORD PTR _MaskB$2$[esp+88], esi
	mov	DWORD PTR tv1414[esp+88], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+84]
	sub	ecx, edx
	mov	DWORD PTR tv1404[esp+88], ecx
	mov	ecx, DWORD PTR _VYFullB$[esp+84]
	sub	ecx, edx
	mov	DWORD PTR tv1402[esp+88], ecx
	mov	ecx, DWORD PTR _MaskF$[esp+84]
	mov	DWORD PTR _MaskF$2$[esp+88], ecx
	mov	ecx, DWORD PTR _VXFullF$[esp+84]
	mov	DWORD PTR _VXFullF$2$[esp+88], ecx
	npad	8
$LL10@FlowInterS:

; 363  : 		{
; 364  : 			for (int w=0; w<width; w+=1)

	xor	ebx, ebx
	mov	DWORD PTR _w$1$[esp+88], ebx
	cmp	DWORD PTR _width$[esp+84], ebx
	jle	$LN12@FlowInterS
	mov	eax, 256				; 00000100H
	mov	DWORD PTR tv1409[esp+84], esi
	sub	eax, DWORD PTR _time256$[esp+84]
	mov	esi, ecx
	mov	DWORD PTR tv1423[esp+84], eax
	mov	eax, edx
	sub	eax, ecx
	mov	DWORD PTR tv1407[esp+88], esi
	mov	DWORD PTR tv1420[esp+88], eax
	mov	eax, DWORD PTR tv1402[esp+88]
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR tv1401[esp+88], eax
	mov	eax, DWORD PTR tv1404[esp+88]
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR tv1403[esp+88], eax
	mov	eax, DWORD PTR _pdst$1$[esp+88]
	sub	eax, ecx
	mov	DWORD PTR tv1417[esp+88], eax
	mov	eax, DWORD PTR _MaskF$2$[esp+88]
	sub	eax, DWORD PTR _MaskB$2$[esp+88]
	mov	DWORD PTR tv1406[esp+88], eax
$LL13@FlowInterS:

; 365  : 			{
; 366  : 				//const int		time256 = t256_provider.get_t (w);
; 367  : 
; 368  : //				int vxF = ((VXFullF[w]-128)*time256)/256;
; 369  : //				int vyF = ((VYFullF[w]-128)*time256)/256;
; 370  : 				//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 371  : 				//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 372  :         int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 373  :         int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1420[esp+88]
	lea	edx, DWORD PTR [ebx+ebx]
	movsx	ecx, WORD PTR [eax+esi]
	imul	ecx, DWORD PTR _time256$[esp+84]
	movsx	eax, WORD PTR [esi]
	imul	eax, DWORD PTR _time256$[esp+84]
	sar	ecx, 8

; 374  :         int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 375  : 				int dstF = prefF[adrF];

	imul	ecx, edi
	sar	eax, 8
	add	ecx, edx
	add	eax, ecx
	mov	ecx, DWORD PTR tv1414[esp+88]
	lea	eax, DWORD PTR [ecx+eax*2]
	movzx	ebx, WORD PTR [eax+ebp]

; 376  : 				//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 377  : 				//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 378  :         int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 379  :         int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1401[esp+88]
	movsx	ecx, WORD PTR [eax+esi]
	imul	ecx, DWORD PTR tv1423[esp+84]
	mov	eax, DWORD PTR tv1403[esp+88]
	movsx	eax, WORD PTR [eax+esi]
	imul	eax, DWORD PTR tv1423[esp+84]
	sar	ecx, 8

; 380  :         int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 381  : 				int dstB = prefB[adrB];

	imul	ecx, edi
	sar	eax, 8
	add	ecx, edx

; 382  : 				pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +

	mov	edx, 255				; 000000ffH
	add	eax, ecx
	mov	ecx, DWORD PTR tv1406[esp+88]
	movzx	edi, WORD PTR [ebp+eax*2]
	mov	eax, DWORD PTR tv1409[esp+84]
	inc	DWORD PTR tv1409[esp+84]
	movzx	esi, BYTE PTR [eax+ecx]
	movzx	ecx, BYTE PTR [eax]
	mov	eax, 255				; 000000ffH
	sub	eax, esi
	sub	edx, ecx
	imul	ecx, ebx
	imul	eax, ebx
	mov	ebx, DWORD PTR _w$1$[esp+88]
	imul	esi, edi
	inc	ebx
	imul	edx, edi
	mov	edi, DWORD PTR _ref_pitch$[esp+84]
	add	ecx, 255				; 000000ffH
	mov	DWORD PTR _w$1$[esp+88], ebx
	add	esi, 255				; 000000ffH
	add	eax, esi
	add	ecx, edx
	mov	esi, DWORD PTR tv1407[esp+88]
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[esp+84]
	sar	eax, 8
	imul	eax, DWORD PTR tv1423[esp+84]
	add	ecx, eax
	mov	eax, DWORD PTR tv1417[esp+88]
	sar	ecx, 8
	mov	WORD PTR [eax+esi], cx
	add	esi, 2
	mov	DWORD PTR tv1407[esp+88], esi
	cmp	ebx, DWORD PTR _width$[esp+84]
	jl	$LL13@FlowInterS
	mov	ecx, DWORD PTR _VXFullF$2$[esp+88]
	mov	eax, DWORD PTR _pdst$1$[esp+88]
	mov	edx, DWORD PTR _VYFullF$1$[esp+88]
	mov	esi, DWORD PTR _MaskB$2$[esp+88]
$LN12@FlowInterS:

; 383  : 				            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*     time256   )>>8;
; 384  : 			}
; 385  : 			pdst += dst_pitch;

	add	eax, DWORD PTR tv1429[esp+88]

; 386  : 			prefB += ref_pitch<<NPELL2;

	lea	ebx, DWORD PTR [edi*4]

; 387  : 			prefF += ref_pitch<<NPELL2;
; 388  : 			//t256_provider.jump_to_next_row ();
; 389  : 			VXFullB += VPitch;
; 390  : 			VYFullB += VPitch;
; 391  : 			VXFullF += VPitch;

	add	ecx, DWORD PTR tv1425[esp+88]
	add	ebp, ebx

; 392  : 			VYFullF += VPitch;
; 393  : 			MaskB += VPitch;

	mov	ebx, DWORD PTR _VPitch$[esp+84]
	add	esi, ebx
	add	edx, DWORD PTR tv1425[esp+88]

; 394  : 			MaskF += VPitch;

	add	DWORD PTR _MaskF$2$[esp+88], ebx
	sub	DWORD PTR _height$2$[esp+88], 1
	mov	DWORD PTR _pdst$1$[esp+88], eax
	mov	DWORD PTR _VXFullF$2$[esp+88], ecx
	mov	DWORD PTR _VYFullF$1$[esp+88], edx
	mov	DWORD PTR _MaskB$2$[esp+88], esi
	jne	$LL10@FlowInterS
$LN9@FlowInterS:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 72					; 00000048H
	ret	0
??$FlowInterSimple_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInterSimple_NPel<unsigned short,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterSimple_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
_pdst$1$ = -72						; size = 4
_VXFullF$1$ = -68					; size = 4
_MaskB$2$ = -68						; size = 4
_VYFullB$1$ = -64					; size = 4
_MaskF$2$ = -64						; size = 4
_w$1$ = -60						; size = 4
_height$1$ = -60					; size = 4
tv1413 = -56						; size = 4
tv1405 = -56						; size = 4
tv1408 = -52						; size = 4
_VXFullF$2$ = -52					; size = 4
tv1411 = -48						; size = 4
_VYFullF$1$ = -48					; size = 4
tv1409 = -44						; size = 4
_height$2$ = -44					; size = 4
tv1417 = -40						; size = 4
tv1397 = -40						; size = 4
tv1410 = -36						; size = 4
tv1395 = -36						; size = 4
tv1414 = -32						; size = 4
tv1412 = -32						; size = 4
tv1418 = -28						; size = 4
tv1416 = -28						; size = 4
tv1428 = -24						; size = 4
tv1399 = -24						; size = 4
tv1424 = -20						; size = 4
tv1396 = -20						; size = 4
tv1403 = -16						; size = 4
tv1415 = -12						; size = 4
tv1427 = -8						; size = 4
tv1423 = -4						; size = 4
tv1407 = 8						; size = 4
_MaskF$1$ = 8						; size = 4
_prefB8$ = 8						; size = 4
tv1421 = 12						; size = 4
_MaskB$1$ = 12						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
tv1420 = 56						; size = 4
_time256$ = 56						; size = 4
??$FlowInterSimple_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInterSimple_NPel<unsigned short,2>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 314  : {

	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp

; 315  :   dst_pitch /= sizeof(pixel_t);
; 316  :   ref_pitch /= sizeof(pixel_t);
; 317  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 318  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);

	mov	ebp, DWORD PTR _prefB8$[esp+76]
	mov	eax, ecx

; 319  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 320  : 
; 321  : 	if (time256 == 128 /*t256_provider.is_half ()*/) // special case double fps - fastest
; 322  : 	{
; 323  : 		for (int h=0; h<height; h++)

	mov	ecx, DWORD PTR _height$[esp+76]
	push	esi
	push	edi
	mov	edi, DWORD PTR _ref_pitch$[esp+84]
	shr	edi, 1
	shr	edx, 1
	cmp	DWORD PTR _time256$[esp+84], 128	; 00000080H
	mov	DWORD PTR _pdst$1$[esp+88], eax
	mov	DWORD PTR _ref_pitch$[esp+84], edi
	jne	$LN14@FlowInterS
	mov	DWORD PTR _height$1$[esp+88], ecx
	test	ecx, ecx
	jle	$LN9@FlowInterS
	mov	esi, DWORD PTR _VYFullB$[esp+84]
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _MaskB$[esp+84]
	mov	DWORD PTR tv1428[esp+88], ecx
	mov	ecx, DWORD PTR _VPitch$[esp+84]
	add	ecx, ecx
	mov	DWORD PTR _VYFullB$1$[esp+88], esi
	mov	DWORD PTR tv1424[esp+88], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+84]
	sub	ecx, ebp
	mov	DWORD PTR _MaskB$1$[esp+84], edx
	mov	edx, DWORD PTR _VXFullF$[esp+84]
	mov	DWORD PTR tv1413[esp+88], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+84]
	sub	ecx, esi
	mov	DWORD PTR _VXFullF$1$[esp+88], edx
	mov	DWORD PTR tv1411[esp+88], ecx
	mov	ecx, DWORD PTR _VYFullF$[esp+84]
	sub	ecx, esi
	mov	DWORD PTR tv1409[esp+88], ecx
	mov	ecx, DWORD PTR _MaskF$[esp+84]
	mov	DWORD PTR _MaskF$1$[esp+84], ecx
	npad	13
$LL4@FlowInterS:

; 324  : 		{
; 325  : 			for (int w=0; w<width; w+=1)

	xor	ebx, ebx
	cmp	DWORD PTR _width$[esp+84], ebx
	jle	$LN6@FlowInterS
	mov	DWORD PTR tv1420[esp+84], ecx
	mov	eax, edx
	mov	ecx, DWORD PTR tv1409[esp+88]
	sub	ecx, edx
	add	ecx, esi
	mov	DWORD PTR tv1408[esp+88], ecx
	mov	ecx, esi
	sub	ecx, edx
	mov	DWORD PTR tv1417[esp+88], ecx
	mov	ecx, DWORD PTR tv1411[esp+88]
	sub	ecx, edx
	add	ecx, esi
	mov	DWORD PTR tv1410[esp+88], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+88]
	sub	ecx, edx
	mov	DWORD PTR tv1416[esp+88], ecx
	mov	ecx, DWORD PTR _MaskB$1$[esp+84]
	sub	ecx, DWORD PTR _MaskF$1$[esp+84]
	mov	DWORD PTR tv1414[esp+88], ecx
	npad	2
$LL7@FlowInterS:

; 326  : 			{
; 327  : //				const int		time256 = t256_provider.get_t (w);
; 328  : 
; 329  : 				//int vxF = (VXFullF[w]-128)>>1;
; 330  : 				//int vyF = (VYFullF[w]-128)>>1;
; 331  :         int vxF = (VXFullF[w]) >> 1; // 2.5.11.22
; 332  :         int vyF = (VYFullF[w]) >> 1; // 2.5.11.22
; 333  :         //				int vxF = t256_provider.get_vect_f (time256, VXFullF[w]);
; 334  : //				int vyF = t256_provider.get_vect_f (time256, VYFullF[w]);
; 335  : 				int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 336  : 				int dstF = prefF[adrF];

	mov	ecx, DWORD PTR tv1408[esp+88]
	lea	esi, DWORD PTR [ebx*4]
	inc	ebx
	lea	eax, DWORD PTR [eax+2]
	movsx	edx, WORD PTR [ecx+eax-2]
	movsx	ecx, WORD PTR [eax-2]
	sar	edx, 1
	imul	edx, edi
	sar	ecx, 1
	add	edx, esi
	add	ecx, edx
	mov	edx, DWORD PTR tv1413[esp+88]
	lea	ecx, DWORD PTR [edx+ecx*2]
	movzx	edi, WORD PTR [ecx+ebp]

; 337  : 				//int vxB = (VXFullB[w]-128)>>1;
; 338  : 				//int vyB = (VYFullB[w]-128)>>1;
; 339  :         int vxB = (VXFullB[w]) >> 1; // 2.5.11.22
; 340  :         int vyB = (VYFullB[w]) >> 1; // 2.5.11.22
; 341  :         //				int vxB = t256_provider.get_vect_b (time256, VXFullB[w]);
; 342  : //				int vyB = t256_provider.get_vect_b (time256, VYFullB[w]);
; 343  : 				int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 344  : 				int dstB = prefB[adrB];

	mov	ecx, DWORD PTR tv1417[esp+88]
	movsx	edx, WORD PTR [ecx+eax-2]
	mov	ecx, DWORD PTR tv1410[esp+88]
	sar	edx, 1
	imul	edx, DWORD PTR _ref_pitch$[esp+84]
	movsx	ecx, WORD PTR [ecx+eax-2]
	sar	ecx, 1
	add	edx, esi

; 345  : 				pdst[w] = ( ((dstF + dstB)<<8) + (dstB - dstF)*(MaskF[w] - MaskB[w]) )>>9;

	mov	esi, DWORD PTR tv1420[esp+84]
	add	ecx, edx
	inc	DWORD PTR tv1420[esp+84]
	movzx	edx, WORD PTR [ebp+ecx*2]
	mov	ecx, DWORD PTR tv1414[esp+88]
	movzx	ecx, BYTE PTR [ecx+esi]
	movzx	esi, BYTE PTR [esi]
	sub	esi, ecx
	mov	ecx, edx
	sub	ecx, edi
	imul	esi, ecx
	lea	ecx, DWORD PTR [edx+edi]
	mov	edi, DWORD PTR _ref_pitch$[esp+84]
	shl	ecx, 8
	add	esi, ecx
	mov	ecx, DWORD PTR tv1416[esp+88]
	sar	esi, 9
	mov	WORD PTR [ecx+eax-2], si
	cmp	ebx, DWORD PTR _width$[esp+84]
	jl	$LL7@FlowInterS
	mov	edx, DWORD PTR _VXFullF$1$[esp+88]
	mov	esi, DWORD PTR _VYFullB$1$[esp+88]
	mov	eax, DWORD PTR _pdst$1$[esp+88]
	mov	ecx, DWORD PTR _MaskF$1$[esp+84]
$LN6@FlowInterS:

; 346  : 			}
; 347  : 			pdst += dst_pitch;

	add	eax, DWORD PTR tv1428[esp+88]

; 348  : 			prefB += ref_pitch<<NPELL2;

	lea	ebx, DWORD PTR [edi*8]

; 349  : 			prefF += ref_pitch<<NPELL2;
; 350  : //			t256_provider.jump_to_next_row ();
; 351  : 			VXFullB += VPitch;
; 352  : 			VYFullB += VPitch;

	add	esi, DWORD PTR tv1424[esp+88]
	add	ebp, ebx

; 353  : 			VXFullF += VPitch;
; 354  : 			VYFullF += VPitch;
; 355  : 			MaskB += VPitch;

	mov	ebx, DWORD PTR _VPitch$[esp+84]

; 356  : 			MaskF += VPitch;

	add	ecx, ebx
	add	edx, DWORD PTR tv1424[esp+88]
	add	DWORD PTR _MaskB$1$[esp+84], ebx
	sub	DWORD PTR _height$1$[esp+88], 1
	mov	DWORD PTR _pdst$1$[esp+88], eax
	mov	DWORD PTR _VYFullB$1$[esp+88], esi
	mov	DWORD PTR _VXFullF$1$[esp+88], edx
	mov	DWORD PTR _MaskF$1$[esp+84], ecx
	jne	$LL4@FlowInterS
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 72					; 00000048H
	ret	0
$LN14@FlowInterS:

; 357  : 		}
; 358  : 	}
; 359  : 
; 360  : 	else // general case
; 361  : 	{
; 362  : 		for (int h=0; h<height; h++)

	mov	DWORD PTR _height$2$[esp+88], ecx
	test	ecx, ecx
	jle	$LN9@FlowInterS
	mov	esi, DWORD PTR _MaskB$[esp+84]
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _VYFullF$[esp+84]
	mov	DWORD PTR tv1427[esp+88], ecx
	mov	ecx, DWORD PTR _VPitch$[esp+84]
	add	ecx, ecx
	mov	DWORD PTR _VYFullF$1$[esp+88], edx
	mov	DWORD PTR tv1423[esp+88], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+84]
	sub	ecx, ebp
	mov	DWORD PTR _MaskB$2$[esp+88], esi
	mov	DWORD PTR tv1412[esp+88], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+84]
	sub	ecx, edx
	mov	DWORD PTR tv1399[esp+88], ecx
	mov	ecx, DWORD PTR _VYFullB$[esp+84]
	sub	ecx, edx
	mov	DWORD PTR tv1396[esp+88], ecx
	mov	ecx, DWORD PTR _MaskF$[esp+84]
	mov	DWORD PTR _MaskF$2$[esp+88], ecx
	mov	ecx, DWORD PTR _VXFullF$[esp+84]
	mov	DWORD PTR _VXFullF$2$[esp+88], ecx
	npad	4
$LL10@FlowInterS:

; 363  : 		{
; 364  : 			for (int w=0; w<width; w+=1)

	xor	ebx, ebx
	mov	DWORD PTR _w$1$[esp+88], ebx
	cmp	DWORD PTR _width$[esp+84], ebx
	jle	$LN12@FlowInterS
	mov	eax, 256				; 00000100H
	mov	DWORD PTR tv1407[esp+84], esi
	sub	eax, DWORD PTR _time256$[esp+84]
	mov	esi, ecx
	mov	DWORD PTR tv1421[esp+84], eax
	mov	eax, edx
	sub	eax, ecx
	mov	DWORD PTR tv1405[esp+88], esi
	mov	DWORD PTR tv1418[esp+88], eax
	mov	eax, DWORD PTR tv1396[esp+88]
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR tv1395[esp+88], eax
	mov	eax, DWORD PTR tv1399[esp+88]
	sub	eax, ecx
	add	eax, edx
	mov	DWORD PTR tv1397[esp+88], eax
	mov	eax, DWORD PTR _pdst$1$[esp+88]
	sub	eax, ecx
	mov	DWORD PTR tv1415[esp+88], eax
	mov	eax, DWORD PTR _MaskF$2$[esp+88]
	sub	eax, DWORD PTR _MaskB$2$[esp+88]
	mov	DWORD PTR tv1403[esp+88], eax
	npad	13
$LL13@FlowInterS:

; 365  : 			{
; 366  : 				//const int		time256 = t256_provider.get_t (w);
; 367  : 
; 368  : //				int vxF = ((VXFullF[w]-128)*time256)/256;
; 369  : //				int vyF = ((VYFullF[w]-128)*time256)/256;
; 370  : 				//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 371  : 				//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 372  :         int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 373  :         int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1418[esp+88]
	lea	edx, DWORD PTR [ebx*4]
	movsx	ecx, WORD PTR [eax+esi]
	imul	ecx, DWORD PTR _time256$[esp+84]
	movsx	eax, WORD PTR [esi]
	imul	eax, DWORD PTR _time256$[esp+84]
	sar	ecx, 8

; 374  :         int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 375  : 				int dstF = prefF[adrF];

	imul	ecx, edi
	sar	eax, 8
	add	ecx, edx
	add	eax, ecx
	mov	ecx, DWORD PTR tv1412[esp+88]
	lea	eax, DWORD PTR [ecx+eax*2]
	movzx	ebx, WORD PTR [eax+ebp]

; 376  : 				//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 377  : 				//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 378  :         int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 379  :         int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1395[esp+88]
	movsx	ecx, WORD PTR [eax+esi]
	imul	ecx, DWORD PTR tv1421[esp+84]
	mov	eax, DWORD PTR tv1397[esp+88]
	movsx	eax, WORD PTR [eax+esi]
	imul	eax, DWORD PTR tv1421[esp+84]
	sar	ecx, 8

; 380  :         int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 381  : 				int dstB = prefB[adrB];

	imul	ecx, edi
	sar	eax, 8
	add	ecx, edx

; 382  : 				pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +

	mov	edx, 255				; 000000ffH
	add	eax, ecx
	mov	ecx, DWORD PTR tv1403[esp+88]
	movzx	edi, WORD PTR [ebp+eax*2]
	mov	eax, DWORD PTR tv1407[esp+84]
	inc	DWORD PTR tv1407[esp+84]
	movzx	esi, BYTE PTR [eax+ecx]
	movzx	ecx, BYTE PTR [eax]
	mov	eax, 255				; 000000ffH
	sub	eax, esi
	sub	edx, ecx
	imul	ecx, ebx
	imul	eax, ebx
	mov	ebx, DWORD PTR _w$1$[esp+88]
	imul	esi, edi
	inc	ebx
	imul	edx, edi
	mov	edi, DWORD PTR _ref_pitch$[esp+84]
	add	ecx, 255				; 000000ffH
	mov	DWORD PTR _w$1$[esp+88], ebx
	add	esi, 255				; 000000ffH
	add	eax, esi
	add	ecx, edx
	mov	esi, DWORD PTR tv1405[esp+88]
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[esp+84]
	sar	eax, 8
	imul	eax, DWORD PTR tv1421[esp+84]
	add	ecx, eax
	mov	eax, DWORD PTR tv1415[esp+88]
	sar	ecx, 8
	mov	WORD PTR [eax+esi], cx
	add	esi, 2
	mov	DWORD PTR tv1405[esp+88], esi
	cmp	ebx, DWORD PTR _width$[esp+84]
	jl	$LL13@FlowInterS
	mov	ecx, DWORD PTR _VXFullF$2$[esp+88]
	mov	eax, DWORD PTR _pdst$1$[esp+88]
	mov	edx, DWORD PTR _VYFullF$1$[esp+88]
	mov	esi, DWORD PTR _MaskB$2$[esp+88]
$LN12@FlowInterS:

; 383  : 				            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*     time256   )>>8;
; 384  : 			}
; 385  : 			pdst += dst_pitch;

	add	eax, DWORD PTR tv1427[esp+88]

; 386  : 			prefB += ref_pitch<<NPELL2;

	lea	ebx, DWORD PTR [edi*8]

; 387  : 			prefF += ref_pitch<<NPELL2;
; 388  : 			//t256_provider.jump_to_next_row ();
; 389  : 			VXFullB += VPitch;
; 390  : 			VYFullB += VPitch;
; 391  : 			VXFullF += VPitch;

	add	ecx, DWORD PTR tv1423[esp+88]
	add	ebp, ebx

; 392  : 			VYFullF += VPitch;
; 393  : 			MaskB += VPitch;

	mov	ebx, DWORD PTR _VPitch$[esp+84]
	add	esi, ebx
	add	edx, DWORD PTR tv1423[esp+88]

; 394  : 			MaskF += VPitch;

	add	DWORD PTR _MaskF$2$[esp+88], ebx
	sub	DWORD PTR _height$2$[esp+88], 1
	mov	DWORD PTR _pdst$1$[esp+88], eax
	mov	DWORD PTR _VXFullF$2$[esp+88], ecx
	mov	DWORD PTR _VYFullF$1$[esp+88], edx
	mov	DWORD PTR _MaskB$2$[esp+88], esi
	jne	$LL10@FlowInterS
$LN9@FlowInterS:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 395  : 		}
; 396  : 	}
; 397  : }

	add	esp, 72					; 00000048H
	ret	0
??$FlowInterSimple_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInterSimple_NPel<unsigned short,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInter_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
tv1029 = -60						; size = 4
_pdst$1$ = -56						; size = 4
tv1031 = -52						; size = 4
tv1026 = -48						; size = 4
tv1030 = -44						; size = 4
tv1012 = -40						; size = 4
tv1025 = -36						; size = 4
tv1014 = -32						; size = 4
tv1024 = -28						; size = 4
tv1022 = -24						; size = 4
_dstF$1$ = -20						; size = 4
tv1016 = -16						; size = 4
tv1019 = -12						; size = 4
tv1021 = -8						; size = 4
_dst_pitch$1$ = -4					; size = 4
_w$1$ = 8						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
??$FlowInter_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInter_NPel<unsigned char,0>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 169  : {

	sub	esp, 60					; 0000003cH

; 170  :   dst_pitch /= sizeof(pixel_t);
; 171  :   ref_pitch /= sizeof(pixel_t);
; 172  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 173  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);

	mov	eax, DWORD PTR _prefB8$[esp+56]
	push	edi

; 174  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 175  : 
; 176  :   for (int h=0; h<height; h++)

	mov	edi, DWORD PTR _height$[esp+60]
	mov	DWORD PTR _dst_pitch$1$[esp+64], edx
	mov	DWORD PTR _pdst$1$[esp+64], ecx
	test	edi, edi
	jle	$LN3@FlowInter_
	mov	edx, DWORD PTR _VPitch$[esp+60]
	sub	DWORD PTR _prefF8$[esp+60], eax
	add	edx, edx
	push	ebx
	mov	ebx, DWORD PTR _VXFullF$[esp+64]
	push	ebp
	mov	ebp, DWORD PTR _VYFullB$[esp+68]
	sub	DWORD PTR _VXFullB$[esp+68], ebp
	sub	DWORD PTR _VYFullF$[esp+68], ebp
	push	esi
	mov	esi, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1030[esp+76], edx
	mov	edx, DWORD PTR _MaskF$[esp+72]
	npad	11
$LL4@FlowInter_:

; 177  : 	{
; 178  : 		for (int w=0; w<width; w++)

	cmp	DWORD PTR _width$[esp+72], 0
	mov	DWORD PTR _w$1$[esp+72], 0
	jle	$LN6@FlowInter_
	mov	ecx, 256				; 00000100H
	mov	DWORD PTR tv1029[esp+76], edx
	sub	ecx, DWORD PTR _time256$[esp+72]
	mov	edi, ebx
	mov	DWORD PTR tv1031[esp+76], ecx
	mov	ecx, DWORD PTR _VYFullF$[esp+72]
	sub	ecx, ebx
	mov	DWORD PTR tv1026[esp+76], edi
	add	ecx, ebp
	mov	DWORD PTR tv1012[esp+76], ecx
	mov	ecx, ebp
	sub	ecx, ebx
	mov	DWORD PTR tv1025[esp+76], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+72]
	sub	ecx, ebx
	mov	ebx, DWORD PTR _time256$[esp+72]
	add	ecx, ebp
	mov	ebp, DWORD PTR _w$1$[esp+72]
	mov	DWORD PTR tv1014[esp+76], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+72]
	add	ecx, eax
	sub	ecx, eax
	mov	DWORD PTR tv1016[esp+76], ecx
	mov	ecx, eax
	sub	ecx, edx
	mov	DWORD PTR tv1024[esp+76], ecx
	mov	ecx, DWORD PTR _MaskB$[esp+72]
	sub	ecx, edx
	mov	DWORD PTR tv1022[esp+76], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+76]
	sub	ecx, edx
	mov	DWORD PTR tv1021[esp+76], ecx
$LL7@FlowInter_:

; 179  : 		{
; 180  : 			// const int		time256 = t256_provider.get_t (w);
; 181  : 
; 182  : //			int vxF = ((VXFullF[w]-128)*time256)/256;
; 183  : //			int vyF = ((VYFullF[w]-128)*time256)/256;
; 184  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 185  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1012[esp+76]

; 186  :       //int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 187  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 188  : 			int dstF = prefF[vyF*ref_pitch + vxF + (w<<NPELL2)];
; 189  : 			int dstF0 = prefF[(w<<NPELL2)]; // zero

	mov	esi, DWORD PTR tv1029[esp+76]
	movsx	edx, WORD PTR [ecx+edi]
	movsx	ecx, WORD PTR [edi]
	imul	ecx, ebx
	imul	edx, ebx
	mov	ebx, DWORD PTR _prefF8$[esp+72]
	add	ebx, eax
	sar	ecx, 8
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	add	edx, ebx
	mov	ebx, DWORD PTR tv1024[esp+76]
	add	ecx, edx
	add	ebx, esi
	movzx	ecx, BYTE PTR [ecx+ebp]
	mov	DWORD PTR _dstF$1$[esp+76], ecx

; 190  : //			int vxB = ((VXFullB[w]-128)*(256-time256))/256;
; 191  : //			int vyB = ((VYFullB[w]-128)*(256-time256))/256;
; 192  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 193  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1025[esp+76]
	movsx	edx, WORD PTR [ecx+edi]
	imul	edx, DWORD PTR tv1031[esp+76]
	mov	ecx, DWORD PTR tv1014[esp+76]
	movsx	ecx, WORD PTR [ecx+edi]

; 194  :       
; 195  : //      int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 196  : //			int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 197  : 			int dstB = prefB[vyB*ref_pitch + vxB + (w<<NPELL2)];
; 198  : 			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 199  : 			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +

	mov	edi, 255				; 000000ffH
	imul	ecx, DWORD PTR tv1031[esp+76]
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, ebp
	add	ecx, edx
	mov	edx, DWORD PTR tv1022[esp+76]
	movzx	ebp, BYTE PTR [edx+esi]
	mov	edx, 255				; 000000ffH
	movzx	ecx, BYTE PTR [ecx+eax]
	sub	edx, ebp
	movzx	esi, BYTE PTR [esi]
	imul	edx, ecx
	sub	edi, esi
	mov	ecx, DWORD PTR tv1016[esp+76]
	imul	edi, DWORD PTR _dstF$1$[esp+76]
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, ebp
	mov	DWORD PTR tv1019[esp+76], edx
	add	ecx, edx
	lea	edx, DWORD PTR [edi+255]
	imul	ecx, esi
	add	ecx, 255				; 000000ffH
	sar	ecx, 8
	add	edx, ecx
	movzx	ecx, BYTE PTR [ebx]
	imul	ecx, esi
	mov	esi, DWORD PTR tv1019[esp+76]
	mov	ebx, DWORD PTR _time256$[esp+72]
	add	esi, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR tv1031[esp+76]
	add	ecx, edi
	mov	edi, DWORD PTR tv1026[esp+76]
	imul	ecx, ebp
	add	edi, 2
	mov	ebp, DWORD PTR _w$1$[esp+72]
	inc	ebp
	mov	DWORD PTR tv1026[esp+76], edi
	mov	DWORD PTR _w$1$[esp+72], ebp
	add	ecx, 255				; 000000ffH
	sar	ecx, 8
	add	ecx, esi
	mov	esi, DWORD PTR tv1029[esp+76]
	sar	ecx, 8
	imul	ecx, ebx
	add	edx, ecx
	mov	ecx, DWORD PTR tv1021[esp+76]
	sar	edx, 8
	mov	BYTE PTR [ecx+esi], dl
	inc	esi
	mov	DWORD PTR tv1029[esp+76], esi
	cmp	ebp, DWORD PTR _width$[esp+72]
	jl	$LL7@FlowInter_
	mov	edx, DWORD PTR _MaskF$[esp+72]
	mov	ebx, DWORD PTR _VXFullF$[esp+72]
	mov	ebp, DWORD PTR _VYFullB$[esp+72]
	mov	ecx, DWORD PTR _pdst$1$[esp+76]
	mov	esi, DWORD PTR _MaskB$[esp+72]
	mov	edi, DWORD PTR _height$[esp+72]
$LN6@FlowInter_:

; 200  : 			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*     time256   )>>8;
; 201  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +
; 202  : //			            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*time256 )>>8;
; 203  : 		}
; 204  : 		pdst += dst_pitch;

	add	ecx, DWORD PTR _dst_pitch$1$[esp+76]

; 205  : 		prefB += ref_pitch<<NPELL2;
; 206  : 		prefF += ref_pitch<<NPELL2;
; 207  : 		//t256_provider.jump_to_next_row ();
; 208  : 		VXFullB += VPitch;
; 209  : 		VYFullB += VPitch;

	add	ebp, DWORD PTR tv1030[esp+76]

; 210  : 		VXFullF += VPitch;

	add	ebx, DWORD PTR tv1030[esp+76]

; 211  : 		VYFullF += VPitch;
; 212  : 		MaskB += VPitch;

	add	esi, DWORD PTR _VPitch$[esp+72]

; 213  : 		MaskF += VPitch;

	add	edx, DWORD PTR _VPitch$[esp+72]
	add	eax, DWORD PTR _ref_pitch$[esp+72]
	sub	edi, 1
	mov	DWORD PTR _pdst$1$[esp+76], ecx
	mov	DWORD PTR _VYFullB$[esp+72], ebp
	mov	DWORD PTR _VXFullF$[esp+72], ebx
	mov	DWORD PTR _MaskB$[esp+72], esi
	mov	DWORD PTR _MaskF$[esp+72], edx
	mov	DWORD PTR _height$[esp+72], edi
	jne	$LL4@FlowInter_
	pop	esi
	pop	ebp
	pop	ebx
$LN3@FlowInter_:
	pop	edi

; 214  : 	}
; 215  : }

	add	esp, 60					; 0000003cH
	ret	0
??$FlowInter_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInter_NPel<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInter_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
tv1050 = -60						; size = 4
_pdst$1$ = -56						; size = 4
tv1053 = -52						; size = 4
_w$1$ = -48						; size = 4
_dstF$1$ = -44						; size = 4
tv1047 = -44						; size = 4
tv1034 = -40						; size = 4
tv1046 = -36						; size = 4
tv1036 = -32						; size = 4
tv1044 = -28						; size = 4
tv1045 = -24						; size = 4
tv1038 = -20						; size = 4
tv1043 = -16						; size = 4
tv1051 = -12						; size = 4
_dst_pitch$1$ = -8					; size = 4
tv1052 = -4						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
??$FlowInter_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z PROC	; FlowInter_NPel<unsigned char,1>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 169  : {

	sub	esp, 60					; 0000003cH

; 170  :   dst_pitch /= sizeof(pixel_t);
; 171  :   ref_pitch /= sizeof(pixel_t);
; 172  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 173  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 174  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 175  : 
; 176  :   for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+56], 0
	mov	DWORD PTR _dst_pitch$1$[esp+60], edx
	mov	DWORD PTR _pdst$1$[esp+60], ecx
	jle	$LN3@FlowInter_
	mov	eax, DWORD PTR _ref_pitch$[esp+56]
	mov	edx, DWORD PTR _VYFullB$[esp+56]
	add	eax, eax
	sub	DWORD PTR _VXFullB$[esp+56], edx
	push	ebx
	mov	ebx, DWORD PTR _prefB8$[esp+60]
	sub	DWORD PTR _prefF8$[esp+60], ebx
	sub	DWORD PTR _VYFullF$[esp+60], edx
	push	ebp
	mov	ebp, DWORD PTR _MaskB$[esp+64]
	mov	DWORD PTR tv1052[esp+68], eax
	mov	eax, DWORD PTR _VPitch$[esp+64]
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _VXFullF$[esp+72]
	mov	DWORD PTR tv1051[esp+76], edi
	npad	5
$LL4@FlowInter_:

; 177  : 	{
; 178  : 		for (int w=0; w<width; w++)

	xor	esi, esi
	mov	DWORD PTR _w$1$[esp+76], esi
	cmp	DWORD PTR _width$[esp+72], esi
	jle	$LN6@FlowInter_
	mov	ecx, DWORD PTR _VYFullF$[esp+72]
	mov	edi, 256				; 00000100H
	sub	ecx, eax
	sub	edi, DWORD PTR _time256$[esp+72]
	add	ecx, edx
	mov	DWORD PTR tv1047[esp+76], eax
	mov	DWORD PTR tv1034[esp+76], ecx
	mov	ecx, edx
	sub	ecx, eax
	mov	DWORD PTR tv1053[esp+76], edi
	mov	DWORD PTR tv1046[esp+76], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+72]
	sub	ecx, eax
	mov	DWORD PTR tv1050[esp+76], ebp
	add	ecx, edx
	mov	DWORD PTR tv1036[esp+76], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+72]
	add	ecx, ebx
	sub	ecx, eax
	mov	DWORD PTR tv1038[esp+76], ecx
	mov	ecx, ebx
	sub	ecx, eax
	mov	eax, DWORD PTR _MaskF$[esp+72]
	sub	eax, ebp
	mov	DWORD PTR tv1045[esp+76], ecx
	mov	DWORD PTR tv1044[esp+76], eax
	mov	eax, DWORD PTR _pdst$1$[esp+76]
	sub	eax, ebp
	mov	DWORD PTR tv1043[esp+76], eax
	mov	eax, DWORD PTR tv1047[esp+76]
$LL7@FlowInter_:

; 179  : 		{
; 180  : 			// const int		time256 = t256_provider.get_t (w);
; 181  : 
; 182  : //			int vxF = ((VXFullF[w]-128)*time256)/256;
; 183  : //			int vyF = ((VYFullF[w]-128)*time256)/256;
; 184  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 185  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1034[esp+76]
	lea	eax, DWORD PTR [eax+2]

; 186  :       //int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 187  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 188  : 			int dstF = prefF[vyF*ref_pitch + vxF + (w<<NPELL2)];

	mov	ebp, DWORD PTR _prefF8$[esp+72]
	add	esi, esi
	add	ebp, ebx

; 189  : 			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 190  : //			int vxB = ((VXFullB[w]-128)*(256-time256))/256;
; 191  : //			int vyB = ((VYFullB[w]-128)*(256-time256))/256;
; 192  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 193  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 194  :       
; 195  : //      int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 196  : //			int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 197  : 			int dstB = prefB[vyB*ref_pitch + vxB + (w<<NPELL2)];
; 198  : 			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 199  : 			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +

	mov	edi, 255				; 000000ffH
	movsx	edx, WORD PTR [ecx+eax-2]
	imul	edx, DWORD PTR _time256$[esp+72]
	movsx	ecx, WORD PTR [eax-2]
	imul	ecx, DWORD PTR _time256$[esp+72]
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, ebp
	mov	ebp, 255				; 000000ffH
	add	ecx, edx
	movzx	ecx, BYTE PTR [ecx+esi]
	mov	DWORD PTR _dstF$1$[esp+76], ecx
	mov	ecx, DWORD PTR tv1046[esp+76]
	movsx	edx, WORD PTR [ecx+eax-2]
	imul	edx, DWORD PTR tv1053[esp+76]
	mov	ecx, DWORD PTR tv1036[esp+76]
	movsx	ecx, WORD PTR [ecx+eax-2]
	imul	ecx, DWORD PTR tv1053[esp+76]
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, esi
	add	ecx, edx
	mov	edx, DWORD PTR tv1050[esp+76]
	movzx	ecx, BYTE PTR [ecx+ebx]
	movzx	ebx, BYTE PTR [edx]
	sub	ebp, ebx
	imul	ebp, ecx
	mov	ecx, DWORD PTR tv1044[esp+76]
	movzx	esi, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR tv1045[esp+76]
	sub	edi, esi
	imul	edi, DWORD PTR _dstF$1$[esp+76]
	movzx	edx, BYTE PTR [ecx+eax-2]
	mov	ecx, DWORD PTR tv1038[esp+76]
	imul	edx, esi
	movzx	ecx, BYTE PTR [ecx+eax-2]
	imul	ecx, ebx
	add	edx, edi
	imul	edx, ebx
	mov	ebx, DWORD PTR tv1043[esp+76]
	add	ecx, ebp
	imul	ecx, esi
	mov	esi, DWORD PTR _w$1$[esp+76]
	add	edx, 255				; 000000ffH
	sar	edx, 8
	inc	esi
	add	edx, 255				; 000000ffH
	mov	DWORD PTR _w$1$[esp+76], esi
	add	edx, ebp
	add	ecx, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR _time256$[esp+72]
	sar	ecx, 8
	add	ecx, 255				; 000000ffH
	add	ecx, edi
	sar	ecx, 8
	imul	ecx, DWORD PTR tv1053[esp+76]
	add	edx, ecx
	mov	ecx, DWORD PTR tv1050[esp+76]
	sar	edx, 8
	mov	BYTE PTR [ebx+ecx], dl
	inc	ecx
	mov	ebx, DWORD PTR _prefB8$[esp+72]
	mov	DWORD PTR tv1050[esp+76], ecx
	cmp	esi, DWORD PTR _width$[esp+72]
	jl	$LL7@FlowInter_
	mov	eax, DWORD PTR _VXFullF$[esp+72]
	mov	edx, DWORD PTR _VYFullB$[esp+72]
	mov	ebp, DWORD PTR _MaskB$[esp+72]
	mov	ecx, DWORD PTR _pdst$1$[esp+76]
	mov	edi, DWORD PTR tv1051[esp+76]
$LN6@FlowInter_:

; 200  : 			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*     time256   )>>8;
; 201  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +
; 202  : //			            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*time256 )>>8;
; 203  : 		}
; 204  : 		pdst += dst_pitch;
; 205  : 		prefB += ref_pitch<<NPELL2;
; 206  : 		prefF += ref_pitch<<NPELL2;
; 207  : 		//t256_provider.jump_to_next_row ();
; 208  : 		VXFullB += VPitch;
; 209  : 		VYFullB += VPitch;
; 210  : 		VXFullF += VPitch;
; 211  : 		VYFullF += VPitch;
; 212  : 		MaskB += VPitch;

	mov	esi, DWORD PTR _VPitch$[esp+72]
	add	edx, edi
	add	ecx, DWORD PTR _dst_pitch$1$[esp+76]
	add	eax, edi
	add	ebx, DWORD PTR tv1052[esp+76]
	add	ebp, esi

; 213  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+72], esi
	sub	DWORD PTR _height$[esp+72], 1
	mov	DWORD PTR _pdst$1$[esp+76], ecx
	mov	DWORD PTR _prefB8$[esp+72], ebx
	mov	DWORD PTR _VYFullB$[esp+72], edx
	mov	DWORD PTR _VXFullF$[esp+72], eax
	mov	DWORD PTR _MaskB$[esp+72], ebp
	jne	$LL4@FlowInter_
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@FlowInter_:

; 214  : 	}
; 215  : }

	add	esp, 60					; 0000003cH
	ret	0
??$FlowInter_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP	; FlowInter_NPel<unsigned char,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInter_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
tv1079 = -60						; size = 4
tv1083 = -56						; size = 4
_pdst$1$ = -52						; size = 4
tv1076 = -48						; size = 4
tv1080 = -44						; size = 4
tv1064 = -40						; size = 4
tv1075 = -36						; size = 4
tv1066 = -32						; size = 4
tv1074 = -28						; size = 4
_dstF$1$ = -24						; size = 4
tv1068 = -20						; size = 4
tv1077 = -16						; size = 4
tv1073 = -12						; size = 4
_dst_pitch$1$ = -8					; size = 4
tv1081 = -4						; size = 4
_w$1$ = 8						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
??$FlowInter_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z PROC	; FlowInter_NPel<unsigned char,2>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 169  : {

	sub	esp, 60					; 0000003cH

; 170  :   dst_pitch /= sizeof(pixel_t);
; 171  :   ref_pitch /= sizeof(pixel_t);
; 172  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 173  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);

	mov	eax, DWORD PTR _prefB8$[esp+56]
	push	edi

; 174  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 175  : 
; 176  :   for (int h=0; h<height; h++)

	mov	edi, DWORD PTR _height$[esp+60]
	mov	DWORD PTR _dst_pitch$1$[esp+64], edx
	mov	DWORD PTR _pdst$1$[esp+64], ecx
	test	edi, edi
	jle	$LN3@FlowInter_
	mov	edx, DWORD PTR _ref_pitch$[esp+60]
	sub	DWORD PTR _prefF8$[esp+60], eax
	shl	edx, 2
	mov	DWORD PTR tv1081[esp+64], edx
	mov	edx, DWORD PTR _VPitch$[esp+60]
	push	ebx
	mov	ebx, DWORD PTR _VYFullB$[esp+64]
	add	edx, edx
	sub	DWORD PTR _VXFullB$[esp+64], ebx
	sub	DWORD PTR _VYFullF$[esp+64], ebx
	push	ebp
	mov	ebp, DWORD PTR _MaskF$[esp+68]
	push	esi
	mov	esi, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1080[esp+76], edx
	mov	edx, DWORD PTR _VXFullF$[esp+72]
$LL4@FlowInter_:

; 177  : 	{
; 178  : 		for (int w=0; w<width; w++)

	cmp	DWORD PTR _width$[esp+72], 0
	mov	DWORD PTR _w$1$[esp+72], 0
	jle	$LN6@FlowInter_
	mov	ecx, DWORD PTR _VYFullF$[esp+72]
	mov	edi, 256				; 00000100H
	sub	ecx, edx
	sub	edi, DWORD PTR _time256$[esp+72]
	add	ecx, ebx
	mov	DWORD PTR tv1083[esp+76], edi
	mov	DWORD PTR tv1064[esp+76], ecx
	mov	ebp, edx
	mov	ecx, ebx
	mov	DWORD PTR tv1079[esp+76], esi
	sub	ecx, edx
	mov	DWORD PTR tv1076[esp+76], ebp
	mov	DWORD PTR tv1075[esp+76], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+72]
	sub	ecx, edx
	mov	edx, DWORD PTR _w$1$[esp+72]
	add	ecx, ebx
	mov	DWORD PTR tv1066[esp+76], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+72]
	add	ecx, eax
	sub	ecx, eax
	mov	DWORD PTR tv1068[esp+76], ecx
	mov	ecx, DWORD PTR _MaskF$[esp+72]
	sub	ecx, esi
	mov	DWORD PTR tv1074[esp+76], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+76]
	sub	ecx, esi
	mov	DWORD PTR tv1073[esp+76], ecx
$LL7@FlowInter_:

; 179  : 		{
; 180  : 			// const int		time256 = t256_provider.get_t (w);
; 181  : 
; 182  : //			int vxF = ((VXFullF[w]-128)*time256)/256;
; 183  : //			int vyF = ((VYFullF[w]-128)*time256)/256;
; 184  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 185  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1064[esp+76]
	lea	esi, DWORD PTR [edx*4]

; 186  :       //int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 187  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 188  : 			int dstF = prefF[vyF*ref_pitch + vxF + (w<<NPELL2)];

	mov	ebx, DWORD PTR _prefF8$[esp+72]

; 189  : 			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 190  : //			int vxB = ((VXFullB[w]-128)*(256-time256))/256;
; 191  : //			int vyB = ((VYFullB[w]-128)*(256-time256))/256;
; 192  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 193  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 194  :       
; 195  : //      int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 196  : //			int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 197  : 			int dstB = prefB[vyB*ref_pitch + vxB + (w<<NPELL2)];
; 198  : 			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 199  : 			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +

	mov	edi, 255				; 000000ffH
	add	ebx, eax
	movsx	edx, WORD PTR [ecx+ebp]
	imul	edx, DWORD PTR _time256$[esp+72]
	movsx	ecx, WORD PTR [ebp]
	imul	ecx, DWORD PTR _time256$[esp+72]
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, ebx
	lea	ebx, DWORD PTR [esi+eax]
	add	ecx, edx
	movzx	ecx, BYTE PTR [ecx+esi]
	mov	DWORD PTR _dstF$1$[esp+76], ecx
	mov	ecx, DWORD PTR tv1075[esp+76]
	movsx	edx, WORD PTR [ecx+ebp]
	imul	edx, DWORD PTR tv1083[esp+76]
	mov	ecx, DWORD PTR tv1066[esp+76]
	movsx	ecx, WORD PTR [ecx+ebp]
	imul	ecx, DWORD PTR tv1083[esp+76]
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, esi
	mov	esi, DWORD PTR tv1079[esp+76]
	add	ecx, edx
	mov	edx, 255				; 000000ffH
	movzx	ebp, BYTE PTR [esi]
	movzx	ecx, BYTE PTR [ecx+eax]
	sub	edx, ebp
	imul	edx, ecx
	mov	ecx, DWORD PTR tv1074[esp+76]
	movzx	esi, BYTE PTR [ecx+esi]
	mov	ecx, DWORD PTR tv1068[esp+76]
	sub	edi, esi
	imul	edi, DWORD PTR _dstF$1$[esp+76]
	mov	DWORD PTR tv1077[esp+76], edx
	movzx	ecx, BYTE PTR [ecx+ebx]
	imul	ecx, ebp
	add	ecx, edx
	lea	edx, DWORD PTR [edi+255]
	imul	ecx, esi
	add	ecx, 255				; 000000ffH
	sar	ecx, 8
	add	edx, ecx
	movzx	ecx, BYTE PTR [ebx]
	imul	ecx, esi
	mov	esi, DWORD PTR tv1077[esp+76]
	mov	ebx, DWORD PTR tv1073[esp+76]
	add	esi, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR tv1083[esp+76]
	add	ecx, edi
	imul	ecx, ebp
	mov	ebp, DWORD PTR tv1076[esp+76]
	add	ebp, 2
	mov	DWORD PTR tv1076[esp+76], ebp
	add	ecx, 255				; 000000ffH
	sar	ecx, 8
	add	ecx, esi
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[esp+72]
	add	edx, ecx
	mov	ecx, DWORD PTR tv1079[esp+76]
	sar	edx, 8
	mov	BYTE PTR [ebx+ecx], dl
	inc	ecx
	mov	edx, DWORD PTR _w$1$[esp+72]
	inc	edx
	mov	DWORD PTR tv1079[esp+76], ecx
	mov	DWORD PTR _w$1$[esp+72], edx
	cmp	edx, DWORD PTR _width$[esp+72]
	jl	$LL7@FlowInter_
	mov	edx, DWORD PTR _VXFullF$[esp+72]
	mov	ebx, DWORD PTR _VYFullB$[esp+72]
	mov	esi, DWORD PTR _MaskB$[esp+72]
	mov	ecx, DWORD PTR _pdst$1$[esp+76]
	mov	ebp, DWORD PTR _MaskF$[esp+72]
	mov	edi, DWORD PTR _height$[esp+72]
$LN6@FlowInter_:

; 200  : 			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*     time256   )>>8;
; 201  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +
; 202  : //			            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*time256 )>>8;
; 203  : 		}
; 204  : 		pdst += dst_pitch;

	add	ecx, DWORD PTR _dst_pitch$1$[esp+76]

; 205  : 		prefB += ref_pitch<<NPELL2;
; 206  : 		prefF += ref_pitch<<NPELL2;
; 207  : 		//t256_provider.jump_to_next_row ();
; 208  : 		VXFullB += VPitch;
; 209  : 		VYFullB += VPitch;

	add	ebx, DWORD PTR tv1080[esp+76]

; 210  : 		VXFullF += VPitch;

	add	edx, DWORD PTR tv1080[esp+76]

; 211  : 		VYFullF += VPitch;
; 212  : 		MaskB += VPitch;

	add	esi, DWORD PTR _VPitch$[esp+72]

; 213  : 		MaskF += VPitch;

	add	ebp, DWORD PTR _VPitch$[esp+72]
	add	eax, DWORD PTR tv1081[esp+76]
	sub	edi, 1
	mov	DWORD PTR _pdst$1$[esp+76], ecx
	mov	DWORD PTR _VYFullB$[esp+72], ebx
	mov	DWORD PTR _VXFullF$[esp+72], edx
	mov	DWORD PTR _MaskB$[esp+72], esi
	mov	DWORD PTR _MaskF$[esp+72], ebp
	mov	DWORD PTR _height$[esp+72], edi
	jne	$LL4@FlowInter_
	pop	esi
	pop	ebp
	pop	ebx
$LN3@FlowInter_:
	pop	edi

; 214  : 	}
; 215  : }

	add	esp, 60					; 0000003cH
	ret	0
??$FlowInter_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP	; FlowInter_NPel<unsigned char,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInter_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
tv1046 = -56						; size = 4
_pdst$1$ = -52						; size = 4
tv1050 = -48						; size = 4
_w$1$ = -44						; size = 4
_dstF$1$ = -40						; size = 4
tv1043 = -40						; size = 4
tv1030 = -36						; size = 4
tv1042 = -32						; size = 4
tv1032 = -28						; size = 4
tv1039 = -24						; size = 4
tv1041 = -20						; size = 4
tv1034 = -16						; size = 4
tv1040 = -12						; size = 4
tv1049 = -8						; size = 4
tv1048 = -4						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
??$FlowInter_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z PROC ; FlowInter_NPel<unsigned short,0>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 169  : {

	sub	esp, 56					; 00000038H

; 170  :   dst_pitch /= sizeof(pixel_t);
; 171  :   ref_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _ref_pitch$[esp+52]
	shr	eax, 1
	shr	edx, 1

; 172  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 173  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 174  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 175  : 
; 176  :   for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+52], 0
	mov	DWORD PTR _pdst$1$[esp+56], ecx
	mov	DWORD PTR _ref_pitch$[esp+52], eax
	jle	$LN3@FlowInter_
	push	ebx
	mov	ebx, DWORD PTR _prefB8$[esp+56]
	add	edx, edx
	sub	DWORD PTR _prefF8$[esp+56], ebx
	add	eax, eax
	push	ebp
	push	esi
	mov	esi, DWORD PTR _VPitch$[esp+64]
	mov	DWORD PTR tv1049[esp+68], edx
	mov	edx, DWORD PTR _VYFullB$[esp+64]
	sub	DWORD PTR _VXFullB$[esp+64], edx
	sub	DWORD PTR _VYFullF$[esp+64], edx
	push	edi
	mov	edi, DWORD PTR _MaskB$[esp+68]
	mov	DWORD PTR tv1048[esp+72], eax
	mov	eax, DWORD PTR _VXFullF$[esp+68]
	npad	2
$LL4@FlowInter_:

; 177  : 	{
; 178  : 		for (int w=0; w<width; w++)

	xor	ebp, ebp
	mov	DWORD PTR _w$1$[esp+72], ebp
	cmp	DWORD PTR _width$[esp+68], ebp
	jle	$LN6@FlowInter_
	mov	ecx, DWORD PTR _VYFullF$[esp+68]
	mov	esi, 256				; 00000100H
	sub	ecx, eax
	sub	esi, DWORD PTR _time256$[esp+68]
	add	ecx, edx
	mov	DWORD PTR tv1043[esp+72], eax
	mov	DWORD PTR tv1030[esp+72], ecx
	mov	ecx, edx
	sub	ecx, eax
	mov	DWORD PTR tv1050[esp+72], esi
	mov	DWORD PTR tv1042[esp+72], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+68]
	sub	ecx, eax
	mov	DWORD PTR tv1046[esp+72], edi
	add	ecx, edx
	mov	DWORD PTR tv1032[esp+72], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+68]
	add	ecx, ebx
	sub	ecx, eax
	mov	DWORD PTR tv1034[esp+72], ecx
	mov	ecx, ebx
	sub	ecx, eax
	mov	DWORD PTR tv1041[esp+72], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+72]
	sub	ecx, eax
	mov	eax, DWORD PTR _MaskF$[esp+68]
	sub	eax, edi
	mov	DWORD PTR tv1040[esp+72], ecx
	mov	DWORD PTR tv1039[esp+72], eax
	mov	eax, DWORD PTR tv1043[esp+72]
$LL7@FlowInter_:

; 179  : 		{
; 180  : 			// const int		time256 = t256_provider.get_t (w);
; 181  : 
; 182  : //			int vxF = ((VXFullF[w]-128)*time256)/256;
; 183  : //			int vyF = ((VYFullF[w]-128)*time256)/256;
; 184  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 185  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1030[esp+72]
	lea	eax, DWORD PTR [eax+2]
	movsx	edx, WORD PTR [ecx+eax-2]
	imul	edx, DWORD PTR _time256$[esp+68]
	movsx	ecx, WORD PTR [eax-2]
	imul	ecx, DWORD PTR _time256$[esp+68]
	sar	edx, 8

; 186  :       //int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 187  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 188  : 			int dstF = prefF[vyF*ref_pitch + vxF + (w<<NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+68]
	sar	ecx, 8
	add	edx, ebp
	add	ecx, edx
	mov	edx, DWORD PTR _prefF8$[esp+68]
	add	edx, ebx
	movzx	ecx, WORD PTR [edx+ecx*2]
	mov	DWORD PTR _dstF$1$[esp+72], ecx

; 189  : 			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 190  : //			int vxB = ((VXFullB[w]-128)*(256-time256))/256;
; 191  : //			int vyB = ((VYFullB[w]-128)*(256-time256))/256;
; 192  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 193  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1042[esp+72]
	movsx	edx, WORD PTR [ecx+eax-2]
	imul	edx, DWORD PTR tv1050[esp+72]
	mov	ecx, DWORD PTR tv1032[esp+72]
	movsx	ecx, WORD PTR [ecx+eax-2]
	imul	ecx, DWORD PTR tv1050[esp+72]
	sar	edx, 8

; 194  :       
; 195  : //      int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 196  : //			int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 197  : 			int dstB = prefB[vyB*ref_pitch + vxB + (w<<NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+68]
	sar	ecx, 8
	add	edx, ebp

; 198  : 			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 199  : 			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +

	mov	ebp, 255				; 000000ffH
	add	ecx, edx
	movzx	ecx, WORD PTR [ebx+ecx*2]
	movzx	ebx, BYTE PTR [edi]
	sub	ebp, ebx
	imul	ebp, ecx
	mov	ecx, DWORD PTR tv1039[esp+72]
	movzx	esi, BYTE PTR [ecx+edi]
	mov	edi, 255				; 000000ffH
	mov	ecx, DWORD PTR tv1041[esp+72]
	sub	edi, esi
	imul	edi, DWORD PTR _dstF$1$[esp+72]
	movzx	edx, WORD PTR [ecx+eax-2]
	mov	ecx, DWORD PTR tv1034[esp+72]
	imul	edx, esi
	movzx	ecx, WORD PTR [ecx+eax-2]
	imul	ecx, ebx
	add	edx, edi
	add	edi, 255				; 000000ffH
	imul	edx, ebx
	mov	ebx, DWORD PTR _prefB8$[esp+68]
	add	ecx, ebp
	imul	ecx, esi
	add	edx, 255				; 000000ffH
	sar	edx, 8
	add	edx, 255				; 000000ffH
	add	edx, ebp
	mov	ebp, DWORD PTR _w$1$[esp+72]
	add	ecx, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR _time256$[esp+68]
	inc	ebp
	sar	ecx, 8
	add	ecx, edi
	mov	DWORD PTR _w$1$[esp+72], ebp
	mov	edi, DWORD PTR tv1046[esp+72]
	sar	ecx, 8
	inc	edi
	imul	ecx, DWORD PTR tv1050[esp+72]
	mov	DWORD PTR tv1046[esp+72], edi
	add	edx, ecx
	mov	ecx, DWORD PTR tv1040[esp+72]
	sar	edx, 8
	mov	WORD PTR [ecx+eax-2], dx
	cmp	ebp, DWORD PTR _width$[esp+68]
	jl	$LL7@FlowInter_
	mov	eax, DWORD PTR _VXFullF$[esp+68]
	mov	edx, DWORD PTR _VYFullB$[esp+68]
	mov	edi, DWORD PTR _MaskB$[esp+68]
	mov	ecx, DWORD PTR _pdst$1$[esp+72]
	mov	esi, DWORD PTR _VPitch$[esp+68]
$LN6@FlowInter_:

; 200  : 			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*     time256   )>>8;
; 201  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +
; 202  : //			            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*time256 )>>8;
; 203  : 		}
; 204  : 		pdst += dst_pitch;

	add	ecx, DWORD PTR tv1049[esp+72]

; 205  : 		prefB += ref_pitch<<NPELL2;
; 206  : 		prefF += ref_pitch<<NPELL2;
; 207  : 		//t256_provider.jump_to_next_row ();
; 208  : 		VXFullB += VPitch;
; 209  : 		VYFullB += VPitch;

	lea	ebp, DWORD PTR [esi+esi]
	add	ebx, DWORD PTR tv1048[esp+72]
	lea	edx, DWORD PTR [edx+esi*2]

; 210  : 		VXFullF += VPitch;
; 211  : 		VYFullF += VPitch;
; 212  : 		MaskB += VPitch;
; 213  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+68], esi
	add	eax, ebp
	add	edi, esi
	mov	DWORD PTR _pdst$1$[esp+72], ecx
	sub	DWORD PTR _height$[esp+68], 1
	mov	DWORD PTR _prefB8$[esp+68], ebx
	mov	DWORD PTR _VYFullB$[esp+68], edx
	mov	DWORD PTR _VXFullF$[esp+68], eax
	mov	DWORD PTR _MaskB$[esp+68], edi
	jne	$LL4@FlowInter_
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@FlowInter_:

; 214  : 	}
; 215  : }

	add	esp, 56					; 00000038H
	ret	0
??$FlowInter_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP ; FlowInter_NPel<unsigned short,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInter_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
tv1073 = -60						; size = 4
_pdst$1$ = -56						; size = 4
_w$1$ = -52						; size = 4
tv1066 = -48						; size = 4
tv1065 = -44						; size = 4
tv1053 = -40						; size = 4
tv1064 = -36						; size = 4
tv1055 = -32						; size = 4
tv1062 = -28						; size = 4
tv1057 = -24						; size = 4
tv1067 = -20						; size = 4
tv1063 = -16						; size = 4
tv1070 = -12						; size = 4
tv1072 = -8						; size = 4
tv1071 = -4						; size = 4
tv1069 = 8						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
??$FlowInter_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z PROC	; FlowInter_NPel<unsigned short,1>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 169  : {

	sub	esp, 60					; 0000003cH

; 170  :   dst_pitch /= sizeof(pixel_t);
; 171  :   ref_pitch /= sizeof(pixel_t);
; 172  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 173  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);

	mov	eax, DWORD PTR _prefB8$[esp+56]
	push	ebp
	mov	ebp, ecx
	mov	DWORD PTR _pdst$1$[esp+64], ecx
	mov	ecx, DWORD PTR _ref_pitch$[esp+60]
	shr	ecx, 1
	shr	edx, 1

; 174  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 175  : 
; 176  :   for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+60], 0
	mov	DWORD PTR _ref_pitch$[esp+60], ecx
	jle	$LN3@FlowInter_
	sub	DWORD PTR _prefF8$[esp+60], eax
	add	edx, edx
	shl	ecx, 2
	push	ebx
	mov	ebx, DWORD PTR _VYFullB$[esp+64]
	sub	DWORD PTR _VXFullB$[esp+64], ebx
	sub	DWORD PTR _VYFullF$[esp+64], ebx
	mov	DWORD PTR tv1071[esp+68], ecx
	mov	ecx, DWORD PTR _VPitch$[esp+64]
	push	esi
	push	edi
	mov	DWORD PTR tv1072[esp+76], edx
	mov	edx, DWORD PTR _VXFullF$[esp+72]
	lea	edi, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1070[esp+76], edi
	npad	8
$LL4@FlowInter_:

; 177  : 	{
; 178  : 		for (int w=0; w<width; w++)

	xor	esi, esi
	mov	DWORD PTR _w$1$[esp+76], esi
	cmp	DWORD PTR _width$[esp+72], esi
	jle	$LN6@FlowInter_
	mov	DWORD PTR tv1069[esp+72], ecx
	mov	edi, 256				; 00000100H
	sub	edi, DWORD PTR _time256$[esp+72]
	mov	ecx, ebx
	sub	ecx, edx
	mov	DWORD PTR tv1073[esp+76], edi
	add	ecx, DWORD PTR _VYFullF$[esp+72]
	mov	ebp, edx
	mov	DWORD PTR tv1053[esp+76], ecx
	mov	ecx, ebx
	sub	ecx, edx
	mov	DWORD PTR tv1066[esp+76], eax
	mov	DWORD PTR tv1064[esp+76], ecx
	mov	ecx, DWORD PTR _VXFullB$[esp+72]
	sub	ecx, edx
	mov	DWORD PTR tv1065[esp+76], ebp
	add	ecx, ebx
	mov	DWORD PTR tv1055[esp+76], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+76]
	sub	ecx, edx
	mov	DWORD PTR tv1063[esp+76], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+72]
	add	ecx, eax
	sub	ecx, eax
	mov	DWORD PTR tv1057[esp+76], ecx
	mov	ecx, DWORD PTR _MaskF$[esp+72]
	sub	ecx, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1062[esp+76], ecx
$LL7@FlowInter_:

; 179  : 		{
; 180  : 			// const int		time256 = t256_provider.get_t (w);
; 181  : 
; 182  : //			int vxF = ((VXFullF[w]-128)*time256)/256;
; 183  : //			int vyF = ((VYFullF[w]-128)*time256)/256;
; 184  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 185  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1053[esp+76]
	add	esi, esi
	movsx	edx, WORD PTR [ecx+ebp]
	imul	edx, DWORD PTR _time256$[esp+72]
	movsx	ecx, WORD PTR [ebp]
	imul	ecx, DWORD PTR _time256$[esp+72]
	sar	edx, 8

; 186  :       //int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 187  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 188  : 			int dstF = prefF[vyF*ref_pitch + vxF + (w<<NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, esi
	add	ecx, edx
	mov	edx, DWORD PTR _prefF8$[esp+72]
	add	edx, eax
	movzx	ebx, WORD PTR [edx+ecx*2]

; 189  : 			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 190  : //			int vxB = ((VXFullB[w]-128)*(256-time256))/256;
; 191  : //			int vyB = ((VYFullB[w]-128)*(256-time256))/256;
; 192  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 193  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1064[esp+76]
	movsx	edx, WORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR tv1055[esp+76]
	imul	edx, edi
	movsx	ecx, WORD PTR [ecx+ebp]
	imul	ecx, edi

; 194  :       
; 195  : //      int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 196  : //			int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 197  : 			int dstB = prefB[vyB*ref_pitch + vxB + (w<<NPELL2)];
; 198  : 			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 199  : 			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +

	mov	edi, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, esi
	mov	esi, DWORD PTR tv1069[esp+72]
	add	ecx, edx
	inc	DWORD PTR tv1069[esp+72]
	mov	edx, 255				; 000000ffH
	movzx	ebp, BYTE PTR [esi]
	movzx	ecx, WORD PTR [eax+ecx*2]
	sub	edx, ebp
	imul	edx, ecx
	mov	ecx, DWORD PTR tv1062[esp+76]
	movzx	esi, BYTE PTR [ecx+esi]
	mov	ecx, DWORD PTR tv1057[esp+76]
	sub	edi, esi
	imul	edi, ebx
	mov	ebx, DWORD PTR tv1066[esp+76]
	mov	DWORD PTR tv1067[esp+76], edx
	movzx	ecx, WORD PTR [ecx+ebx]
	imul	ecx, ebp
	add	edx, ecx
	movzx	ecx, WORD PTR [ebx]
	imul	ecx, esi
	add	ebx, 4
	imul	edx, esi
	mov	esi, DWORD PTR tv1067[esp+76]
	add	esi, 255				; 000000ffH
	mov	DWORD PTR tv1066[esp+76], ebx
	add	ecx, edi
	imul	ecx, ebp
	add	edx, 255				; 000000ffH
	mov	ebp, DWORD PTR tv1065[esp+76]
	sar	edx, 8
	add	edx, 255				; 000000ffH
	add	edx, edi
	mov	edi, DWORD PTR tv1073[esp+76]
	add	ecx, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR tv1073[esp+76]
	sar	ecx, 8
	add	ecx, esi
	mov	esi, DWORD PTR _w$1$[esp+76]
	sar	ecx, 8
	inc	esi
	imul	ecx, DWORD PTR _time256$[esp+72]
	mov	DWORD PTR _w$1$[esp+76], esi
	add	edx, ecx
	mov	ecx, DWORD PTR tv1063[esp+76]
	sar	edx, 8
	mov	WORD PTR [ecx+ebp], dx
	add	ebp, 2
	mov	DWORD PTR tv1065[esp+76], ebp
	cmp	esi, DWORD PTR _width$[esp+72]
	jl	$LL7@FlowInter_
	mov	edx, DWORD PTR _VXFullF$[esp+72]
	mov	ebx, DWORD PTR _VYFullB$[esp+72]
	mov	ecx, DWORD PTR _MaskB$[esp+72]
	mov	ebp, DWORD PTR _pdst$1$[esp+76]
	mov	edi, DWORD PTR tv1070[esp+76]
$LN6@FlowInter_:

; 200  : 			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*     time256   )>>8;
; 201  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +
; 202  : //			            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*time256 )>>8;
; 203  : 		}
; 204  : 		pdst += dst_pitch;
; 205  : 		prefB += ref_pitch<<NPELL2;
; 206  : 		prefF += ref_pitch<<NPELL2;
; 207  : 		//t256_provider.jump_to_next_row ();
; 208  : 		VXFullB += VPitch;
; 209  : 		VYFullB += VPitch;
; 210  : 		VXFullF += VPitch;
; 211  : 		VYFullF += VPitch;
; 212  : 		MaskB += VPitch;

	mov	esi, DWORD PTR _VPitch$[esp+72]
	add	ebx, edi
	add	ebp, DWORD PTR tv1072[esp+76]
	add	edx, edi
	add	eax, DWORD PTR tv1071[esp+76]
	add	ecx, esi

; 213  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+72], esi
	sub	DWORD PTR _height$[esp+72], 1
	mov	DWORD PTR _pdst$1$[esp+76], ebp
	mov	DWORD PTR _VYFullB$[esp+72], ebx
	mov	DWORD PTR _VXFullF$[esp+72], edx
	mov	DWORD PTR _MaskB$[esp+72], ecx
	jne	$LL4@FlowInter_
	pop	edi
	pop	esi
	pop	ebx
$LN3@FlowInter_:
	pop	ebp

; 214  : 	}
; 215  : }

	add	esp, 60					; 0000003cH
	ret	0
??$FlowInter_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP	; FlowInter_NPel<unsigned short,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInter_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z
_TEXT	SEGMENT
_pdst$1$ = -60						; size = 4
_w$1$ = -56						; size = 4
tv1070 = -52						; size = 4
tv1069 = -48						; size = 4
tv1077 = -44						; size = 4
tv1057 = -40						; size = 4
tv1068 = -36						; size = 4
tv1059 = -32						; size = 4
tv1066 = -28						; size = 4
tv1061 = -24						; size = 4
tv1071 = -20						; size = 4
tv1067 = -16						; size = 4
tv1074 = -12						; size = 4
tv1076 = -8						; size = 4
tv1075 = -4						; size = 4
tv1073 = 8						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
??$FlowInter_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z PROC	; FlowInter_NPel<unsigned short,2>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 169  : {

	sub	esp, 60					; 0000003cH

; 170  :   dst_pitch /= sizeof(pixel_t);
; 171  :   ref_pitch /= sizeof(pixel_t);
; 172  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 173  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);

	mov	eax, DWORD PTR _prefB8$[esp+56]
	push	ebp
	mov	ebp, ecx
	mov	DWORD PTR _pdst$1$[esp+64], ecx
	mov	ecx, DWORD PTR _ref_pitch$[esp+60]
	shr	ecx, 1
	shr	edx, 1

; 174  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 175  : 
; 176  :   for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+60], 0
	mov	DWORD PTR _ref_pitch$[esp+60], ecx
	jle	$LN3@FlowInter_
	sub	DWORD PTR _prefF8$[esp+60], eax
	add	edx, edx
	shl	ecx, 3
	push	ebx
	mov	ebx, DWORD PTR _VYFullB$[esp+64]
	sub	DWORD PTR _VXFullB$[esp+64], ebx
	sub	DWORD PTR _VYFullF$[esp+64], ebx
	mov	DWORD PTR tv1075[esp+68], ecx
	mov	ecx, DWORD PTR _VPitch$[esp+64]
	push	esi
	push	edi
	mov	DWORD PTR tv1076[esp+76], edx
	mov	edx, DWORD PTR _VXFullF$[esp+72]
	lea	edi, DWORD PTR [ecx+ecx]
	mov	ecx, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1074[esp+76], edi
	npad	8
$LL4@FlowInter_:

; 177  : 	{
; 178  : 		for (int w=0; w<width; w++)

	xor	esi, esi
	mov	DWORD PTR _w$1$[esp+76], esi
	cmp	DWORD PTR _width$[esp+72], esi
	jle	$LN6@FlowInter_
	mov	DWORD PTR tv1073[esp+72], ecx
	mov	edi, 256				; 00000100H
	mov	ecx, DWORD PTR _VYFullF$[esp+72]
	mov	ebp, edx
	sub	ecx, edx
	sub	edi, DWORD PTR _time256$[esp+72]
	add	ecx, ebx
	mov	DWORD PTR tv1077[esp+76], edi
	mov	DWORD PTR tv1057[esp+76], ecx
	mov	ecx, ebx
	sub	ecx, edx
	mov	DWORD PTR tv1070[esp+76], eax
	mov	DWORD PTR tv1068[esp+76], ecx
	mov	ecx, ebx
	sub	ecx, edx
	mov	DWORD PTR tv1069[esp+76], ebp
	add	ecx, DWORD PTR _VXFullB$[esp+72]
	mov	DWORD PTR tv1059[esp+76], ecx
	mov	ecx, DWORD PTR _pdst$1$[esp+76]
	sub	ecx, edx
	mov	DWORD PTR tv1067[esp+76], ecx
	mov	ecx, DWORD PTR _prefF8$[esp+72]
	add	ecx, eax
	sub	ecx, eax
	mov	DWORD PTR tv1061[esp+76], ecx
	mov	ecx, DWORD PTR _MaskF$[esp+72]
	sub	ecx, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1066[esp+76], ecx
$LL7@FlowInter_:

; 179  : 		{
; 180  : 			// const int		time256 = t256_provider.get_t (w);
; 181  : 
; 182  : //			int vxF = ((VXFullF[w]-128)*time256)/256;
; 183  : //			int vyF = ((VYFullF[w]-128)*time256)/256;
; 184  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 185  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1057[esp+76]
	shl	esi, 2
	movsx	edx, WORD PTR [ecx+ebp]
	imul	edx, DWORD PTR _time256$[esp+72]
	movsx	ecx, WORD PTR [ebp]
	imul	ecx, DWORD PTR _time256$[esp+72]
	sar	edx, 8

; 186  :       //int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 187  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 188  : 			int dstF = prefF[vyF*ref_pitch + vxF + (w<<NPELL2)];

	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, esi
	add	ecx, edx
	mov	edx, DWORD PTR _prefF8$[esp+72]
	add	edx, eax
	movzx	ebx, WORD PTR [edx+ecx*2]

; 189  : 			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 190  : //			int vxB = ((VXFullB[w]-128)*(256-time256))/256;
; 191  : //			int vyB = ((VYFullB[w]-128)*(256-time256))/256;
; 192  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 193  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	ecx, DWORD PTR tv1068[esp+76]
	movsx	edx, WORD PTR [ecx+ebp]
	mov	ecx, DWORD PTR tv1059[esp+76]
	imul	edx, edi
	movsx	ecx, WORD PTR [ecx+ebp]
	imul	ecx, edi

; 194  :       
; 195  : //      int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 196  : //			int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 197  : 			int dstB = prefB[vyB*ref_pitch + vxB + (w<<NPELL2)];
; 198  : 			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 199  : 			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +

	mov	edi, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR _ref_pitch$[esp+72]
	sar	ecx, 8
	add	edx, esi
	mov	esi, DWORD PTR tv1073[esp+72]
	add	ecx, edx
	inc	DWORD PTR tv1073[esp+72]
	mov	edx, 255				; 000000ffH
	movzx	ebp, BYTE PTR [esi]
	movzx	ecx, WORD PTR [eax+ecx*2]
	sub	edx, ebp
	imul	edx, ecx
	mov	ecx, DWORD PTR tv1066[esp+76]
	movzx	esi, BYTE PTR [ecx+esi]
	mov	ecx, DWORD PTR tv1061[esp+76]
	sub	edi, esi
	imul	edi, ebx
	mov	ebx, DWORD PTR tv1070[esp+76]
	mov	DWORD PTR tv1071[esp+76], edx
	movzx	ecx, WORD PTR [ebx+ecx]
	imul	ecx, ebp
	add	edx, ecx
	movzx	ecx, WORD PTR [ebx]
	imul	ecx, esi
	add	ebx, 8
	imul	edx, esi
	mov	esi, DWORD PTR tv1071[esp+76]
	add	esi, 255				; 000000ffH
	mov	DWORD PTR tv1070[esp+76], ebx
	add	ecx, edi
	imul	ecx, ebp
	add	edx, 255				; 000000ffH
	mov	ebp, DWORD PTR tv1069[esp+76]
	sar	edx, 8
	add	edx, 255				; 000000ffH
	add	edx, edi
	mov	edi, DWORD PTR tv1077[esp+76]
	add	ecx, 255				; 000000ffH
	sar	edx, 8
	imul	edx, DWORD PTR tv1077[esp+76]
	sar	ecx, 8
	add	ecx, esi
	mov	esi, DWORD PTR _w$1$[esp+76]
	sar	ecx, 8
	inc	esi
	imul	ecx, DWORD PTR _time256$[esp+72]
	mov	DWORD PTR _w$1$[esp+76], esi
	add	edx, ecx
	mov	ecx, DWORD PTR tv1067[esp+76]
	sar	edx, 8
	mov	WORD PTR [ecx+ebp], dx
	add	ebp, 2
	mov	DWORD PTR tv1069[esp+76], ebp
	cmp	esi, DWORD PTR _width$[esp+72]
	jl	$LL7@FlowInter_
	mov	edx, DWORD PTR _VXFullF$[esp+72]
	mov	ebx, DWORD PTR _VYFullB$[esp+72]
	mov	ecx, DWORD PTR _MaskB$[esp+72]
	mov	ebp, DWORD PTR _pdst$1$[esp+76]
	mov	edi, DWORD PTR tv1074[esp+76]
$LN6@FlowInter_:

; 200  : 			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*     time256   )>>8;
; 201  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + dstB*MaskF[w] + 255)>>8 )*(256-time256) +
; 202  : //			            ( (dstB*(255-MaskB[w]) + dstF*MaskB[w] + 255)>>8 )*time256 )>>8;
; 203  : 		}
; 204  : 		pdst += dst_pitch;
; 205  : 		prefB += ref_pitch<<NPELL2;
; 206  : 		prefF += ref_pitch<<NPELL2;
; 207  : 		//t256_provider.jump_to_next_row ();
; 208  : 		VXFullB += VPitch;
; 209  : 		VYFullB += VPitch;
; 210  : 		VXFullF += VPitch;
; 211  : 		VYFullF += VPitch;
; 212  : 		MaskB += VPitch;

	mov	esi, DWORD PTR _VPitch$[esp+72]
	add	ebx, edi
	add	ebp, DWORD PTR tv1076[esp+76]
	add	edx, edi
	add	eax, DWORD PTR tv1075[esp+76]
	add	ecx, esi

; 213  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+72], esi
	sub	DWORD PTR _height$[esp+72], 1
	mov	DWORD PTR _pdst$1$[esp+76], ebp
	mov	DWORD PTR _VYFullB$[esp+72], ebx
	mov	DWORD PTR _VXFullF$[esp+72], edx
	mov	DWORD PTR _MaskB$[esp+72], ecx
	jne	$LL4@FlowInter_
	pop	edi
	pop	esi
	pop	ebx
$LN3@FlowInter_:
	pop	ebp

; 214  : 	}
; 215  : }

	add	esp, 60					; 0000003cH
	ret	0
??$FlowInter_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH@Z ENDP	; FlowInter_NPel<unsigned short,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterExtra_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z
_TEXT	SEGMENT
_dstB$1$ = -60						; size = 4
_pdst$1$ = -56						; size = 4
_dstF$1$ = -52						; size = 4
tv1476 = -48						; size = 4
tv1482 = -44						; size = 4
tv1466 = -40						; size = 4
tv1458 = -36						; size = 4
tv1462 = -32						; size = 4
tv1475 = -28						; size = 4
tv1468 = -24						; size = 4
tv1460 = -20						; size = 4
tv1464 = -16						; size = 4
tv1474 = -12						; size = 4
tv1473 = -8						; size = 4
_dst_pitch$1$ = -4					; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_VXFullBB$ = 60						; size = 4
_VXFullFF$ = 64						; size = 4
_VYFullBB$ = 68						; size = 4
_VYFullFF$ = 72						; size = 4
??$FlowInterExtra_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z PROC ; FlowInterExtra_NPel<unsigned char,0>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 234  : {

	sub	esp, 60					; 0000003cH

; 235  :   dst_pitch /= sizeof(pixel_t);
; 236  :   ref_pitch /= sizeof(pixel_t);
; 237  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 238  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 239  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 240  : 
; 241  : 	for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+56], 0
	push	ebx
	mov	DWORD PTR _dst_pitch$1$[esp+64], edx
	mov	ebx, ecx
	mov	DWORD PTR _pdst$1$[esp+64], ecx
	jle	$LN3@FlowInterE
	mov	ecx, DWORD PTR _VYFullB$[esp+60]
	mov	eax, DWORD PTR _prefB8$[esp+60]
	sub	DWORD PTR _prefF8$[esp+60], eax
	sub	DWORD PTR _VXFullB$[esp+60], ecx
	sub	DWORD PTR _VYFullF$[esp+60], ecx
	sub	DWORD PTR _VXFullBB$[esp+60], ecx
	sub	DWORD PTR _VXFullFF$[esp+60], ecx
	sub	DWORD PTR _VYFullBB$[esp+60], ecx
	sub	DWORD PTR _VYFullFF$[esp+60], ecx
	mov	edx, DWORD PTR _VXFullF$[esp+60]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _VPitch$[esp+68]
	push	edi
	mov	edi, DWORD PTR _MaskB$[esp+72]
$LL4@FlowInterE:

; 242  : 	{
; 243  : 		for (int w=0; w<width; w++)

	xor	ebp, ebp
	cmp	DWORD PTR _width$[esp+72], ebp
	jle	$LN6@FlowInterE
	mov	eax, DWORD PTR _VYFullF$[esp+72]
	mov	esi, 256				; 00000100H
	sub	eax, edx
	sub	esi, DWORD PTR _time256$[esp+72]
	add	eax, ecx
	mov	DWORD PTR tv1482[esp+76], esi
	mov	DWORD PTR tv1466[esp+76], eax
	mov	ebx, edx
	mov	eax, DWORD PTR _VYFullFF$[esp+72]
	sub	eax, edx
	mov	DWORD PTR tv1476[esp+76], ebx
	add	eax, ecx
	mov	DWORD PTR tv1458[esp+76], eax
	mov	eax, DWORD PTR _VXFullFF$[esp+72]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1462[esp+76], eax
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR tv1475[esp+76], eax
	mov	eax, DWORD PTR _VXFullB$[esp+72]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1468[esp+76], eax
	mov	eax, DWORD PTR _VYFullBB$[esp+72]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1460[esp+76], eax
	mov	eax, DWORD PTR _VXFullBB$[esp+72]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1464[esp+76], eax
	mov	eax, DWORD PTR _MaskF$[esp+72]
	sub	eax, edi
	mov	DWORD PTR tv1474[esp+76], eax
	mov	eax, DWORD PTR _pdst$1$[esp+76]
	sub	eax, edi
	mov	DWORD PTR tv1473[esp+76], eax
$LL7@FlowInterE:

; 244  : 		{
; 245  : 			//const int		time256 = t256_provider.get_t (w);
; 246  : 
; 247  : 			//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 248  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 249  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 250  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1466[esp+76]

; 251  :       int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 252  : 			int dstF = prefF[adrF];

	mov	edx, DWORD PTR _prefF8$[esp+72]
	add	edx, DWORD PTR _prefB8$[esp+72]
	movsx	ecx, WORD PTR [ebx+eax]
	imul	ecx, DWORD PTR _time256$[esp+72]
	movsx	eax, WORD PTR [ebx]
	imul	eax, DWORD PTR _time256$[esp+72]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+72]
	sar	eax, 8
	add	ecx, edx
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+ebp]
	mov	DWORD PTR _dstF$1$[esp+76], eax

; 253  : //			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 254  : 			//int vxFF = t256_provider.get_vect_f (time256, VXFullFF[w]); 2.6.0.5
; 255  : 			//int vyFF = t256_provider.get_vect_f (time256, VYFullFF[w]); 2.6.0.5
; 256  :       int vxFF = (VXFullFF[w] * time256) >> 8; // is it correct time?
; 257  :       int vyFF = (VYFullFF[w] * time256) >> 8;  // 2.5.11.22

	mov	eax, DWORD PTR tv1458[esp+76]
	movsx	ecx, WORD PTR [ebx+eax]
	imul	ecx, DWORD PTR _time256$[esp+72]
	mov	eax, DWORD PTR tv1462[esp+76]
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, DWORD PTR _time256$[esp+72]
	sar	ecx, 8

; 258  :       int adrFF = vyFF*ref_pitch + vxFF + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+72]
	sar	eax, 8

; 259  : 			int dstFF = prefF[adrFF];

	add	ecx, edx
	add	eax, ecx
	movzx	edx, BYTE PTR [eax+ebp]

; 260  : 			//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 261  : 			//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 262  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 263  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1475[esp+76]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1468[esp+76]
	imul	ecx, esi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, esi
	sar	ecx, 8

; 264  :       int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+72]
	sar	eax, 8

; 265  : 			int dstB = prefB[adrB];

	add	ecx, ebp
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+72]
	movzx	eax, BYTE PTR [eax+ecx]
	mov	DWORD PTR _dstB$1$[esp+76], eax

; 266  : //			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 267  : 			//int vxBB = t256_provider.get_vect_b (time256, VXFullBB[w]); 2.6.0.5
; 268  : 			//int vyBB = t256_provider.get_vect_b (time256, VYFullBB[w]); 2.6.0.5
; 269  :       int vxBB = (VXFullBB[w] * (256 - time256)) >> 8;
; 270  :       int vyBB = (VYFullBB[w] * (256 - time256)) >> 8;

	mov	eax, DWORD PTR tv1460[esp+76]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1464[esp+76]
	imul	ecx, esi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, esi
	mov	esi, DWORD PTR _dstF$1$[esp+76]
	sar	ecx, 8

; 271  :       int adrBB = vyBB*ref_pitch + vxBB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+72]
	sar	eax, 8

; 272  : 			int dstBB = prefB[adrBB];

	add	ecx, ebp
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+72]
	movzx	ebx, BYTE PTR [eax+ecx]
	mov	ecx, esi
	mov	eax, DWORD PTR _dstB$1$[esp+76]
	cmp	esi, eax
	cmovbe	ecx, eax
	cmp	esi, eax
	cmovbe	eax, esi
	cmp	ebx, eax

; 147  : 	if (b <= a) return a;

	ja	SHORT $LN12@FlowInterE
	mov	ebx, eax
	jmp	SHORT $LN14@FlowInterE
$LN12@FlowInterE:
	cmp	ecx, ebx

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	cmovbe	ebx, ecx
$LN14@FlowInterE:
	cmp	edx, eax

; 147  : 	if (b <= a) return a;

	jbe	SHORT $LN20@FlowInterE
	cmp	ecx, edx

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	mov	eax, edx
	cmovbe	eax, ecx
$LN20@FlowInterE:

; 273  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +
; 274  : //			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*time256 )>>8;
; 275  :              // use median, firsly get min max of compensations
; 276  :              int minfb;
; 277  :              int maxfb;
; 278  :              if (dstF > dstB) {
; 279  :                  minfb = dstB;
; 280  :                  maxfb = dstF;
; 281  :              } else {
; 282  :                  maxfb = dstB;
; 283  :                  minfb = dstF;
; 284  :              }
; 285  :              // PF todo check: +255 is bits_per_pixel-aware?
; 286  :              pdst[w] = (((Median3r(minfb, dstBB, maxfb)*MaskF[w] + dstF*(255-MaskF[w])+255)>>8)*(256-time256) +

	mov	ecx, DWORD PTR tv1474[esp+76]
	add	edi, ebp
	inc	ebp
	movzx	edx, BYTE PTR [edi+ecx]
	mov	ecx, 255				; 000000ffH
	movzx	esi, BYTE PTR [edi]
	sub	ecx, edx
	imul	ecx, DWORD PTR _dstF$1$[esp+76]
	imul	edx, ebx
	mov	ebx, DWORD PTR tv1476[esp+76]
	imul	eax, esi
	add	ebx, 2
	mov	DWORD PTR tv1476[esp+76], ebx
	add	ecx, 255				; 000000ffH
	add	edx, ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, esi
	sar	edx, 8
	imul	ecx, DWORD PTR _dstB$1$[esp+76]
	add	eax, 255				; 000000ffH
	imul	edx, DWORD PTR tv1482[esp+76]
	mov	esi, DWORD PTR tv1482[esp+76]
	add	eax, ecx
	sar	eax, 8
	imul	eax, DWORD PTR _time256$[esp+72]
	add	edx, eax
	mov	eax, DWORD PTR tv1473[esp+76]
	sar	edx, 8
	mov	BYTE PTR [edi+eax], dl
	mov	edi, DWORD PTR _MaskB$[esp+72]
	cmp	ebp, DWORD PTR _width$[esp+72]
	jl	$LL7@FlowInterE
	mov	ecx, DWORD PTR _VYFullB$[esp+72]
	mov	edx, DWORD PTR _VXFullF$[esp+72]
	mov	eax, DWORD PTR _prefB8$[esp+72]
	mov	ebx, DWORD PTR _pdst$1$[esp+76]
	mov	esi, DWORD PTR _VPitch$[esp+72]
$LN6@FlowInterE:

; 287  :                         ((Median3r(minfb, dstFF, maxfb)*MaskB[w] + dstB*(255-MaskB[w])+255)>>8)*     time256   )>>8;
; 288  : 		}
; 289  : 		pdst += dst_pitch;

	add	ebx, DWORD PTR _dst_pitch$1$[esp+76]

; 290  : 		prefB += ref_pitch<<NPELL2;
; 291  : 		prefF += ref_pitch<<NPELL2;
; 292  : 		//t256_provider.jump_to_next_row ();
; 293  : 		VXFullB += VPitch;
; 294  : 		VYFullB += VPitch;

	lea	ebp, DWORD PTR [esi+esi]
	add	eax, DWORD PTR _ref_pitch$[esp+72]
	lea	ecx, DWORD PTR [ecx+esi*2]

; 295  : 		VXFullF += VPitch;
; 296  : 		VYFullF += VPitch;
; 297  : 		MaskB += VPitch;
; 298  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+72], esi
	add	edx, ebp
	add	edi, esi
	mov	DWORD PTR _pdst$1$[esp+76], ebx
	sub	DWORD PTR _height$[esp+72], 1
	mov	DWORD PTR _prefB8$[esp+72], eax
	mov	DWORD PTR _VYFullB$[esp+72], ecx
	mov	DWORD PTR _VXFullF$[esp+72], edx
	mov	DWORD PTR _MaskB$[esp+72], edi
	jne	$LL4@FlowInterE
	pop	edi
	pop	esi
	pop	ebp
$LN3@FlowInterE:
	pop	ebx

; 299  : 		VXFullBB += VPitch;
; 300  : 		VYFullBB += VPitch;
; 301  : 		VXFullFF += VPitch;
; 302  : 		VYFullFF += VPitch;
; 303  : 	}
; 304  : }

	add	esp, 60					; 0000003cH
	ret	0
??$FlowInterExtra_NPel@E$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z ENDP ; FlowInterExtra_NPel<unsigned char,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterExtra_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z
_TEXT	SEGMENT
_dstB$1$ = -68						; size = 4
_pdst$1$ = -64						; size = 4
_dstF$1$ = -60						; size = 4
_w$1$ = -56						; size = 4
tv1458 = -52						; size = 4
tv1450 = -48						; size = 4
tv1454 = -44						; size = 4
tv1467 = -40						; size = 4
tv1460 = -36						; size = 4
tv1452 = -32						; size = 4
tv1456 = -28						; size = 4
tv1466 = -24						; size = 4
tv1475 = -20						; size = 4
tv1465 = -16						; size = 4
tv1473 = -12						; size = 4
_dst_pitch$1$ = -8					; size = 4
tv1474 = -4						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_VXFullBB$ = 60						; size = 4
_VXFullFF$ = 64						; size = 4
_VYFullBB$ = 68						; size = 4
_VYFullFF$ = 72						; size = 4
??$FlowInterExtra_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z PROC ; FlowInterExtra_NPel<unsigned char,1>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 234  : {

	sub	esp, 68					; 00000044H

; 235  :   dst_pitch /= sizeof(pixel_t);
; 236  :   ref_pitch /= sizeof(pixel_t);
; 237  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 238  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 239  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 240  : 
; 241  : 	for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+64], 0
	push	ebp
	mov	DWORD PTR _dst_pitch$1$[esp+72], edx
	mov	ebp, ecx
	mov	DWORD PTR _pdst$1$[esp+72], ecx
	jle	$LN3@FlowInterE
	mov	eax, DWORD PTR _ref_pitch$[esp+68]
	mov	ecx, DWORD PTR _VYFullB$[esp+68]
	add	eax, eax
	sub	DWORD PTR _VXFullB$[esp+68], ecx
	sub	DWORD PTR _VYFullF$[esp+68], ecx
	sub	DWORD PTR _VXFullBB$[esp+68], ecx
	sub	DWORD PTR _VXFullFF$[esp+68], ecx
	sub	DWORD PTR _VYFullBB$[esp+68], ecx
	push	ebx
	mov	ebx, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1474[esp+76], eax
	mov	eax, DWORD PTR _VPitch$[esp+72]
	push	esi
	mov	esi, DWORD PTR _VXFullF$[esp+76]
	push	edi
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _prefB8$[esp+80]
	sub	DWORD PTR _prefF8$[esp+80], eax
	sub	DWORD PTR _VYFullFF$[esp+80], ecx
	mov	DWORD PTR tv1473[esp+84], edi
	npad	7
$LL4@FlowInterE:

; 242  : 	{
; 243  : 		for (int w=0; w<width; w++)

	xor	edx, edx
	mov	DWORD PTR _w$1$[esp+84], edx
	cmp	DWORD PTR _width$[esp+80], edx
	jle	$LN6@FlowInterE
	mov	eax, DWORD PTR _VYFullF$[esp+80]
	mov	edi, 256				; 00000100H
	sub	eax, esi
	sub	edi, DWORD PTR _time256$[esp+80]
	add	eax, ecx
	mov	DWORD PTR tv1475[esp+84], edi
	mov	DWORD PTR tv1458[esp+84], eax
	mov	ebp, esi
	mov	eax, DWORD PTR _VYFullFF$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1450[esp+84], eax
	mov	eax, DWORD PTR _VXFullFF$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1454[esp+84], eax
	mov	eax, ecx
	sub	eax, esi
	mov	DWORD PTR tv1467[esp+84], eax
	mov	eax, DWORD PTR _VXFullB$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1460[esp+84], eax
	mov	eax, DWORD PTR _VYFullBB$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1452[esp+84], eax
	mov	eax, DWORD PTR _VXFullBB$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1456[esp+84], eax
	mov	eax, DWORD PTR _MaskF$[esp+80]
	sub	eax, DWORD PTR _MaskB$[esp+80]
	mov	DWORD PTR tv1466[esp+84], eax
	mov	eax, DWORD PTR _pdst$1$[esp+84]
	sub	eax, DWORD PTR _MaskB$[esp+80]
	mov	DWORD PTR tv1465[esp+84], eax
	npad	7
$LL7@FlowInterE:

; 244  : 		{
; 245  : 			//const int		time256 = t256_provider.get_t (w);
; 246  : 
; 247  : 			//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 248  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 249  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 250  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1458[esp+84]
	lea	esi, DWORD PTR [edx+edx]

; 251  :       int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 252  : 			int dstF = prefF[adrF];

	mov	edx, DWORD PTR _prefF8$[esp+80]
	add	edx, DWORD PTR _prefB8$[esp+80]
	movsx	ecx, WORD PTR [eax+ebp]
	imul	ecx, DWORD PTR _time256$[esp+80]
	movsx	eax, WORD PTR [ebp]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+edx]
	mov	DWORD PTR _dstF$1$[esp+84], eax

; 253  : //			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 254  : 			//int vxFF = t256_provider.get_vect_f (time256, VXFullFF[w]); 2.6.0.5
; 255  : 			//int vyFF = t256_provider.get_vect_f (time256, VYFullFF[w]); 2.6.0.5
; 256  :       int vxFF = (VXFullFF[w] * time256) >> 8; // is it correct time?
; 257  :       int vyFF = (VYFullFF[w] * time256) >> 8;  // 2.5.11.22

	mov	eax, DWORD PTR tv1450[esp+84]
	movsx	ecx, WORD PTR [eax+ebp]
	imul	ecx, DWORD PTR _time256$[esp+80]
	mov	eax, DWORD PTR tv1454[esp+84]
	movsx	eax, WORD PTR [eax+ebp]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8

; 258  :       int adrFF = vyFF*ref_pitch + vxFF + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8

; 259  : 			int dstFF = prefF[adrFF];

	add	ecx, esi
	add	eax, ecx
	movzx	edx, BYTE PTR [eax+edx]

; 260  : 			//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 261  : 			//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 262  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 263  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1467[esp+84]
	movsx	ecx, WORD PTR [eax+ebp]
	mov	eax, DWORD PTR tv1460[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [eax+ebp]
	imul	eax, edi
	sar	ecx, 8

; 264  :       int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8

; 265  : 			int dstB = prefB[adrB];

	add	ecx, esi
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	eax, BYTE PTR [eax+ecx]
	mov	DWORD PTR _dstB$1$[esp+84], eax

; 266  : //			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 267  : 			//int vxBB = t256_provider.get_vect_b (time256, VXFullBB[w]); 2.6.0.5
; 268  : 			//int vyBB = t256_provider.get_vect_b (time256, VYFullBB[w]); 2.6.0.5
; 269  :       int vxBB = (VXFullBB[w] * (256 - time256)) >> 8;
; 270  :       int vyBB = (VYFullBB[w] * (256 - time256)) >> 8;

	mov	eax, DWORD PTR tv1452[esp+84]
	movsx	ecx, WORD PTR [eax+ebp]
	mov	eax, DWORD PTR tv1456[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [eax+ebp]
	imul	eax, edi
	sar	ecx, 8

; 271  :       int adrBB = vyBB*ref_pitch + vxBB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8

; 272  : 			int dstBB = prefB[adrBB];

	add	ecx, esi
	mov	esi, DWORD PTR _dstF$1$[esp+84]
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	edi, BYTE PTR [eax+ecx]
	mov	ecx, esi
	mov	eax, DWORD PTR _dstB$1$[esp+84]
	cmp	esi, eax
	cmovbe	ecx, eax
	cmp	esi, eax
	cmovbe	eax, esi
	cmp	edi, eax

; 147  : 	if (b <= a) return a;

	ja	SHORT $LN12@FlowInterE
	mov	edi, eax
	jmp	SHORT $LN14@FlowInterE
$LN12@FlowInterE:
	cmp	ecx, edi

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	cmovbe	edi, ecx
$LN14@FlowInterE:
	cmp	edx, eax

; 147  : 	if (b <= a) return a;

	jbe	SHORT $LN20@FlowInterE
	cmp	ecx, edx

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	mov	eax, edx
	cmovbe	eax, ecx
$LN20@FlowInterE:

; 273  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +
; 274  : //			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*time256 )>>8;
; 275  :              // use median, firsly get min max of compensations
; 276  :              int minfb;
; 277  :              int maxfb;
; 278  :              if (dstF > dstB) {
; 279  :                  minfb = dstB;
; 280  :                  maxfb = dstF;
; 281  :              } else {
; 282  :                  maxfb = dstB;
; 283  :                  minfb = dstF;
; 284  :              }
; 285  :              // PF todo check: +255 is bits_per_pixel-aware?
; 286  :              pdst[w] = (((Median3r(minfb, dstBB, maxfb)*MaskF[w] + dstF*(255-MaskF[w])+255)>>8)*(256-time256) +

	mov	ecx, DWORD PTR tv1466[esp+84]
	add	ebp, 2
	movzx	edx, BYTE PTR [ebx]
	movzx	esi, BYTE PTR [ebx+ecx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, edx
	imul	edx, eax
	imul	ecx, DWORD PTR _dstB$1$[esp+84]
	mov	eax, 255				; 000000ffH
	sub	eax, esi
	imul	esi, edi
	imul	eax, DWORD PTR _dstF$1$[esp+84]
	mov	edi, DWORD PTR tv1475[esp+84]
	add	edx, 255				; 000000ffH
	add	ecx, edx
	mov	edx, DWORD PTR _w$1$[esp+84]
	sar	ecx, 8
	inc	edx
	imul	ecx, DWORD PTR _time256$[esp+80]
	add	eax, 255				; 000000ffH
	add	eax, esi
	mov	DWORD PTR _w$1$[esp+84], edx
	sar	eax, 8
	imul	eax, edi
	add	ecx, eax
	mov	eax, DWORD PTR tv1465[esp+84]
	sar	ecx, 8
	mov	BYTE PTR [ebx+eax], cl
	inc	ebx
	cmp	edx, DWORD PTR _width$[esp+80]
	jl	$LL7@FlowInterE
	mov	ecx, DWORD PTR _VYFullB$[esp+80]
	mov	esi, DWORD PTR _VXFullF$[esp+80]
	mov	eax, DWORD PTR _prefB8$[esp+80]
	mov	ebx, DWORD PTR _MaskB$[esp+80]
	mov	ebp, DWORD PTR _pdst$1$[esp+84]
	mov	edi, DWORD PTR tv1473[esp+84]
$LN6@FlowInterE:

; 287  :                         ((Median3r(minfb, dstFF, maxfb)*MaskB[w] + dstB*(255-MaskB[w])+255)>>8)*     time256   )>>8;
; 288  : 		}
; 289  : 		pdst += dst_pitch;
; 290  : 		prefB += ref_pitch<<NPELL2;
; 291  : 		prefF += ref_pitch<<NPELL2;
; 292  : 		//t256_provider.jump_to_next_row ();
; 293  : 		VXFullB += VPitch;
; 294  : 		VYFullB += VPitch;
; 295  : 		VXFullF += VPitch;
; 296  : 		VYFullF += VPitch;
; 297  : 		MaskB += VPitch;

	mov	edx, DWORD PTR _VPitch$[esp+80]
	add	ecx, edi
	add	ebp, DWORD PTR _dst_pitch$1$[esp+84]
	add	esi, edi
	add	eax, DWORD PTR tv1474[esp+84]
	add	ebx, edx

; 298  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+80], edx
	sub	DWORD PTR _height$[esp+80], 1
	mov	DWORD PTR _pdst$1$[esp+84], ebp
	mov	DWORD PTR _prefB8$[esp+80], eax
	mov	DWORD PTR _VYFullB$[esp+80], ecx
	mov	DWORD PTR _VXFullF$[esp+80], esi
	mov	DWORD PTR _MaskB$[esp+80], ebx
	jne	$LL4@FlowInterE
	pop	edi
	pop	esi
	pop	ebx
$LN3@FlowInterE:
	pop	ebp

; 299  : 		VXFullBB += VPitch;
; 300  : 		VYFullBB += VPitch;
; 301  : 		VXFullFF += VPitch;
; 302  : 		VYFullFF += VPitch;
; 303  : 	}
; 304  : }

	add	esp, 68					; 00000044H
	ret	0
??$FlowInterExtra_NPel@E$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z ENDP ; FlowInterExtra_NPel<unsigned char,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterExtra_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z
_TEXT	SEGMENT
_dstB$1$ = -68						; size = 4
_pdst$1$ = -64						; size = 4
_dstF$1$ = -60						; size = 4
_w$1$ = -56						; size = 4
tv1462 = -52						; size = 4
tv1454 = -48						; size = 4
tv1458 = -44						; size = 4
tv1471 = -40						; size = 4
tv1464 = -36						; size = 4
tv1456 = -32						; size = 4
tv1460 = -28						; size = 4
tv1470 = -24						; size = 4
tv1479 = -20						; size = 4
tv1469 = -16						; size = 4
tv1477 = -12						; size = 4
_dst_pitch$1$ = -8					; size = 4
tv1478 = -4						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_VXFullBB$ = 60						; size = 4
_VXFullFF$ = 64						; size = 4
_VYFullBB$ = 68						; size = 4
_VYFullFF$ = 72						; size = 4
??$FlowInterExtra_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z PROC ; FlowInterExtra_NPel<unsigned char,2>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 234  : {

	sub	esp, 68					; 00000044H

; 235  :   dst_pitch /= sizeof(pixel_t);
; 236  :   ref_pitch /= sizeof(pixel_t);
; 237  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 238  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 239  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 240  : 
; 241  : 	for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+64], 0
	push	ebp
	mov	DWORD PTR _dst_pitch$1$[esp+72], edx
	mov	ebp, ecx
	mov	DWORD PTR _pdst$1$[esp+72], ecx
	jle	$LN3@FlowInterE
	mov	eax, DWORD PTR _ref_pitch$[esp+68]
	mov	ecx, DWORD PTR _VYFullB$[esp+68]
	sub	DWORD PTR _VXFullB$[esp+68], ecx
	sub	DWORD PTR _VYFullF$[esp+68], ecx
	sub	DWORD PTR _VXFullBB$[esp+68], ecx
	sub	DWORD PTR _VXFullFF$[esp+68], ecx
	sub	DWORD PTR _VYFullBB$[esp+68], ecx
	shl	eax, 2
	push	ebx
	mov	ebx, DWORD PTR _MaskB$[esp+72]
	mov	DWORD PTR tv1478[esp+76], eax
	mov	eax, DWORD PTR _VPitch$[esp+72]
	push	esi
	mov	esi, DWORD PTR _VXFullF$[esp+76]
	push	edi
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _prefB8$[esp+80]
	sub	DWORD PTR _prefF8$[esp+80], eax
	sub	DWORD PTR _VYFullFF$[esp+80], ecx
	mov	DWORD PTR tv1477[esp+84], edi
	npad	6
$LL4@FlowInterE:

; 242  : 	{
; 243  : 		for (int w=0; w<width; w++)

	xor	edx, edx
	mov	DWORD PTR _w$1$[esp+84], edx
	cmp	DWORD PTR _width$[esp+80], edx
	jle	$LN6@FlowInterE
	mov	eax, DWORD PTR _VYFullF$[esp+80]
	mov	edi, 256				; 00000100H
	sub	eax, esi
	sub	edi, DWORD PTR _time256$[esp+80]
	add	eax, ecx
	mov	DWORD PTR tv1479[esp+84], edi
	mov	DWORD PTR tv1462[esp+84], eax
	mov	ebp, esi
	mov	eax, DWORD PTR _VYFullFF$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1454[esp+84], eax
	mov	eax, DWORD PTR _VXFullFF$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1458[esp+84], eax
	mov	eax, ecx
	sub	eax, esi
	mov	DWORD PTR tv1471[esp+84], eax
	mov	eax, DWORD PTR _VXFullB$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1464[esp+84], eax
	mov	eax, DWORD PTR _VYFullBB$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1456[esp+84], eax
	mov	eax, DWORD PTR _VXFullBB$[esp+80]
	sub	eax, esi
	add	eax, ecx
	mov	DWORD PTR tv1460[esp+84], eax
	mov	eax, DWORD PTR _MaskF$[esp+80]
	sub	eax, DWORD PTR _MaskB$[esp+80]
	mov	DWORD PTR tv1470[esp+84], eax
	mov	eax, DWORD PTR _pdst$1$[esp+84]
	sub	eax, DWORD PTR _MaskB$[esp+80]
	mov	DWORD PTR tv1469[esp+84], eax
	npad	7
$LL7@FlowInterE:

; 244  : 		{
; 245  : 			//const int		time256 = t256_provider.get_t (w);
; 246  : 
; 247  : 			//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 248  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 249  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 250  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1462[esp+84]
	lea	esi, DWORD PTR [edx*4]

; 251  :       int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 252  : 			int dstF = prefF[adrF];

	mov	edx, DWORD PTR _prefF8$[esp+80]
	add	edx, DWORD PTR _prefB8$[esp+80]
	movsx	ecx, WORD PTR [eax+ebp]
	imul	ecx, DWORD PTR _time256$[esp+80]
	movsx	eax, WORD PTR [ebp]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	movzx	eax, BYTE PTR [eax+edx]
	mov	DWORD PTR _dstF$1$[esp+84], eax

; 253  : //			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 254  : 			//int vxFF = t256_provider.get_vect_f (time256, VXFullFF[w]); 2.6.0.5
; 255  : 			//int vyFF = t256_provider.get_vect_f (time256, VYFullFF[w]); 2.6.0.5
; 256  :       int vxFF = (VXFullFF[w] * time256) >> 8; // is it correct time?
; 257  :       int vyFF = (VYFullFF[w] * time256) >> 8;  // 2.5.11.22

	mov	eax, DWORD PTR tv1454[esp+84]
	movsx	ecx, WORD PTR [eax+ebp]
	imul	ecx, DWORD PTR _time256$[esp+80]
	mov	eax, DWORD PTR tv1458[esp+84]
	movsx	eax, WORD PTR [eax+ebp]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8

; 258  :       int adrFF = vyFF*ref_pitch + vxFF + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8

; 259  : 			int dstFF = prefF[adrFF];

	add	ecx, esi
	add	eax, ecx
	movzx	edx, BYTE PTR [eax+edx]

; 260  : 			//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 261  : 			//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 262  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 263  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1471[esp+84]
	movsx	ecx, WORD PTR [eax+ebp]
	mov	eax, DWORD PTR tv1464[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [eax+ebp]
	imul	eax, edi
	sar	ecx, 8

; 264  :       int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8

; 265  : 			int dstB = prefB[adrB];

	add	ecx, esi
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	eax, BYTE PTR [eax+ecx]
	mov	DWORD PTR _dstB$1$[esp+84], eax

; 266  : //			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 267  : 			//int vxBB = t256_provider.get_vect_b (time256, VXFullBB[w]); 2.6.0.5
; 268  : 			//int vyBB = t256_provider.get_vect_b (time256, VYFullBB[w]); 2.6.0.5
; 269  :       int vxBB = (VXFullBB[w] * (256 - time256)) >> 8;
; 270  :       int vyBB = (VYFullBB[w] * (256 - time256)) >> 8;

	mov	eax, DWORD PTR tv1456[esp+84]
	movsx	ecx, WORD PTR [eax+ebp]
	mov	eax, DWORD PTR tv1460[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [eax+ebp]
	imul	eax, edi
	sar	ecx, 8

; 271  :       int adrBB = vyBB*ref_pitch + vxBB + (w<<NPELL2);

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8

; 272  : 			int dstBB = prefB[adrBB];

	add	ecx, esi
	mov	esi, DWORD PTR _dstF$1$[esp+84]
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	edi, BYTE PTR [eax+ecx]
	mov	ecx, esi
	mov	eax, DWORD PTR _dstB$1$[esp+84]
	cmp	esi, eax
	cmovbe	ecx, eax
	cmp	esi, eax
	cmovbe	eax, esi
	cmp	edi, eax

; 147  : 	if (b <= a) return a;

	ja	SHORT $LN12@FlowInterE
	mov	edi, eax
	jmp	SHORT $LN14@FlowInterE
$LN12@FlowInterE:
	cmp	ecx, edi

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	cmovbe	edi, ecx
$LN14@FlowInterE:
	cmp	edx, eax

; 147  : 	if (b <= a) return a;

	jbe	SHORT $LN20@FlowInterE
	cmp	ecx, edx

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	mov	eax, edx
	cmovbe	eax, ecx
$LN20@FlowInterE:

; 273  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +
; 274  : //			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*time256 )>>8;
; 275  :              // use median, firsly get min max of compensations
; 276  :              int minfb;
; 277  :              int maxfb;
; 278  :              if (dstF > dstB) {
; 279  :                  minfb = dstB;
; 280  :                  maxfb = dstF;
; 281  :              } else {
; 282  :                  maxfb = dstB;
; 283  :                  minfb = dstF;
; 284  :              }
; 285  :              // PF todo check: +255 is bits_per_pixel-aware?
; 286  :              pdst[w] = (((Median3r(minfb, dstBB, maxfb)*MaskF[w] + dstF*(255-MaskF[w])+255)>>8)*(256-time256) +

	mov	ecx, DWORD PTR tv1470[esp+84]
	add	ebp, 2
	movzx	edx, BYTE PTR [ebx]
	movzx	esi, BYTE PTR [ebx+ecx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, edx
	imul	edx, eax
	imul	ecx, DWORD PTR _dstB$1$[esp+84]
	mov	eax, 255				; 000000ffH
	sub	eax, esi
	imul	esi, edi
	imul	eax, DWORD PTR _dstF$1$[esp+84]
	mov	edi, DWORD PTR tv1479[esp+84]
	add	edx, 255				; 000000ffH
	add	ecx, edx
	mov	edx, DWORD PTR _w$1$[esp+84]
	sar	ecx, 8
	inc	edx
	imul	ecx, DWORD PTR _time256$[esp+80]
	add	eax, 255				; 000000ffH
	add	eax, esi
	mov	DWORD PTR _w$1$[esp+84], edx
	sar	eax, 8
	imul	eax, edi
	add	ecx, eax
	mov	eax, DWORD PTR tv1469[esp+84]
	sar	ecx, 8
	mov	BYTE PTR [ebx+eax], cl
	inc	ebx
	cmp	edx, DWORD PTR _width$[esp+80]
	jl	$LL7@FlowInterE
	mov	ecx, DWORD PTR _VYFullB$[esp+80]
	mov	esi, DWORD PTR _VXFullF$[esp+80]
	mov	eax, DWORD PTR _prefB8$[esp+80]
	mov	ebx, DWORD PTR _MaskB$[esp+80]
	mov	ebp, DWORD PTR _pdst$1$[esp+84]
	mov	edi, DWORD PTR tv1477[esp+84]
$LN6@FlowInterE:

; 287  :                         ((Median3r(minfb, dstFF, maxfb)*MaskB[w] + dstB*(255-MaskB[w])+255)>>8)*     time256   )>>8;
; 288  : 		}
; 289  : 		pdst += dst_pitch;
; 290  : 		prefB += ref_pitch<<NPELL2;
; 291  : 		prefF += ref_pitch<<NPELL2;
; 292  : 		//t256_provider.jump_to_next_row ();
; 293  : 		VXFullB += VPitch;
; 294  : 		VYFullB += VPitch;
; 295  : 		VXFullF += VPitch;
; 296  : 		VYFullF += VPitch;
; 297  : 		MaskB += VPitch;

	mov	edx, DWORD PTR _VPitch$[esp+80]
	add	ecx, edi
	add	ebp, DWORD PTR _dst_pitch$1$[esp+84]
	add	esi, edi
	add	eax, DWORD PTR tv1478[esp+84]
	add	ebx, edx

; 298  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+80], edx
	sub	DWORD PTR _height$[esp+80], 1
	mov	DWORD PTR _pdst$1$[esp+84], ebp
	mov	DWORD PTR _prefB8$[esp+80], eax
	mov	DWORD PTR _VYFullB$[esp+80], ecx
	mov	DWORD PTR _VXFullF$[esp+80], esi
	mov	DWORD PTR _MaskB$[esp+80], ebx
	jne	$LL4@FlowInterE
	pop	edi
	pop	esi
	pop	ebx
$LN3@FlowInterE:
	pop	ebp

; 299  : 		VXFullBB += VPitch;
; 300  : 		VYFullBB += VPitch;
; 301  : 		VXFullFF += VPitch;
; 302  : 		VYFullFF += VPitch;
; 303  : 	}
; 304  : }

	add	esp, 68					; 00000044H
	ret	0
??$FlowInterExtra_NPel@E$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z ENDP ; FlowInterExtra_NPel<unsigned char,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterExtra_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z
_TEXT	SEGMENT
_dstB$1$ = -64						; size = 4
_pdst$1$ = -60						; size = 4
_dstF$1$ = -56						; size = 4
tv1469 = -52						; size = 4
tv1460 = -48						; size = 4
tv1465 = -44						; size = 4
tv1478 = -40						; size = 4
tv1471 = -36						; size = 4
tv1462 = -32						; size = 4
tv1467 = -28						; size = 4
tv1476 = -24						; size = 4
tv1487 = -20						; size = 4
tv1477 = -16						; size = 4
tv1484 = -12						; size = 4
tv1483 = -8						; size = 4
tv1482 = -4						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_VXFullBB$ = 60						; size = 4
_VXFullFF$ = 64						; size = 4
_VYFullBB$ = 68						; size = 4
_VYFullFF$ = 72						; size = 4
??$FlowInterExtra_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z PROC ; FlowInterExtra_NPel<unsigned short,0>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 234  : {

	sub	esp, 64					; 00000040H

; 235  :   dst_pitch /= sizeof(pixel_t);
; 236  :   ref_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _ref_pitch$[esp+60]
	shr	eax, 1
	shr	edx, 1

; 237  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 238  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 239  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 240  : 
; 241  : 	for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+60], 0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _pdst$1$[esp+68], ecx
	mov	DWORD PTR _ref_pitch$[esp+64], eax
	jle	$LN3@FlowInterE
	add	eax, eax
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _VXFullF$[esp+64]
	mov	DWORD PTR tv1483[esp+68], eax
	mov	eax, DWORD PTR _VPitch$[esp+64]
	push	ebx
	mov	ebx, DWORD PTR _prefB8$[esp+68]
	add	eax, eax
	sub	DWORD PTR _prefF8$[esp+68], ebx
	push	ebp
	mov	DWORD PTR tv1484[esp+76], ecx
	mov	ecx, DWORD PTR _VYFullB$[esp+72]
	sub	DWORD PTR _VXFullB$[esp+72], ecx
	sub	DWORD PTR _VYFullF$[esp+72], ecx
	sub	DWORD PTR _VXFullBB$[esp+72], ecx
	sub	DWORD PTR _VXFullFF$[esp+72], ecx
	sub	DWORD PTR _VYFullBB$[esp+72], ecx
	sub	DWORD PTR _VYFullFF$[esp+72], ecx
	push	edi
	mov	edi, DWORD PTR _time256$[esp+76]
	mov	DWORD PTR tv1482[esp+80], eax
	mov	eax, DWORD PTR _MaskB$[esp+76]
	npad	6
$LL4@FlowInterE:

; 242  : 	{
; 243  : 		for (int w=0; w<width; w++)

	xor	ebp, ebp
	cmp	DWORD PTR _width$[esp+76], ebp
	jle	$LN6@FlowInterE
	mov	eax, DWORD PTR _VYFullF$[esp+76]
	mov	esi, 256				; 00000100H
	sub	eax, edx
	sub	esi, edi
	add	eax, ecx
	mov	DWORD PTR tv1487[esp+80], esi
	mov	DWORD PTR tv1469[esp+80], eax
	mov	ebx, edx
	mov	eax, DWORD PTR _VYFullFF$[esp+76]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1460[esp+80], eax
	mov	eax, DWORD PTR _VXFullFF$[esp+76]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1465[esp+80], eax
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR tv1478[esp+80], eax
	mov	eax, DWORD PTR _VXFullB$[esp+76]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1471[esp+80], eax
	mov	eax, DWORD PTR _VYFullBB$[esp+76]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1462[esp+80], eax
	mov	eax, DWORD PTR _VXFullBB$[esp+76]
	sub	eax, edx
	add	eax, ecx
	mov	DWORD PTR tv1467[esp+80], eax
	mov	eax, DWORD PTR _pdst$1$[esp+80]
	sub	eax, edx
	mov	DWORD PTR tv1477[esp+80], eax
	mov	eax, DWORD PTR _MaskF$[esp+76]
	sub	eax, DWORD PTR _MaskB$[esp+76]
	mov	DWORD PTR tv1476[esp+80], eax
	npad	5
$LL7@FlowInterE:

; 244  : 		{
; 245  : 			//const int		time256 = t256_provider.get_t (w);
; 246  : 
; 247  : 			//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 248  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 249  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 250  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1469[esp+80]

; 251  :       int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 252  : 			int dstF = prefF[adrF];

	mov	edx, DWORD PTR _prefF8$[esp+76]
	add	edx, DWORD PTR _prefB8$[esp+76]
	movsx	ecx, WORD PTR [ebx+eax]
	movsx	eax, WORD PTR [ebx]
	imul	ecx, edi
	imul	eax, edi
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+76]
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	movzx	eax, WORD PTR [edx+eax*2]
	mov	DWORD PTR _dstF$1$[esp+80], eax

; 253  : //			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 254  : 			//int vxFF = t256_provider.get_vect_f (time256, VXFullFF[w]); 2.6.0.5
; 255  : 			//int vyFF = t256_provider.get_vect_f (time256, VYFullFF[w]); 2.6.0.5
; 256  :       int vxFF = (VXFullFF[w] * time256) >> 8; // is it correct time?
; 257  :       int vyFF = (VYFullFF[w] * time256) >> 8;  // 2.5.11.22

	mov	eax, DWORD PTR tv1460[esp+80]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1465[esp+80]
	imul	ecx, edi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, edi
	sar	ecx, 8

; 258  :       int adrFF = vyFF*ref_pitch + vxFF + (w<<NPELL2);
; 259  : 			int dstFF = prefF[adrFF];

	imul	ecx, DWORD PTR _ref_pitch$[esp+76]

; 260  : 			//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 261  : 			//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 262  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 263  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 264  :       int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 265  : 			int dstB = prefB[adrB];

	mov	edi, DWORD PTR _prefB8$[esp+76]
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	movzx	edx, WORD PTR [edx+eax*2]
	mov	eax, DWORD PTR tv1478[esp+80]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1471[esp+80]
	imul	ecx, esi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, esi
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+76]
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	movzx	eax, WORD PTR [edi+eax*2]
	mov	DWORD PTR _dstB$1$[esp+80], eax

; 266  : //			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 267  : 			//int vxBB = t256_provider.get_vect_b (time256, VXFullBB[w]); 2.6.0.5
; 268  : 			//int vyBB = t256_provider.get_vect_b (time256, VYFullBB[w]); 2.6.0.5
; 269  :       int vxBB = (VXFullBB[w] * (256 - time256)) >> 8;
; 270  :       int vyBB = (VYFullBB[w] * (256 - time256)) >> 8;

	mov	eax, DWORD PTR tv1462[esp+80]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1467[esp+80]
	imul	ecx, esi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, esi
	mov	esi, DWORD PTR _dstF$1$[esp+80]
	sar	ecx, 8

; 271  :       int adrBB = vyBB*ref_pitch + vxBB + (w<<NPELL2);
; 272  : 			int dstBB = prefB[adrBB];

	imul	ecx, DWORD PTR _ref_pitch$[esp+76]
	sar	eax, 8
	add	ecx, ebp
	add	eax, ecx
	mov	ecx, esi
	movzx	edi, WORD PTR [edi+eax*2]
	mov	eax, DWORD PTR _dstB$1$[esp+80]
	cmp	esi, eax
	cmovbe	ecx, eax
	cmp	esi, eax
	cmovbe	eax, esi
	cmp	edi, eax

; 147  : 	if (b <= a) return a;

	ja	SHORT $LN12@FlowInterE
	mov	edi, eax
	jmp	SHORT $LN14@FlowInterE
$LN12@FlowInterE:
	cmp	ecx, edi

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	cmovbe	edi, ecx
$LN14@FlowInterE:
	cmp	edx, eax

; 147  : 	if (b <= a) return a;

	jbe	SHORT $LN20@FlowInterE
	cmp	ecx, edx

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	mov	eax, edx
	cmovbe	eax, ecx
$LN20@FlowInterE:

; 273  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +
; 274  : //			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*time256 )>>8;
; 275  :              // use median, firsly get min max of compensations
; 276  :              int minfb;
; 277  :              int maxfb;
; 278  :              if (dstF > dstB) {
; 279  :                  minfb = dstB;
; 280  :                  maxfb = dstF;
; 281  :              } else {
; 282  :                  maxfb = dstB;
; 283  :                  minfb = dstF;
; 284  :              }
; 285  :              // PF todo check: +255 is bits_per_pixel-aware?
; 286  :              pdst[w] = (((Median3r(minfb, dstBB, maxfb)*MaskF[w] + dstF*(255-MaskF[w])+255)>>8)*(256-time256) +

	mov	ecx, DWORD PTR _MaskB$[esp+76]
	mov	edx, DWORD PTR tv1476[esp+80]
	add	ecx, ebp
	inc	ebp
	movzx	esi, BYTE PTR [ecx+edx]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, edx
	imul	edx, eax
	imul	ecx, DWORD PTR _dstB$1$[esp+80]
	mov	eax, 255				; 000000ffH
	sub	eax, esi
	imul	esi, edi
	imul	eax, DWORD PTR _dstF$1$[esp+80]
	mov	edi, DWORD PTR _time256$[esp+76]
	add	ecx, 255				; 000000ffH
	add	ecx, edx
	add	esi, 255				; 000000ffH
	add	eax, esi
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[esp+76]
	mov	esi, DWORD PTR tv1487[esp+80]
	sar	eax, 8
	imul	eax, esi
	add	ecx, eax
	mov	eax, DWORD PTR tv1477[esp+80]
	sar	ecx, 8
	mov	WORD PTR [ebx+eax], cx
	add	ebx, 2
	cmp	ebp, DWORD PTR _width$[esp+76]
	jl	$LL7@FlowInterE
	mov	ecx, DWORD PTR _VYFullB$[esp+76]
	mov	edx, DWORD PTR _VXFullF$[esp+76]
	mov	eax, DWORD PTR _MaskB$[esp+76]
	mov	ebx, DWORD PTR _prefB8$[esp+76]
	mov	esi, DWORD PTR _pdst$1$[esp+80]
$LN6@FlowInterE:

; 287  :                         ((Median3r(minfb, dstFF, maxfb)*MaskB[w] + dstB*(255-MaskB[w])+255)>>8)*     time256   )>>8;
; 288  : 		}
; 289  : 		pdst += dst_pitch;
; 290  : 		prefB += ref_pitch<<NPELL2;
; 291  : 		prefF += ref_pitch<<NPELL2;
; 292  : 		//t256_provider.jump_to_next_row ();
; 293  : 		VXFullB += VPitch;
; 294  : 		VYFullB += VPitch;
; 295  : 		VXFullF += VPitch;
; 296  : 		VYFullF += VPitch;
; 297  : 		MaskB += VPitch;

	mov	ebp, DWORD PTR _VPitch$[esp+76]
	add	eax, ebp
	add	esi, DWORD PTR tv1484[esp+80]
	add	ebx, DWORD PTR tv1483[esp+80]
	add	ecx, DWORD PTR tv1482[esp+80]
	add	edx, DWORD PTR tv1482[esp+80]

; 298  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+76], ebp
	sub	DWORD PTR _height$[esp+76], 1
	mov	DWORD PTR _pdst$1$[esp+80], esi
	mov	DWORD PTR _prefB8$[esp+76], ebx
	mov	DWORD PTR _VYFullB$[esp+76], ecx
	mov	DWORD PTR _VXFullF$[esp+76], edx
	mov	DWORD PTR _MaskB$[esp+76], eax
	jne	$LL4@FlowInterE
	pop	edi
	pop	ebp
	pop	ebx
$LN3@FlowInterE:
	pop	esi

; 299  : 		VXFullBB += VPitch;
; 300  : 		VYFullBB += VPitch;
; 301  : 		VXFullFF += VPitch;
; 302  : 		VYFullFF += VPitch;
; 303  : 	}
; 304  : }

	add	esp, 64					; 00000040H
	ret	0
??$FlowInterExtra_NPel@G$0A@@@YAXPAEHPBE1HPAF22200HHHH2222@Z ENDP ; FlowInterExtra_NPel<unsigned short,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterExtra_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z
_TEXT	SEGMENT
_dstB$1$ = -68						; size = 4
_pdst$1$ = -64						; size = 4
_dstF$1$ = -60						; size = 4
_w$1$ = -56						; size = 4
tv1521 = -52						; size = 4
tv1513 = -48						; size = 4
tv1517 = -44						; size = 4
tv1530 = -40						; size = 4
tv1523 = -36						; size = 4
tv1515 = -32						; size = 4
tv1519 = -28						; size = 4
tv1528 = -24						; size = 4
tv1539 = -20						; size = 4
tv1529 = -16						; size = 4
tv1536 = -12						; size = 4
tv1538 = -8						; size = 4
tv1537 = -4						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_VXFullBB$ = 60						; size = 4
_VXFullFF$ = 64						; size = 4
_VYFullBB$ = 68						; size = 4
_VYFullFF$ = 72						; size = 4
??$FlowInterExtra_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z PROC ; FlowInterExtra_NPel<unsigned short,1>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 234  : {

	sub	esp, 68					; 00000044H

; 235  :   dst_pitch /= sizeof(pixel_t);
; 236  :   ref_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _ref_pitch$[esp+64]
	shr	eax, 1
	shr	edx, 1

; 237  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 238  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 239  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 240  : 
; 241  : 	for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+64], 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _pdst$1$[esp+72], ecx
	mov	DWORD PTR _ref_pitch$[esp+68], eax
	jle	$LN3@FlowInterE
	shl	eax, 2
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _VYFullB$[esp+68]
	sub	DWORD PTR _VXFullB$[esp+68], edx
	sub	DWORD PTR _VYFullF$[esp+68], edx
	sub	DWORD PTR _VXFullBB$[esp+68], edx
	sub	DWORD PTR _VXFullFF$[esp+68], edx
	sub	DWORD PTR _VYFullBB$[esp+68], edx
	mov	DWORD PTR tv1537[esp+72], eax
	mov	eax, DWORD PTR _VPitch$[esp+68]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _VXFullF$[esp+76]
	lea	ebp, DWORD PTR [eax+eax]
	mov	DWORD PTR tv1538[esp+80], ecx
	mov	eax, DWORD PTR _prefB8$[esp+76]
	sub	DWORD PTR _prefF8$[esp+76], eax
	sub	DWORD PTR _VYFullFF$[esp+76], edx
	push	edi
	mov	DWORD PTR tv1536[esp+84], ebp
$LL4@FlowInterE:

; 242  : 	{
; 243  : 		for (int w=0; w<width; w++)

	xor	ecx, ecx
	mov	DWORD PTR _w$1$[esp+84], ecx
	cmp	DWORD PTR _width$[esp+80], ecx
	jle	$LN6@FlowInterE
	mov	eax, DWORD PTR _VYFullF$[esp+80]
	mov	edi, 256				; 00000100H
	sub	eax, esi
	sub	edi, DWORD PTR _time256$[esp+80]
	add	eax, edx
	mov	ebp, DWORD PTR _MaskB$[esp+80]
	mov	DWORD PTR tv1521[esp+84], eax
	mov	ebx, esi
	mov	eax, DWORD PTR _VYFullFF$[esp+80]
	sub	eax, esi
	mov	DWORD PTR tv1539[esp+84], edi
	add	eax, edx
	mov	DWORD PTR tv1513[esp+84], eax
	mov	eax, DWORD PTR _VXFullFF$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1517[esp+84], eax
	mov	eax, edx
	sub	eax, esi
	mov	DWORD PTR tv1530[esp+84], eax
	mov	eax, DWORD PTR _VXFullB$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1523[esp+84], eax
	mov	eax, DWORD PTR _VYFullBB$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1515[esp+84], eax
	mov	eax, DWORD PTR _VXFullBB$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1519[esp+84], eax
	mov	eax, DWORD PTR _pdst$1$[esp+84]
	sub	eax, esi
	mov	DWORD PTR tv1529[esp+84], eax
	mov	eax, DWORD PTR _MaskF$[esp+80]
	sub	eax, ebp
	mov	DWORD PTR tv1528[esp+84], eax
	npad	6
$LL7@FlowInterE:

; 244  : 		{
; 245  : 			//const int		time256 = t256_provider.get_t (w);
; 246  : 
; 247  : 			//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 248  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 249  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 250  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1521[esp+84]
	lea	esi, DWORD PTR [ecx+ecx]

; 251  :       int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 252  : 			int dstF = prefF[adrF];

	mov	edx, DWORD PTR _prefF8$[esp+80]
	add	edx, DWORD PTR _prefB8$[esp+80]
	movsx	ecx, WORD PTR [ebx+eax]
	imul	ecx, DWORD PTR _time256$[esp+80]
	movsx	eax, WORD PTR [ebx]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	movzx	eax, WORD PTR [edx+eax*2]
	mov	DWORD PTR _dstF$1$[esp+84], eax

; 253  : //			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 254  : 			//int vxFF = t256_provider.get_vect_f (time256, VXFullFF[w]); 2.6.0.5
; 255  : 			//int vyFF = t256_provider.get_vect_f (time256, VYFullFF[w]); 2.6.0.5
; 256  :       int vxFF = (VXFullFF[w] * time256) >> 8; // is it correct time?
; 257  :       int vyFF = (VYFullFF[w] * time256) >> 8;  // 2.5.11.22

	mov	eax, DWORD PTR tv1513[esp+84]
	movsx	ecx, WORD PTR [ebx+eax]
	imul	ecx, DWORD PTR _time256$[esp+80]
	mov	eax, DWORD PTR tv1517[esp+84]
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8

; 258  :       int adrFF = vyFF*ref_pitch + vxFF + (w<<NPELL2);
; 259  : 			int dstFF = prefF[adrFF];

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	movzx	edx, WORD PTR [edx+eax*2]

; 260  : 			//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 261  : 			//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 262  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 263  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1530[esp+84]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1523[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, edi
	sar	ecx, 8

; 264  :       int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 265  : 			int dstB = prefB[adrB];

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _dstB$1$[esp+84], eax

; 266  : //			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 267  : 			//int vxBB = t256_provider.get_vect_b (time256, VXFullBB[w]); 2.6.0.5
; 268  : 			//int vyBB = t256_provider.get_vect_b (time256, VYFullBB[w]); 2.6.0.5
; 269  :       int vxBB = (VXFullBB[w] * (256 - time256)) >> 8;
; 270  :       int vyBB = (VYFullBB[w] * (256 - time256)) >> 8;

	mov	eax, DWORD PTR tv1515[esp+84]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1519[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, edi
	sar	ecx, 8

; 271  :       int adrBB = vyBB*ref_pitch + vxBB + (w<<NPELL2);
; 272  : 			int dstBB = prefB[adrBB];

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	mov	esi, DWORD PTR _dstF$1$[esp+84]
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	edi, WORD PTR [ecx+eax*2]
	mov	ecx, esi
	mov	eax, DWORD PTR _dstB$1$[esp+84]
	cmp	esi, eax
	cmovbe	ecx, eax
	cmp	esi, eax
	cmovbe	eax, esi
	cmp	edi, eax

; 147  : 	if (b <= a) return a;

	ja	SHORT $LN12@FlowInterE
	mov	edi, eax
	jmp	SHORT $LN14@FlowInterE
$LN12@FlowInterE:
	cmp	ecx, edi

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	cmovbe	edi, ecx
$LN14@FlowInterE:
	cmp	edx, eax

; 147  : 	if (b <= a) return a;

	jbe	SHORT $LN20@FlowInterE
	cmp	ecx, edx

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	mov	eax, edx
	cmovbe	eax, ecx
$LN20@FlowInterE:

; 273  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +
; 274  : //			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*time256 )>>8;
; 275  :              // use median, firsly get min max of compensations
; 276  :              int minfb;
; 277  :              int maxfb;
; 278  :              if (dstF > dstB) {
; 279  :                  minfb = dstB;
; 280  :                  maxfb = dstF;
; 281  :              } else {
; 282  :                  maxfb = dstB;
; 283  :                  minfb = dstF;
; 284  :              }
; 285  :              // PF todo check: +255 is bits_per_pixel-aware?
; 286  :              pdst[w] = (((Median3r(minfb, dstBB, maxfb)*MaskF[w] + dstF*(255-MaskF[w])+255)>>8)*(256-time256) +

	mov	ecx, DWORD PTR tv1528[esp+84]
	movzx	esi, BYTE PTR [ebp]
	imul	eax, esi
	movzx	edx, BYTE PTR [ecx+ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, edx
	inc	ebp
	imul	ecx, DWORD PTR _dstF$1$[esp+84]
	imul	edx, edi
	mov	edi, DWORD PTR tv1539[esp+84]
	add	ecx, 255				; 000000ffH
	add	edx, ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, esi
	sar	edx, 8
	imul	ecx, DWORD PTR _dstB$1$[esp+84]
	imul	edx, edi
	add	ecx, 255				; 000000ffH
	add	eax, ecx
	mov	ecx, DWORD PTR _w$1$[esp+84]
	sar	eax, 8
	inc	ecx
	imul	eax, DWORD PTR _time256$[esp+80]
	mov	DWORD PTR _w$1$[esp+84], ecx
	add	edx, eax
	mov	eax, DWORD PTR tv1529[esp+84]
	sar	edx, 8
	mov	WORD PTR [ebx+eax], dx
	add	ebx, 2
	cmp	ecx, DWORD PTR _width$[esp+80]
	jl	$LL7@FlowInterE
	mov	edx, DWORD PTR _VYFullB$[esp+80]
	mov	esi, DWORD PTR _VXFullF$[esp+80]
	mov	eax, DWORD PTR _prefB8$[esp+80]
	mov	ebx, DWORD PTR _pdst$1$[esp+84]
	mov	ebp, DWORD PTR tv1536[esp+84]
$LN6@FlowInterE:

; 287  :                         ((Median3r(minfb, dstFF, maxfb)*MaskB[w] + dstB*(255-MaskB[w])+255)>>8)*     time256   )>>8;
; 288  : 		}
; 289  : 		pdst += dst_pitch;
; 290  : 		prefB += ref_pitch<<NPELL2;
; 291  : 		prefF += ref_pitch<<NPELL2;
; 292  : 		//t256_provider.jump_to_next_row ();
; 293  : 		VXFullB += VPitch;
; 294  : 		VYFullB += VPitch;
; 295  : 		VXFullF += VPitch;
; 296  : 		VYFullF += VPitch;
; 297  : 		MaskB += VPitch;

	mov	ecx, DWORD PTR _VPitch$[esp+80]
	add	edx, ebp
	add	ebx, DWORD PTR tv1538[esp+84]
	add	esi, ebp
	add	eax, DWORD PTR tv1537[esp+84]
	add	DWORD PTR _MaskB$[esp+80], ecx

; 298  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+80], ecx
	sub	DWORD PTR _height$[esp+80], 1
	mov	DWORD PTR _pdst$1$[esp+84], ebx
	mov	DWORD PTR _prefB8$[esp+80], eax
	mov	DWORD PTR _VYFullB$[esp+80], edx
	mov	DWORD PTR _VXFullF$[esp+80], esi
	jne	$LL4@FlowInterE
	pop	edi
	pop	esi
	pop	ebp
$LN3@FlowInterE:
	pop	ebx

; 299  : 		VXFullBB += VPitch;
; 300  : 		VYFullBB += VPitch;
; 301  : 		VXFullFF += VPitch;
; 302  : 		VYFullFF += VPitch;
; 303  : 	}
; 304  : }

	add	esp, 68					; 00000044H
	ret	0
??$FlowInterExtra_NPel@G$00@@YAXPAEHPBE1HPAF22200HHHH2222@Z ENDP ; FlowInterExtra_NPel<unsigned short,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\maskfun.hpp
;	COMDAT ??$FlowInterExtra_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z
_TEXT	SEGMENT
_dstB$1$ = -68						; size = 4
_pdst$1$ = -64						; size = 4
_dstF$1$ = -60						; size = 4
_w$1$ = -56						; size = 4
tv1495 = -52						; size = 4
tv1487 = -48						; size = 4
tv1491 = -44						; size = 4
tv1504 = -40						; size = 4
tv1497 = -36						; size = 4
tv1489 = -32						; size = 4
tv1493 = -28						; size = 4
tv1502 = -24						; size = 4
tv1513 = -20						; size = 4
tv1503 = -16						; size = 4
tv1510 = -12						; size = 4
tv1512 = -8						; size = 4
tv1511 = -4						; size = 4
_prefB8$ = 8						; size = 4
_prefF8$ = 12						; size = 4
_ref_pitch$ = 16					; size = 4
_VXFullB$ = 20						; size = 4
_VXFullF$ = 24						; size = 4
_VYFullB$ = 28						; size = 4
_VYFullF$ = 32						; size = 4
_MaskB$ = 36						; size = 4
_MaskF$ = 40						; size = 4
_VPitch$ = 44						; size = 4
_width$ = 48						; size = 4
_height$ = 52						; size = 4
_time256$ = 56						; size = 4
_VXFullBB$ = 60						; size = 4
_VXFullFF$ = 64						; size = 4
_VYFullBB$ = 68						; size = 4
_VYFullFF$ = 72						; size = 4
??$FlowInterExtra_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z PROC ; FlowInterExtra_NPel<unsigned short,2>, COMDAT
; _pdst8$ = ecx
; _dst_pitch$ = edx

; 234  : {

	sub	esp, 68					; 00000044H

; 235  :   dst_pitch /= sizeof(pixel_t);
; 236  :   ref_pitch /= sizeof(pixel_t);

	mov	eax, DWORD PTR _ref_pitch$[esp+64]
	shr	eax, 1
	shr	edx, 1

; 237  :   pixel_t *pdst = reinterpret_cast<pixel_t *>(pdst8);
; 238  :   const pixel_t *prefB = reinterpret_cast<const pixel_t *>(prefB8);
; 239  :   const pixel_t *prefF = reinterpret_cast<const pixel_t *>(prefF8);
; 240  : 
; 241  : 	for (int h=0; h<height; h++)

	cmp	DWORD PTR _height$[esp+64], 0
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _pdst$1$[esp+72], ecx
	mov	DWORD PTR _ref_pitch$[esp+68], eax
	jle	$LN3@FlowInterE
	shl	eax, 3
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _VYFullB$[esp+68]
	sub	DWORD PTR _VXFullB$[esp+68], edx
	sub	DWORD PTR _VYFullF$[esp+68], edx
	sub	DWORD PTR _VXFullBB$[esp+68], edx
	sub	DWORD PTR _VXFullFF$[esp+68], edx
	sub	DWORD PTR _VYFullBB$[esp+68], edx
	mov	DWORD PTR tv1511[esp+72], eax
	mov	eax, DWORD PTR _VPitch$[esp+68]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _VXFullF$[esp+76]
	lea	ebp, DWORD PTR [eax+eax]
	mov	DWORD PTR tv1512[esp+80], ecx
	mov	eax, DWORD PTR _prefB8$[esp+76]
	sub	DWORD PTR _prefF8$[esp+76], eax
	sub	DWORD PTR _VYFullFF$[esp+76], edx
	push	edi
	mov	DWORD PTR tv1510[esp+84], ebp
$LL4@FlowInterE:

; 242  : 	{
; 243  : 		for (int w=0; w<width; w++)

	xor	ecx, ecx
	mov	DWORD PTR _w$1$[esp+84], ecx
	cmp	DWORD PTR _width$[esp+80], ecx
	jle	$LN6@FlowInterE
	mov	eax, DWORD PTR _VYFullF$[esp+80]
	mov	edi, 256				; 00000100H
	sub	eax, esi
	sub	edi, DWORD PTR _time256$[esp+80]
	add	eax, edx
	mov	ebp, DWORD PTR _MaskB$[esp+80]
	mov	DWORD PTR tv1495[esp+84], eax
	mov	ebx, esi
	mov	eax, DWORD PTR _VYFullFF$[esp+80]
	sub	eax, esi
	mov	DWORD PTR tv1513[esp+84], edi
	add	eax, edx
	mov	DWORD PTR tv1487[esp+84], eax
	mov	eax, DWORD PTR _VXFullFF$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1491[esp+84], eax
	mov	eax, edx
	sub	eax, esi
	mov	DWORD PTR tv1504[esp+84], eax
	mov	eax, DWORD PTR _VXFullB$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1497[esp+84], eax
	mov	eax, DWORD PTR _VYFullBB$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1489[esp+84], eax
	mov	eax, DWORD PTR _VXFullBB$[esp+80]
	sub	eax, esi
	add	eax, edx
	mov	DWORD PTR tv1493[esp+84], eax
	mov	eax, DWORD PTR _pdst$1$[esp+84]
	sub	eax, esi
	mov	DWORD PTR tv1503[esp+84], eax
	mov	eax, DWORD PTR _MaskF$[esp+80]
	sub	eax, ebp
	mov	DWORD PTR tv1502[esp+84], eax
	npad	6
$LL7@FlowInterE:

; 244  : 		{
; 245  : 			//const int		time256 = t256_provider.get_t (w);
; 246  : 
; 247  : 			//int vxF = t256_provider.get_vect_f (time256, VXFullF[w]); 2.6.0.5
; 248  : 			//int vyF = t256_provider.get_vect_f (time256, VYFullF[w]); 2.6.0.5
; 249  :       int vxF = (VXFullF[w] * time256) >> 8; // 2.5.11.22
; 250  :       int vyF = (VYFullF[w] * time256) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1495[esp+84]
	lea	esi, DWORD PTR [ecx*4]

; 251  :       int adrF = vyF*ref_pitch + vxF + (w<<NPELL2);
; 252  : 			int dstF = prefF[adrF];

	mov	edx, DWORD PTR _prefF8$[esp+80]
	add	edx, DWORD PTR _prefB8$[esp+80]
	movsx	ecx, WORD PTR [ebx+eax]
	imul	ecx, DWORD PTR _time256$[esp+80]
	movsx	eax, WORD PTR [ebx]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8
	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	movzx	eax, WORD PTR [edx+eax*2]
	mov	DWORD PTR _dstF$1$[esp+84], eax

; 253  : //			int dstF0 = prefF[(w<<NPELL2)]; // zero
; 254  : 			//int vxFF = t256_provider.get_vect_f (time256, VXFullFF[w]); 2.6.0.5
; 255  : 			//int vyFF = t256_provider.get_vect_f (time256, VYFullFF[w]); 2.6.0.5
; 256  :       int vxFF = (VXFullFF[w] * time256) >> 8; // is it correct time?
; 257  :       int vyFF = (VYFullFF[w] * time256) >> 8;  // 2.5.11.22

	mov	eax, DWORD PTR tv1487[esp+84]
	movsx	ecx, WORD PTR [ebx+eax]
	imul	ecx, DWORD PTR _time256$[esp+80]
	mov	eax, DWORD PTR tv1491[esp+84]
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, DWORD PTR _time256$[esp+80]
	sar	ecx, 8

; 258  :       int adrFF = vyFF*ref_pitch + vxFF + (w<<NPELL2);
; 259  : 			int dstFF = prefF[adrFF];

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	movzx	edx, WORD PTR [edx+eax*2]

; 260  : 			//int vxB = t256_provider.get_vect_b (time256, VXFullB[w]); 2.6.0.5
; 261  : 			//int vyB = t256_provider.get_vect_b (time256, VYFullB[w]); 2.6.0.5
; 262  :       int vxB = (VXFullB[w] * (256 - time256)) >> 8; // 2.5.11.22
; 263  :       int vyB = (VYFullB[w] * (256 - time256)) >> 8; // 2.5.11.22

	mov	eax, DWORD PTR tv1504[esp+84]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1497[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, edi
	sar	ecx, 8

; 264  :       int adrB = vyB*ref_pitch + vxB + (w<<NPELL2);
; 265  : 			int dstB = prefB[adrB];

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _dstB$1$[esp+84], eax

; 266  : //			int dstB0 = prefB[(w<<NPELL2)]; // zero
; 267  : 			//int vxBB = t256_provider.get_vect_b (time256, VXFullBB[w]); 2.6.0.5
; 268  : 			//int vyBB = t256_provider.get_vect_b (time256, VYFullBB[w]); 2.6.0.5
; 269  :       int vxBB = (VXFullBB[w] * (256 - time256)) >> 8;
; 270  :       int vyBB = (VYFullBB[w] * (256 - time256)) >> 8;

	mov	eax, DWORD PTR tv1489[esp+84]
	movsx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv1493[esp+84]
	imul	ecx, edi
	movsx	eax, WORD PTR [ebx+eax]
	imul	eax, edi
	sar	ecx, 8

; 271  :       int adrBB = vyBB*ref_pitch + vxBB + (w<<NPELL2);
; 272  : 			int dstBB = prefB[adrBB];

	imul	ecx, DWORD PTR _ref_pitch$[esp+80]
	sar	eax, 8
	add	ecx, esi
	mov	esi, DWORD PTR _dstF$1$[esp+84]
	add	eax, ecx
	mov	ecx, DWORD PTR _prefB8$[esp+80]
	movzx	edi, WORD PTR [ecx+eax*2]
	mov	ecx, esi
	mov	eax, DWORD PTR _dstB$1$[esp+84]
	cmp	esi, eax
	cmovbe	ecx, eax
	cmp	esi, eax
	cmovbe	eax, esi
	cmp	edi, eax

; 147  : 	if (b <= a) return a;

	ja	SHORT $LN12@FlowInterE
	mov	edi, eax
	jmp	SHORT $LN14@FlowInterE
$LN12@FlowInterE:
	cmp	ecx, edi

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	cmovbe	edi, ecx
$LN14@FlowInterE:
	cmp	edx, eax

; 147  : 	if (b <= a) return a;

	jbe	SHORT $LN20@FlowInterE
	cmp	ecx, edx

; 148  : 	// a c b
; 149  : 	else  if (c <= b) return c;

	mov	eax, edx
	cmovbe	eax, ecx
$LN20@FlowInterE:

; 273  : //			pdst[w] = ( ( (dstF*(255-MaskF[w]) + ((MaskF[w]*(dstB*(255-MaskB[w])+MaskB[w]*dstF0)+255)>>8) + 255)>>8 )*(256-time256) +
; 274  : //			            ( (dstB*(255-MaskB[w]) + ((MaskB[w]*(dstF*(255-MaskF[w])+MaskF[w]*dstB0)+255)>>8) + 255)>>8 )*time256 )>>8;
; 275  :              // use median, firsly get min max of compensations
; 276  :              int minfb;
; 277  :              int maxfb;
; 278  :              if (dstF > dstB) {
; 279  :                  minfb = dstB;
; 280  :                  maxfb = dstF;
; 281  :              } else {
; 282  :                  maxfb = dstB;
; 283  :                  minfb = dstF;
; 284  :              }
; 285  :              // PF todo check: +255 is bits_per_pixel-aware?
; 286  :              pdst[w] = (((Median3r(minfb, dstBB, maxfb)*MaskF[w] + dstF*(255-MaskF[w])+255)>>8)*(256-time256) +

	mov	ecx, DWORD PTR tv1502[esp+84]
	movzx	esi, BYTE PTR [ebp]
	imul	eax, esi
	movzx	edx, BYTE PTR [ecx+ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, edx
	inc	ebp
	imul	ecx, DWORD PTR _dstF$1$[esp+84]
	imul	edx, edi
	mov	edi, DWORD PTR tv1513[esp+84]
	add	ecx, 255				; 000000ffH
	add	edx, ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, esi
	sar	edx, 8
	imul	ecx, DWORD PTR _dstB$1$[esp+84]
	imul	edx, edi
	add	ecx, 255				; 000000ffH
	add	eax, ecx
	mov	ecx, DWORD PTR _w$1$[esp+84]
	sar	eax, 8
	inc	ecx
	imul	eax, DWORD PTR _time256$[esp+80]
	mov	DWORD PTR _w$1$[esp+84], ecx
	add	edx, eax
	mov	eax, DWORD PTR tv1503[esp+84]
	sar	edx, 8
	mov	WORD PTR [ebx+eax], dx
	add	ebx, 2
	cmp	ecx, DWORD PTR _width$[esp+80]
	jl	$LL7@FlowInterE
	mov	edx, DWORD PTR _VYFullB$[esp+80]
	mov	esi, DWORD PTR _VXFullF$[esp+80]
	mov	eax, DWORD PTR _prefB8$[esp+80]
	mov	ebx, DWORD PTR _pdst$1$[esp+84]
	mov	ebp, DWORD PTR tv1510[esp+84]
$LN6@FlowInterE:

; 287  :                         ((Median3r(minfb, dstFF, maxfb)*MaskB[w] + dstB*(255-MaskB[w])+255)>>8)*     time256   )>>8;
; 288  : 		}
; 289  : 		pdst += dst_pitch;
; 290  : 		prefB += ref_pitch<<NPELL2;
; 291  : 		prefF += ref_pitch<<NPELL2;
; 292  : 		//t256_provider.jump_to_next_row ();
; 293  : 		VXFullB += VPitch;
; 294  : 		VYFullB += VPitch;
; 295  : 		VXFullF += VPitch;
; 296  : 		VYFullF += VPitch;
; 297  : 		MaskB += VPitch;

	mov	ecx, DWORD PTR _VPitch$[esp+80]
	add	edx, ebp
	add	ebx, DWORD PTR tv1512[esp+84]
	add	esi, ebp
	add	eax, DWORD PTR tv1511[esp+84]
	add	DWORD PTR _MaskB$[esp+80], ecx

; 298  : 		MaskF += VPitch;

	add	DWORD PTR _MaskF$[esp+80], ecx
	sub	DWORD PTR _height$[esp+80], 1
	mov	DWORD PTR _pdst$1$[esp+84], ebx
	mov	DWORD PTR _prefB8$[esp+80], eax
	mov	DWORD PTR _VYFullB$[esp+80], edx
	mov	DWORD PTR _VXFullF$[esp+80], esi
	jne	$LL4@FlowInterE
	pop	edi
	pop	esi
	pop	ebp
$LN3@FlowInterE:
	pop	ebx

; 299  : 		VXFullBB += VPitch;
; 300  : 		VYFullBB += VPitch;
; 301  : 		VXFullFF += VPitch;
; 302  : 		VYFullFF += VPitch;
; 303  : 	}
; 304  : }

	add	esp, 68					; 00000044H
	ret	0
??$FlowInterExtra_NPel@G$01@@YAXPAEHPBE1HPAF22200HHHH2222@Z ENDP ; FlowInterExtra_NPel<unsigned short,2>
_TEXT	ENDS
END
