; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\dctint.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_7DCTINT@@6B@					; DCTINT::`vftable'
PUBLIC	??_R0?AVDCTINT@@@8				; DCTINT `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@DCTINT@@8				; DCTINT::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3DCTINT@@8					; DCTINT::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DCTINT@@8					; DCTINT::`RTTI Base Class Array'
PUBLIC	??_R4DCTINT@@6B@				; DCTINT::`RTTI Complete Object Locator'
EXTRN	_fdct_sse2:PROC
EXTRN	__imp___aligned_malloc:PROC
EXTRN	__imp___aligned_free:PROC
;	COMDAT ??_R4DCTINT@@6B@
rdata$r	SEGMENT
??_R4DCTINT@@6B@ DD 00H					; DCTINT::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDCTINT@@@8
	DD	FLAT:??_R3DCTINT@@8
rdata$r	ENDS
;	COMDAT ??_R2DCTINT@@8
rdata$r	SEGMENT
??_R2DCTINT@@8 DD FLAT:??_R1A@?0A@EA@DCTINT@@8		; DCTINT::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DCTClass@@8
rdata$r	ENDS
;	COMDAT ??_R3DCTINT@@8
rdata$r	SEGMENT
??_R3DCTINT@@8 DD 00H					; DCTINT::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DCTINT@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@DCTINT@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DCTINT@@8 DD FLAT:??_R0?AVDCTINT@@@8	; DCTINT::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DCTINT@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDCTINT@@@8
data$r	SEGMENT
??_R0?AVDCTINT@@@8 DD FLAT:??_7type_info@@6B@		; DCTINT `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDCTINT@@', 00H
data$r	ENDS
;	COMDAT ??_7DCTINT@@6B@
CONST	SEGMENT
??_7DCTINT@@6B@ DD FLAT:??_R4DCTINT@@6B@		; DCTINT::`vftable'
	DD	FLAT:?DCTBytes2D@DCTINT@@UAEXPBEHPAEH@Z
PUBLIC	?DCTBytes2D@DCTINT@@UAEXPBEHPAEH@Z		; DCTINT::DCTBytes2D
PUBLIC	??0DCTINT@@QAE@HHH@Z				; DCTINT::DCTINT
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\dctint.cpp
;	COMDAT ??0DCTINT@@QAE@HHH@Z
_TEXT	SEGMENT
__sizex$ = 8						; size = 4
__sizey$ = 12						; size = 4
__dctmode$ = 16						; size = 4
??0DCTINT@@QAE@HHH@Z PROC				; DCTINT::DCTINT, COMDAT
; _this$ = ecx

; 67   : 	// only 8x8 implemented !
; 68   : 		sizex = _sizex;

	mov	eax, DWORD PTR __sizex$[esp-4]
	push	esi
	mov	esi, ecx

; 69   : 		sizey = _sizey;
; 70   : 		dctmode = _dctmode;
; 71   : //		int size2d = sizey*sizex;
; 72   : //		int cursize = 1;
; 73   : //		dctshift = 0;
; 74   : //		while (cursize < size2d) 
; 75   : //		{
; 76   : //			dctshift++;
; 77   : //			cursize = (cursize<<1);
; 78   : //		}
; 79   : 		
; 80   : 
; 81   : 		pWorkArea = (short * const) _aligned_malloc(8*8*2, 128);

	push	128					; 00000080H
	push	128					; 00000080H
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __sizey$[esp+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __dctmode$[esp+8]
	mov	DWORD PTR [esi], OFFSET ??_7DCTINT@@6B@
	mov	DWORD PTR [esi+12], eax
	call	DWORD PTR __imp___aligned_malloc
	add	esp, 8
	mov	DWORD PTR [esi+24], eax

; 82   : 
; 83   : 
; 84   : }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
??0DCTINT@@QAE@HHH@Z ENDP				; DCTINT::DCTINT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\dctint.cpp
;	COMDAT ?DCTBytes2D@DCTINT@@UAEXPBEHPAEH@Z
_TEXT	SEGMENT
_pDestW$1$ = -76					; size = 4
tv1835 = -72						; size = 4
tv1844 = -68						; size = 4
tv1853 = -64						; size = 4
tv1871 = -60						; size = 4
tv1887 = -56						; size = 4
tv1910 = -52						; size = 4
_pWorkAreaW$1$ = -48					; size = 4
tv1856 = -44						; size = 4
tv1898 = -40						; size = 4
tv1884 = -36						; size = 4
tv1883 = -32						; size = 4
tv1892 = -28						; size = 4
tv1891 = -24						; size = 4
tv1890 = -20						; size = 4
tv1889 = -16						; size = 4
tv1888 = -12						; size = 4
tv1900 = -8						; size = 4
tv1899 = -4						; size = 4
_srcp$ = 8						; size = 4
_src_pit$ = 12						; size = 4
_dstp$ = 16						; size = 4
_dst_pit$ = 20						; size = 4
?DCTBytes2D@DCTINT@@UAEXPBEHPAEH@Z PROC			; DCTINT::DCTBytes2D, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 80					; 00000050H

; 96   : 	if ( (sizex != 8) || (sizey != 8) ) // may be sometime we will implement 4x4 and 16x16 dct

	cmp	DWORD PTR [ecx+4], 8
	push	esi
	push	edi
	jne	$LN9@DCTBytes2D
	cmp	DWORD PTR [ecx+8], 8
	jne	$LN9@DCTBytes2D

; 97   : 		return;
; 98   : 
; 99   : 	int rowsize = sizex;
; 100  : 	int FldHeight = sizey;
; 101  : 	int dctshift0ext = 4 - DCTSHIFT;// for DC component
; 102  : 
; 103  : 
; 104  : 	const uint8_t * pSrc = srcp;
; 105  : 	const uint8_t * pSrcW;
; 106  : 	uint8_t * pDest = dstp;
; 107  : 	uint8_t * pDestW;
; 108  : 
; 109  : 	const unsigned __int64 i128 = 0x8080808080808080;
; 110  : 
; 111  : 	int y;
; 112  : 	int ct = (rowsize/8);
; 113  : 	int ctW;
; 114  : 	//short* pFactors = &factors[0][0];
; 115  : 	short* pWorkAreaW = pWorkArea;			// so inline asm can access

	mov	eax, DWORD PTR [ecx+24]
	mov	esi, DWORD PTR _dst_pit$[ebp]
	mov	edi, DWORD PTR _srcp$[ebp]
	mov	edx, DWORD PTR _dstp$[ebp]
	mov	DWORD PTR _pWorkAreaW$1$[esp+88], eax
	mov	eax, DWORD PTR _src_pit$[ebp]
	mov	DWORD PTR tv1910[esp+88], 1
	lea	ecx, DWORD PTR [eax*8]
	mov	DWORD PTR tv1900[esp+88], ecx
	lea	ecx, DWORD PTR [esi*8]
	mov	DWORD PTR tv1899[esp+88], ecx
$LL4@DCTBytes2D:

; 116  : 
; 117  : /* PF: Test with 0<dct<5 and BlockSize==8
; 118  : a=a.QTGMC(Preset="Slower",dct=3, BlockSize=8, ChromaMotion=true)
; 119  : sup = a.MSuper(pel=1)
; 120  : fw = sup.MAnalyse(isb=false, delta=1, overlap=4)
; 121  : bw = sup.MAnalyse(isb=true, delta=1, overlap=4)
; 122  : a=a.MFlowInter(sup, bw, fw, time=50, thSCD1=400)
; 123  : a
; 124  : */
; 125  : #define USE_SSE2_DCTINT_INTRINSIC
; 126  : 
; 127  : 	for (y=0; y <= FldHeight-8; y+=8)
; 128  : 	{
; 129  : 		pSrcW = pSrc;
; 130  : 		pDestW = pDest;

	add	eax, eax
	mov	DWORD PTR _pDestW$1$[esp+88], edx
	lea	ecx, DWORD PTR [esi+esi]
	mov	DWORD PTR tv1887[esp+88], 1
	lea	esi, DWORD PTR [ecx+edx]
	xorps	xmm3, xmm3
	mov	DWORD PTR tv1871[esp+88], esi
	lea	esi, DWORD PTR [eax+edi]
	mov	DWORD PTR tv1835[esp+88], esi
	lea	esi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR tv1844[esp+88], esi
	lea	esi, DWORD PTR [edi+eax*2]
	add	esi, eax
	mov	DWORD PTR tv1853[esp+88], esi
	mov	esi, DWORD PTR _src_pit$[ebp]
	shl	esi, 3
	sub	esi, DWORD PTR _src_pit$[ebp]
	add	esi, edi
	mov	DWORD PTR tv1856[esp+88], esi

; 131  : 		ctW = ct;
; 132  : #ifdef USE_SSE2_DCTINT_INTRINSIC
; 133  :     // rewritten by PF for SSE2 intrinsics instead of MMX inline asm
; 134  :     for(int i=0; i<ctW; i++)

	mov	esi, DWORD PTR _src_pit$[ebp]
	sub	esi, eax
	mov	eax, edi
	sub	eax, edx
	mov	DWORD PTR tv1884[esp+88], esi
	mov	esi, DWORD PTR _dst_pit$[ebp]
	mov	DWORD PTR tv1898[esp+88], eax
	mov	eax, esi
	sub	eax, ecx
	mov	edi, DWORD PTR tv1856[esp+88]
	mov	DWORD PTR tv1883[esp+88], eax
	lea	eax, DWORD PTR [esi+esi*2]
	sub	eax, ecx
	mov	DWORD PTR tv1892[esp+88], eax
	lea	eax, DWORD PTR [esi*4]
	sub	eax, ecx
	mov	DWORD PTR tv1891[esp+88], eax
	lea	eax, DWORD PTR [esi+esi*4]
	sub	eax, ecx
	mov	DWORD PTR tv1890[esp+88], eax
	lea	eax, DWORD PTR [esi+esi*2]
	add	eax, eax
	sub	eax, ecx
	mov	DWORD PTR tv1889[esp+88], eax
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	mov	esi, DWORD PTR _pWorkAreaW$1$[esp+88]
	sub	eax, ecx
	mov	DWORD PTR tv1888[esp+88], eax
	mov	eax, DWORD PTR tv1853[esp+88]
$LL7@DCTBytes2D:

; 135  :     {
; 136  :       __m128i zero = _mm_setzero_si128();
; 137  :     __m128i src0 = zero, src1 = zero, src0_8words, src1_8words;
; 138  :     const uint8_t *tmp_pSrcW = pSrcW;
; 139  :     // 8-8 bytes #0-#1 (8: DCTINT 8 implementation)
; 140  :     src0 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src0), reinterpret_cast<const double *>(tmp_pSrcW)));  // load the lower 64 bits from (unaligned) ptr

	mov	ecx, DWORD PTR tv1898[esp+88]
	movaps	xmm1, xmm3

; 141  :     src1 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src1), reinterpret_cast<const double *>(tmp_pSrcW+src_pit)));

	movaps	xmm2, xmm3

; 142  :     src0_8words = _mm_unpacklo_epi8(src0, zero);  // 8 bytes -> 8 words
; 143  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+0*8), src0_8words);
; 144  :     src1_8words = _mm_unpacklo_epi8(src1, zero);  // 8 bytes -> 8 words
; 145  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+1*8), src1_8words);
; 146  :     tmp_pSrcW += 2 * src_pit;
; 147  : 
; 148  :     // 8-8 bytes #2-#3 (8: DCTINT 8 implementation)
; 149  :     src0 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src0), reinterpret_cast<const double *>(tmp_pSrcW)));  // load the lower 64 bits from (unaligned) ptr
; 150  :     src1 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src1), reinterpret_cast<const double *>(tmp_pSrcW+src_pit)));
; 151  :     src0_8words = _mm_unpacklo_epi8(src0, zero);  // 8 bytes -> 8 words
; 152  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+2*8), src0_8words);
; 153  :     src1_8words = _mm_unpacklo_epi8(src1, zero);  // 8 bytes -> 8 words
; 154  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+3*8), src1_8words);
; 155  :     tmp_pSrcW += 2 * src_pit;
; 156  : 
; 157  :     // 8-8 bytes #4-#5 (8: DCTINT 8 implementation)
; 158  :     src0 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src0), reinterpret_cast<const double *>(tmp_pSrcW)));  // load the lower 64 bits from (unaligned) ptr
; 159  :     src1 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src1), reinterpret_cast<const double *>(tmp_pSrcW+src_pit)));
; 160  :     src0_8words = _mm_unpacklo_epi8(src0, zero);  // 8 bytes -> 8 words
; 161  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+4*8), src0_8words);
; 162  :     src1_8words = _mm_unpacklo_epi8(src1, zero);  // 8 bytes -> 8 words
; 163  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+5*8), src1_8words);
; 164  :     tmp_pSrcW += 2 * src_pit;
; 165  : 
; 166  :     // 8-8 bytes #6-#7 (8: DCTINT 8 implementation)
; 167  :     src0 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src0), reinterpret_cast<const double *>(tmp_pSrcW)));  // load the lower 64 bits from (unaligned) ptr
; 168  :     src1 = _mm_castpd_si128(_mm_loadl_pd(_mm_castsi128_pd(src1), reinterpret_cast<const double *>(tmp_pSrcW+src_pit)));
; 169  :     src0_8words = _mm_unpacklo_epi8(src0, zero);  // 8 bytes -> 8 words
; 170  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+6*8), src0_8words);
; 171  :     src1_8words = _mm_unpacklo_epi8(src1, zero);  // 8 bytes -> 8 words
; 172  :     _mm_storeu_si128(reinterpret_cast<__m128i *>(pWorkAreaW+7*8), src1_8words);
; 173  : 
; 174  :     pSrcW += 8;
; 175  : 
; 176  :     fdct_sse2(pWorkAreaW);					// go do forward DCT

	push	esi
	movlpd	xmm1, QWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR tv1884[esp+92]
	movaps	xmm0, xmm1
	mov	edx, DWORD PTR tv1835[esp+92]
	punpcklbw xmm0, xmm3
	movlpd	xmm2, QWORD PTR [ecx+edx]
	movups	XMMWORD PTR [esi], xmm0
	movaps	xmm0, xmm2
	punpcklbw xmm0, xmm3
	movups	XMMWORD PTR [esi+16], xmm0
	movlpd	xmm1, QWORD PTR [edx]
	mov	edx, DWORD PTR tv1844[esp+92]
	movaps	xmm0, xmm1
	punpcklbw xmm0, xmm3
	movlpd	xmm2, QWORD PTR [ecx+edx]
	movups	XMMWORD PTR [esi+32], xmm0
	movaps	xmm0, xmm2
	punpcklbw xmm0, xmm3
	movups	XMMWORD PTR [esi+48], xmm0
	movlpd	xmm1, QWORD PTR [edx]
	movlpd	xmm2, QWORD PTR [ecx+eax]
	movaps	xmm0, xmm1
	punpcklbw xmm0, xmm3
	movups	XMMWORD PTR [esi+64], xmm0
	movaps	xmm0, xmm2
	punpcklbw xmm0, xmm3
	movups	XMMWORD PTR [esi+80], xmm0
	movlpd	xmm1, QWORD PTR [eax]
	movlpd	xmm2, QWORD PTR [edi]
	punpcklbw xmm1, xmm3
	punpcklbw xmm2, xmm3
	movups	XMMWORD PTR [esi+96], xmm1
	movups	XMMWORD PTR [esi+112], xmm2
	call	_fdct_sse2

; 177  : 
; 178  :     // decrease dc component
; 179  :     *(short *)(pWorkAreaW) >>= dctshift0ext; // PF instead of asm
; 180  : 
; 181  :     // decrease all components
; 182  : 
; 183  :     // lets adjust some of the DCT components
; 184  :     //		DO_ADJUST(pWorkAreaW);
; 185  :     __m128i signbits_byte = _mm_set1_epi8(-128); // prepare constant: bytes sign bits 0x80
; 186  :     uint8_t *tmp_pDestW_rdi = pDestW;
; 187  :     __m128i mm20, mm31, result;
; 188  : 
; 189  :     // #0-#1 of 8
; 190  :     mm20 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+0*8));
; 191  :     mm31 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+1*8));
; 192  :     mm20 = _mm_srai_epi16(mm20, DCTSHIFT); // decrease by bits shift from (-2047, +2047) to 
; 193  :     mm31 = _mm_srai_epi16(mm31, DCTSHIFT);
; 194  :     result = _mm_packs_epi16(mm20, mm31); // to bytes with signed saturation
; 195  :     result = _mm_xor_si128(result, signbits_byte); // convert to unsigned (0, 255) by adding 128
; 196  :     _mm_storel_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 0 * dst_pit), _mm_castsi128_pd(result)); // store lower 8 byte
; 197  :     _mm_storeh_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 1 * dst_pit), _mm_castsi128_pd(result)); // store upper 8 byte

	mov	ecx, DWORD PTR tv1871[esp+92]
	add	esp, 4
	sar	WORD PTR [esi], 2
	movups	xmm1, XMMWORD PTR [esi]
	mov	edx, DWORD PTR _pDestW$1$[esp+88]
	movups	xmm0, XMMWORD PTR [esi+16]
	mov	eax, DWORD PTR tv1883[esp+88]
	movaps	xmm2, XMMWORD PTR __xmm@80808080808080808080808080808080
	psraw	xmm1, 2
	psraw	xmm0, 2
	packsswb xmm1, xmm0
	pxor	xmm1, xmm2
	movlpd	QWORD PTR [edx], xmm1
	movhpd	QWORD PTR [eax+ecx], xmm1

; 198  :     // #2-#3 of 8
; 199  :     mm20 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+2*8));

	movups	xmm1, XMMWORD PTR [esi+32]

; 200  :     mm31 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+3*8));
; 201  :     mm20 = _mm_srai_epi16(mm20, DCTSHIFT); // decrease by bits shift from (-2047, +2047) to 
; 202  :     mm31 = _mm_srai_epi16(mm31, DCTSHIFT);
; 203  :     result = _mm_packs_epi16(mm20, mm31); // to bytes with signed saturation
; 204  :     result = _mm_xor_si128(result, signbits_byte); // convert to unsigned (0, 255) by adding 128
; 205  :     _mm_storel_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 2 * dst_pit), _mm_castsi128_pd(result)); // store lower 8 byte
; 206  :     _mm_storeh_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 3 * dst_pit), _mm_castsi128_pd(result)); // store upper 8 byte

	mov	eax, DWORD PTR tv1892[esp+88]
	movups	xmm0, XMMWORD PTR [esi+48]
	psraw	xmm1, 2
	psraw	xmm0, 2
	packsswb xmm1, xmm0
	pxor	xmm1, xmm2
	movlpd	QWORD PTR [ecx], xmm1
	movhpd	QWORD PTR [ecx+eax], xmm1

; 207  :     // #4-#5 of 8
; 208  :     mm20 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+4*8));

	movups	xmm1, XMMWORD PTR [esi+64]

; 209  :     mm31 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+5*8));
; 210  :     mm20 = _mm_srai_epi16(mm20, DCTSHIFT); // decrease by bits shift from (-2047, +2047) to 
; 211  :     mm31 = _mm_srai_epi16(mm31, DCTSHIFT);
; 212  :     result = _mm_packs_epi16(mm20, mm31); // to bytes with signed saturation
; 213  :     result = _mm_xor_si128(result, signbits_byte); // convert to unsigned (0, 255) by adding 128
; 214  :     _mm_storel_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 4 * dst_pit), _mm_castsi128_pd(result)); // store lower 8 byte

	mov	eax, DWORD PTR tv1891[esp+88]
	movups	xmm0, XMMWORD PTR [esi+80]
	psraw	xmm1, 2
	psraw	xmm0, 2
	packsswb xmm1, xmm0
	pxor	xmm1, xmm2
	movlpd	QWORD PTR [ecx+eax], xmm1

; 215  :     _mm_storeh_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 5 * dst_pit), _mm_castsi128_pd(result)); // store upper 8 byte

	mov	eax, DWORD PTR tv1890[esp+88]
	movhpd	QWORD PTR [ecx+eax], xmm1

; 216  :     // #6-#7 of 8
; 217  :     mm20 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+6*8));

	movups	xmm1, XMMWORD PTR [esi+96]

; 218  :     mm31 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(pWorkAreaW+7*8));
; 219  :     mm20 = _mm_srai_epi16(mm20, DCTSHIFT); // decrease by bits shift from (-2047, +2047) to 
; 220  :     mm31 = _mm_srai_epi16(mm31, DCTSHIFT);
; 221  :     result = _mm_packs_epi16(mm20, mm31); // to bytes with signed saturation
; 222  :     result = _mm_xor_si128(result, signbits_byte); // convert to unsigned (0, 255) by adding 128
; 223  :     _mm_storel_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 6 * dst_pit), _mm_castsi128_pd(result)); // store lower 8 byte

	mov	eax, DWORD PTR tv1889[esp+88]
	movups	xmm0, XMMWORD PTR [esi+112]
	psraw	xmm1, 2
	psraw	xmm0, 2
	packsswb xmm1, xmm0
	pxor	xmm1, xmm2
	movlpd	QWORD PTR [ecx+eax], xmm1

; 224  :     _mm_storeh_pd(reinterpret_cast<double *>(tmp_pDestW_rdi + 7 * dst_pit), _mm_castsi128_pd(result)); // store upper 8 byte

	mov	eax, DWORD PTR tv1888[esp+88]
	movhpd	QWORD PTR [ecx+eax], xmm1

; 225  :     pDestW += 8;

	mov	eax, DWORD PTR tv1853[esp+88]
	lea	edi, DWORD PTR [edi+8]
	add	DWORD PTR tv1835[esp+88], 8
	add	edx, 8
	add	DWORD PTR tv1844[esp+88], 8
	add	eax, 8
	add	ecx, 8
	mov	DWORD PTR _pDestW$1$[esp+88], edx
	sub	DWORD PTR tv1887[esp+88], 1
	xorps	xmm3, xmm3
	mov	DWORD PTR tv1853[esp+88], eax
	mov	DWORD PTR tv1871[esp+88], ecx
	jne	$LL7@DCTBytes2D

; 226  :    } // for ctW
; 227  : 
; 228  : #else
; 229  : 		__asm
; 230  : 		{
; 231  : 		// Loop general reg usage
; 232  : 		//
; 233  : 		// ecx - inner loop counter
; 234  : 		// ebx - src pitch
; 235  : 		// edx - dest pitch
; 236  : 		// edi - dest
; 237  : 		// esi - src pixels
; 238  : 
; 239  : // SPLIT Qword
; 240  : 
; 241  : 		align 16
; 242  : LoopQ:	
; 243  : 		mov		rsi, pSrcW   
; 244  : 		lea		rax, [rsi+8]
; 245  : 		mov		pSrcW, rax					// save for next time
; 246  : 		mov		ebx, src_pit        // PF todo 160620 rbx??!! in theory, 32 bit operands are zero extended to 64 bit
; 247  : 		mov		rax, pWorkAreaW
; 248  : 
; 249  : 		// expand bytes to words in work area
; 250  :       // __m128i zero = _mm_setzero_si128()
; 251  : 		pxor	mm7, mm7
; 252  : //-----------------------
; 253  :       // __m128i src0 = _mm_move_epi64 (pSrcW);          // 8 bytes #0 DCTINT 8!
; 254  : 		movq	mm0, qword ptr[rsi]			// # 0
; 255  :       // __m128i src1 = _mm_move_epi64 (pSrcW+src_pit);  // 8 bytes #1
; 256  :     movq	mm2, qword ptr[rsi+rbx]		// # 1
; 257  : 
; 258  : 		movq	mm1, mm0
; 259  : 		punpcklbw mm0, mm7					// low bytes to words
; 260  : 		movq	qword ptr[rax], mm0			// low words to work area
; 261  : 		punpckhbw mm1, mm7					// high bytes to words
; 262  : 		movq	qword ptr[rax+8], mm1		// high words to work area
; 263  :   // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 264  :   // __m128i src0_8words = _mm_unpacklo_epi8(src0, zero);  // 8 bytes -> 8 words
; 265  :   // _mm_storeu_epi128(reinterpret_cast<__m128i *>(pWorkAreaW), src0_8words);
; 266  : 
; 267  : 		movq	mm3, mm2
; 268  : 		punpcklbw mm2, mm7					// low bytes to words
; 269  : 		movq	qword ptr[rax+1*16], mm2	// low words to work area
; 270  : 		punpckhbw mm3, mm7					// high bytes to words
; 271  : 		movq	qword ptr[rax+1*16+8], mm3	// high words to work area
; 272  :     // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 273  :     // __m128i src1_8words = _mm_unpacklo_epi8(src1, zero);  // 8 bytes -> 8 words
; 274  :     // void _mm_storeu_epi128(reinterpret_cast<__m128i *>(pWorkAreaW+1*16), src1_8words);
; 275  : 
; 276  : 		lea		rsi, [rsi+2*rbx]
; 277  :       // pSrcW += 2*src_pit;
; 278  : //-----------------------
; 279  :       // __m128i src2 = _mm_move_epi64 (pSrcW);          // 8 bytes #2 DCTINT 8!
; 280  :     movq	mm0, qword ptr[rsi]			// #2
; 281  :       // __m128i src3 = _mm_move_epi64 (pSrcW+src_pit);  // 8 bytes #3
; 282  :     movq	mm2, qword ptr[rsi+rbx]		// #3
; 283  : 
; 284  : 		movq	mm1, mm0
; 285  : 		punpcklbw mm0, mm7					// low bytes to words
; 286  : 		movq	qword ptr[rax+2*16], mm0	// low words to work area
; 287  : 		punpckhbw mm1, mm7					// high bytes to words
; 288  : 		movq	qword ptr[rax+2*16+8], mm1	// high words to work area
; 289  :     // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 290  :     // __m128i src2_8words = _mm_unpacklo_epi8(src2, zero);  // 8 bytes -> 8 words
; 291  :     // _mm_storeu_epi128(reinterpret_cast<__m128i *>(pWorkAreaW+2*16), src2_8words);
; 292  : 
; 293  : 		movq	mm3, mm2
; 294  : 		punpcklbw mm2, mm7					// low bytes to words
; 295  : 		movq	qword ptr[rax+3*16], mm2	// low words to work area
; 296  : 		punpckhbw mm3, mm7					// high bytes to words
; 297  : 		movq	qword ptr[rax+3*16+8], mm3	// high words to work area
; 298  :     // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 299  :     // __m128i src3_8words = _mm_unpacklo_epi8(src3, zero);  // 8 bytes -> 8 words
; 300  :     // _mm_storeu_epi128(reinterpret_cast<__m128i *>(pWorkAreaW+3*16), src3_8words);
; 301  : 
; 302  : 		lea		rsi, [rsi+2*rbx]
; 303  :       // pSrcW += 2*src_pit;
; 304  : //-----------------------
; 305  :     
; 306  :     // __m128i src4 = _mm_move_epi64 (pSrcW);          // 8 bytes #4 DCTINT 8!
; 307  :     movq	mm0, qword ptr[rsi]			// #4
; 308  :     // __m128i src5 = _mm_move_epi64 (pSrcW+src_pit);  // 8 bytes #5
; 309  :     movq	mm2, qword ptr[rsi+rbx]		// #5
; 310  : 
; 311  : 		movq	mm1, mm0
; 312  : 		punpcklbw mm0, mm7					// low bytes to words
; 313  : 		movq	qword ptr[rax+4*16], mm0	// low words to work area
; 314  : 		punpckhbw mm1, mm7					// high bytes to words
; 315  : 		movq	qword ptr[rax+4*16+8], mm1	// high words to work area
; 316  :     // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 317  :     // __m128i src4_8words = _mm_unpacklo_epi8(src4, zero);  // 8 bytes -> 8 words
; 318  :     // _mm_storeu_epi128(reinterpret_cast<__m128i *>(pWorkAreaW+4*16), src4_8words);
; 319  :     movq	mm3, mm2
; 320  : 		punpcklbw mm2, mm7					// low bytes to words
; 321  : 		movq	qword ptr[rax+5*16], mm2	// low words to work area
; 322  : 		punpckhbw mm3, mm7					// high bytes to words
; 323  : 		movq	qword ptr[rax+5*16+8], mm3	// high words to work area
; 324  :     // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 325  :     // __m128i src5_8words = _mm_unpacklo_epi8(src5, zero);  // 8 bytes -> 8 words
; 326  :     // _mm_storeu_epi128(reinterpret_cast<__m128i *>(short *pWorkAreaW+5*16), src5_8words);
; 327  : 
; 328  : 		lea		rsi, [rsi+2*rbx]
; 329  :     // pSrcW += 2*src_pit;
; 330  : 
; 331  : //-----------------------
; 332  : 
; 333  :     // __m128i src6 = _mm_move_epi64 (pSrcW);          // 8 bytes #6 DCTINT 8!
; 334  : 		movq	mm0, qword ptr[rsi]			// #6
; 335  :     // __m128i src7 = _mm_move_epi64 (pSrcW+src_pit);  // 8 bytes #7
; 336  :     movq	mm2, qword ptr[rsi+rbx]		// #7
; 337  : 
; 338  : 		movq	mm1, mm0
; 339  : 		punpcklbw mm0, mm7					// low bytes to words
; 340  : 		movq	qword ptr[rax+6*16], mm0	// low words to work area
; 341  : 		punpckhbw mm1, mm7					// high bytes to words
; 342  : 		movq	qword ptr[rax+6*16+8], mm1	// high words to work area
; 343  :     // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 344  :     // __m128i src6_8words = _mm_unpacklo_epi8(src6, zero);  // 8 bytes -> 8 words
; 345  :     // _mm_storeu_epi128(reinterpret_cast<__m128i *>(pWorkAreaW+6*16), src6_8words);
; 346  : 
; 347  : 		movq	mm3, mm2
; 348  : 		punpcklbw mm2, mm7					// low bytes to words
; 349  : 		movq	qword ptr[rax+7*16], mm2	// low words to work area
; 350  : 		punpckhbw mm3, mm7					// high bytes to words
; 351  : 		movq	qword ptr[rax+7*16+8], mm3	// high words to work area	
; 352  :     // assembly above uses 64 bit mmx registers, we can do it in one step in sse2
; 353  :     // __m128i src7_8words = _mm_unpacklo_epi8(src7, zero);  // 8 bytes -> 8 words
; 354  :     // _mm_storeu_epi128(reinterpret_cast<__m128i *>(pWorkAreaW+7*16), src7_8words);
; 355  :     } // end asm
; 356  : 
; 357  : 		
; 358  : 		fdct_sse2(pWorkAreaW);					// go do forward DCT
; 359  : 
; 360  :     // decrease dc component
; 361  :     *(short *)(pWorkAreaW) >>= dctshift0ext; // PF instead of asm
; 362  : #if 0
; 363  : 		_asm 
; 364  : 		{
; 365  : 			mov	rax, pWorkAreaW;
; 366  : 			mov ebx, [rax];
; 367  : 			mov ecx, dctshift0ext;
; 368  : 			sar bx, cl;
; 369  : 			mov [rax], ebx;
; 370  : 		}
; 371  : #endif
; 372  : 		_asm
; 373  : 		{
; 374  : 
; 375  : 		movq mm7, i128 // prepare constant: bytes sign bits
; 376  : 
; 377  : 		mov		rdi, pDestW					// got em, now store em
; 378  : 		lea		rax, [rdi+8]
; 379  : 		mov		pDestW, rax					// save for next time
; 380  : 		mov		edx, dst_pit 
; 381  : 
; 382  : 		mov		rax, pWorkAreaW
; 383  : 		// collapse words to bytes in dest
; 384  : 
; 385  : 		movq	mm0, qword ptr[rax]			// low qwords
; 386  : 		movq	mm1, qword ptr[rax+1*16]
; 387  : 		movq	mm2, qword ptr[rax+8]			// high qwords
; 388  : 		movq	mm3, qword ptr[rax+1*16+8]
; 389  : 		// decrease by bits shift from (-2047, +2047) to 
; 390  : 		psraw	mm0, DCTSHIFT  
; 391  : 		psraw	mm1, DCTSHIFT
; 392  : 		psraw	mm2, DCTSHIFT
; 393  : 		psraw	mm3, DCTSHIFT
; 394  : 		// to bytes with signed saturation
; 395  : 		packsswb mm0, mm2		
; 396  : 		packsswb mm1, mm3
; 397  : 		// convert to unsigned (0, 255) by adding 128
; 398  : 		pxor mm0, mm7     
; 399  : 		pxor mm1, mm7
; 400  : 		// store to dest
; 401  : 		movq	qword ptr[rdi], mm0	
; 402  : 		movq	qword ptr[rdi+rdx], mm1
; 403  : 
; 404  : 		//NEXT
; 405  : 		movq	mm0, qword ptr[rax+2*16]			// low qwords
; 406  : 		movq	mm1, qword ptr[rax+3*16]
; 407  : 		movq	mm2, qword ptr[rax+2*16+8]			// high qwords
; 408  : 		movq	mm3, qword ptr[rax+3*16+8]
; 409  : 		// decrease by bits shift from (-2047, +2047) to 
; 410  : 		psraw	mm0, DCTSHIFT  
; 411  : 		psraw	mm1, DCTSHIFT
; 412  : 		psraw	mm2, DCTSHIFT
; 413  : 		psraw	mm3, DCTSHIFT
; 414  : 		// to bytes with signed saturation
; 415  : 		packsswb mm0, mm2		
; 416  : 		packsswb mm1, mm3
; 417  : 		// convert to unsigned (0, 255) by adding 128
; 418  : 		pxor mm0, mm7     
; 419  : 		pxor mm1, mm7
; 420  : 		// store to dest
; 421  : 		lea		rdi, [rdi+2*rdx]
; 422  : 		movq	qword ptr[rdi], mm0	
; 423  : 		movq	qword ptr[rdi+rdx], mm1
; 424  : 
; 425  : 		//NEXT
; 426  : 		movq	mm0, qword ptr[rax+4*16]			// low qwords
; 427  : 		movq	mm1, qword ptr[rax+5*16]
; 428  : 		movq	mm2, qword ptr[rax+4*16+8]			// high qwords
; 429  : 		movq	mm3, qword ptr[rax+5*16+8]
; 430  : 		// decrease by bits shift from (-2047, +2047) to 
; 431  : 		psraw	mm0, DCTSHIFT  
; 432  : 		psraw	mm1, DCTSHIFT
; 433  : 		psraw	mm2, DCTSHIFT
; 434  : 		psraw	mm3, DCTSHIFT
; 435  : 		// to bytes with signed saturation
; 436  : 		packsswb mm0, mm2		
; 437  : 		packsswb mm1, mm3
; 438  : 		// convert to unsigned (0, 255) by adding 128
; 439  : 		pxor mm0, mm7     
; 440  : 		pxor mm1, mm7
; 441  : 		// store to dest
; 442  : 		lea		rdi, [rdi+2*rdx]
; 443  : 		movq	qword ptr[rdi], mm0	
; 444  : 		movq	qword ptr[rdi+rdx], mm1
; 445  : 
; 446  : 		//NEXT
; 447  : 		movq	mm0, qword ptr[rax+6*16]			// low qwords
; 448  : 		movq	mm1, qword ptr[rax+7*16]
; 449  : 		movq	mm2, qword ptr[rax+6*16+8]			// high qwords
; 450  : 		movq	mm3, qword ptr[rax+7*16+8]
; 451  : 		// decrease by bits shift from (-2047, +2047) to 
; 452  : 		psraw	mm0, DCTSHIFT  
; 453  : 		psraw	mm1, DCTSHIFT
; 454  : 		psraw	mm2, DCTSHIFT
; 455  : 		psraw	mm3, DCTSHIFT
; 456  : 		// to bytes with signed saturation
; 457  : 		packsswb mm0, mm2		
; 458  : 		packsswb mm1, mm3
; 459  : 		// convert to unsigned (0, 255) by adding 128
; 460  : 		pxor mm0, mm7     
; 461  : 		pxor mm1, mm7
; 462  : 		// store to dest
; 463  : 		lea		edi, [rdi+2*rdx]
; 464  : 		movq	qword ptr[rdi], mm0	
; 465  : 		movq	qword ptr[rdi+rdx], mm1
; 466  : 
; 467  : 	
; 468  : 		dec		ctW
; 469  : 		jnz		LoopQ
; 470  : 
; 471  : 		}
; 472  : #endif
; 473  : 
; 474  : 	// adjust for next line
; 475  : 	pSrc  += 8*src_pit;

	mov	edi, DWORD PTR _srcp$[ebp]

; 476  : 	pDest += 8*dst_pit;

	mov	edx, DWORD PTR _dstp$[ebp]
	add	edi, DWORD PTR tv1900[esp+88]
	add	edx, DWORD PTR tv1899[esp+88]
	sub	DWORD PTR tv1910[esp+88], 1
	mov	esi, DWORD PTR _dst_pit$[ebp]
	mov	eax, DWORD PTR _src_pit$[ebp]
	mov	DWORD PTR _srcp$[ebp], edi
	mov	DWORD PTR _dstp$[ebp], edx
	jne	$LL4@DCTBytes2D

; 477  : 	}
; 478  : #ifndef _M_X64 
; 479  :   _mm_empty ();

	emms
$LN9@DCTBytes2D:

; 480  : #endif
; 481  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DCTBytes2D@DCTINT@@UAEXPBEHPAEH@Z ENDP			; DCTINT::DCTBytes2D
_TEXT	ENDS
END
