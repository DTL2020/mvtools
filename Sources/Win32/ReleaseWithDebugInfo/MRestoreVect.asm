; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mrestorevect.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CD@MOOKPMFC@MRestoreVect?3?5invalid?5index?5valu@ ; `string'
PUBLIC	??_C@_0DF@DFKHPKJB@MRestoreVect?3?5frame?5too?5small?5to@ ; `string'
PUBLIC	??_C@_0DG@DIKJBENH@MRestoreVect?3?5unexpected?5or?5corr@ ; `string'
PUBLIC	??_C@_0CL@KGPCKJCK@MRestoreVect?3?5invalid?5content?5at@ ; `string'
PUBLIC	??_C@_0DF@GOEDLGCN@MRestoreVect?3?5clip?5does?5not?5wrap@ ; `string'
PUBLIC	??_C@_0EF@MCCBKGFL@MRestoreVect?3?5unsupported?5versio@ ; `string'
PUBLIC	??_C@_0DE@ODMHMIKC@MRestoreVect?3?5clip?5not?5found?5?$CIin@ ; `string'
PUBLIC	??_C@_0BO@JMPPBJPG@MRestoreVect?3?5corrupted?5data?4?$AA@ ; `string'
PUBLIC	??_R2MRestoreVect@@8				; MRestoreVect::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MRestoreVect@@8			; MRestoreVect::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MRestoreVect@@6B@				; MRestoreVect::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMRestoreVect@@@8			; MRestoreVect `RTTI Type Descriptor'
PUBLIC	??_R3MRestoreVect@@8				; MRestoreVect::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7MRestoreVect@@6B@				; MRestoreVect::`vftable'
;	COMDAT ??_7MRestoreVect@@6B@
CONST	SEGMENT
??_7MRestoreVect@@6B@ DD FLAT:??_R4MRestoreVect@@6B@	; MRestoreVect::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@GenericVideoFilter@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMRestoreVect@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3MRestoreVect@@8
rdata$r	SEGMENT
??_R3MRestoreVect@@8 DD 00H				; MRestoreVect::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2MRestoreVect@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMRestoreVect@@@8
data$r	SEGMENT
??_R0?AVMRestoreVect@@@8 DD FLAT:??_7type_info@@6B@	; MRestoreVect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMRestoreVect@@', 00H
data$r	ENDS
;	COMDAT ??_R4MRestoreVect@@6B@
rdata$r	SEGMENT
??_R4MRestoreVect@@6B@ DD 00H				; MRestoreVect::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMRestoreVect@@@8
	DD	FLAT:??_R3MRestoreVect@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MRestoreVect@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MRestoreVect@@8 DD FLAT:??_R0?AVMRestoreVect@@@8 ; MRestoreVect::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MRestoreVect@@8
rdata$r	ENDS
;	COMDAT ??_R2MRestoreVect@@8
rdata$r	SEGMENT
??_R2MRestoreVect@@8 DD FLAT:??_R1A@?0A@EA@MRestoreVect@@8 ; MRestoreVect::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BO@JMPPBJPG@MRestoreVect?3?5corrupted?5data?4?$AA@
CONST	SEGMENT
??_C@_0BO@JMPPBJPG@MRestoreVect?3?5corrupted?5data?4?$AA@ DB 'MRestoreVec'
	DB	't: corrupted data.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ODMHMIKC@MRestoreVect?3?5clip?5not?5found?5?$CIin@
CONST	SEGMENT
??_C@_0DE@ODMHMIKC@MRestoreVect?3?5clip?5not?5found?5?$CIin@ DB 'MRestore'
	DB	'Vect: clip not found (invalid index value).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@MCCBKGFL@MRestoreVect?3?5unsupported?5versio@
CONST	SEGMENT
??_C@_0EF@MCCBKGFL@MRestoreVect?3?5unsupported?5versio@ DB 'MRestoreVect:'
	DB	' unsupported version (%d) of the motion vector wrapper.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GOEDLGCN@MRestoreVect?3?5clip?5does?5not?5wrap@
CONST	SEGMENT
??_C@_0DF@GOEDLGCN@MRestoreVect?3?5clip?5does?5not?5wrap@ DB 'MRestoreVec'
	DB	't: clip does not wrap motion vector data.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KGPCKJCK@MRestoreVect?3?5invalid?5content?5at@
CONST	SEGMENT
??_C@_0CL@KGPCKJCK@MRestoreVect?3?5invalid?5content?5at@ DB 'MRestoreVect'
	DB	': invalid content at frame %d.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DIKJBENH@MRestoreVect?3?5unexpected?5or?5corr@
CONST	SEGMENT
??_C@_0DG@DIKJBENH@MRestoreVect?3?5unexpected?5or?5corr@ DB 'MRestoreVect'
	DB	': unexpected or corrupted contained data.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DFKHPKJB@MRestoreVect?3?5frame?5too?5small?5to@
CONST	SEGMENT
??_C@_0DF@DFKHPKJB@MRestoreVect?3?5frame?5too?5small?5to@ DB 'MRestoreVec'
	DB	't: frame too small to contain valid data.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MOOKPMFC@MRestoreVect?3?5invalid?5index?5valu@
CONST	SEGMENT
??_C@_0CD@MOOKPMFC@MRestoreVect?3?5invalid?5index?5valu@ DB 'MRestoreVect'
	DB	': invalid index value.', 00H		; `string'
PUBLIC	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z	; MRestoreVect::read_from_clip
PUBLIC	?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z ; MRestoreVect::read_frame_info
PUBLIC	?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MRestoreVect::GetFrame
PUBLIC	??_GMRestoreVect@@UAEPAXI@Z			; MRestoreVect::`scalar deleting destructor'
PUBLIC	??1MRestoreVect@@UAE@XZ				; MRestoreVect::~MRestoreVect
PUBLIC	??4PVideoFrame@@QAEXABV0@@Z			; PVideoFrame::operator=
PUBLIC	?GetMagicKey@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetMagicKey
PUBLIC	??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z ; MRestoreVect::MRestoreVect
EXTRN	??_EMRestoreVect@@UAEPAXI@Z:PROC		; MRestoreVect::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MRestoreVect@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MRestoreVect@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MRestoreVect@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MRestoreVect@@UAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GMRestoreVect@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GMRestoreVect@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_GMRestoreVect@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GMRestoreVect@@UAEPAXI@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z$1
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
;	COMDAT ??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_data_len$ = -20					; size = 4
_frame_ptr$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_src$ = 8						; size = 4
_data_ptr$1$ = 12					; size = 4
_clip_index$ = 12					; size = 4
_contiguous_flag$ = 15					; size = 1
_pos$ = 16						; size = 4
_data_offset$ = 16					; size = 4
_env$ = 16						; size = 4
??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z PROC ; MRestoreVect::MRestoreVect, COMDAT
; _this$ = ecx

; 39   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mrestorevect.cpp

; 33   : :	::GenericVideoFilter (src)

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN13@MRestoreVe
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN13@MRestoreVe
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _src$[ebp]
	push	edx
	call	eax
$LN13@MRestoreVe:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 33   : :	::GenericVideoFilter (src)

	mov	ecx, edi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 34   : ,	_mad ()

	push	88					; 00000058H
	lea	eax, DWORD PTR [edi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	push	eax

; 39   : {

	mov	DWORD PTR [edi], OFFSET ??_7MRestoreVect@@6B@
	call	_memset
	mov	eax, DWORD PTR _clip_index$[ebp]
	add	esp, 12					; 0000000cH

; 40   : 	if (_clip_index < 0)

	mov	ebx, DWORD PTR _env$[ebp]
	mov	DWORD PTR [edi+152], eax
	mov	DWORD PTR [edi+156], 0
	mov	DWORD PTR [edi+160], 0
	mov	DWORD PTR [edi+164], 0
	test	eax, eax
	jns	SHORT $LN2@MRestoreVe

; 41   : 	{
; 42   : 		env.ThrowError ("MRestoreVect: invalid index value.");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0CD@MOOKPMFC@MRestoreVect?3?5invalid?5index?5valu@
	push	ebx
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@MRestoreVe:
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN17@MRestoreVe
	cmp	DWORD PTR [eax], 152			; 00000098H
	jbe	SHORT $LN17@MRestoreVe
	mov	eax, DWORD PTR [eax+152]
; File c:\github\mvtools\sources\mrestorevect.cpp

; 45   : 	_bytes_per_pix  = vi.BitsPerPixel () >> 3;

	lea	ecx, DWORD PTR [edi+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	call	eax
	jmp	SHORT $LN18@MRestoreVe
$LN17@MRestoreVe:
	xor	eax, eax
$LN18@MRestoreVe:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 46   : 	_row_size       = vi.width  * _bytes_per_pix;

	mov	ecx, DWORD PTR [edi+16]
	sar	eax, 3
	imul	ecx, eax
	mov	DWORD PTR [edi+156], eax

; 47   : 	_available_size = vi.height * _row_size;

	mov	eax, DWORD PTR [edi+20]
	imul	eax, ecx
	mov	DWORD PTR [edi+160], ecx
	mov	DWORD PTR [edi+164], eax

; 48   : 	if (_available_size < 4 * sizeof (int32_t))

	cmp	eax, 16					; 00000010H
	jae	SHORT $LN3@MRestoreVe

; 49   : 	{
; 50   : 		env.ThrowError ("MRestoreVect: frame too small to contain valid data.");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0DF@DFKHPKJB@MRestoreVect?3?5frame?5too?5small?5to@
	push	ebx
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN3@MRestoreVe:

; 51   : 	}
; 52   : 
; 53   : 	::PVideoFrame	frame_ptr = src->GetFrame (0, &env);

	mov	eax, DWORD PTR _src$[ebp]
	lea	edx, DWORD PTR _frame_ptr$[ebp]
	push	ebx
	push	0
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mrestorevect.cpp

; 54   : 	int				data_offset     = 0;		// Bytes

	mov	DWORD PTR _data_offset$[ebp], 0

; 55   : 	int				data_len        = 0;		// Bytes

	mov	DWORD PTR _data_len$[ebp], 0

; 57   : 	read_frame_info (data_offset, data_len, contiguous_flag, frame_ptr, env);

	push	ebx
	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN23@MRestoreVe
	cmp	DWORD PTR [eax], 256			; 00000100H
	jbe	SHORT $LN23@MRestoreVe
	mov	eax, DWORD PTR [eax+256]
	lea	edx, DWORD PTR _frame_ptr$[ebp]
	push	edx
	call	eax
$LN23@MRestoreVe:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 57   : 	read_frame_info (data_offset, data_len, contiguous_flag, frame_ptr, env);

	lea	eax, DWORD PTR _contiguous_flag$[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR _data_len$[ebp]
	push	eax
	lea	eax, DWORD PTR _data_offset$[ebp]
	push	eax
	call	?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z ; MRestoreVect::read_frame_info
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN29@MRestoreVe
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN29@MRestoreVe
	mov	ecx, DWORD PTR _frame_ptr$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _data_ptr$1$[ebp], eax
	jmp	SHORT $LN30@MRestoreVe
$LN29@MRestoreVe:
	mov	DWORD PTR _data_ptr$1$[ebp], 0
$LN30@MRestoreVe:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN35@MRestoreVe
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN35@MRestoreVe
	mov	ecx, DWORD PTR _frame_ptr$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN36@MRestoreVe
$LN35@MRestoreVe:
	xor	ecx, ecx
$LN36@MRestoreVe:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 61   : 	int				pos      = data_offset + sizeof (int32_t);

	add	DWORD PTR _data_offset$[ebp], 4

; 62   : 	read_from_clip (pos, data_ptr, &_mad, sizeof (_mad), pitch);

	lea	eax, DWORD PTR [edi+64]
	push	ecx
	push	88					; 00000058H
	push	eax
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _pos$[ebp]
	mov	ecx, edi
	push	eax
	call	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ; MRestoreVect::read_from_clip

; 63   : 	if (_mad.GetMagicKey () != MVAnalysisData::MOTION_MAGIC_KEY)

	cmp	DWORD PTR [edi+64], 22093		; 0000564dH
	je	SHORT $LN4@MRestoreVe

; 64   : 	{
; 65   : 		env.ThrowError ("MRestoreVect: unexpected or corrupted contained data.");

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0DG@DIKJBENH@MRestoreVect?3?5unexpected?5or?5corr@
	push	ebx
	call	DWORD PTR [eax+20]
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
$LN4@MRestoreVe:
; File c:\github\mvtools\sources\clipfnc.cpp

; 91   : 		    && vi.pixel_type != VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [edi+36]
	lea	ecx, DWORD PTR [edi+16]
	cmp	eax, 1342177282				; 50000002H
	je	SHORT $LN42@MRestoreVe
	cmp	eax, 1342177281				; 50000001H
	je	SHORT $LN42@MRestoreVe
	cmp	eax, 1610612740				; 60000004H
	je	SHORT $LN42@MRestoreVe

; 92   : 		{
; 93   : 			env.ThrowError (

	mov	eax, DWORD PTR [ebx]
	push	OFFSET ??_C@_0N@NLLEADCO@MRestoreVect?$AA@
	push	OFFSET ??_C@_0DA@HILKLKFM@?$CFs?3?5unsupported?5colorspace?5for?5t@
	push	ebx
	call	DWORD PTR [eax+20]
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	lea	ecx, DWORD PTR [edi+16]
	add	esp, 12					; 0000000cH
$LN42@MRestoreVe:
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	test	esi, esi
	je	SHORT $LN55@MRestoreVe
	cmp	DWORD PTR [esi], 152			; 00000098H
	jbe	SHORT $LN55@MRestoreVe
	mov	eax, DWORD PTR [esi+152]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN56@MRestoreVe
$LN55@MRestoreVe:
	xor	ecx, ecx
$LN56@MRestoreVe:
; File c:\github\mvtools\sources\clipfnc.cpp

; 126  : 		vi.width  = nbr_groups * nbr_pix_per_group;

	mov	eax, DWORD PTR _data_len$[ebp]
	dec	eax
	sar	ecx, 3
	add	eax, ecx

; 127  : 		vi.height = 1;

	mov	DWORD PTR [edi+20], 1
	cdq
	idiv	ecx

; 128  : 	}
; 129  : 	else
; 130  : 	{
; 131  : 		const int		width_bytes =
; 132  : 			compute_mvclip_best_width (nbr_blk_x, unit_size, FRAME_ALIGN);
; 133  : 		vi.width  = width_bytes / bytes_per_pix;
; 134  : 		vi.height = (size_bytes + width_bytes - 1) / width_bytes;
; 135  : 	}
; 136  : 
; 137  : 	vi.audio_samples_per_second = 0; //v1.8.1

	mov	DWORD PTR [edi+40], 0
	mov	DWORD PTR [edi+16], eax
; File c:\github\mvtools\sources\mrestorevect.cpp

; 73   : 	vi.nchannels = reinterpret_cast <uintptr_t> (&_mad);

	lea	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [edi+56], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	test	esi, esi
	je	SHORT $LN59@MRestoreVe
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN59@MRestoreVe
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _frame_ptr$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN59@MRestoreVe:

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	esi, esi
	je	SHORT $LN67@MRestoreVe
	cmp	DWORD PTR [esi], 248			; 000000f8H
	jbe	SHORT $LN67@MRestoreVe
	mov	eax, DWORD PTR [esi+248]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
$LN67@MRestoreVe:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 80   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR _frame_ptr$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MRestoreVect@@QAE@VPClip@@HAAVIScriptEnvironment@@@Z ENDP ; MRestoreVect::MRestoreVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetMagicKey@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetMagicKey@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetMagicKey, COMDAT
; _this$ = ecx

; 117  :    inline int GetMagicKey() const { return nMagicKey; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetMagicKey@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetMagicKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??4PVideoFrame@@QAEXABV0@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
??4PVideoFrame@@QAEXABV0@@Z PROC			; PVideoFrame::operator=, COMDAT
; _this$ = ecx

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@operator
	cmp	DWORD PTR [eax], 268			; 0000010cH
	jbe	SHORT $LN3@operator
	mov	eax, DWORD PTR [eax+268]
	jmp	eax
$LN3@operator:
	ret	4
??4PVideoFrame@@QAEXABV0@@Z ENDP			; PVideoFrame::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mrestorevect.h
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.h
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.h
;	COMDAT ??1MRestoreVect@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MRestoreVect@@UAE@XZ PROC				; MRestoreVect::~MRestoreVect, COMDAT
; _this$ = ecx

; 44   : 	virtual			~MRestoreVect () {}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MRestoreVect@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7MRestoreVect@@6B@
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN14@MRestoreVe
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN14@MRestoreVe
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN14@MRestoreVe:
; File c:\github\mvtools\sources\mrestorevect.h

; 44   : 	virtual			~MRestoreVect () {}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mrestorevect.h

; 44   : 	virtual			~MRestoreVect () {}

	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MRestoreVect@@UAE@XZ$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MRestoreVect@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MRestoreVect@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MRestoreVect@@UAE@XZ ENDP				; MRestoreVect::~MRestoreVect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mrestorevect.h
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??_GMRestoreVect@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GMRestoreVect@@UAEPAXI@Z PROC			; MRestoreVect::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_GMRestoreVect@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\mrestorevect.h

; 44   : 	virtual			~MRestoreVect () {}

	mov	DWORD PTR [esi], OFFSET ??_7MRestoreVect@@6B@
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN12@scalar
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN12@scalar
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN12@scalar:
	test	BYTE PTR ___flags$[ebp], 1

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
	je	SHORT $LN18@scalar
	push	168					; 000000a8H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GMRestoreVect@@UAEPAXI@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_GMRestoreVect@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GMRestoreVect@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GMRestoreVect@@UAEPAXI@Z ENDP			; MRestoreVect::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
;	COMDAT ?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_src_data_ptr$1$ = -24					; size = 4
_data_offset$ = -20					; size = 4
_src_ptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dst_data_ptr$1$ = 8					; size = 4
_this$ = 8						; size = 4
_contiguous_flag$ = 11					; size = 1
___$ReturnUdt$ = 12					; size = 4
_src_pitch$1$ = 16					; size = 4
$T4 = 16						; size = 4
_n$ = 16						; size = 4
_data_len$ = 20						; size = 4
_env_ptr$ = 20						; size = 4
?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MRestoreVect::GetFrame, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T3[ebp], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mrestorevect.cpp

; 85   : {

	push	esi
	push	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	test	eax, eax
	je	SHORT $LN15@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN15@GetFrame
	mov	eax, DWORD PTR [eax+252]
	mov	ecx, edi
	call	eax
$LN15@GetFrame:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 123  : 	return (dst_ptr);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR _src_ptr$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\mrestorevect.cpp

; 91   : 	::PVideoFrame	src_ptr = child->GetFrame (n, env_ptr);

	mov	esi, DWORD PTR _env_ptr$[ebp]
	push	esi
	push	DWORD PTR _n$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mrestorevect.cpp

; 91   : 	::PVideoFrame	src_ptr = child->GetFrame (n, env_ptr);

	push	edx
	push	eax
	mov	DWORD PTR $T3[ebp], 1
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mrestorevect.cpp

; 93   : 	int				data_offset     = 0;		// Bytes

	mov	DWORD PTR _data_offset$[ebp], 0

; 94   : 	int				data_len        = 0;		// Bytes

	mov	DWORD PTR _data_len$[ebp], 0

; 95   : 	bool				contiguous_flag = false;

	mov	BYTE PTR _contiguous_flag$[ebp], 0

; 96   : 	read_frame_info (data_offset, data_len, contiguous_flag, src_ptr, *env_ptr);

	push	esi
	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN21@GetFrame
	cmp	DWORD PTR [eax], 256			; 00000100H
	jbe	SHORT $LN21@GetFrame
	mov	eax, DWORD PTR [eax+256]
	lea	edx, DWORD PTR _src_ptr$[ebp]
	push	edx
	call	eax
$LN21@GetFrame:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 96   : 	read_frame_info (data_offset, data_len, contiguous_flag, src_ptr, *env_ptr);

	lea	eax, DWORD PTR _contiguous_flag$[ebp]
	mov	ecx, ebx
	push	eax
	lea	eax, DWORD PTR _data_len$[ebp]
	push	eax
	lea	eax, DWORD PTR _data_offset$[ebp]
	push	eax
	call	?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z ; MRestoreVect::read_frame_info

; 97   : 	if (data_len > vi.width * vi.height * _bytes_per_pix)

	mov	eax, DWORD PTR [ebx+20]
	lea	ecx, DWORD PTR [ebx+16]
	imul	eax, DWORD PTR [ebx+156]
	imul	eax, DWORD PTR [ecx]
	cmp	DWORD PTR _data_len$[ebp], eax
	jle	SHORT $LN2@GetFrame

; 98   : 	{
; 99   : 		env_ptr->ThrowError ("MRestoreVect: invalid content at frame %d.", n);

	push	DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CL@KGPCKJCK@MRestoreVect?3?5invalid?5content?5at@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [ebx+16]
$LN2@GetFrame:

; 100  : 	}
; 101  : 
; 102  : 	if (contiguous_flag)

	cmp	BYTE PTR _contiguous_flag$[ebp], 0
	je	$LN3@GetFrame

; 103  : 	{
; 104  : 		const int		dst_pitch = vi.width * _bytes_per_pix;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ebx+156]

; 105  : 		dst_ptr = env_ptr->Subframe (

	push	DWORD PTR [ebx+20]
	imul	ecx, eax
	push	eax
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mrestorevect.cpp

; 105  : 		dst_ptr = env_ptr->Subframe (

	push	ecx
	push	DWORD PTR _data_offset$[ebp]
	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN25@GetFrame
	cmp	DWORD PTR [eax], 256			; 00000100H
	jbe	SHORT $LN25@GetFrame
	mov	eax, DWORD PTR [eax+256]
	lea	edx, DWORD PTR _src_ptr$[ebp]
	push	edx
	call	eax
$LN25@GetFrame:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 105  : 		dst_ptr = env_ptr->Subframe (

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	push	esi
	call	DWORD PTR [eax+76]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN29@GetFrame
	cmp	DWORD PTR [esi], 268			; 0000010cH
	jbe	SHORT $LN29@GetFrame
	push	eax
	mov	eax, DWORD PTR [esi+268]
	mov	ecx, edi
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN29@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	test	esi, esi
	je	$LN4@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	$LN4@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR $T4[ebp]
	call	eax
; File c:\github\mvtools\sources\mrestorevect.cpp

; 109  : 	else

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	$LN4@GetFrame
$LN3@GetFrame:

; 110  : 	{
; 111  : 		dst_ptr = env_ptr->NewVideoFrame (vi);

	mov	eax, DWORD PTR [esi]
	push	32					; 00000020H
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	push	esi
	call	DWORD PTR [eax+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN38@GetFrame
	cmp	DWORD PTR [esi], 268			; 0000010cH
	jbe	SHORT $LN38@GetFrame
	push	eax
	mov	eax, DWORD PTR [esi+268]
	mov	ecx, edi
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN38@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	esi, esi
	je	SHORT $LN42@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN42@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR $T2[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN42@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN49@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN49@GetFrame
	mov	ecx, DWORD PTR _src_ptr$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _src_data_ptr$1$[ebp], eax
	jmp	SHORT $LN50@GetFrame
$LN49@GetFrame:
	mov	DWORD PTR _src_data_ptr$1$[ebp], 0
$LN50@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN55@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN55@GetFrame
	mov	ecx, DWORD PTR _src_ptr$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _src_pitch$1$[ebp], eax
	jmp	SHORT $LN56@GetFrame
$LN55@GetFrame:
	mov	DWORD PTR _src_pitch$1$[ebp], 0
$LN56@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN61@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN61@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _dst_data_ptr$1$[ebp], eax
	jmp	SHORT $LN62@GetFrame
$LN61@GetFrame:
	mov	DWORD PTR _dst_data_ptr$1$[ebp], 0
$LN62@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN67@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN67@GetFrame
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN67@GetFrame:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 118  : 		read_from_clip (data_offset, src_data_ptr, dst_data_ptr, data_len, src_pitch);

	push	DWORD PTR _src_pitch$1$[ebp]
	lea	eax, DWORD PTR _data_offset$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _data_len$[ebp]
	push	DWORD PTR _dst_data_ptr$1$[ebp]
	push	DWORD PTR _src_data_ptr$1$[ebp]
	push	eax
	call	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ; MRestoreVect::read_from_clip
$LN4@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 6
	test	esi, esi
	je	SHORT $LN74@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN74@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src_ptr$[ebp]
	call	edx
$LN74@GetFrame:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 124  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	and	eax, 1
	je	$LN7@GetFrame
	and	DWORD PTR $T3[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN7@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _src_ptr$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MRestoreVect@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MRestoreVect::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mrestorevect.cpp
;	COMDAT ?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_offset_end$ = -36					; size = 4
_nbr_clips$ = -36					; size = 4
_ver$ = -32						; size = 4
_key$ = -28						; size = 4
_pitch$1$ = -24						; size = 4
_data_ptr$1$ = -20					; size = 4
_pos$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_data_offset$ = 8					; size = 4
_data_len$ = 12						; size = 4
_contiguous_flag$ = 16					; size = 4
_frame_ptr$ = 20					; size = 4
tv276 = 24						; size = 4
_offset_beg$ = 24					; size = 4
_env$ = 24						; size = 4
?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z PROC ; MRestoreVect::read_frame_info, COMDAT
; _this$ = ecx

; 138  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN13@read_frame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN13@read_frame
	mov	ecx, DWORD PTR _frame_ptr$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _data_ptr$1$[ebp], eax
	jmp	SHORT $LN14@read_frame
$LN13@read_frame:
	mov	DWORD PTR _data_ptr$1$[ebp], 0
$LN14@read_frame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN19@read_frame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN19@read_frame
	mov	ecx, DWORD PTR _frame_ptr$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	mov	DWORD PTR _pitch$1$[ebp], eax
	jmp	SHORT $LN20@read_frame
$LN19@read_frame:
	xor	edi, edi
	mov	DWORD PTR _pitch$1$[ebp], edi
$LN20@read_frame:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 151  : 	read_from_clip (pos, data_ptr, &key, sizeof (key), pitch);

	push	edi
	push	4
	lea	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR _pos$[ebp], 0
	push	eax
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _pos$[ebp]
	mov	ecx, ebx
	push	eax
	call	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ; MRestoreVect::read_from_clip

; 152  : 	read_from_clip (pos, data_ptr, &ver, sizeof (ver), pitch);

	push	edi
	push	4
	lea	eax, DWORD PTR _ver$[ebp]
	mov	ecx, ebx
	push	eax
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ; MRestoreVect::read_from_clip

; 153  : 	read_from_clip (pos, data_ptr, &nbr_clips, sizeof (nbr_clips), pitch);

	push	edi
	push	4
	lea	eax, DWORD PTR _nbr_clips$[ebp]
	mov	ecx, ebx
	push	eax
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ; MRestoreVect::read_from_clip

; 154  : 
; 155  : 	if (key != MVAnalysisData::STORE_KEY)

	cmp	DWORD PTR _key$[ebp], 48813		; 0000beadH
	mov	edi, DWORD PTR _env$[ebp]
	je	SHORT $LN2@read_frame

; 156  : 	{
; 157  : 		env.ThrowError ("MRestoreVect: clip does not wrap motion vector data.");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DF@GOEDLGCN@MRestoreVect?3?5clip?5does?5not?5wrap@
	push	edi
	call	DWORD PTR [eax+20]
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
$LN2@read_frame:

; 158  : 	}
; 159  : 	if (ver != MVAnalysisData::STORE_VERSION)

	mov	ecx, DWORD PTR _ver$[ebp]
	cmp	ecx, 5
	je	SHORT $LN3@read_frame

; 160  : 	{
; 161  : 		env.ThrowError (

	mov	eax, DWORD PTR [edi]
	push	ecx
	push	OFFSET ??_C@_0EF@MCCBKGFL@MRestoreVect?3?5unsupported?5versio@
	push	edi
	call	DWORD PTR [eax+20]
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 12					; 0000000cH
$LN3@read_frame:

; 162  : 			"MRestoreVect: unsupported version (%d) of the motion vector wrapper.",
; 163  : 			ver
; 164  : 		);
; 165  : 	}
; 166  : 
; 167  : 	if (_clip_index >= nbr_clips)

	mov	eax, DWORD PTR [ebx+152]
	cmp	eax, DWORD PTR _nbr_clips$[ebp]
	jl	SHORT $LN4@read_frame

; 168  : 	{
; 169  : 		env.ThrowError ("MRestoreVect: clip not found (invalid index value).");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DE@ODMHMIKC@MRestoreVect?3?5clip?5not?5found?5?$CIin@
	push	edi
	call	DWORD PTR [eax+20]
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
$LN4@read_frame:

; 170  : 	}
; 171  : 	pos += _clip_index * sizeof (int32_t);

	mov	ecx, DWORD PTR [ebx+152]
	mov	eax, DWORD PTR _pos$[ebp]

; 172  : 
; 173  : 	int32_t			offset_beg;
; 174  : 	int32_t			offset_end;
; 175  : 	read_from_clip (pos, data_ptr, &offset_beg, sizeof (offset_beg), pitch);

	push	DWORD PTR _pitch$1$[ebp]
	push	4
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, ebx
	mov	DWORD PTR _pos$[ebp], eax
	lea	eax, DWORD PTR _offset_beg$[ebp]
	push	eax
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ; MRestoreVect::read_from_clip

; 176  : 	read_from_clip (pos, data_ptr, &offset_end, sizeof (offset_end), pitch);

	push	DWORD PTR _pitch$1$[ebp]
	lea	eax, DWORD PTR _offset_end$[ebp]
	mov	ecx, ebx
	push	4
	push	eax
	push	DWORD PTR _data_ptr$1$[ebp]
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	call	?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ; MRestoreVect::read_from_clip

; 177  : 	data_offset =               offset_beg  * sizeof (int32_t);

	mov	ecx, DWORD PTR _offset_beg$[ebp]
	mov	edx, DWORD PTR _data_offset$[ebp]
	lea	eax, DWORD PTR [ecx*4]
	mov	DWORD PTR [edx], eax

; 178  : 	data_len    = (offset_end - offset_beg) * sizeof (int32_t);

	mov	eax, DWORD PTR _offset_end$[ebp]
	sub	eax, ecx
	shl	eax, 2
	mov	DWORD PTR tv276[ebp], eax
	mov	eax, DWORD PTR _data_len$[ebp]
	mov	ecx, DWORD PTR tv276[ebp]
	mov	DWORD PTR [eax], ecx

; 179  : 	if (   data_offset            <  pos
; 180  : 	    || data_len               <= sizeof (int32_t) + sizeof (_mad)
; 181  : 	    || data_offset + data_len >= _available_size)

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _pos$[ebp]
	jl	SHORT $LN6@read_frame
	cmp	ecx, 92					; 0000005cH
	jbe	SHORT $LN6@read_frame
	add	eax, ecx
	cmp	eax, DWORD PTR [ebx+164]
	jl	SHORT $LN5@read_frame
$LN6@read_frame:

; 182  : 	{
; 183  : 		env.ThrowError ("MRestoreVect: corrupted data.");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BO@JMPPBJPG@MRestoreVect?3?5corrupted?5data?4?$AA@
	push	edi
	call	DWORD PTR [eax+20]
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
$LN5@read_frame:

; 184  : 	}
; 185  : 
; 186  : 	contiguous_flag = (pitch == _row_size);

	mov	eax, DWORD PTR _pitch$1$[ebp]
	cmp	eax, DWORD PTR [ebx+160]
	mov	eax, DWORD PTR _contiguous_flag$[ebp]
	sete	cl
	mov	BYTE PTR [eax], cl
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	esi, esi
	je	SHORT $LN23@read_frame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN23@read_frame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _frame_ptr$[ebp]
	call	eax
$LN23@read_frame:
; File c:\github\mvtools\sources\mrestorevect.cpp

; 187  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _frame_ptr$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_frame_info@MRestoreVect@@ABEXAAH0AA_NVPVideoFrame@@AAVIScriptEnvironment@@@Z ENDP ; MRestoreVect::read_frame_info
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mrestorevect.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mrestorevect.cpp
;	COMDAT ?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_src_pos$ = 8						; size = 4
_base_ptr$ = 12						; size = 4
_dst_ptr$ = 16						; size = 4
_len$ = 20						; size = 4
_stride$ = 24						; size = 4
?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z PROC	; MRestoreVect::read_from_clip, COMDAT
; _this$ = ecx

; 192  : {

	push	ecx

; 193  : 	assert (src_pos >= 0);
; 194  : 	assert (src_pos + len <= _available_size);
; 195  : 	assert (base_ptr != 0);
; 196  : 	assert (dst_ptr != 0);
; 197  : 	assert (len > 0);
; 198  : 	assert (stride > 0);
; 199  : 
; 200  : 	if (stride == _row_size)

	mov	eax, DWORD PTR _stride$[esp]
	push	esi
	push	edi

; 201  : 	{
; 202  : 		memcpy (dst_ptr, base_ptr + src_pos, len);

	mov	edi, DWORD PTR _len$[esp+8]
	mov	DWORD PTR _this$1$[esp+12], ecx
	cmp	eax, DWORD PTR [ecx+160]
	jne	SHORT $LN4@read_from_
	mov	esi, DWORD PTR _src_pos$[esp+8]
	push	edi
	mov	eax, DWORD PTR [esi]
	add	eax, DWORD PTR _base_ptr$[esp+12]
	push	eax
	push	DWORD PTR _dst_ptr$[esp+16]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 203  : 		src_pos += len;

	add	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 220  : 		}
; 221  : 	}
; 222  : }

	pop	ecx
	ret	20					; 00000014H
$LN4@read_from_:
	push	ebp

; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		int				dst_pos  = 0;

	xor	ebp, ebp

; 208  : 		while (dst_pos < len)

	test	edi, edi
	jle	SHORT $LN14@read_from_
	mov	eax, DWORD PTR _src_pos$[esp+12]
	push	ebx
$LL2@read_from_:

; 209  : 		{
; 210  : 			const int		y = src_pos / _row_size;

	mov	ebx, DWORD PTR [eax]

; 211  : 			const int		x = src_pos - y * _row_size;	// In bytes
; 212  : 			const int		work_len = std::min (len - dst_pos, _row_size - x);

	sub	edi, ebp
	mov	esi, DWORD PTR [ecx+160]
	mov	eax, ebx
	cdq
	mov	ecx, esi
	idiv	esi
	imul	ecx, eax
	sub	ebx, ecx
	sub	esi, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	esi, edi
	cmovl	edi, esi
; File c:\github\mvtools\sources\mrestorevect.cpp

; 213  : 			memcpy (

	imul	eax, DWORD PTR _stride$[esp+16]
	push	edi
	add	eax, ebx
	add	eax, DWORD PTR _base_ptr$[esp+20]
	push	eax
	mov	eax, DWORD PTR _dst_ptr$[esp+24]
	add	eax, ebp
	push	eax
	call	_memcpy

; 214  : 				reinterpret_cast <uint8_t *> (dst_ptr) + dst_pos,
; 215  : 				base_ptr + y * stride + x,
; 216  : 				work_len
; 217  : 			);
; 218  : 			dst_pos += work_len;
; 219  : 			src_pos += work_len;

	mov	eax, DWORD PTR _src_pos$[esp+28]
	add	ebp, edi
	mov	ecx, DWORD PTR _this$1$[esp+32]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [eax], edi
	mov	edi, DWORD PTR _len$[esp+16]
	cmp	ebp, edi
	jl	SHORT $LL2@read_from_
	pop	ebx
$LN14@read_from_:
	pop	ebp
	pop	edi
	pop	esi

; 220  : 		}
; 221  : 	}
; 222  : }

	pop	ecx
	ret	20					; 00000014H
?read_from_clip@MRestoreVect@@ABEXAAHQBEPAXHH@Z ENDP	; MRestoreVect::read_from_clip
_TEXT	ENDS
END
