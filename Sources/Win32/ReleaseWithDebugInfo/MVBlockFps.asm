; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvblockfps.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CE@FPGFCKKD@MBlockFps?3?5Clip?5must?5be?5YUV?5or?5Y@ ; `string'
PUBLIC	??_C@_0CL@HJOLEPGD@MBlockFps?3?5only?58?916?5bit?5clips?5a@ ; `string'
PUBLIC	??_C@_0BM@PBKIEKMD@MBlockFps?3?5mode?5from?50?5to?58?$AA@ ; `string'
PUBLIC	??_C@_0EF@FFNOFKJN@MBlockFPS?3?5cannot?5use?5motion?5vec@ ; `string'
PUBLIC	??_C@_0CN@FBLKKCJO@MBlockFps?5?3?5wrong?5source?5or?5supe@ ; `string'
PUBLIC	??_C@_0EF@EDDNICOL@MBlockFps?3?5cannot?5use?5motion?5vec@ ; `string'
PUBLIC	??_R2MVBlockFps@@8				; MVBlockFps::`RTTI Base Class Array'
PUBLIC	??_R0?AVMVBlockFps@@@8				; MVBlockFps `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@MVBlockFps@@8			; MVBlockFps::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MVBlockFps@@6B@				; MVBlockFps::`RTTI Complete Object Locator'
PUBLIC	??_7MVBlockFps@@6B@				; MVBlockFps::`vftable'
PUBLIC	??_R3MVBlockFps@@8				; MVBlockFps::`RTTI Class Hierarchy Descriptor'
;	COMDAT ??_R3MVBlockFps@@8
rdata$r	SEGMENT
??_R3MVBlockFps@@8 DD 00H				; MVBlockFps::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVBlockFps@@8
rdata$r	ENDS
;	COMDAT ??_7MVBlockFps@@6B@
CONST	SEGMENT
??_7MVBlockFps@@6B@ DD FLAT:??_R4MVBlockFps@@6B@	; MVBlockFps::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVBlockFps@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVBlockFps@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4MVBlockFps@@6B@
rdata$r	SEGMENT
??_R4MVBlockFps@@6B@ DD 00H				; MVBlockFps::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVBlockFps@@@8
	DD	FLAT:??_R3MVBlockFps@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVBlockFps@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVBlockFps@@8 DD FLAT:??_R0?AVMVBlockFps@@@8 ; MVBlockFps::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVBlockFps@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVBlockFps@@@8
data$r	SEGMENT
??_R0?AVMVBlockFps@@@8 DD FLAT:??_7type_info@@6B@	; MVBlockFps `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVBlockFps@@', 00H
data$r	ENDS
;	COMDAT ??_R2MVBlockFps@@8
rdata$r	SEGMENT
??_R2MVBlockFps@@8 DD FLAT:??_R1A@?0A@EA@MVBlockFps@@8	; MVBlockFps::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_C@_0EF@EDDNICOL@MBlockFps?3?5cannot?5use?5motion?5vec@
CONST	SEGMENT
??_C@_0EF@EDDNICOL@MBlockFps?3?5cannot?5use?5motion?5vec@ DB 'MBlockFps: '
	DB	'cannot use motion vectors with absolute frame references.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FBLKKCJO@MBlockFps?5?3?5wrong?5source?5or?5supe@
CONST	SEGMENT
??_C@_0CN@FBLKKCJO@MBlockFps?5?3?5wrong?5source?5or?5supe@ DB 'MBlockFps '
	DB	': wrong source or super frame size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@FFNOFKJN@MBlockFPS?3?5cannot?5use?5motion?5vec@
CONST	SEGMENT
??_C@_0EF@FFNOFKJN@MBlockFPS?3?5cannot?5use?5motion?5vec@ DB 'MBlockFPS: '
	DB	'cannot use motion vectors with absolute frame references.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PBKIEKMD@MBlockFps?3?5mode?5from?50?5to?58?$AA@
CONST	SEGMENT
??_C@_0BM@PBKIEKMD@MBlockFps?3?5mode?5from?50?5to?58?$AA@ DB 'MBlockFps: '
	DB	'mode from 0 to 8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HJOLEPGD@MBlockFps?3?5only?58?916?5bit?5clips?5a@
CONST	SEGMENT
??_C@_0CL@HJOLEPGD@MBlockFps?3?5only?58?916?5bit?5clips?5a@ DB 'MBlockFps'
	DB	': only 8-16 bit clips are allowed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FPGFCKKD@MBlockFps?3?5Clip?5must?5be?5YUV?5or?5Y@
CONST	SEGMENT
??_C@_0CE@FPGFCKKD@MBlockFps?3?5Clip?5must?5be?5YUV?5or?5Y@ DB 'MBlockFps'
	DB	': Clip must be YUV or YUY2', 00H		; `string'
PUBLIC	??$max@G@std@@YAABGABG0@Z			; std::max<unsigned short>
PUBLIC	??$min@G@std@@YAABGABG0@Z			; std::min<unsigned short>
PUBLIC	??$max@E@std@@YAABEABE0@Z			; std::max<unsigned char>
PUBLIC	??$min@E@std@@YAABEABE0@Z			; std::min<unsigned char>
PUBLIC	??$MEDIAN@G@@YAGGGG@Z				; MEDIAN<unsigned short>
PUBLIC	??$MEDIAN@E@@YAEEEE@Z				; MEDIAN<unsigned char>
PUBLIC	??$ResultBlock@G@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ; MVBlockFps::ResultBlock<unsigned short>
PUBLIC	??$ResultBlock@E@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ; MVBlockFps::ResultBlock<unsigned char>
PUBLIC	?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVBlockFps::GetFrame
PUBLIC	?MultMasks@MVBlockFps@@AAEXPAE00HH@Z		; MVBlockFps::MultMasks
PUBLIC	??_GSimpleResize@@QAEPAXI@Z			; SimpleResize::`scalar deleting destructor'
PUBLIC	??1MVBlockFps@@UAE@XZ				; MVBlockFps::~MVBlockFps
PUBLIC	??_GMVBlockFps@@UAEPAXI@Z			; MVBlockFps::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVBlockFps@@UAGHHH@Z		; MVBlockFps::SetCacheHints
PUBLIC	?GetBlkCount@MVClip@@QBEHXZ			; MVClip::GetBlkCount
PUBLIC	?GetDeltaFrame@MVAnalysisData@@QBEHXZ		; MVAnalysisData::GetDeltaFrame
PUBLIC	??4PVideoFrame@@QAEXPAVVideoFrame@@@Z		; PVideoFrame::operator=
PUBLIC	?IsPlanarRGBA@VideoInfo@@QBE_NXZ		; VideoInfo::IsPlanarRGBA
PUBLIC	?IsPlanarRGB@VideoInfo@@QBE_NXZ			; VideoInfo::IsPlanarRGB
PUBLIC	?IsYUVA@VideoInfo@@QBE_NXZ			; VideoInfo::IsYUVA
PUBLIC	?SetFPS@VideoInfo@@QAEXII@Z			; VideoInfo::SetFPS
PUBLIC	??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z ; MVBlockFps::MVBlockFps
EXTRN	??_EMVBlockFps@@UAEPAXI@Z:PROC			; MVBlockFps::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$9
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$10
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$15
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$16
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$19
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVBlockFps@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1MVBlockFps@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVBlockFps@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVBlockFps@@UAE@XZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVBlockFps@@UAE@XZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVBlockFps@@UAE@XZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVBlockFps@@UAE@XZ$18
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	021H
	DD	FLAT:__unwindtable$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$16
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$20
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9
	DD	012H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10
	DD	012H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$21
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$25
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$27
	DD	0aH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$28
	DD	09H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$29
	DD	08H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$30
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$31
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$32
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$33
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
__super$ = 12						; size = 4
_mvbw$ = 16						; size = 4
_mvfw$ = 20						; size = 4
__num$ = 24						; size = 4
__den$ = 28						; size = 4
__mode$ = 32						; size = 4
__ml$ = 36						; size = 8
$T2 = 44						; size = 4
$T3 = 44						; size = 4
__blend$ = 44						; size = 1
_nSCD1$ = 48						; size = 4
_nSCD2$ = 52						; size = 4
tv1795 = 56						; size = 4
tv1794 = 56						; size = 4
_nSuperPel$1$ = 56					; size = 4
$T4 = 56						; size = 4
$T5 = 56						; size = 4
$T6 = 56						; size = 4
$T7 = 56						; size = 4
$T8 = 56						; size = 4
__isse2$ = 56						; size = 1
tv1859 = 60						; size = 4
_nHeightS$1$ = 60					; size = 4
__planar$ = 60						; size = 1
_mt_flag$ = 64						; size = 1
_env$ = 68						; size = 4
??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z PROC ; MVBlockFps::MVBlockFps, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvblockfps.cpp

; 43   :   : GenericVideoFilter(_child)

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN69@MVBlockFps
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN69@MVBlockFps
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN69@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 43   :   : GenericVideoFilter(_child)

	mov	ecx, ebx
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 44   :   , MVFilter(mvbw, "MBlockFps", env, 1, 0)

	mov	esi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR _mvbw$[ebp]
	push	0
	push	1
	push	esi
	push	OFFSET ??_C@_09PDPBMHMM@MBlockFps?$AA@
	push	ecx
	lea	ecx, DWORD PTR [ebx+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter

; 45   :   , mvClipB(mvbw, nSCD1, nSCD2, env, 1, 0)

	mov	edi, DWORD PTR _nSCD2$[ebp]
	lea	eax, DWORD PTR _mvbw$[ebp]
	push	0
	push	1
	push	esi
	mov	esi, DWORD PTR _nSCD1$[ebp]
	lea	ecx, DWORD PTR [ebx+152]
	push	edi
	push	esi
	push	eax

; 48   : {

	mov	DWORD PTR [ebx], OFFSET ??_7MVBlockFps@@6B@
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	push	0
	push	1
	push	DWORD PTR _env$[ebp]
	lea	eax, DWORD PTR _mvfw$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	edi
	push	esi
	push	eax
	lea	ecx, DWORD PTR [ebx+392]
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 47   :   , super(_super)

	lea	ecx, DWORD PTR [ebx+664]
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN73@MVBlockFps
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN73@MVBlockFps
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __super$[ebp]
	push	edx
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN73@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 47   :   , super(_super)

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	test	eax, eax
	je	SHORT $LN138@MVBlockFps
	cmp	DWORD PTR [eax], 24			; 00000018H
	jbe	SHORT $LN137@MVBlockFps
	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 49   :   if (!vi.IsYUV() && !vi.IsYUVA())

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvblockfps.cpp

; 49   :   if (!vi.IsYUV() && !vi.IsYUVA())

	test	al, al
	jne	SHORT $LN143@MVBlockFps
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN137@MVBlockFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 716  :   bool IsYUVA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsYUVA, false) )

	test	eax, eax
	je	SHORT $LN138@MVBlockFps
	cmp	DWORD PTR [eax], 564			; 00000234H
	jbe	SHORT $LN138@MVBlockFps
	mov	eax, DWORD PTR [eax+564]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 49   :   if (!vi.IsYUV() && !vi.IsYUVA())

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 716  :   bool IsYUVA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsYUVA, false) )

	call	eax
; File c:\github\mvtools\sources\mvblockfps.cpp

; 49   :   if (!vi.IsYUV() && !vi.IsYUVA())

	test	al, al
	jne	SHORT $LN143@MVBlockFps
$LN138@MVBlockFps:

; 50   :     env->ThrowError("MBlockFps: Clip must be YUV or YUY2");

	mov	esi, DWORD PTR _env$[ebp]
	push	OFFSET ??_C@_0CE@FPGFCKKD@MBlockFps?3?5Clip?5must?5be?5YUV?5or?5Y@
	push	esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+20]
	add	esp, 8
	jmp	SHORT $LN2@MVBlockFps
$LN143@MVBlockFps:
	mov	esi, DWORD PTR _env$[ebp]
$LN2@MVBlockFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN141@MVBlockFps
	cmp	DWORD PTR [eax], 536			; 00000218H
	jbe	SHORT $LN141@MVBlockFps
	mov	eax, DWORD PTR [eax+536]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 51   :   if (vi.BitsPerComponent() > 16)

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	call	eax
; File c:\github\mvtools\sources\mvblockfps.cpp

; 51   :   if (vi.BitsPerComponent() > 16)

	cmp	eax, 16					; 00000010H
	jle	SHORT $LN141@MVBlockFps

; 52   :     env->ThrowError("MBlockFps: only 8-16 bit clips are allowed");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CL@HJOLEPGD@MBlockFps?3?5only?58?916?5bit?5clips?5a@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN141@MVBlockFps:

; 53   : 
; 54   :   numeratorOld = vi.fps_numerator;
; 55   :   denominatorOld = vi.fps_denominator;
; 56   : 
; 57   :   if (_num != 0 && _den != 0)

	mov	eax, DWORD PTR __num$[ebp]
	mov	ecx, DWORD PTR [ebx+24]
	mov	esi, DWORD PTR [ebx+28]
	mov	DWORD PTR [ebx+640], ecx
	mov	DWORD PTR [ebx+644], esi
	test	eax, eax
	je	SHORT $LN4@MVBlockFps
	mov	edx, DWORD PTR __den$[ebp]
	test	edx, edx
	je	SHORT $LN4@MVBlockFps

; 58   :   {
; 59   :     numerator = _num;

	mov	DWORD PTR [ebx+632], eax

; 60   :     denominator = _den;

	mov	DWORD PTR [ebx+636], edx
	jmp	SHORT $LN7@MVBlockFps
$LN4@MVBlockFps:

; 61   :   }
; 62   :   else if (numeratorOld < (1 << 30))

	cmp	ecx, 1073741824				; 40000000H
	jae	SHORT $LN6@MVBlockFps

; 63   :   {
; 64   :     numerator = (numeratorOld << 1); // double fps by default

	lea	eax, DWORD PTR [ecx+ecx]

; 65   :     denominator = denominatorOld;

	mov	DWORD PTR [ebx+636], esi
	mov	DWORD PTR [ebx+632], eax

; 66   :   }
; 67   :   else // very big numerator

	jmp	SHORT $LN7@MVBlockFps
$LN6@MVBlockFps:

; 68   :   {
; 69   :     numerator = numeratorOld;
; 70   :     denominator = (denominatorOld >> 1);// double fps by default

	mov	eax, esi
	mov	DWORD PTR [ebx+632], ecx
	shr	eax, 1
	mov	DWORD PTR [ebx+636], eax
$LN7@MVBlockFps:

; 71   :   }
; 72   : 
; 73   :   //  safe for big numbers since v2.1
; 74   :   fa = __int64(denominator)*__int64(numeratorOld);

	mov	eax, DWORD PTR [ebx+636]
	mul	ecx
	mov	DWORD PTR [ebx+672], eax

; 75   :   fb = __int64(numerator)*__int64(denominatorOld);

	mov	eax, DWORD PTR [ebx+632]
	mov	DWORD PTR [ebx+676], edx
	mul	esi
	mov	DWORD PTR [ebx+680], eax

; 76   :   __int64 fgcd = gcd(fa, fb); // general common divisor

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ebx+684], edx
	mov	ebx, DWORD PTR [ebx+676]
	push	DWORD PTR [eax+684]
	push	DWORD PTR [eax+680]
	push	ebx
	push	DWORD PTR [eax+672]
	call	?gcd@@YA_J_J0@Z				; gcd
	add	esp, 16					; 00000010H
	mov	esi, edx
	mov	edi, eax

; 77   :   fa /= fgcd;

	push	esi
	push	edi
	push	ebx
	mov	ebx, DWORD PTR _this$[ebp]
	push	DWORD PTR [ebx+672]
	call	__alldiv

; 78   :   fb /= fgcd;

	push	esi
	push	edi
	push	DWORD PTR [ebx+684]
	mov	DWORD PTR [ebx+672], eax
	push	DWORD PTR [ebx+680]
	mov	DWORD PTR [ebx+676], edx
	call	__alldiv
	mov	DWORD PTR [ebx+680], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 668  :   void SetFPS(unsigned numerator, unsigned denominator) AVS_BakedCode(AVS_LinkCall(SetFPS)(numerator, denominator))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvblockfps.cpp

; 78   :   fb /= fgcd;

	mov	DWORD PTR [ebx+684], edx
; File c:\github\mvtools\sources\include\avisynth.h

; 668  :   void SetFPS(unsigned numerator, unsigned denominator) AVS_BakedCode(AVS_LinkCall(SetFPS)(numerator, denominator))

	test	eax, eax
	je	SHORT $LN89@MVBlockFps
	cmp	DWORD PTR [eax], 160			; 000000a0H
	jbe	SHORT $LN89@MVBlockFps
	push	DWORD PTR [ebx+636]
	mov	eax, DWORD PTR [eax+160]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 80   :   vi.SetFPS(numerator, denominator);

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 668  :   void SetFPS(unsigned numerator, unsigned denominator) AVS_BakedCode(AVS_LinkCall(SetFPS)(numerator, denominator))

	push	DWORD PTR [ebx+632]
	call	eax
$LN89@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 82   :   vi.num_frames = (int)(1 + __int64(vi.num_frames - 1) * fb / fa);

	push	DWORD PTR [ebx+684]
	mov	eax, DWORD PTR [ebx+32]
	push	DWORD PTR [ebx+680]
	dec	eax
	cdq
	push	edx
	push	eax
	call	__allmul
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+672]
	push	edx
	push	eax
	call	__alldiv
	inc	eax
	mov	DWORD PTR [ebx+32], eax
	mov	eax, DWORD PTR __mode$[ebp]
	mov	DWORD PTR [ebx+648], eax

; 83   : 
; 84   :   mode = _mode;
; 85   :   if (mode < 0 || mode >8)

	test	eax, eax
	js	SHORT $LN9@MVBlockFps
	cmp	eax, 8
	jle	SHORT $LN144@MVBlockFps
$LN9@MVBlockFps:

; 86   :     env->ThrowError("MBlockFps: mode from 0 to 8");

	mov	esi, DWORD PTR _env$[ebp]
	push	OFFSET ??_C@_0BM@PBKIEKMD@MBlockFps?3?5mode?5from?50?5to?58?$AA@
	push	esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+20]
	add	esp, 8
	jmp	SHORT $LN8@MVBlockFps
$LN144@MVBlockFps:
	mov	esi, DWORD PTR _env$[ebp]
$LN8@MVBlockFps:

; 87   :   ml = _ml;
; 88   :   isse_flag = _isse2;
; 89   :   planar = _planar;
; 90   :   blend = _blend;
; 91   : 
; 92   :   if (mvClipB.GetDeltaFrame() <= 0 || mvClipF.GetDeltaFrame() <= 0)

	cmp	DWORD PTR [ebx+292], 0
	mov	al, BYTE PTR __isse2$[ebp]
	movsd	xmm0, QWORD PTR __ml$[ebp]
	mov	BYTE PTR [ebx+668], al
	mov	al, BYTE PTR __planar$[ebp]
	mov	BYTE PTR [ebx+669], al
	mov	al, BYTE PTR __blend$[ebp]
	movsd	QWORD PTR [ebx+656], xmm0
	mov	BYTE PTR [ebx+670], al
	jle	SHORT $LN11@MVBlockFps
	cmp	DWORD PTR [ebx+532], 0
	jg	SHORT $LN10@MVBlockFps
$LN11@MVBlockFps:

; 93   :     env->ThrowError("MBlockFPS: cannot use motion vectors with absolute frame references.");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0EF@FFNOFKJN@MBlockFPS?3?5cannot?5use?5motion?5vec@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN10@MVBlockFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+664]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN46@MVBlockFps

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN45@MVBlockFps
$LN46@MVBlockFps:
	push	ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 97   :   memcpy(&params, &super->GetVideoInfo().num_audio_samples, 8);

	call	eax
$LN45@MVBlockFps:
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+36]

; 98   :   int nHeightS = params.nHeight;

	movzx	eax, cx
	mov	DWORD PTR _nHeightS$1$[ebp], eax

; 99   :   nSuperHPad = params.nHPad;

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	movzx	eax, al
	mov	DWORD PTR [ebx+856], eax

; 100  :   nSuperVPad = params.nVPad;
; 101  :   int nSuperPel = params.nPel;

	movzx	eax, dl
	mov	DWORD PTR _nSuperPel$1$[ebp], eax

; 102  :   nSuperModeYUV = params.nModeYUV;

	mov	eax, edx
	shr	eax, 8
	shr	ecx, 24					; 00000018H
	movzx	eax, al

; 103  :   int nSuperLevels = params.nLevels;

	shr	edx, 16					; 00000010H

; 104  : 
; 105  :   // todo: super_xRatioUV?
; 106  :   pRefBGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse_flag, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	push	44					; 0000002cH
	mov	DWORD PTR [ebx+860], ecx
	mov	DWORD PTR [ebx+688], eax
	movzx	edi, dl
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T3[ebp], ecx
	mov	esi, DWORD PTR _mt_flag$[ebp]
	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	DWORD PTR [ebx+140]
	movzx	eax, BYTE PTR [ebx+668]
	push	DWORD PTR [ebx+136]
	push	DWORD PTR [ebx+124]
	push	DWORD PTR [ebx+120]
	push	eax
	push	DWORD PTR [ebx+688]
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR _nSuperPel$1$[ebp]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	push	edi
	call	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ; MVGroupOfFrames::MVGroupOfFrames
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 107  :   pRefFGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse_flag, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	push	44					; 0000002cH
	mov	DWORD PTR [ebx+840], eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], ecx
	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	DWORD PTR [ebx+140]
	movzx	eax, BYTE PTR [ebx+668]
	push	DWORD PTR [ebx+136]
	push	DWORD PTR [ebx+124]
	push	DWORD PTR [ebx+120]
	push	eax
	push	DWORD PTR [ebx+688]
	push	DWORD PTR [ebx+860]
	push	DWORD PTR [ebx+856]
	push	DWORD PTR _nSuperPel$1$[ebp]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	push	edi
	call	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ; MVGroupOfFrames::MVGroupOfFrames
	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+664]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 107  :   pRefFGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse_flag, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	mov	DWORD PTR [ebx+844], eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN48@MVBlockFps
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN47@MVBlockFps
$LN48@MVBlockFps:
	push	ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 108  :   int nSuperWidth = super->GetVideoInfo().width;

	call	eax
$LN47@MVBlockFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+664]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 108  :   int nSuperWidth = super->GetVideoInfo().width;

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	je	SHORT $LN49@MVBlockFps

; 109  :   int nSuperHeight = super->GetVideoInfo().height;

	push	ecx
	call	eax
$LN49@MVBlockFps:

; 110  : 
; 111  :   if (nHeight != nHeightS
; 112  :     || nHeight != vi.height
; 113  :     || nWidth != nSuperWidth - nSuperHPad * 2
; 114  :     || nWidth != vi.width
; 115  :     || nPel != nSuperPel)

	mov	eax, DWORD PTR [ebx+96]
	cmp	eax, DWORD PTR _nHeightS$1$[ebp]
	jne	SHORT $LN13@MVBlockFps
	cmp	eax, DWORD PTR [ebx+20]
	jne	SHORT $LN13@MVBlockFps
	mov	eax, DWORD PTR [ebx+856]
	mov	ecx, DWORD PTR [ebx+92]
	add	eax, eax
	sub	esi, eax
	cmp	ecx, esi
	jne	SHORT $LN13@MVBlockFps
	cmp	ecx, DWORD PTR [ebx+16]
	jne	SHORT $LN13@MVBlockFps
	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	cmp	DWORD PTR [ebx+104], eax
	je	SHORT $LN145@MVBlockFps
$LN13@MVBlockFps:

; 116  :   {
; 117  :     env->ThrowError("MBlockFps : wrong source or super frame size");

	mov	esi, DWORD PTR _env$[ebp]
	push	OFFSET ??_C@_0CN@FBLKKCJO@MBlockFps?5?3?5wrong?5source?5or?5supe@
	push	esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+20]
	add	esp, 8
	jmp	SHORT $LN12@MVBlockFps
$LN145@MVBlockFps:
	mov	esi, DWORD PTR _env$[ebp]
$LN12@MVBlockFps:

; 118  :   }
; 119  : 
; 120  :   // in overlaps.h
; 121  :   // OverlapsLsbFunction
; 122  :   // OverlapsFunction
; 123  :   // in M(V)DegrainX: DenoiseXFunction
; 124  :   arch_t arch;
; 125  :   if ((((env->GetCPUFlags() & CPUF_AVX2) != 0) & isse_flag))

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
	movzx	ecx, BYTE PTR [ebx+668]
	shr	eax, 13					; 0000000dH
	and	ecx, eax
	test	cl, 1
	je	SHORT $LN14@MVBlockFps

; 126  :     arch = USE_AVX2;

	mov	esi, 6
	jmp	SHORT $LN20@MVBlockFps
$LN14@MVBlockFps:

; 127  :   else if ((((env->GetCPUFlags() & CPUF_AVX) != 0) & isse_flag))

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
	movzx	ecx, BYTE PTR [ebx+668]
	shr	eax, 11					; 0000000bH
	and	ecx, eax
	test	cl, 1
	je	SHORT $LN16@MVBlockFps

; 128  :     arch = USE_AVX;

	mov	esi, 5
	jmp	SHORT $LN20@MVBlockFps
$LN16@MVBlockFps:

; 129  :   else if ((((env->GetCPUFlags() & CPUF_SSE4_1) != 0) & isse_flag))

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
	movzx	ecx, BYTE PTR [ebx+668]
	shr	eax, 10					; 0000000aH
	and	ecx, eax
	test	cl, 1
	je	SHORT $LN18@MVBlockFps

; 130  :     arch = USE_SSE41;

	mov	esi, 3
	jmp	SHORT $LN20@MVBlockFps
$LN18@MVBlockFps:

; 131  :   else if ((((env->GetCPUFlags() & CPUF_SSE2) != 0) & isse_flag))

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
	shr	eax, 5
	movzx	esi, al
	movzx	eax, BYTE PTR [ebx+668]
	and	esi, eax
	and	esi, 1
	add	esi, esi
$LN20@MVBlockFps:

; 132  :     arch = USE_SSE2;
; 133  :   /*  else if ((pixelsize == 1) && _isse_flag) // PF no MMX support
; 134  :   arch = USE_MMX;*/
; 135  :   else
; 136  :     arch = NO_SIMD;
; 137  : 
; 138  :   OVERSLUMA = get_overlaps_function(nBlkSizeX, nBlkSizeY, pixelsize, arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+76]
	push	esi
	push	DWORD PTR [ebx+136]
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function
	mov	DWORD PTR [ebx+804], eax

; 139  :   OVERSCHROMA = get_overlaps_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, pixelsize, arch);

	mov	eax, DWORD PTR [ebx+80]
	cdq
	idiv	DWORD PTR [ebx+124]
	push	esi
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+76]
	cdq
	idiv	DWORD PTR [ebx+120]
	push	DWORD PTR [ebx+136]
	mov	edx, ecx
	mov	ecx, eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 140  :   BLITLUMA = get_copy_function(nBlkSizeX, nBlkSizeY, pixelsize, arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+76]
	push	esi
	push	DWORD PTR [ebx+136]
	mov	DWORD PTR [ebx+808], eax
	call	?get_copy_function@@YAP6AXPAEHPBEH@ZHHHW4arch_t@@@Z ; get_copy_function
	mov	DWORD PTR [ebx+776], eax

; 141  :   BLITCHROMA = get_copy_function(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, pixelsize, arch);

	mov	eax, DWORD PTR [ebx+80]
	cdq
	idiv	DWORD PTR [ebx+124]
	push	esi
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+76]
	cdq
	idiv	DWORD PTR [ebx+120]
	push	DWORD PTR [ebx+136]
	mov	edx, ecx
	mov	ecx, eax
	call	?get_copy_function@@YAP6AXPAEHPBEH@ZHHHW4arch_t@@@Z ; get_copy_function

; 142  :   // 161115
; 143  :   OVERSLUMA16 = get_overlaps_function(nBlkSizeX, nBlkSizeY, sizeof(uint16_t), arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+76]
	push	esi
	push	2
	mov	DWORD PTR [ebx+780], eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 144  :   OVERSCHROMA16 = get_overlaps_function(nBlkSizeX >> nLogxRatioUV, nBlkSizeY >> nLogyRatioUV, sizeof(uint16_t), arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+132]
	mov	DWORD PTR [ebx+812], eax
	mov	eax, DWORD PTR [ebx+76]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+128]
	sar	eax, cl
	push	esi
	push	2
	mov	ecx, eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 145  : 
; 146  :   // may be padded for full frame cover
; 147  :   nBlkXP = (nBlkX*(nBlkSizeX - nOverlapX) + nOverlapX < nWidth) ? nBlkX + 1 : nBlkX;

	mov	edx, DWORD PTR [ebx+76]
	add	esp, 48					; 00000030H
	sub	edx, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR [ebx+816], eax
	mov	eax, ecx
	imul	eax, edx
	mov	DWORD PTR tv1794[ebp], edx
	add	eax, DWORD PTR [ebx+108]
	cmp	eax, DWORD PTR [ebx+92]
	jge	SHORT $LN31@MVBlockFps
	inc	ecx
$LN31@MVBlockFps:

; 148  :   nBlkYP = (nBlkY*(nBlkSizeY - nOverlapY) + nOverlapY < nHeight) ? nBlkY + 1 : nBlkY;

	mov	edi, DWORD PTR [ebx+112]
	mov	edx, DWORD PTR [ebx+80]
	mov	esi, DWORD PTR [ebx+68]
	sub	edx, edi
	mov	eax, esi
	mov	DWORD PTR [ebx+768], ecx
	imul	eax, edx
	mov	DWORD PTR tv1859[ebp], edi
	add	eax, edi
	cmp	eax, DWORD PTR [ebx+96]
	jge	SHORT $LN33@MVBlockFps
	inc	esi
$LN33@MVBlockFps:

; 149  :   nWidthP = nBlkXP*(nBlkSizeX - nOverlapX) + nOverlapX;

	mov	eax, DWORD PTR tv1794[ebp]
	imul	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]

; 150  :   nHeightP = nBlkYP*(nBlkSizeY - nOverlapY) + nOverlapY;

	imul	edx, esi
	mov	DWORD PTR [ebx+772], esi
	mov	ebx, DWORD PTR [ebx+108]
	add	ebx, eax

; 151  :   // for YV12 and any type
; 152  :   nWidthPUV = nWidthP / xRatioUV;
; 153  :   nHeightPUV = nHeightP / yRatioUV;

	mov	esi, DWORD PTR tv1859[ebp]
	mov	DWORD PTR [ecx+736], ebx
	mov	DWORD PTR tv1795[ebp], edx
	lea	eax, DWORD PTR [edx+edi]
	mov	DWORD PTR [ecx+740], eax
	mov	eax, ebx
	cdq
	idiv	DWORD PTR [ecx+120]
	mov	edi, eax
	mov	eax, DWORD PTR tv1795[ebp]
	mov	DWORD PTR [ecx+756], edi
	mov	ecx, DWORD PTR [ecx+124]
	lea	eax, DWORD PTR [eax+esi]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+752], eax

; 154  :   nHeightUV = nHeight / yRatioUV;

	mov	eax, DWORD PTR [edx+96]
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+760], eax

; 155  :   nWidthUV = nWidth / xRatioUV;

	mov	eax, DWORD PTR [ecx+92]
	cdq
	idiv	DWORD PTR [ecx+120]
	mov	DWORD PTR [ecx+764], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	ecx, DWORD PTR [ebx+15]
	mov	ebx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edi+15]
	and	eax, -16				; fffffff0H
	and	ecx, -16				; fffffff0H
; File c:\github\mvtools\sources\mvblockfps.cpp

; 158  :   nPitchUV = AlignNumber(nWidthPUV, 16);

	mov	DWORD PTR [ebx+748], eax

; 159  : 
; 160  :   // PF remark: masks are 8 bits
; 161  :   MaskFullYB = new BYTE[nHeightP*nPitchY];

	mov	eax, DWORD PTR tv1795[ebp]
	add	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebx+744], ecx
	imul	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+692], eax

; 162  :   MaskFullUVB = new BYTE[nHeightPUV*nPitchUV];

	mov	eax, DWORD PTR [ebx+752]
	imul	eax, DWORD PTR [ebx+748]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+696], eax

; 163  :   MaskFullYF = new BYTE[nHeightP*nPitchY];

	mov	eax, DWORD PTR [ebx+744]
	imul	eax, DWORD PTR [ebx+740]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+700], eax

; 164  :   MaskFullUVF = new BYTE[nHeightPUV*nPitchUV];

	mov	eax, DWORD PTR [ebx+752]
	imul	eax, DWORD PTR [ebx+748]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+704], eax

; 165  : 
; 166  :   MaskOccY = new BYTE[nHeightP*nPitchY];

	mov	eax, DWORD PTR [ebx+744]
	imul	eax, DWORD PTR [ebx+740]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+708], eax

; 167  :   MaskOccUV = new BYTE[nHeightPUV*nPitchUV];

	mov	eax, DWORD PTR [ebx+752]
	imul	eax, DWORD PTR [ebx+748]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+712], eax

; 168  : 
; 169  :   smallMaskF = new BYTE[nBlkXP*nBlkYP];

	mov	eax, DWORD PTR [ebx+772]
	imul	eax, DWORD PTR [ebx+768]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+716], eax

; 170  :   smallMaskB = new BYTE[nBlkXP*nBlkYP];

	mov	eax, DWORD PTR [ebx+772]
	imul	eax, DWORD PTR [ebx+768]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+720], eax

; 171  :   smallMaskO = new BYTE[nBlkXP*nBlkYP];

	mov	eax, DWORD PTR [ebx+772]
	imul	eax, DWORD PTR [ebx+768]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	mov	ecx, DWORD PTR [ebx+76]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 171  :   smallMaskO = new BYTE[nBlkXP*nBlkYP];

	mov	DWORD PTR [ebx+724], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	add	ecx, 15					; 0000000fH
; File c:\github\mvtools\sources\mvblockfps.cpp

; 176  :   TmpBlock = (BYTE *)_aligned_malloc(nBlkPitch*nBlkSizeY*pixelsize, tmpBlkAlign); // new BYTE[nBlkPitch*nBlkSizeY*pixelsize]; // may be more padding?

	mov	eax, DWORD PTR [ebx+136]
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	and	ecx, -16				; fffffff0H
; File c:\github\mvtools\sources\mvblockfps.cpp

; 176  :   TmpBlock = (BYTE *)_aligned_malloc(nBlkPitch*nBlkSizeY*pixelsize, tmpBlkAlign); // new BYTE[nBlkPitch*nBlkSizeY*pixelsize]; // may be more padding?

	imul	eax, ecx
	push	16					; 00000010H
	mov	DWORD PTR [ebx+732], ecx
	imul	eax, DWORD PTR [ebx+80]
	push	eax
	call	DWORD PTR __imp___aligned_malloc

; 177  : 
; 178  :   int CPUF_Resize = env->GetCPUFlags();

	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 44					; 0000002cH
	mov	DWORD PTR [ebx+728], eax
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+4]
	mov	esi, eax

; 179  :   if (!isse_flag) CPUF_Resize = (CPUF_Resize & !CPUF_INTEGER_SSE) & !CPUF_SSE2;

	xor	eax, eax
	cmp	BYTE PTR [ebx+668], al

; 180  : 
; 181  :   upsizer = new SimpleResize(nWidthP, nHeightP, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	cmove	esi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+772]
	push	DWORD PTR [ebx+768]
	push	DWORD PTR [ebx+740]
	push	DWORD PTR [ebx+736]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize

; 182  :   upsizerUV = new SimpleResize(nWidthPUV, nHeightPUV, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	mov	DWORD PTR [ebx+848], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+772]
	push	DWORD PTR [ebx+768]
	push	DWORD PTR [ebx+752]
	push	DWORD PTR [ebx+756]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize
	mov	DWORD PTR [ebx+852], eax

; 183  : 
; 184  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN23@MVBlockFps
	cmp	BYTE PTR [ebx+669], 0
	jne	SHORT $LN23@MVBlockFps

; 185  :   {
; 186  :     DstPlanes = new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes
	mov	DWORD PTR [ebx+784], eax
$LN23@MVBlockFps:
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	mov	eax, DWORD PTR [ebx+92]
	lea	ecx, DWORD PTR [eax+15]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 191  :   dstShortPitchUV = AlignNumber(nWidth / xRatioUV, tmpDstAlign);

	cdq
	idiv	DWORD PTR [ebx+120]
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	and	ecx, -16				; fffffff0H
	add	eax, 15					; 0000000fH
; File c:\github\mvtools\sources\mvblockfps.cpp

; 190  :   dstShortPitch = AlignNumber(nWidth, tmpDstAlign); // 2.5.11.22

	mov	DWORD PTR [ebx+832], ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	and	eax, -16				; fffffff0H
; File c:\github\mvtools\sources\mvblockfps.cpp

; 193  :   if (nOverlapX > 0 || nOverlapY > 0)

	cmp	DWORD PTR [ebx+108], 0
	mov	DWORD PTR [ebx+836], eax
	jg	SHORT $LN25@MVBlockFps
	cmp	DWORD PTR [ebx+112], 0
	jle	$LN24@MVBlockFps
$LN25@MVBlockFps:

; 194  :   {
; 195  :     OverWins = new OverlapWindows(nBlkSizeX, nBlkSizeY, nOverlapX, nOverlapY);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, eax
	push	DWORD PTR [ebx+112]
	push	DWORD PTR [ebx+108]
	push	DWORD PTR [ebx+80]
	push	DWORD PTR [ebx+76]
	call	??0OverlapWindows@@QAE@HHHH@Z		; OverlapWindows::OverlapWindows
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 196  :     OverWinsUV = new OverlapWindows(nBlkSizeX / xRatioUV, nBlkSizeY / yRatioUV, nOverlapX / xRatioUV, nOverlapY / yRatioUV);

	push	48					; 00000030H
	mov	DWORD PTR [ebx+796], eax
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], edi
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, edi
	mov	eax, DWORD PTR [ebx+112]
	cdq
	idiv	DWORD PTR [ebx+124]
	push	eax
	mov	eax, DWORD PTR [ebx+108]
	cdq
	idiv	DWORD PTR [ebx+120]
	push	eax
	mov	eax, DWORD PTR [ebx+80]
	cdq
	idiv	DWORD PTR [ebx+124]
	push	eax
	mov	eax, DWORD PTR [ebx+76]
	cdq
	idiv	DWORD PTR [ebx+120]
	push	eax
	call	??0OverlapWindows@@QAE@HHHH@Z		; OverlapWindows::OverlapWindows

; 197  :     // *pixelsize: allow reuse DstShort for DstInt
; 198  :     // todo: rename to DstTemp and make BYTE *, cast later.
; 199  :     DstShort = (unsigned short *)_aligned_malloc(dstShortPitch*nHeight * sizeof(short)*pixelsize, tmpDstAlign); // PF aligned

	mov	esi, DWORD PTR __imp___aligned_malloc
	mov	DWORD PTR [ebx+800], eax
	mov	eax, DWORD PTR [ebx+832]
	imul	eax, DWORD PTR [ebx+96]
	push	16					; 00000010H
	imul	eax, DWORD PTR [ebx+136]
	add	eax, eax
	push	eax
	call	esi
	mov	DWORD PTR [ebx+820], eax

; 200  :     DstShortU = (unsigned short *)_aligned_malloc(dstShortPitchUV*nHeight * sizeof(short)*pixelsize, tmpDstAlign);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+96]
	push	16					; 00000010H
	imul	eax, DWORD PTR [ebx+136]
	add	eax, eax
	push	eax
	call	esi
	mov	DWORD PTR [ebx+824], eax

; 201  :     DstShortV = (unsigned short *)_aligned_malloc(dstShortPitchUV*nHeight * sizeof(short)*pixelsize, tmpDstAlign);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+96]
	push	16					; 00000010H
	imul	eax, DWORD PTR [ebx+136]
	add	eax, eax
	push	eax
	call	esi
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+828], eax
$LN24@MVBlockFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN119@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN119@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN119@MVBlockFps:
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	eax, eax
	je	SHORT $LN124@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN124@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN124@MVBlockFps:
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	test	eax, eax
	je	SHORT $LN129@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN129@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _mvbw$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN129@MVBlockFps:
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	eax, eax
	je	SHORT $LN139@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN139@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _mvfw$[ebp]
	call	eax
$LN139@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 203  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _mvfw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _mvbw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR __super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 664				; 00000298H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$9:
	push	44					; 0000002cH
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$10:
	push	44					; 0000002cH
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$14:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$15:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$17:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$18:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z$19:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVBlockFps@@QAE@VPClip@@000IIHN_NHH111PAVIScriptEnvironment@@@Z ENDP ; MVBlockFps::MVBlockFps
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?gcd@@YA_J_J0@Z
_TEXT	SEGMENT
_shift$1$ = -8						; size = 4
_u$1$ = -4						; size = 4
_u$ = 8							; size = 8
_v$ = 16						; size = 8
?gcd@@YA_J_J0@Z PROC					; gcd, COMDAT

; 41   :  {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 42   :      int shift;
; 43   : 
; 44   :      /* GCD(0,x) := x */
; 45   :      if (u == 0 || v == 0)

	mov	edx, DWORD PTR _u$[ebp]
	sub	esp, 12					; 0000000cH
	mov	eax, edx
	push	ebx
	mov	ebx, DWORD PTR _u$[ebp+4]
	or	eax, ebx
	mov	eax, DWORD PTR _v$[ebp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _v$[ebp]
	je	$LN13@gcd
	mov	ecx, edi
	or	ecx, eax
	je	$LN13@gcd

; 47   : 
; 48   :      /* Let shift := lg K, where K is the greatest power of 2
; 49   :         dividing both u and v. */
; 50   :      for (shift = 0; ((u | v) & 1) == 0; ++shift) {

	mov	ecx, edx
	xor	esi, esi
	or	ecx, edi
	mov	DWORD PTR _shift$1$[esp+24], esi
	and	ecx, 1
	or	ecx, esi
	jne	SHORT $LN18@gcd
	npad	3
$LL4@gcd:

; 51   :          u >>= 1;

	shrd	edx, ebx, 1

; 52   :          v >>= 1;

	shrd	edi, eax, 1
	mov	ecx, edx
	sar	ebx, 1
	or	ecx, edi
	sar	eax, 1
	and	ecx, 1
	inc	esi
	or	ecx, 0
	je	SHORT $LL4@gcd
	mov	DWORD PTR _shift$1$[esp+24], esi
$LN18@gcd:

; 53   :      }
; 54   : 
; 55   :      while ((u & 1) == 0)

	mov	ecx, edx
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LL9@gcd
$LL5@gcd:

; 56   :        u >>= 1;

	shrd	edx, ebx, 1
	mov	ecx, edx
	sar	ebx, 1
	and	ecx, 1
	or	ecx, 0
	je	SHORT $LL5@gcd
$LL9@gcd:

; 57   : 
; 58   :      /* From here on, u is always odd. */
; 59   :      do {
; 60   :          while ((v & 1) == 0)  /* Loop X */

	mov	ecx, edi
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN11@gcd
$LL10@gcd:

; 61   :            v >>= 1;

	shrd	edi, eax, 1
	mov	ecx, edi
	sar	eax, 1
	and	ecx, 1
	or	ecx, 0
	je	SHORT $LL10@gcd
$LN11@gcd:

; 62   : 
; 63   :          /* Now u and v are both odd, so diff(u, v) is even.
; 64   :             Let u = min(u, v), v = diff(u, v)/2. */
; 65   :          if (u < v) {

	cmp	ebx, eax
	jg	SHORT $LN14@gcd
	jl	SHORT $LN40@gcd
	cmp	edx, edi
	jae	SHORT $LN14@gcd
$LN40@gcd:

; 66   :              v -= u;

	sub	edi, edx
	sbb	eax, ebx

; 67   :          } else {

	jmp	SHORT $LN15@gcd
$LN14@gcd:

; 68   :              __int64 diff = u - v;

	sub	edx, edi

; 69   :              u = v;

	mov	DWORD PTR _u$1$[esp+24], edi
	mov	ecx, edx
	sbb	ebx, eax

; 70   :              v = diff;

	mov	edi, ecx
	mov	edx, ebx
	mov	ebx, eax
	mov	eax, edx
	mov	edx, DWORD PTR _u$1$[esp+24]
$LN15@gcd:

; 71   :          }
; 72   :          v >>= 1;

	shrd	edi, eax, 1
	sar	eax, 1

; 73   :      } while (v != 0);

	mov	esi, edi
	or	esi, eax
	jne	SHORT $LL9@gcd

; 74   : 
; 75   :      return u << shift;

	mov	ecx, DWORD PTR _shift$1$[esp+24]
	mov	eax, edx
	mov	edx, ebx
	call	__allshl

; 76   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@gcd:

; 46   :        return u | v;

	or	edx, edi
	or	ebx, eax

; 76   : }

	pop	edi
	mov	eax, edx
	mov	edx, ebx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?gcd@@YA_J_J0@Z ENDP					; gcd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?SetFPS@VideoInfo@@QAEXII@Z
_TEXT	SEGMENT
_numerator$ = 8						; size = 4
_denominator$ = 12					; size = 4
?SetFPS@VideoInfo@@QAEXII@Z PROC			; VideoInfo::SetFPS, COMDAT
; _this$ = ecx

; 668  :   void SetFPS(unsigned numerator, unsigned denominator) AVS_BakedCode(AVS_LinkCall(SetFPS)(numerator, denominator))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@SetFPS
	cmp	DWORD PTR [eax], 160			; 000000a0H
	jbe	SHORT $LN3@SetFPS
	mov	eax, DWORD PTR [eax+160]
	jmp	eax
$LN3@SetFPS:
	ret	8
?SetFPS@VideoInfo@@QAEXII@Z ENDP			; VideoInfo::SetFPS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?IsYUVA@VideoInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsYUVA@VideoInfo@@QBE_NXZ PROC				; VideoInfo::IsYUVA, COMDAT
; _this$ = ecx

; 716  :   bool IsYUVA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsYUVA, false) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@IsYUVA
	cmp	DWORD PTR [eax], 564			; 00000234H
	jbe	SHORT $LN3@IsYUVA
	mov	eax, DWORD PTR [eax+564]
	jmp	eax
$LN3@IsYUVA:
	xor	al, al
	ret	0
?IsYUVA@VideoInfo@@QBE_NXZ ENDP				; VideoInfo::IsYUVA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?IsPlanarRGB@VideoInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsPlanarRGB@VideoInfo@@QBE_NXZ PROC			; VideoInfo::IsPlanarRGB, COMDAT
; _this$ = ecx

; 719  :   bool IsPlanarRGB() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsPlanarRGB, false) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@IsPlanarRG
	cmp	DWORD PTR [eax], 568			; 00000238H
	jbe	SHORT $LN3@IsPlanarRG
	mov	eax, DWORD PTR [eax+568]
	jmp	eax
$LN3@IsPlanarRG:
	xor	al, al
	ret	0
?IsPlanarRGB@VideoInfo@@QBE_NXZ ENDP			; VideoInfo::IsPlanarRGB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?IsPlanarRGBA@VideoInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsPlanarRGBA@VideoInfo@@QBE_NXZ PROC			; VideoInfo::IsPlanarRGBA, COMDAT
; _this$ = ecx

; 722  :   bool IsPlanarRGBA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsPlanarRGBA, false) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@IsPlanarRG
	cmp	DWORD PTR [eax], 572			; 0000023cH
	jbe	SHORT $LN3@IsPlanarRG
	mov	eax, DWORD PTR [eax+572]
	jmp	eax
$LN3@IsPlanarRG:
	xor	al, al
	ret	0
?IsPlanarRGBA@VideoInfo@@QBE_NXZ ENDP			; VideoInfo::IsPlanarRGBA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??4PVideoFrame@@QAEXPAVVideoFrame@@@Z
_TEXT	SEGMENT
_x$dead$ = 8						; size = 4
??4PVideoFrame@@QAEXPAVVideoFrame@@@Z PROC		; PVideoFrame::operator=, COMDAT
; _this$ = ecx

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@operator
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN3@operator
	mov	eax, DWORD PTR [eax+264]
	mov	DWORD PTR _x$dead$[esp-4], 0
	jmp	eax
$LN3@operator:
	ret	4
??4PVideoFrame@@QAEXPAVVideoFrame@@@Z ENDP		; PVideoFrame::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalysisdata.h
;	COMDAT ?GetDeltaFrame@MVAnalysisData@@QBEHXZ
_TEXT	SEGMENT
?GetDeltaFrame@MVAnalysisData@@QBEHXZ PROC		; MVAnalysisData::GetDeltaFrame, COMDAT
; _this$ = ecx

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	eax, DWORD PTR [ecx+24]
	ret	0
?GetDeltaFrame@MVAnalysisData@@QBEHXZ ENDP		; MVAnalysisData::GetDeltaFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvclip.h
;	COMDAT ?GetBlkCount@MVClip@@QBEHXZ
_TEXT	SEGMENT
?GetBlkCount@MVClip@@QBEHXZ PROC			; MVClip::GetBlkCount, COMDAT
; _this$ = ecx

; 80   :    inline int GetBlkCount() const { return nBlkCount; }

	mov	eax, DWORD PTR [ecx+204]
	ret	0
?GetBlkCount@MVClip@@QBEHXZ ENDP			; MVClip::GetBlkCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.h
;	COMDAT ?SetCacheHints@MVBlockFps@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVBlockFps@@UAGHHH@Z PROC		; MVBlockFps::SetCacheHints, COMDAT

; 105  :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 106  :   }

	ret	12					; 0000000cH
?SetCacheHints@MVBlockFps@@UAGHHH@Z ENDP		; MVBlockFps::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVBlockFps@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVBlockFps@@UAEPAXI@Z PROC				; MVBlockFps::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVBlockFps@@UAE@XZ			; MVBlockFps::~MVBlockFps
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	864					; 00000360H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVBlockFps@@UAEPAXI@Z ENDP				; MVBlockFps::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ??1MVBlockFps@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVBlockFps@@UAE@XZ PROC				; MVBlockFps::~MVBlockFps, COMDAT
; _this$ = ecx

; 206  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVBlockFps@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 207  :   delete upsizer;

	mov	edi, DWORD PTR __imp___aligned_free
	mov	ebx, DWORD PTR [esi+848]
	mov	DWORD PTR [esi], OFFSET ??_7MVBlockFps@@6B@
	test	ebx, ebx
	je	SHORT $LN21@MVBlockFps
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN21@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 208  :   delete upsizerUV;

	mov	ebx, DWORD PTR [esi+852]
	test	ebx, ebx
	je	SHORT $LN28@MVBlockFps
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN28@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 210  :   delete[] MaskFullYB;

	push	DWORD PTR [esi+692]
	call	??_V@YAXPAX@Z				; operator delete[]

; 211  :   delete[] MaskFullUVB;

	push	DWORD PTR [esi+696]
	call	??_V@YAXPAX@Z				; operator delete[]

; 212  :   delete[] MaskFullYF;

	push	DWORD PTR [esi+700]
	call	??_V@YAXPAX@Z				; operator delete[]

; 213  :   delete[] MaskFullUVF;

	push	DWORD PTR [esi+704]
	call	??_V@YAXPAX@Z				; operator delete[]

; 214  :   delete[] MaskOccY;

	push	DWORD PTR [esi+708]
	call	??_V@YAXPAX@Z				; operator delete[]

; 215  :   delete[] MaskOccUV;

	push	DWORD PTR [esi+712]
	call	??_V@YAXPAX@Z				; operator delete[]

; 216  :   delete[] smallMaskF;

	push	DWORD PTR [esi+716]
	call	??_V@YAXPAX@Z				; operator delete[]

; 217  :   delete[] smallMaskB;

	push	DWORD PTR [esi+720]
	call	??_V@YAXPAX@Z				; operator delete[]

; 218  :   delete[] smallMaskO;

	push	DWORD PTR [esi+724]
	call	??_V@YAXPAX@Z				; operator delete[]

; 219  : 
; 220  :   _aligned_free(TmpBlock); // PF 161116

	push	DWORD PTR [esi+728]
	call	edi

; 221  : 
; 222  : 
; 223  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [esi+116]
	add	esp, 40					; 00000028H
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN35@MVBlockFps
	cmp	BYTE PTR [esi+669], 0
	jne	SHORT $LN35@MVBlockFps

; 224  :   {
; 225  :     delete DstPlanes;

	mov	ebx, DWORD PTR [esi+784]
	test	ebx, ebx
	je	SHORT $LN35@MVBlockFps
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN35@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 227  :   delete pRefBGOF;

	mov	ebx, DWORD PTR [esi+840]
	test	ebx, ebx
	je	SHORT $LN42@MVBlockFps
	mov	ecx, ebx
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN42@MVBlockFps:

; 228  :   delete pRefFGOF;

	mov	ebx, DWORD PTR [esi+844]
	test	ebx, ebx
	je	SHORT $LN46@MVBlockFps
	mov	ecx, ebx
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN46@MVBlockFps:

; 229  :   if (nOverlapX > 0 || nOverlapY > 0)

	cmp	DWORD PTR [esi+108], 0
	jg	SHORT $LN4@MVBlockFps
	cmp	DWORD PTR [esi+112], 0
	jle	SHORT $LN3@MVBlockFps
$LN4@MVBlockFps:

; 230  :   {
; 231  :     delete OverWins;

	mov	ecx, DWORD PTR [esi+796]
	test	ecx, ecx
	je	SHORT $LN16@MVBlockFps
	push	ecx
	call	??_GOverlapWindows@@QAEPAXI@Z
$LN16@MVBlockFps:

; 232  :     delete OverWinsUV;

	mov	ecx, DWORD PTR [esi+800]
	test	ecx, ecx
	je	SHORT $LN18@MVBlockFps
	push	ecx
	call	??_GOverlapWindows@@QAEPAXI@Z
$LN18@MVBlockFps:

; 233  :     _aligned_free(DstShort); // PF 161116

	push	DWORD PTR [esi+820]
	call	edi

; 234  :     _aligned_free(DstShortU);

	push	DWORD PTR [esi+824]
	call	edi

; 235  :     _aligned_free(DstShortV);

	push	DWORD PTR [esi+828]
	call	edi
	add	esp, 12					; 0000000cH
$LN3@MVBlockFps:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN51@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN51@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 241  : }

	lea	ecx, DWORD PTR [esi+664]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
$LN51@MVBlockFps:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+456]
	mov	DWORD PTR [esi+392], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN62@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN62@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+400]
	call	eax
$LN62@MVBlockFps:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+392], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN76@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN76@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN76@MVBlockFps:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN93@MVBlockFps
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN93@MVBlockFps
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN93@MVBlockFps:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvblockfps.cpp

; 241  : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVBlockFps@@UAE@XZ$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVBlockFps@@UAE@XZ$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVBlockFps@@UAE@XZ$15:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVBlockFps@@UAE@XZ$18:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVBlockFps@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVBlockFps@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVBlockFps@@UAE@XZ ENDP				; MVBlockFps::~MVBlockFps
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\simpleresize.cpp
;	COMDAT ??_GSimpleResize@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GSimpleResize@@QAEPAXI@Z PROC			; SimpleResize::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi

; 103  :   _aligned_free(hControl);

	mov	esi, DWORD PTR __imp___aligned_free
	push	edi
	mov	edi, ecx
	push	DWORD PTR [edi+16]
	call	esi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [edi+28]
	call	esi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [edi+32]
	call	esi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [edi+20]
	call	esi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [edi+24]
	call	esi
	push	40					; 00000028H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??_GSimpleResize@@QAEPAXI@Z ENDP			; SimpleResize::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ?MultMasks@MVBlockFps@@AAEXPAE00HH@Z
_TEXT	SEGMENT
_smallmaskF$ = 8					; size = 4
tv316 = 12						; size = 4
_smallmaskB$ = 12					; size = 4
_smallmaskO$ = 16					; size = 4
_nBlkX$ = 20						; size = 4
_nBlkY$ = 24						; size = 4
?MultMasks@MVBlockFps@@AAEXPAE00HH@Z PROC		; MVBlockFps::MultMasks, COMDAT
; _this$dead$ = ecx

; 320  :   for (int j = 0; j < nBlkY; j++)

	mov	edx, DWORD PTR _nBlkY$[esp-4]
	test	edx, edx
	jle	SHORT $LN3@MultMasks
	mov	eax, DWORD PTR _smallmaskF$[esp-4]
	mov	ecx, DWORD PTR _smallmaskO$[esp-4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _nBlkX$[esp+8]
	push	edi
	mov	edi, DWORD PTR _smallmaskB$[esp+12]
	npad	4
$LL4@MultMasks:

; 321  :   {
; 322  :     for (int i = 0; i < nBlkX; i++) {

	test	esi, esi
	jle	SHORT $LN6@MultMasks
	mov	ebp, DWORD PTR _smallmaskO$[esp+12]
	mov	ebx, eax
	sub	ebx, edi
	mov	DWORD PTR tv316[esp+12], esi
	mov	ecx, edi
	sub	ebp, edi
$LL7@MultMasks:

; 323  :       smallmaskO[i] = (smallmaskF[i] * smallmaskB[i]) / 255;

	movzx	eax, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	movzx	edx, BYTE PTR [ebx+ecx-1]
	imul	edx, eax
	mov	eax, -2139062143			; 80808081H
	mul	edx
	shr	edx, 7
	mov	BYTE PTR [ecx+ebp-1], dl
	sub	esi, 1
	jne	SHORT $LL7@MultMasks
	mov	esi, DWORD PTR _nBlkX$[esp+12]
	mov	eax, DWORD PTR _smallmaskF$[esp+12]
	mov	ecx, DWORD PTR _smallmaskO$[esp+12]
	mov	edx, DWORD PTR _nBlkY$[esp+12]
$LN6@MultMasks:

; 324  :     }
; 325  :     smallmaskF += nBlkX;
; 326  :     smallmaskB += nBlkX;
; 327  :     smallmaskO += nBlkX;

	add	ecx, esi
	add	eax, esi
	add	edi, esi
	mov	DWORD PTR _smallmaskO$[esp+12], ecx
	sub	edx, 1
	mov	DWORD PTR _smallmaskF$[esp+12], eax
	mov	DWORD PTR _nBlkY$[esp+12], edx
	jne	SHORT $LL4@MultMasks
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN3@MultMasks:

; 328  :   }
; 329  : }

	ret	20					; 00000014H
?MultMasks@MVBlockFps@@AAEXPAE00HH@Z ENDP		; MVBlockFps::MultMasks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvclip.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvclip.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -284						; size = 4
$T3 = -280						; size = 12
$T4 = -280						; size = 12
$T5 = -268						; size = 12
$T6 = -268						; size = 12
$T7 = -256						; size = 12
$T8 = -256						; size = 12
$T9 = -244						; size = 12
$T10 = -244						; size = 12
_pPlanesF$11 = -232					; size = 12
_planesRGB$12 = -232					; size = 12
_pPlanesB$13 = -220					; size = 12
$T14 = -208						; size = 4
$T15 = -208						; size = 4
_pDstSave$16 = -204					; size = 12
_planesYUV$17 = -204					; size = 12
_pDstYUY2$1$ = -192					; size = 4
_nDstPitchYUY2$1$ = -188				; size = 4
_pDstSave$3$ = -184					; size = 4
$T18 = -180						; size = 4
$T19 = -180						; size = 4
$T20 = -180						; size = 4
$T21 = -176						; size = 4
tv7534 = -176						; size = 4
$T22 = -172						; size = 4
tv7533 = -172						; size = 4
_mvB$ = -168						; size = 4
_mvF$ = -164						; size = 4
_refxF$1$ = -160					; size = 4
_refyF$1$ = -160					; size = 4
_this$1$ = -156						; size = 4
$T23 = -156						; size = 4
tv7535 = -156						; size = 4
_nDstPitches$1$ = -152					; size = 4
_pDstShortV$1$ = -148					; size = 4
_i$1$ = -148						; size = 4
_nBlkSizeX_UV$1$ = -144					; size = 4
_nDstPitches$2$ = -140					; size = 4
_pSrc$2$ = -136						; size = 4
_this$1$ = -136						; size = 4
tv7538 = -136						; size = 4
_nDstPitches$ = -132					; size = 12
_src$ = -120						; size = 4
_ref$ = -116						; size = 4
_pDst$2$ = -112						; size = 4
_pDst$1$ = -108						; size = 4
_this$1$ = -104						; size = 4
_this$1$ = -104						; size = 4
_pDstShortU$1$ = -104					; size = 4
_pDstShort$1$ = -100					; size = 4
tv7561 = -100						; size = 4
tv7558 = -100						; size = 4
_refxB$1$ = -96						; size = 4
tv7560 = -96						; size = 4
tv7557 = -96						; size = 4
_refyB$1$ = -92						; size = 4
tv7559 = -92						; size = 4
tv7556 = -92						; size = 4
_pSrc$ = -88						; size = 12
_pRef$ = -76						; size = 12
_nSrcPitches$ = -64					; size = 12
_nRefPitches$ = -52					; size = 12
_pMaskOccUV$1$ = -40					; size = 4
_pMaskOccY$1$ = -36					; size = 4
_pMaskFullUVF$1$ = -32					; size = 4
_pMaskFullYF$1$ = -28					; size = 4
_pMaskFullUVB$1$ = -24					; size = 4
_pMaskFullYB$1$ = -20					; size = 4
_pSrc$4$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pSrc$3$ = 0						; size = 4
_pSrc$1$ = 4						; size = 4
_pRef$3$ = 8						; size = 4
_pDst$3$ = 12						; size = 4
tv7545 = 16						; size = 4
tv7542 = 16						; size = 4
tv7413 = 16						; size = 4
tv7412 = 16						; size = 4
_pRef$4$ = 20						; size = 4
_pDst$ = 24						; size = 12
tv6441 = 28						; size = 8
_wby$1$ = 32						; size = 4
$T24 = 36						; size = 4
$T25 = 36						; size = 4
_bx$1$ = 36						; size = 4
tv6939 = 36						; size = 4
$T26 = 40						; size = 4
$T27 = 40						; size = 4
_by$1$ = 40						; size = 4
tv7544 = 40						; size = 4
_pRef$1$ = 44						; size = 4
_nBlkSizeY_UV$1$ = 48					; size = 4
_refyF$1$ = 52						; size = 4
_nHeightUV$1$ = 52					; size = 4
_nWidth_B_UV$1$ = 56					; size = 4
_refyB$1$ = 56						; size = 4
_current_xx$1$ = 60					; size = 4
tv7290 = 60						; size = 4
_pRef$2$ = 64						; size = 4
$T28 = 64						; size = 4
$T29 = 64						; size = 4
$T30 = 64						; size = 4
_nright$1$ = 64						; size = 4
tv7537 = 64						; size = 4
_refxF$1$ = 68						; size = 4
_nHeight_B$1$ = 68					; size = 4
_xx$1$ = 72						; size = 4
_refxB$1$ = 72						; size = 4
_nHeight_B_UV$1$ = 76					; size = 4
_blocks$1$ = 76						; size = 4
_nSrcPitches$2$ = 80					; size = 4
$T31 = 80						; size = 4
$T32 = 80						; size = 4
$T33 = 80						; size = 4
$T34 = 80						; size = 4
$T35 = 80						; size = 4
_planes$1$ = 80						; size = 4
_nleft$1$ = 80						; size = 4
tv7536 = 80						; size = 4
_xxUV$1$ = 84						; size = 4
_nWidthUV$1$ = 84					; size = 4
_nY$1$ = 88						; size = 4
_nY$1$ = 88						; size = 4
_nWidth_B$1$ = 88					; size = 4
_dst$ = 92						; size = 4
_time256$1$ = 96					; size = 4
_nY$1$ = 100						; size = 4
_nY$1$ = 100						; size = 4
_nY$1$ = 100						; size = 4
_nY$1$ = 100						; size = 4
_nY$1$ = 100						; size = 4
_nY$1$ = 100						; size = 4
_src$36 = 112						; size = 4
_nDstPitchYUY2$ = 112					; size = 4
_pDstYUY2$ = 112					; size = 4
$T37 = 112						; size = 4
$T38 = 112						; size = 4
_this$ = 112						; size = 4
___$ReturnUdt$ = 116					; size = 4
_nRefPitches$2$ = 120					; size = 4
_off$1$ = 120						; size = 4
_needProcessPlanes$ = 120				; size = 3
$T39 = 120						; size = 4
_n$ = 120						; size = 4
_pitch$1$ = 124						; size = 4
_pitch$1$ = 124						; size = 4
_pitch$1$ = 124						; size = 4
_p$1$ = 124						; size = 4
_p$1$ = 124						; size = 4
_p$1$ = 124						; size = 4
_j$1$ = 124						; size = 4
_planeCount$1$ = 124					; size = 4
tv7460 = 124						; size = 4
_ref$40 = 124						; size = 4
_env$ = 124						; size = 4
?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVBlockFps::GetFrame, COMDAT

; 466  : {

	push	ebp
	lea	ebp, DWORD PTR [esp-104]
	sub	esp, 104				; 00000068H
	push	-1
	push	__ehhandler$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 272				; 00000110H

; 467  :   int nWidth_B = nBlkX*(nBlkSizeX - nOverlapX) + nOverlapX;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edx, DWORD PTR [ecx+76]
	sub	edx, DWORD PTR [ecx+108]
	imul	edx, DWORD PTR [ecx+64]

; 468  :   int nHeight_B = nBlkY*(nBlkSizeY - nOverlapY) + nOverlapY;
; 469  :   int nHeightUV = nHeight / yRatioUV;

	mov	eax, DWORD PTR [ecx+96]
	mov	DWORD PTR $T2[ebp], 0
	add	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _nWidth_B$1$[ebp], edx
	mov	edx, DWORD PTR [ecx+80]
	sub	edx, DWORD PTR [ecx+112]
	imul	edx, DWORD PTR [ecx+68]
	add	edx, DWORD PTR [ecx+112]
	mov	DWORD PTR _nHeight_B$1$[ebp], edx
	cdq
	idiv	DWORD PTR [ecx+124]
	mov	DWORD PTR _nHeightUV$1$[ebp], eax

; 470  :   int nWidthUV = nWidth / xRatioUV;

	mov	eax, DWORD PTR [ecx+92]
	cdq
	idiv	DWORD PTR [ecx+120]
	mov	DWORD PTR _nWidthUV$1$[ebp], eax

; 471  : 
; 472  : #ifndef _M_X64
; 473  :   _mm_empty();  // paranoya

	emms

; 474  : #endif
; 475  :   // intermediate product may be very large! Now I know how to multiply int64
; 476  :   int nleft = (int)(__int64(n)* fa / fb);

	mov	edi, DWORD PTR [ecx+676]
	mov	esi, DWORD PTR _n$[ebp]
	mov	eax, esi
	mov	ebx, DWORD PTR [ecx+684]
	push	edi
	push	DWORD PTR [ecx+672]
	cdq
	push	edx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _this$[ebp]
	push	ebx
	push	DWORD PTR [ecx+680]
	push	edx
	push	eax
	call	__alldiv

; 477  :   int time256 = int((double(n)*double(fa) / double(fb) - nleft) * 256 + 0.5);

	mov	edx, edi
	mov	DWORD PTR _nleft$1$[ebp], eax
	mov	edi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edi+672]
	call	__ltod3
	mov	ecx, DWORD PTR [edi+680]
	mov	edx, ebx
	movd	xmm1, esi
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm1
	movsd	QWORD PTR tv6441[ebp], xmm0
	call	__ltod3
	movsd	xmm2, QWORD PTR tv6441[ebp]
	divsd	xmm2, xmm0
	mov	esi, DWORD PTR _nleft$1$[ebp]
	movd	xmm1, esi
	cvtdq2pd xmm1, xmm1
	subsd	xmm2, xmm1
	mulsd	xmm2, QWORD PTR __real@4070000000000000
	addsd	xmm2, QWORD PTR __real@3fe0000000000000
	cvttsd2si eax, xmm2
	mov	DWORD PTR _time256$1$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN233@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN233@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
$LN233@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 479  :   PVideoFrame dst;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	ecx, DWORD PTR [edi+292]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 491  :   if (off <= 0)

	mov	ebx, DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	DWORD PTR _off$1$[ebp], ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 491  :   if (off <= 0)

	test	ecx, ecx
	jg	SHORT $LN51@GetFrame

; 492  :   {
; 493  :     env->ThrowError("MBlockFps: cannot use motion vectors with absolute frame references.");

	mov	ecx, DWORD PTR [ebx]
	push	OFFSET ??_C@_0EF@EDDNICOL@MBlockFps?3?5cannot?5use?5motion?5vec@
	push	ebx
	call	DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _off$1$[ebp]
	add	esp, 8
$LN51@GetFrame:

; 494  :   }
; 495  :   // usually off must be = 1
; 496  :   if (off > 1)
; 497  :     time256 = time256 / off;

	mov	eax, DWORD PTR _time256$1$[ebp]
	cmp	ecx, 1
	jle	SHORT $LN52@GetFrame
	cdq
	idiv	ecx
	mov	DWORD PTR _time256$1$[ebp], eax
$LN52@GetFrame:

; 498  : 
; 499  :   int nright = nleft + off;

	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR _nright$1$[ebp], edx

; 504  :     dst = child->GetFrame(nleft, env); // simply left

	push	ebx
	test	eax, eax
	jne	$LN53@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 504  :     dst = child->GetFrame(nleft, env); // simply left

	lea	edx, DWORD PTR $T38[ebp]
	push	esi
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN241@GetFrame
	cmp	DWORD PTR [edx], 268			; 0000010cH
	jbe	SHORT $LN241@GetFrame
	push	eax
	mov	eax, DWORD PTR [edx+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN241@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN245@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN245@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR $T38[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN245@GetFrame:

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN250@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN250@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN250@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\mvblockfps.cpp

; 505  :     return dst;

	jmp	$LN1036@GetFrame
$LN53@GetFrame:

; 508  :     dst = child->GetFrame(nright, env); // simply right

	push	edx
	cmp	eax, 256				; 00000100H
	jne	$LN55@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 508  :     dst = child->GetFrame(nright, env); // simply right

	lea	edx, DWORD PTR $T37[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN261@GetFrame
	cmp	DWORD PTR [edx], 268			; 0000010cH
	jbe	SHORT $LN261@GetFrame
	push	eax
	mov	eax, DWORD PTR [edx+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN261@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	edx, edx
	je	SHORT $LN265@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN265@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR $T37[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN265@GetFrame:

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN270@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN270@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN270@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File c:\github\mvtools\sources\mvblockfps.cpp

; 509  :     return dst;

	jmp	$LN1036@GetFrame
$LN55@GetFrame:

; 510  :   }
; 511  : 
; 512  :   PVideoFrame mvF = mvClipF.GetFrame(nright, env);

	mov	eax, DWORD PTR [edi+392]
	lea	ecx, DWORD PTR [edi+392]
	lea	edx, DWORD PTR _mvF$[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 513  :   mvClipF.Update(mvF, env);// forward from current to next

	push	ebx
	lea	eax, DWORD PTR _mvF$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	lea	ecx, DWORD PTR [edi+392]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN279@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN279@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvF$[ebp]
	push	0
	call	eax
$LN279@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 516  :   PVideoFrame mvB = mvClipB.GetFrame(nleft, env);

	mov	eax, DWORD PTR [edi+152]
	lea	ecx, DWORD PTR [edi+152]
	push	ebx
	push	esi
	lea	edx, DWORD PTR _mvB$[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 517  :   mvClipB.Update(mvB, env);// backward from next to current

	push	ebx
	lea	eax, DWORD PTR _mvB$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	eax
	lea	ecx, DWORD PTR [edi+152]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN283@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN283@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvB$[ebp]
	push	0
	call	eax
$LN283@GetFrame:

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+664]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 520  :   PVideoFrame	src = super->GetFrame(nleft, env);

	lea	edx, DWORD PTR _src$[ebp]
	push	ebx
	push	esi
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 521  :   PVideoFrame ref = super->GetFrame(nright, env);//  ref for backward compensation

	lea	edx, DWORD PTR _ref$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+664]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 521  :   PVideoFrame ref = super->GetFrame(nright, env);//  ref for backward compensation

	push	ebx
	push	DWORD PTR _nright$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]

; 522  : 
; 523  : //	const Time256ProviderCst	t256_prov_cst (time256, 0, 0); 2.6.0.5
; 524  : 
; 525  :   dst = env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	ecx, DWORD PTR [edi+16]
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	DWORD PTR tv7460[ebp], ecx
	lea	ecx, DWORD PTR $T39[ebp]
	push	ecx
	push	ebx
	call	DWORD PTR [eax+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN291@GetFrame
	cmp	DWORD PTR [esi], 268			; 0000010cH
	jbe	SHORT $LN291@GetFrame
	push	eax
	mov	eax, DWORD PTR [esi+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN291@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	esi, esi
	je	SHORT $LN295@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN295@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR $T39[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN295@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File c:\github\mvtools\sources\mvblockfps.cpp

; 527  :   bool needProcessPlanes[3] = { true, !!(nSuperModeYUV & UPLANE), !!(nSuperModeYUV & VPLANE) };

	mov	ecx, DWORD PTR [edi+688]
	mov	eax, ecx
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [edi+372]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 527  :   bool needProcessPlanes[3] = { true, !!(nSuperModeYUV & UPLANE), !!(nSuperModeYUV & VPLANE) };

	shr	ecx, 2
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [edi+368]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 527  :   bool needProcessPlanes[3] = { true, !!(nSuperModeYUV & UPLANE), !!(nSuperModeYUV & VPLANE) };

	and	cl, 1
	shr	eax, 1
	mov	BYTE PTR _needProcessPlanes$[ebp+2], cl
	and	al, 1
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	mov	ecx, DWORD PTR [edi+240]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 527  :   bool needProcessPlanes[3] = { true, !!(nSuperModeYUV & UPLANE), !!(nSuperModeYUV & VPLANE) };

	mov	BYTE PTR _needProcessPlanes$[ebp], 1
	mov	BYTE PTR _needProcessPlanes$[ebp+1], al
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN56@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [edi+220]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN56@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [edi+612]
	mov	ecx, DWORD PTR [edi+480]
	push	DWORD PTR [edi+608]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN56@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [edi+460]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN56@GetFrame
; File c:\github\mvtools\sources\mvblockfps.cpp

; 535  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN58@GetFrame

; 536  :     {
; 537  :       pSrc[0] = src->GetReadPtr();

	mov	ecx, DWORD PTR _src$[ebp]
	push	0
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 538  :       pSrc[1] = pSrc[0] + src->GetRowSize() / 2;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	esi, eax
	push	0
	mov	DWORD PTR _pSrc$1$[ebp], esi
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 539  :       pSrc[2] = pSrc[1] + src->GetRowSize() / 4;

	mov	ecx, DWORD PTR _src$[ebp]
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	add	ebx, esi
	push	0
	mov	DWORD PTR _pSrc$3$[ebp], ebx
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 540  :       nSrcPitches[0] = src->GetPitch();

	mov	ecx, DWORD PTR _src$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, ebx
	push	0
	mov	DWORD PTR _pSrc$4$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 541  :       nSrcPitches[1] = nSrcPitches[0];
; 542  :       nSrcPitches[2] = nSrcPitches[0];
; 543  : 
; 544  :       pRef[0] = ref->GetReadPtr();

	mov	ecx, DWORD PTR _ref$[ebp]
	push	0
	mov	DWORD PTR _nSrcPitches$[ebp], eax
	mov	DWORD PTR _nSrcPitches$[ebp+4], eax
	mov	DWORD PTR _nSrcPitches$[ebp+8], eax
	call	?GetReadPtr@VideoFrame@@QBEPBEH@Z	; VideoFrame::GetReadPtr

; 545  :       pRef[1] = pRef[0] + ref->GetRowSize() / 2;

	mov	ecx, DWORD PTR _ref$[ebp]
	push	0
	mov	DWORD PTR _pRef$1$[ebp], eax
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 546  :       pRef[2] = pRef[1] + ref->GetRowSize() / 4;

	mov	ecx, DWORD PTR _ref$[ebp]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	add	esi, DWORD PTR _pRef$1$[ebp]
	push	0
	mov	DWORD PTR _pRef$3$[ebp], esi
	call	?GetRowSize@VideoFrame@@QBEHH@Z		; VideoFrame::GetRowSize

; 547  :       nRefPitches[0] = ref->GetPitch();

	mov	ecx, DWORD PTR _ref$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, esi
	push	0
	mov	DWORD PTR _pRef$4$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 548  :       nRefPitches[1] = nRefPitches[0];
; 549  :       nRefPitches[2] = nRefPitches[0];
; 550  : 
; 551  :       if (!planar)

	cmp	BYTE PTR [edi+669], 0

; 552  :       {
; 553  :         pDstYUY2 = dst->GetWritePtr();

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _nRefPitches$[ebp], eax
	mov	DWORD PTR _nRefPitches$[ebp+4], eax
	mov	DWORD PTR _nRefPitches$[ebp+8], eax
	push	0
	jne	SHORT $LN60@GetFrame
	call	?GetWritePtr@VideoFrame@@QBEPAEH@Z	; VideoFrame::GetWritePtr

; 554  :         nDstPitchYUY2 = dst->GetPitch();

	mov	ecx, DWORD PTR _dst$[ebp]
	push	0
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	ecx, DWORD PTR [edi+784]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 554  :         nDstPitchYUY2 = dst->GetPitch();

	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax

; 555  :         pDst[0] = DstPlanes->GetPtr();

	mov	eax, DWORD PTR [ecx]

; 558  :         nDstPitches[0] = DstPlanes->GetPitch();

	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _pDst$1$[ebp], eax
	mov	DWORD PTR _pDst$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _pDst$2$[ebp], eax
	mov	DWORD PTR _pDst$[ebp+4], eax
	mov	eax, DWORD PTR [ecx+8]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	ecx, DWORD PTR [ecx+24]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 557  :         pDst[2] = DstPlanes->GetPtrV();

	mov	DWORD PTR _pDst$[ebp+8], eax

; 558  :         nDstPitches[0] = DstPlanes->GetPitch();

	mov	DWORD PTR _nDstPitches$1$[ebp], edx
	mov	DWORD PTR _nDstPitches$[ebp], edx
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	DWORD PTR _nDstPitches$2$[ebp], ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 559  :         nDstPitches[1] = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$[ebp+4], ecx

; 560  :         nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$[ebp+8], ecx

; 561  :       }
; 562  :       else

	jmp	$LN1037@GetFrame
$LN60@GetFrame:

; 563  :       {
; 564  :         pDst[0] = dst->GetWritePtr();

	call	?GetWritePtr@VideoFrame@@QBEPAEH@Z	; VideoFrame::GetWritePtr
	mov	ecx, eax

; 565  :         pDst[1] = pDst[0] + nWidth;

	mov	eax, DWORD PTR [edi+92]
	mov	DWORD PTR _pDst$1$[ebp], ecx
	mov	DWORD PTR _pDst$[ebp], ecx
	add	ecx, eax

; 566  :         pDst[2] = pDst[1] + nWidth / 2;

	cdq
	sub	eax, edx
	mov	DWORD PTR _pDst$2$[ebp], ecx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR _pDst$[ebp+4], ecx

; 567  :         nDstPitches[0] = dst->GetPitch();

	mov	ecx, DWORD PTR _dst$[ebp]
	push	0
	mov	DWORD PTR _pDst$3$[ebp], eax
	mov	DWORD PTR _pDst$[ebp+8], eax
	call	?GetPitch@VideoFrame@@QBEHH@Z		; VideoFrame::GetPitch

; 568  :         nDstPitches[1] = nDstPitches[0];

	mov	ecx, eax
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
	mov	DWORD PTR _nDstPitches$[ebp], eax

; 569  :         nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$[ebp+8], eax

; 570  :       }
; 571  :     }
; 572  :     else

	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _pDst$3$[ebp]
	mov	DWORD PTR _nDstPitches$2$[ebp], ecx
	mov	DWORD PTR _nDstPitches$[ebp+4], ecx
	jmp	$LN3@GetFrame
$LN58@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 719  :   bool IsPlanarRGB() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsPlanarRGB, false) )

	mov	edi, DWORD PTR tv7460[ebp]
	test	esi, esi
	je	SHORT $LN988@GetFrame
	cmp	DWORD PTR [esi], 568			; 00000238H
	jbe	SHORT $LN987@GetFrame
	mov	eax, DWORD PTR [esi+568]
	mov	ecx, edi
	call	eax
; File c:\github\mvtools\sources\mvblockfps.cpp

; 574  :       bool isRGB = vi.IsPlanarRGB() || vi.IsPlanarRGBA();

	test	al, al
	jne	SHORT $LN123@GetFrame
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN987@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 722  :   bool IsPlanarRGBA() const AVS_BakedCode( return AVS_LinkCallOptDefault(IsPlanarRGBA, false) )

	test	esi, esi
	je	SHORT $LN988@GetFrame
	cmp	DWORD PTR [esi], 572			; 0000023cH
	jbe	SHORT $LN988@GetFrame
	mov	eax, DWORD PTR [esi+572]
	mov	ecx, edi
	call	eax
; File c:\github\mvtools\sources\mvblockfps.cpp

; 574  :       bool isRGB = vi.IsPlanarRGB() || vi.IsPlanarRGBA();

	test	al, al
	je	SHORT $LN988@GetFrame
$LN123@GetFrame:
	mov	al, 1
	jmp	SHORT $LN124@GetFrame
$LN988@GetFrame:
	xor	al, al
$LN124@GetFrame:

; 575  :       const int planesRGB[] = { PLANAR_G, PLANAR_B, PLANAR_R };
; 576  :       const int planesYUV[] = { PLANAR_Y, PLANAR_U, PLANAR_V };
; 577  :       const int *planes = isRGB ? planesRGB : planesYUV;

	test	al, al
	mov	DWORD PTR _planesRGB$12[ebp], 64	; 00000040H
	lea	ecx, DWORD PTR _planesYUV$17[ebp]
	mov	DWORD PTR _planesRGB$12[ebp+4], 128	; 00000080H
	lea	ebx, DWORD PTR _planesRGB$12[ebp]
	mov	DWORD PTR _planesRGB$12[ebp+8], 32	; 00000020H
	cmove	ebx, ecx
	mov	DWORD PTR _planesYUV$17[ebp], 1

; 578  :       const int planeCount = vi.IsY() ? 1 : 3;

	mov	ecx, edi
	mov	DWORD PTR _planesYUV$17[ebp+4], 2
	mov	DWORD PTR _planesYUV$17[ebp+8], 4
	call	?IsY@VideoInfo@@QBE_NXZ			; VideoInfo::IsY
	xor	ecx, ecx
	test	al, al

; 579  :       for (int p = 0; p < planeCount; p++) { // grey support

	lea	eax, DWORD PTR _pDst$[ebp]
	sete	cl
	xor	esi, esi
	sub	ebx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _planes$1$[ebp], ebx
	lea	ecx, DWORD PTR [ecx*2+1]
	mov	DWORD PTR _planeCount$1$[ebp], ecx
	mov	edi, ecx
	npad	7
$LL4@GetFrame:
	lea	ecx, DWORD PTR _pDst$[ebp]
	lea	ecx, DWORD PTR [ecx+esi*4]

; 580  :         int plane = planes[p];

	mov	ebx, DWORD PTR [ecx+ebx]
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN366@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN366@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+220]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN367@GetFrame
$LN366@GetFrame:
	xor	ecx, ecx
$LN367@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 581  :         pDst[p] = dst->GetWritePtr(plane);

	mov	DWORD PTR _pDst$[ebp+esi*4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN372@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN372@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN373@GetFrame
$LN372@GetFrame:
	xor	ecx, ecx
$LN373@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 582  :         nDstPitches[p] = dst->GetPitch(plane);

	mov	DWORD PTR _nDstPitches$[ebp+esi*4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN378@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN378@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN379@GetFrame
$LN378@GetFrame:
	xor	ecx, ecx
$LN379@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 583  :         pRef[p] = ref->GetReadPtr(plane);

	mov	DWORD PTR _pRef$[ebp+esi*4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN384@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN384@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN385@GetFrame
$LN384@GetFrame:
	xor	ecx, ecx
$LN385@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 584  :         nRefPitches[p] = ref->GetPitch(plane);

	mov	DWORD PTR _nRefPitches$[ebp+esi*4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN390@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN390@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN391@GetFrame
$LN390@GetFrame:
	xor	ecx, ecx
$LN391@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 585  :         pSrc[p] = src->GetReadPtr(plane);

	mov	DWORD PTR _pSrc$[ebp+esi*4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN396@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN396@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	ebx
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN397@GetFrame
$LN396@GetFrame:
	xor	ecx, ecx
$LN397@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 579  :       for (int p = 0; p < planeCount; p++) { // grey support

	mov	ebx, DWORD PTR _planes$1$[ebp]

; 586  :         nSrcPitches[p] = src->GetPitch(plane);

	mov	DWORD PTR _nSrcPitches$[ebp+esi*4], ecx
	inc	esi
	cmp	esi, edi
	jl	$LL4@GetFrame

; 579  :       for (int p = 0; p < planeCount; p++) { // grey support

	mov	eax, DWORD PTR _pSrc$[ebp+8]
	mov	ecx, DWORD PTR _pDst$[ebp+4]
	mov	esi, DWORD PTR _pRef$[ebp+8]
	mov	ebx, DWORD PTR _pSrc$[ebp+4]
	mov	edi, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pSrc$4$[ebp], eax
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR _pSrc$1$[ebp], eax
	mov	eax, DWORD PTR _pRef$[ebp]
	mov	DWORD PTR _pDst$2$[ebp], ecx
	mov	ecx, DWORD PTR _pDst$[ebp]
	mov	DWORD PTR _pRef$1$[ebp], eax
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDst$1$[ebp], ecx
	mov	ecx, DWORD PTR _nDstPitches$[ebp+4]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _pRef$4$[ebp], esi
	mov	esi, DWORD PTR _pRef$[ebp+4]
	mov	DWORD PTR _nDstPitches$2$[ebp], ecx
	mov	ecx, DWORD PTR _nDstPitches$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _pDst$[ebp+8]
	mov	DWORD PTR _pSrc$3$[ebp], ebx
	mov	DWORD PTR _pRef$3$[ebp], esi
	mov	DWORD PTR _nDstPitches$1$[ebp], ecx
$LN1037@GetFrame:
	mov	DWORD PTR _pDst$3$[ebp], eax
$LN3@GetFrame:

; 587  :       }
; 588  :       /*
; 589  :       pDst[0] = YWPLAN(dst);
; 590  :       pDst[1] = UWPLAN(dst);
; 591  :       pDst[2] = VWPLAN(dst);
; 592  :       nDstPitches[0] = YPITCH(dst);
; 593  :       nDstPitches[1] = UPITCH(dst);
; 594  :       nDstPitches[2] = VPITCH(dst);
; 595  : 
; 596  :       pRef[0] = YRPLAN(ref);
; 597  :       pRef[1] = URPLAN(ref);
; 598  :       pRef[2] = VRPLAN(ref);
; 599  :       nRefPitches[0] = YPITCH(ref);
; 600  :       nRefPitches[1] = UPITCH(ref);
; 601  :       nRefPitches[2] = VPITCH(ref);
; 602  : 
; 603  :       pSrc[0] = YRPLAN(src);
; 604  :       pSrc[1] = URPLAN(src);
; 605  :       pSrc[2] = VRPLAN(src);
; 606  :       nSrcPitches[0] = YPITCH(src);
; 607  :       nSrcPitches[1] = UPITCH(src);
; 608  :       nSrcPitches[2] = VPITCH(src);
; 609  :       */
; 610  :     }
; 611  :     PROFILE_STOP(MOTION_PROFILE_YUY2CONVERT);
; 612  : 
; 613  :     BYTE *pDstSave[3];
; 614  :     pDstSave[0] = pDst[0];
; 615  :     pDstSave[1] = pDst[1];
; 616  :     pDstSave[2] = pDst[2];
; 617  : 
; 618  :     pRefBGOF->Update(YUVPLANES, (BYTE*)pRef[0], nRefPitches[0], (BYTE*)pRef[1], nRefPitches[1], (BYTE*)pRef[2], nRefPitches[2]);// v2.0

	push	DWORD PTR _nRefPitches$[ebp+8]
	movq	xmm0, QWORD PTR _pDst$[ebp]
	push	DWORD PTR _pRef$4$[ebp]
	mov	ecx, DWORD PTR [edi+840]
	push	DWORD PTR _nRefPitches$[ebp+4]
	movq	QWORD PTR _pDstSave$16[ebp], xmm0
	push	esi
	push	DWORD PTR _nRefPitches$[ebp]
	mov	DWORD PTR _pDstSave$3$[ebp], eax
	push	DWORD PTR _pRef$1$[ebp]
	push	7
	call	?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z ; MVGroupOfFrames::Update

; 619  :     pRefFGOF->Update(YUVPLANES, (BYTE*)pSrc[0], nSrcPitches[0], (BYTE*)pSrc[1], nSrcPitches[1], (BYTE*)pSrc[2], nSrcPitches[2]);

	push	DWORD PTR _nSrcPitches$[ebp+8]
	mov	ecx, DWORD PTR [edi+844]
	push	DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR _nSrcPitches$[ebp+4]
	push	ebx
	push	DWORD PTR _nSrcPitches$[ebp]
	push	DWORD PTR _pSrc$1$[ebp]
	push	7
	call	?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z ; MVGroupOfFrames::Update

; 624  :     pPlanesB[0] = pRefBGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	ecx, DWORD PTR [edi+840]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ecx], 0
	jg	SHORT $LN399@GetFrame
	xor	eax, eax
	jmp	SHORT $LN398@GetFrame
$LN399@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
$LN398@GetFrame:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ecx], 0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 624  :     pPlanesB[0] = pRefBGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pPlanesB$13[ebp], eax
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	jg	SHORT $LN408@GetFrame
	xor	eax, eax
	jmp	SHORT $LN407@GetFrame
$LN408@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
$LN407@GetFrame:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ecx], 0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 625  :     pPlanesB[1] = pRefBGOF->GetFrame(0)->GetPlane(UPLANE);

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _pPlanesB$13[ebp+4], eax
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	jg	SHORT $LN417@GetFrame
	xor	eax, eax
	jmp	SHORT $LN416@GetFrame
$LN417@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
$LN416@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 628  :     pPlanesF[0] = pRefFGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	ecx, DWORD PTR [edi+844]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _pPlanesB$13[ebp+8], eax
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ecx], 0
	jg	SHORT $LN426@GetFrame
	xor	eax, eax
	jmp	SHORT $LN425@GetFrame
$LN426@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
$LN425@GetFrame:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ecx], 0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 628  :     pPlanesF[0] = pRefFGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pPlanesF$11[ebp], eax
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	jg	SHORT $LN435@GetFrame
	xor	eax, eax
	jmp	SHORT $LN434@GetFrame
$LN435@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
$LN434@GetFrame:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [ecx], 0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 629  :     pPlanesF[1] = pRefFGOF->GetFrame(0)->GetPlane(UPLANE);

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _pPlanesF$11[ebp+4], eax
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	jg	SHORT $LN444@GetFrame
	xor	eax, eax
	jmp	SHORT $LN443@GetFrame
$LN444@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
$LN443@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 633  :     MemZoneSet(MaskFullYB, 0, nWidthP, nHeightP, 0, 0, nPitchY); // put zeros

	push	DWORD PTR [edi+744]
	mov	eax, DWORD PTR [eax+8]
	xor	dl, dl
	mov	ecx, DWORD PTR [edi+692]
	sub	esp, 8
	mov	DWORD PTR _pPlanesF$11[ebp+8], eax
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	call	_MemZoneSet

; 634  :     MemZoneSet(MaskFullYF, 0, nWidthP, nHeightP, 0, 0, nPitchY);

	mov	ecx, DWORD PTR [edi+700]
	add	esp, 20					; 00000014H
	xor	dl, dl
	push	DWORD PTR [edi+744]
	sub	esp, 8
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	call	_MemZoneSet
; File c:\github\mvtools\sources\mvclip.h

; 80   :    inline int GetBlkCount() const { return nBlkCount; }

	mov	eax, DWORD PTR [edi+356]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 634  :     MemZoneSet(MaskFullYF, 0, nWidthP, nHeightP, 0, 0, nPitchY);

	add	esp, 20					; 00000014H
; File c:\github\mvtools\sources\mvclip.h

; 80   :    inline int GetBlkCount() const { return nBlkCount; }

	mov	DWORD PTR _blocks$1$[ebp], eax
; File c:\github\mvtools\sources\mvblockfps.cpp

; 643  :     if (mode >= 3 && mode <= 8) {

	mov	eax, DWORD PTR [edi+648]
	cmp	eax, 3
	jl	$LN62@GetFrame
	cmp	eax, 8
	jg	$LN62@GetFrame

; 644  : 
; 645  :       PROFILE_START(MOTION_PROFILE_MASK);
; 646  :       if (mode <= 5)
; 647  :         MakeVectorOcclusionMaskTime(mvClipF, nBlkX, nBlkY, ml, 1.0, nPel, smallMaskF, nBlkXP, time256, nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	ebx, 1
	cmp	eax, 5
	jg	SHORT $LN63@GetFrame
	mov	eax, DWORD PTR [edi+80]
	lea	ecx, DWORD PTR [edi+392]
	sub	eax, DWORD PTR [edi+112]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	sub	eax, DWORD PTR [edi+108]
	movsd	xmm3, QWORD PTR [edi+656]
	mov	edx, DWORD PTR [edi+64]
	push	eax
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR [edi+768]
	push	DWORD PTR [edi+716]
	push	DWORD PTR [edi+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [edi+68]
	call	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime

; 648  :       else // 6 to 8  // PF 161115 bits_per_pixel scale through dSADNormFactor

	jmp	$LN1038@GetFrame
$LN63@GetFrame:

; 649  :         MakeSADMaskTime(mvClipF, nBlkX, nBlkY, 4.0 / (ml*nBlkSizeX*nBlkSizeY) / (1 << (bits_per_pixel - 8)), 1.0, nPel, smallMaskF, nBlkXP, time256, nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	mov	edx, DWORD PTR [edi+80]
	mov	eax, edx
	sub	eax, DWORD PTR [edi+112]
	mov	ecx, DWORD PTR [edi+76]
	push	eax
	mov	eax, ecx
	movsd	xmm2, QWORD PTR __real@4010000000000000
	sub	eax, DWORD PTR [edi+108]
	push	eax
	push	DWORD PTR _time256$1$[ebp]
	movd	xmm1, ecx
	mov	eax, ebx
	push	DWORD PTR [edi+768]
	cvtdq2pd xmm1, xmm1
	mov	ecx, DWORD PTR [edi+140]
	sub	ecx, 8
	shl	eax, cl
	lea	ecx, DWORD PTR [edi+392]
	push	DWORD PTR [edi+716]
	mulsd	xmm1, QWORD PTR [edi+656]
	push	DWORD PTR [edi+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	mov	edx, DWORD PTR [edi+64]
	push	DWORD PTR [edi+68]
	mulsd	xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm2, xmm1
	divsd	xmm2, xmm0
	movaps	xmm3, xmm2
	call	?MakeSADMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeSADMaskTime
$LN1038@GetFrame:

; 650  :       if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [edi+768]
	add	esp, 36					; 00000024H
	cmp	eax, DWORD PTR [edi+64]
	jle	SHORT $LN6@GetFrame

; 651  :         for (int j = 0; j < nBlkY; j++)

	xor	esi, esi
	cmp	DWORD PTR [edi+68], esi
	jle	SHORT $LN6@GetFrame
	npad	4
$LL7@GetFrame:

; 652  :           smallMaskF[j*nBlkXP + nBlkX] = smallMaskF[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [edi+768]
	mov	ecx, DWORD PTR [edi+716]
	imul	edx, esi
	inc	esi
	add	edx, DWORD PTR [edi+64]
	mov	al, BYTE PTR [edx+ecx-1]
	mov	BYTE PTR [edx+ecx], al
	cmp	esi, DWORD PTR [edi+68]
	jl	SHORT $LL7@GetFrame
$LN6@GetFrame:

; 653  :       if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [edi+772]
	cmp	eax, DWORD PTR [edi+68]
	jle	SHORT $LN9@GetFrame

; 654  :         for (int i = 0; i < nBlkXP; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+768], ebx
	jle	SHORT $LN1024@GetFrame
	npad	12
$LL10@GetFrame:

; 655  :           smallMaskF[nBlkXP*nBlkY + i] = smallMaskF[nBlkXP*(nBlkY - 1) + i];

	mov	edx, DWORD PTR [edi+68]
	mov	esi, DWORD PTR [edi+768]
	mov	eax, DWORD PTR [edi+716]
	lea	ecx, DWORD PTR [edx-1]
	imul	ecx, esi
	imul	esi, edx
	add	ecx, eax
	add	esi, eax
	mov	al, BYTE PTR [ecx+ebx]
	mov	BYTE PTR [esi+ebx], al
	inc	ebx
	cmp	ebx, DWORD PTR [edi+768]
	jl	SHORT $LL10@GetFrame
$LN1024@GetFrame:
	mov	ebx, 1
$LN9@GetFrame:

; 656  :       PROFILE_STOP(MOTION_PROFILE_MASK);
; 657  : 
; 658  :       PROFILE_START(MOTION_PROFILE_RESIZE);
; 659  :       // upsize (bilinear interpolate) vector masks to fullframe size
; 660  :       upsizer->SimpleResizeDo_uint8(MaskFullYF, nWidthP, nHeightP, nPitchY, smallMaskF, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [edi+768]
	push	ecx
	mov	ecx, DWORD PTR [edi+848]
	push	eax
	push	eax
	push	DWORD PTR [edi+716]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+700]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 661  :       upsizerUV->SimpleResizeDo_uint8(MaskFullUVF, nWidthPUV, nHeightPUV, nPitchUV, smallMaskF, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [edi+768]
	push	ecx
	mov	ecx, DWORD PTR [edi+852]
	push	eax
	push	eax
	push	DWORD PTR [edi+716]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+752]
	push	DWORD PTR [edi+756]
	push	DWORD PTR [edi+704]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 662  :       // now we have forward fullframe blured occlusion mask in maskF arrays
; 663  :       PROFILE_STOP(MOTION_PROFILE_RESIZE);
; 664  :       PROFILE_START(MOTION_PROFILE_MASK);
; 665  :       if (mode <= 5)

	cmp	DWORD PTR [edi+648], 5

; 666  :         MakeVectorOcclusionMaskTime(mvClipB, nBlkX, nBlkY, ml, 1.0, nPel, smallMaskB, nBlkXP, (256 - time256), nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	jg	SHORT $LN67@GetFrame
	mov	eax, DWORD PTR [edi+80]
	lea	ecx, DWORD PTR [edi+152]
	sub	eax, DWORD PTR [edi+112]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	sub	eax, DWORD PTR [edi+108]
	movsd	xmm3, QWORD PTR [edi+656]
	mov	edx, DWORD PTR [edi+64]
	push	eax
	mov	eax, 256				; 00000100H
	sub	eax, DWORD PTR _time256$1$[ebp]
	push	eax
	push	DWORD PTR [edi+768]
	push	DWORD PTR [edi+720]
	push	DWORD PTR [edi+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [edi+68]
	call	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime

; 667  :       else // 6 to 8  // PF 161115 bits_per_pixel scale through dSADNormFactor

	jmp	$LN1039@GetFrame
$LN67@GetFrame:

; 668  :         MakeSADMaskTime(mvClipB, nBlkX, nBlkY, 4.0 / (ml*nBlkSizeX*nBlkSizeY) / (1 << (bits_per_pixel - 8)), 1.0, nPel, smallMaskB, nBlkXP, 256 - time256, nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);

	mov	edx, DWORD PTR [edi+80]
	mov	eax, edx
	sub	eax, DWORD PTR [edi+112]
	mov	ecx, DWORD PTR [edi+76]
	push	eax
	mov	eax, ecx
	movsd	xmm2, QWORD PTR __real@4010000000000000
	sub	eax, DWORD PTR [edi+108]
	push	eax
	mov	eax, 256				; 00000100H
	movd	xmm1, ecx
	sub	eax, DWORD PTR _time256$1$[ebp]
	push	eax
	push	DWORD PTR [edi+768]
	cvtdq2pd xmm1, xmm1
	mov	ecx, DWORD PTR [edi+140]
	sub	ecx, 8
	shl	ebx, cl
	lea	ecx, DWORD PTR [edi+152]
	push	DWORD PTR [edi+720]
	mulsd	xmm1, QWORD PTR [edi+656]
	push	DWORD PTR [edi+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	mov	edx, DWORD PTR [edi+64]
	push	DWORD PTR [edi+68]
	mulsd	xmm1, xmm0
	movd	xmm0, ebx
	cvtdq2pd xmm0, xmm0
	divsd	xmm2, xmm1
	divsd	xmm2, xmm0
	movaps	xmm3, xmm2
	call	?MakeSADMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeSADMaskTime
$LN1039@GetFrame:

; 669  : 
; 670  :       if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [edi+768]
	add	esp, 36					; 00000024H
	cmp	eax, DWORD PTR [edi+64]
	jle	SHORT $LN12@GetFrame

; 671  :         for (int j = 0; j < nBlkY; j++)

	xor	ecx, ecx
	mov	DWORD PTR _j$1$[ebp], ecx
	cmp	DWORD PTR [edi+68], ecx
	jle	SHORT $LN12@GetFrame
	npad	2
$LL13@GetFrame:

; 672  :           if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [edi+772]
	cmp	eax, DWORD PTR [edi+68]
	jle	SHORT $LN11@GetFrame

; 673  :             for (int i = 0; i < nBlkXP; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+768], ebx
	jle	SHORT $LN11@GetFrame
	npad	11
$LL16@GetFrame:

; 674  :               smallMaskB[nBlkXP*nBlkY + i] = smallMaskB[nBlkXP*(nBlkY - 1) + i];

	mov	edx, DWORD PTR [edi+68]
	mov	esi, DWORD PTR [edi+768]
	mov	eax, DWORD PTR [edi+720]
	lea	ecx, DWORD PTR [edx-1]
	imul	ecx, esi
	imul	esi, edx
	add	ecx, eax
	add	esi, eax
	mov	al, BYTE PTR [ecx+ebx]
	mov	BYTE PTR [esi+ebx], al
	inc	ebx
	cmp	ebx, DWORD PTR [edi+768]
	jl	SHORT $LL16@GetFrame
	mov	ecx, DWORD PTR _j$1$[ebp]
$LN11@GetFrame:

; 671  :         for (int j = 0; j < nBlkY; j++)

	inc	ecx
	mov	DWORD PTR _j$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+68]
	jl	SHORT $LL13@GetFrame
$LN12@GetFrame:

; 675  :       PROFILE_STOP(MOTION_PROFILE_MASK);
; 676  :       PROFILE_START(MOTION_PROFILE_RESIZE);
; 677  :       // upsize (bilinear interpolate) vector masks to fullframe size
; 678  :       upsizer->SimpleResizeDo_uint8(MaskFullYB, nWidthP, nHeightP, nPitchY, smallMaskB, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [edi+768]
	push	ecx
	mov	ecx, DWORD PTR [edi+848]
	push	eax
	push	eax
	push	DWORD PTR [edi+720]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+692]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 679  :       upsizerUV->SimpleResizeDo_uint8(MaskFullUVB, nWidthPUV, nHeightPUV, nPitchUV, smallMaskB, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [edi+768]
	push	ecx
	mov	ecx, DWORD PTR [edi+852]
	push	eax
	push	eax
	push	DWORD PTR [edi+720]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+752]
	push	DWORD PTR [edi+756]
	push	DWORD PTR [edi+696]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8
$LN62@GetFrame:

; 680  :       PROFILE_STOP(MOTION_PROFILE_RESIZE);
; 681  :     }
; 682  :     if (mode == 4 || mode == 5 || mode == 7 || mode == 8)

	mov	eax, DWORD PTR [edi+648]
	cmp	eax, 4
	je	SHORT $LN72@GetFrame
	cmp	eax, 5
	je	SHORT $LN72@GetFrame
	cmp	eax, 7
	je	SHORT $LN72@GetFrame
	cmp	eax, 8
	jne	$LN71@GetFrame
$LN72@GetFrame:

; 683  :     {
; 684  :       // make final (both directions) occlusion mask
; 685  :       MultMasks(smallMaskF, smallMaskB, smallMaskO, nBlkXP, nBlkYP);

	push	DWORD PTR [edi+772]
	push	DWORD PTR [edi+768]
	push	DWORD PTR [edi+724]
	push	DWORD PTR [edi+720]
	push	DWORD PTR [edi+716]
	call	?MultMasks@MVBlockFps@@AAEXPAE00HH@Z	; MVBlockFps::MultMasks

; 686  :       //InflateMask(smallMaskO, nBlkXP, nBlkYP);
; 687  :       // upsize small mask to full frame size
; 688  :       upsizer->SimpleResizeDo_uint8(MaskOccY, nWidthP, nHeightP, nPitchY, smallMaskO, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [edi+768]
	push	ecx
	mov	ecx, DWORD PTR [edi+848]
	push	eax
	push	eax
	push	DWORD PTR [edi+724]
	push	DWORD PTR [edi+744]
	push	DWORD PTR [edi+740]
	push	DWORD PTR [edi+736]
	push	DWORD PTR [edi+708]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 689  :       upsizerUV->SimpleResizeDo_uint8(MaskOccUV, nWidthPUV, nHeightPUV, nPitchUV, smallMaskO, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [edi+768]
	push	ecx
	mov	ecx, DWORD PTR [edi+852]
	push	eax
	push	eax
	push	DWORD PTR [edi+724]
	push	DWORD PTR [edi+748]
	push	DWORD PTR [edi+752]
	push	DWORD PTR [edi+756]
	push	DWORD PTR [edi+712]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8
$LN71@GetFrame:

; 690  :     }
; 691  : 
; 692  :     // pointers
; 693  :     BYTE * pMaskFullYB = MaskFullYB;

	mov	eax, DWORD PTR [edi+692]

; 694  :     BYTE * pMaskFullYF = MaskFullYF;
; 695  :     BYTE * pMaskFullUVB = MaskFullUVB;
; 696  :     BYTE * pMaskFullUVF = MaskFullUVF;
; 697  :     BYTE * pMaskOccY = MaskOccY;
; 698  :     BYTE * pMaskOccUV = MaskOccUV;
; 699  : 
; 700  :     pSrc[0] += nSuperHPad*pixelsize + nSrcPitches[0] * nSuperVPad; // add offset source in super

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edi+136]
	mov	ebx, DWORD PTR [edi+856]
	mov	DWORD PTR _pMaskFullYB$1$[ebp], eax
	mov	esi, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR [edi+700]
	mov	DWORD PTR _pMaskFullYF$1$[ebp], eax
	mov	eax, DWORD PTR [edi+696]
	mov	DWORD PTR _pMaskFullUVB$1$[ebp], eax
	mov	eax, DWORD PTR [edi+704]
	mov	ecx, DWORD PTR _pSrc$1$[ebp]
	mov	DWORD PTR _pMaskFullUVF$1$[ebp], eax
	mov	eax, DWORD PTR [edi+708]
	mov	DWORD PTR _pMaskOccY$1$[ebp], eax
	mov	eax, DWORD PTR [edi+712]
	mov	edi, edx
	mov	DWORD PTR _pMaskOccUV$1$[ebp], eax
	mov	eax, esi
	imul	eax, DWORD PTR _nSrcPitches$[ebp]
	imul	edi, ebx
	add	eax, edi
	add	ecx, eax

; 701  :     pSrc[1] += (nSuperHPad >> nLogxRatioUV)*pixelsize + nSrcPitches[1] * (nSuperVPad >> nLogyRatioUV);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pSrc$1$[ebp], ecx
	mov	DWORD PTR _pSrc$[ebp], ecx
	mov	ecx, DWORD PTR [eax+128]
	sar	ebx, cl
	mov	ecx, DWORD PTR [eax+132]
	imul	ebx, edx
	mov	edx, esi

; 702  :     pSrc[2] += (nSuperHPad >> nLogxRatioUV)*pixelsize + nSrcPitches[2] * (nSuperVPad >> nLogyRatioUV);
; 703  :     pRef[0] += nSuperHPad*pixelsize + nRefPitches[0] * nSuperVPad;

	imul	esi, DWORD PTR _nRefPitches$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR _pSrc$3$[ebp]
	mov	eax, edx
	imul	eax, DWORD PTR _nSrcPitches$[ebp+4]
	add	esi, edi
	add	eax, ebx
	add	ecx, eax
	mov	eax, edx
	imul	eax, DWORD PTR _nSrcPitches$[ebp+8]
	mov	DWORD PTR _pSrc$3$[ebp], ecx
	mov	DWORD PTR _pSrc$[ebp+4], ecx
	mov	ecx, DWORD PTR _pSrc$4$[ebp]
	add	eax, ebx
	add	ecx, eax
	mov	eax, DWORD PTR _pRef$1$[ebp]
	add	eax, esi
	mov	DWORD PTR _pSrc$4$[ebp], ecx
	mov	DWORD PTR _pRef$1$[ebp], eax
	mov	DWORD PTR _pRef$[ebp], eax

; 704  :     pRef[1] += (nSuperHPad >> nLogxRatioUV)*pixelsize + nRefPitches[1] * (nSuperVPad >> nLogyRatioUV);

	mov	eax, edx
	imul	eax, DWORD PTR _nRefPitches$[ebp+4]

; 705  :     pRef[2] += (nSuperHPad >> nLogxRatioUV)*pixelsize + nRefPitches[2] * (nSuperVPad >> nLogyRatioUV);

	imul	edx, DWORD PTR _nRefPitches$[ebp+8]
	mov	DWORD PTR _pSrc$[ebp+8], ecx
	mov	ecx, DWORD PTR _pRef$3$[ebp]
	add	eax, ebx
	add	ecx, eax
	add	edx, ebx

; 706  : 
; 707  :     // -----------------------------------------------------------------------------
; 708  :     const int nBlkSizeX_UV = nBlkSizeX >> nLogxRatioUV;

	mov	ebx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, edx
	mov	DWORD PTR _pRef$3$[ebp], ecx
	mov	DWORD PTR _pRef$[ebp+4], ecx
	mov	edx, DWORD PTR [ebx+76]

; 709  :     const int nBlkSizeY_UV = nBlkSizeY >> nLogyRatioUV;

	mov	esi, DWORD PTR [ebx+80]
	mov	DWORD PTR _pRef$4$[ebp], eax
	mov	DWORD PTR _pRef$[ebp+8], eax
	mov	eax, DWORD PTR [ebx+128]
	mov	ecx, eax
	sar	edx, cl
	mov	DWORD PTR _nBlkSizeX_UV$1$[ebp], edx
	mov	edx, DWORD PTR [ebx+132]
	mov	ecx, edx
	sar	esi, cl

; 710  :     
; 711  :     if (nOverlapX == 0 && nOverlapY == 0)

	cmp	DWORD PTR [ebx+108], 0
	mov	DWORD PTR _nBlkSizeY_UV$1$[ebp], esi
	jne	$LN73@GetFrame
	cmp	DWORD PTR [ebx+112], 0
	jne	$LN73@GetFrame

; 712  :     {
; 713  : 
; 714  :     // fetch image blocks
; 715  :       for (int i = 0; i < blocks; i++)

	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR _blocks$1$[ebp], eax
	jle	$LN18@GetFrame
	mov	edi, 256				; 00000100H
	sub	edi, DWORD PTR _time256$1$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv7413[ebp], edi
	mov	DWORD PTR tv7290[ebp], edx
$LL19@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+240]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	ecx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+480]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	add	ecx, edx
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [ecx+8]
	movq	QWORD PTR $T10[ebp], xmm0
	movq	xmm0, xmm0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 720  :         int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	imul	edi, DWORD PTR $T10[ebp]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	esi, DWORD PTR [eax+52]
	add	esi, edx
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T8[ebp], xmm0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 720  :         int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	mov	edx, DWORD PTR [ebx+104]
	mov	eax, edx
	imul	eax, DWORD PTR [ecx]
	sar	edi, 8
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [esi+8]
	movq	QWORD PTR $T6[ebp], xmm0
	movq	xmm0, xmm0
	movq	QWORD PTR $T4[ebp], xmm0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 720  :         int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	add	edi, eax

; 721  :         int refyB = blockB.GetY() * nPel + ((blockB.GetMV().y*(256 - time256)) >> 8);

	mov	eax, DWORD PTR tv7413[ebp]
	imul	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR _refxB$1$[ebp], edi

; 722  :         int refxF = blockF.GetX() * nPel + ((blockF.GetMV().x*time256) >> 8);

	mov	edi, DWORD PTR $T6[ebp]
	imul	edi, DWORD PTR _time256$1$[ebp]
	sar	eax, 8
	mov	DWORD PTR _refyB$1$[ebp], eax
	mov	eax, edx
	imul	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _refyB$1$[ebp]
	sar	edi, 8
	add	ecx, eax
	mov	eax, edx
	imul	eax, DWORD PTR [esi]

; 723  :         int refyF = blockF.GetY() * nPel + ((blockF.GetMV().y*time256) >> 8);

	imul	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _refyB$1$[ebp], ecx
	add	edi, eax
	mov	DWORD PTR _refxF$1$[ebp], edi
	mov	edi, DWORD PTR $T4[ebp+4]
	imul	edi, DWORD PTR _time256$1$[ebp]
	sar	edi, 8
	add	edi, edx

; 724  :         for (int p = 0; p < 3; p++)

	xor	edx, edx
	mov	DWORD PTR _refyF$1$[ebp], edi
	mov	DWORD PTR _p$1$[ebp], edx
	npad	9
$LL22@GetFrame:

; 725  :         {
; 726  :           if (needProcessPlanes[p]) {

	cmp	BYTE PTR _needProcessPlanes$[ebp+edx], 0
	je	$LN20@GetFrame

; 727  :             if (pixelsize == 1) {

	mov	eax, DWORD PTR [ebx+136]
	cmp	eax, 1
	jne	$LN76@GetFrame

; 728  :               ResultBlock<uint8_t>(pDst[p], nDstPitches[p],

	mov	eax, DWORD PTR [ebx+80]
	test	edx, edx
	jne	SHORT $LN125@GetFrame
	mov	DWORD PTR tv7561[ebp], eax
	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR tv7560[ebp], eax
	mov	eax, DWORD PTR [ebx+744]
	mov	DWORD PTR $T27[ebp], ecx
	mov	ecx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR tv7559[ebp], eax
	mov	eax, DWORD PTR _refxF$1$[ebp]
	mov	DWORD PTR $T25[ebp], ecx
	jmp	SHORT $LN138@GetFrame
$LN125@GetFrame:
	mov	edx, DWORD PTR [ebx+132]
	mov	ecx, edx
	mov	esi, DWORD PTR [ebx+76]
	sar	eax, cl
	mov	DWORD PTR tv7561[ebp], eax
	mov	eax, DWORD PTR [ebx+128]
	mov	ecx, eax
	sar	esi, cl
	mov	ecx, DWORD PTR [ebx+748]
	mov	DWORD PTR tv7559[ebp], ecx
	mov	ecx, edx
	mov	DWORD PTR tv7560[ebp], esi
	mov	esi, DWORD PTR _refxF$1$[ebp]
	sar	edi, cl
	mov	ecx, eax
	sar	esi, cl
	mov	ecx, edx
	mov	edx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR $T35[ebp], esi
	mov	esi, DWORD PTR _refyB$1$[ebp]
	sar	esi, cl
	mov	ecx, eax
	mov	eax, DWORD PTR $T35[ebp]
	sar	edx, cl
	mov	DWORD PTR $T25[ebp], edx
	mov	edx, DWORD PTR _p$1$[ebp]
	mov	DWORD PTR $T27[ebp], esi
$LN138@GetFrame:
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	esi, DWORD PTR _pPlanesF$11[ebp+edx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T32[ebp], ecx

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	ecx, DWORD PTR [esi+32]
	add	ecx, edi
	mov	edi, DWORD PTR [esi+28]
	add	edi, eax
	mov	DWORD PTR _nY$1$[ebp], ecx

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 1
	jne	SHORT $LN487@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [esi]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN490@GetFrame
$LN487@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, ecx
	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN489@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ecx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1040@GetFrame
$LN489@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ecx, 2
$LN1040@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax

; 69   :       nY >>= NPELL2;

	mov	DWORD PTR _nY$1$[ebp], ecx

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [esi]
	add	edi, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _p$1$[ebp]
$LN490@GetFrame:

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	eax, DWORD PTR [ecx+12]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR $T25[ebp]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T29[ebp], eax

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	eax, DWORD PTR [ecx+32]
	add	eax, DWORD PTR $T27[ebp]

; 82   :       if (nPel == 1)

	cmp	DWORD PTR [ecx+56], 1

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[ebp], eax

; 82   :       if (nPel == 1)

	jne	SHORT $LN503@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	esi, cl
	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN506@GetFrame
$LN503@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	DWORD PTR [ecx+56], 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, eax

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, esi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN505@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1041@GetFrame
$LN505@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 2
$LN1041@GetFrame:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	esi, cl
	or	edx, eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	edx, DWORD PTR _p$1$[ebp]
	add	esi, eax
$LN506@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 728  :               ResultBlock<uint8_t>(pDst[p], nDstPitches[p],

	mov	eax, DWORD PTR _pMaskOccUV$1$[ebp]
	test	edx, edx
	push	ecx
	push	DWORD PTR [ebx+648]
	cmove	eax, DWORD PTR _pMaskOccY$1$[ebp]
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR tv7561[ebp]
	push	DWORD PTR tv7560[ebp]
	push	eax
	mov	eax, DWORD PTR _pMaskFullUVF$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYF$1$[ebp]
	push	eax
	push	DWORD PTR tv7559[ebp]
	mov	eax, DWORD PTR _pMaskFullUVB$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYB$1$[ebp]
	push	eax
	push	DWORD PTR _nSrcPitches$[ebp+edx*4]
	push	DWORD PTR _pSrc$[ebp+edx*4]
	push	DWORD PTR _nRefPitches$[ebp+edx*4]
	push	DWORD PTR _pRef$[ebp+edx*4]
	push	DWORD PTR $T32[ebp]
	push	edi
	push	DWORD PTR $T29[ebp]
	push	esi
	push	DWORD PTR _nDstPitches$[ebp+edx*4]
	push	DWORD PTR _pDst$[ebp+edx*4]
	call	??$ResultBlock@E@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ; MVBlockFps::ResultBlock<unsigned char>
	jmp	$LN1042@GetFrame
$LN76@GetFrame:

; 729  :                 pPlanesB[p]->GetPointer(p == 0 ? refxB : refxB >> nLogxRatioUV, p == 0 ? refyB : refyB >> nLogyRatioUV),
; 730  :                 pPlanesB[p]->GetPitch(),
; 731  :                 pPlanesF[p]->GetPointer(p == 0 ? refxF : refxF >> nLogxRatioUV, p == 0 ? refyF : refyF >> nLogyRatioUV),
; 732  :                 pPlanesF[p]->GetPitch(),
; 733  :                 pRef[p], nRefPitches[p],
; 734  :                 pSrc[p], nSrcPitches[p],
; 735  :                 p == 0 ? pMaskFullYB : pMaskFullUVB,
; 736  :                 p == 0 ? nPitchY : nPitchUV,
; 737  :                 p == 0 ? pMaskFullYF : pMaskFullUVF,
; 738  :                 p == 0 ? pMaskOccY : pMaskOccUV,
; 739  :                 p == 0 ? nBlkSizeX : nBlkSizeX >> nLogxRatioUV,
; 740  :                 p == 0 ? nBlkSizeY : nBlkSizeY >> nLogyRatioUV,
; 741  :                 time256
; 742  :                 , mode, bits_per_pixel);
; 743  :             }
; 744  :             else if (pixelsize == 2)

	cmp	eax, 2
	jne	$LN20@GetFrame

; 746  :               ResultBlock<uint16_t>(pDst[p], nDstPitches[p],

	test	edx, edx
	jne	SHORT $LN139@GetFrame
	mov	eax, DWORD PTR [ebx+80]
	mov	DWORD PTR tv7558[ebp], eax
	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR tv7557[ebp], eax
	mov	eax, DWORD PTR [ebx+744]
	mov	DWORD PTR $T26[ebp], ecx
	mov	ecx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR tv7556[ebp], eax
	mov	eax, DWORD PTR _refxF$1$[ebp]
	mov	DWORD PTR $T24[ebp], ecx
	jmp	SHORT $LN152@GetFrame
$LN139@GetFrame:
	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	mov	edx, DWORD PTR [ebx+132]
	mov	ecx, edx
	mov	esi, DWORD PTR _refxF$1$[ebp]
	mov	DWORD PTR tv7558[ebp], eax
	mov	eax, DWORD PTR _nBlkSizeX_UV$1$[ebp]
	mov	DWORD PTR tv7557[ebp], eax
	mov	eax, DWORD PTR [ebx+748]
	sar	edi, cl
	mov	DWORD PTR tv7556[ebp], eax
	mov	eax, DWORD PTR [ebx+128]
	mov	ecx, eax
	sar	esi, cl
	mov	ecx, edx
	mov	edx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR $T34[ebp], esi
	mov	esi, DWORD PTR _refyB$1$[ebp]
	sar	esi, cl
	mov	ecx, eax
	mov	eax, DWORD PTR $T34[ebp]
	sar	edx, cl
	mov	DWORD PTR $T24[ebp], edx
	mov	edx, DWORD PTR _p$1$[ebp]
	mov	DWORD PTR $T26[ebp], esi
$LN152@GetFrame:
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	esi, DWORD PTR _pPlanesF$11[ebp+edx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T31[ebp], ecx

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	ecx, DWORD PTR [esi+32]
	add	ecx, edi
	mov	edi, DWORD PTR [esi+28]
	add	edi, eax
	mov	DWORD PTR _nY$1$[ebp], ecx

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 1
	jne	SHORT $LN519@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [esi]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN522@GetFrame
$LN519@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, ecx
	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN521@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ecx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1043@GetFrame
$LN521@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ecx, 2
$LN1043@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax

; 69   :       nY >>= NPELL2;

	mov	DWORD PTR _nY$1$[ebp], ecx

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [esi]
	add	edi, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _p$1$[ebp]
$LN522@GetFrame:

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	eax, DWORD PTR [ecx+12]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR $T24[ebp]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T28[ebp], eax

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	eax, DWORD PTR [ecx+32]
	add	eax, DWORD PTR $T26[ebp]

; 82   :       if (nPel == 1)

	cmp	DWORD PTR [ecx+56], 1

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[ebp], eax

; 82   :       if (nPel == 1)

	jne	SHORT $LN535@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	esi, cl
	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN538@GetFrame
$LN535@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	DWORD PTR [ecx+56], 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, eax

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, esi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN537@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1044@GetFrame
$LN537@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 2
$LN1044@GetFrame:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	esi, cl
	or	edx, eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _p$1$[ebp]
$LN538@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 746  :               ResultBlock<uint16_t>(pDst[p], nDstPitches[p],

	push	DWORD PTR [ebx+140]
	mov	eax, DWORD PTR _pMaskOccUV$1$[ebp]
	test	edx, edx
	push	DWORD PTR [ebx+648]
	cmove	eax, DWORD PTR _pMaskOccY$1$[ebp]
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR tv7558[ebp]
	push	DWORD PTR tv7557[ebp]
	push	eax
	mov	eax, DWORD PTR _pMaskFullUVF$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYF$1$[ebp]
	push	eax
	push	DWORD PTR tv7556[ebp]
	mov	eax, DWORD PTR _pMaskFullUVB$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYB$1$[ebp]
	push	eax
	push	DWORD PTR _nSrcPitches$[ebp+edx*4]
	push	DWORD PTR _pSrc$[ebp+edx*4]
	push	DWORD PTR _nRefPitches$[ebp+edx*4]
	push	DWORD PTR _pRef$[ebp+edx*4]
	push	DWORD PTR $T31[ebp]
	push	edi
	push	DWORD PTR $T28[ebp]
	push	esi
	push	DWORD PTR _nDstPitches$[ebp+edx*4]
	push	DWORD PTR _pDst$[ebp+edx*4]
	call	??$ResultBlock@G@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ; MVBlockFps::ResultBlock<unsigned short>
$LN1042@GetFrame:
	mov	edi, DWORD PTR _refyF$1$[ebp]
	mov	ecx, DWORD PTR _refyB$1$[ebp]
	mov	edx, DWORD PTR _p$1$[ebp]
$LN20@GetFrame:

; 724  :         for (int p = 0; p < 3; p++)

	inc	edx
	mov	DWORD PTR _p$1$[ebp], edx
	cmp	edx, 3
	jl	$LL22@GetFrame

; 747  :                 pPlanesB[p]->GetPointer(p == 0 ? refxB : refxB >> nLogxRatioUV, p == 0 ? refyB : refyB >> nLogyRatioUV),
; 748  :                 pPlanesB[p]->GetPitch(),
; 749  :                 pPlanesF[p]->GetPointer(p == 0 ? refxF : refxF >> nLogxRatioUV, p == 0 ? refyF : refyF >> nLogyRatioUV),
; 750  :                 pPlanesF[p]->GetPitch(),
; 751  :                 pRef[p], nRefPitches[p],
; 752  :                 pSrc[p], nSrcPitches[p],
; 753  :                 p == 0 ? pMaskFullYB : pMaskFullUVB,
; 754  :                 p == 0 ? nPitchY : nPitchUV,
; 755  :                 p == 0 ? pMaskFullYF : pMaskFullUVF,
; 756  :                 p == 0 ? pMaskOccY : pMaskOccUV,
; 757  :                 p == 0 ? nBlkSizeX : nBlkSizeX_UV,
; 758  :                 p == 0 ? nBlkSizeY : nBlkSizeY_UV,
; 759  :                 time256
; 760  :                 , mode, bits_per_pixel);
; 761  :             }
; 762  :           }
; 763  :         }
; 764  :         // update pDsts
; 765  :         pDst[0] += nBlkSizeX*pixelsize;

	mov	edx, DWORD PTR [ebx+76]
	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, ecx

; 766  :         pDst[1] += nBlkSizeX_UV * pixelsize;

	mov	edi, DWORD PTR _nBlkSizeX_UV$1$[ebp]
	mov	esi, DWORD PTR _pDst$1$[ebp]
	imul	eax, edx
	imul	ecx, edi

; 767  :         pDst[2] += nBlkSizeX_UV * pixelsize;
; 768  :         pRef[0] += nBlkSizeX*pixelsize;
; 769  :         pRef[1] += nBlkSizeX_UV * pixelsize;
; 770  :         pRef[2] += nBlkSizeX_UV * pixelsize;
; 771  :         pSrc[0] += nBlkSizeX *pixelsize;
; 772  :         pSrc[1] += nBlkSizeX_UV * pixelsize;
; 773  :         pSrc[2] += nBlkSizeX_UV * pixelsize;
; 774  :         pMaskFullYB += nBlkSizeX;

	add	DWORD PTR _pMaskFullYB$1$[ebp], edx

; 775  :         pMaskFullUVB += nBlkSizeX_UV;
; 776  :         pMaskFullYF += nBlkSizeX;

	add	DWORD PTR _pMaskFullYF$1$[ebp], edx

; 777  :         pMaskFullUVF += nBlkSizeX_UV;
; 778  :         pMaskOccY += nBlkSizeX;

	add	DWORD PTR _pMaskOccY$1$[ebp], edx
	add	esi, eax
	add	DWORD PTR _pMaskFullUVB$1$[ebp], edi
	mov	DWORD PTR _pDst$1$[ebp], esi
	mov	DWORD PTR _pDst$[ebp], esi
	mov	esi, DWORD PTR _pDst$2$[ebp]
	add	esi, ecx
	add	DWORD PTR _pMaskFullUVF$1$[ebp], edi
	mov	DWORD PTR _pDst$2$[ebp], esi
	mov	DWORD PTR _pDst$[ebp+4], esi
	mov	esi, DWORD PTR _pDst$3$[ebp]
	add	esi, ecx

; 779  :         pMaskOccUV += nBlkSizeX_UV;

	add	DWORD PTR _pMaskOccUV$1$[ebp], edi
	mov	DWORD PTR _pDst$3$[ebp], esi
	mov	DWORD PTR _pDst$[ebp+8], esi
	mov	esi, DWORD PTR _pRef$1$[ebp]
	add	esi, eax
	mov	DWORD PTR _pRef$1$[ebp], esi
	mov	DWORD PTR _pRef$[ebp], esi
	mov	esi, DWORD PTR _pRef$3$[ebp]
	add	esi, ecx
	mov	DWORD PTR _pRef$3$[ebp], esi
	mov	DWORD PTR _pRef$[ebp+4], esi
	mov	esi, DWORD PTR _pRef$4$[ebp]
	add	esi, ecx
	mov	DWORD PTR _pRef$4$[ebp], esi
	mov	DWORD PTR _pRef$[ebp+8], esi
	mov	esi, DWORD PTR _pSrc$1$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR _pSrc$3$[ebp]
	add	eax, ecx
	mov	DWORD PTR _pSrc$1$[ebp], esi
	mov	DWORD PTR _pSrc$3$[ebp], eax
	mov	DWORD PTR _pSrc$[ebp+4], eax
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	add	eax, ecx
	mov	DWORD PTR _pSrc$[ebp], esi
	mov	DWORD PTR _pSrc$4$[ebp], eax
	mov	DWORD PTR _pSrc$[ebp+8], eax

; 780  : 
; 781  : 
; 782  :         if (!((i + 1) % nBlkX))

	mov	eax, DWORD PTR _i$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cdq
	idiv	DWORD PTR [ebx+64]
	test	edx, edx
	jne	$LN17@GetFrame

; 783  :         {
; 784  :           for (int p = 0; p < 3; p++)

	xor	esi, esi
$LL25@GetFrame:

; 785  :           {
; 786  :             if (needProcessPlanes[p]) {

	cmp	BYTE PTR _needProcessPlanes$[ebp+esi], 0
	je	$LN23@GetFrame

; 787  :               // blend rest right with time weight
; 788  :               if (pixelsize == 1)

	mov	eax, DWORD PTR [ebx+136]
	cmp	eax, 1
	jne	SHORT $LN81@GetFrame

; 789  :                 Blend<uint8_t>(pDst[p], pSrc[p], pRef[p],

	mov	eax, DWORD PTR [ebx+64]
	test	esi, esi
	jne	SHORT $LN153@GetFrame
	imul	eax, DWORD PTR [ebx+76]
	mov	ecx, DWORD PTR [ebx+92]
	sub	ecx, eax
	mov	eax, DWORD PTR [ebx+80]
	jmp	SHORT $LN156@GetFrame
$LN153@GetFrame:
	mov	ecx, DWORD PTR _nWidthUV$1$[ebp]
	imul	eax, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
$LN156@GetFrame:
	mov	edx, DWORD PTR _pSrc$[ebp+esi*4]
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR _nRefPitches$[ebp+esi*4]
	push	DWORD PTR _nSrcPitches$[ebp+esi*4]
	push	DWORD PTR _nDstPitches$[ebp+esi*4]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[ebp+esi*4]
	push	eax
	push	DWORD PTR _pRef$[ebp+esi*4]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>
	jmp	SHORT $LN1045@GetFrame
$LN81@GetFrame:

; 790  :                   p == 0 ? nBlkSizeY : nBlkSizeY_UV,
; 791  :                   p == 0 ? nWidth - nBlkSizeX*nBlkX : nWidthUV - nBlkSizeX_UV*nBlkX,
; 792  :                   nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 793  :               else if (pixelsize == 2)

	cmp	eax, 2
	jne	SHORT $LN23@GetFrame

; 794  :                 Blend<uint16_t>(pDst[p], pSrc[p], pRef[p],

	mov	eax, DWORD PTR [ebx+64]
	test	esi, esi
	jne	SHORT $LN157@GetFrame
	imul	eax, DWORD PTR [ebx+76]
	mov	ecx, DWORD PTR [ebx+92]
	sub	ecx, eax
	mov	eax, DWORD PTR [ebx+80]
	jmp	SHORT $LN160@GetFrame
$LN157@GetFrame:
	mov	ecx, DWORD PTR _nWidthUV$1$[ebp]
	imul	eax, edi
	sub	ecx, eax
	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
$LN160@GetFrame:
	mov	edx, DWORD PTR _pSrc$[ebp+esi*4]
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR _nRefPitches$[ebp+esi*4]
	push	DWORD PTR _nSrcPitches$[ebp+esi*4]
	push	DWORD PTR _nDstPitches$[ebp+esi*4]
	push	ecx
	mov	ecx, DWORD PTR _pDst$[ebp+esi*4]
	push	eax
	push	DWORD PTR _pRef$[ebp+esi*4]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
$LN1045@GetFrame:
	add	esp, 32					; 00000020H
$LN23@GetFrame:

; 783  :         {
; 784  :           for (int p = 0; p < 3; p++)

	inc	esi
	cmp	esi, 3
	jl	$LL25@GetFrame

; 795  :                   p == 0 ? nBlkSizeY : nBlkSizeY_UV,
; 796  :                   p == 0 ? nWidth - nBlkSizeX*nBlkX : nWidthUV - nBlkSizeX_UV*nBlkX,
; 797  :                   nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 798  :             }
; 799  :           }
; 800  : 
; 801  :           pDst[0] += nBlkSizeY    * nDstPitches[0] - nBlkSizeX   *nBlkX*pixelsize;

	mov	edx, DWORD PTR [ebx+136]
	mov	ecx, edx
	mov	edi, DWORD PTR [ebx+76]
	mov	ebx, DWORD PTR [ebx+64]
	mov	eax, DWORD PTR _this$[ebp]

; 802  :           pDst[1] += nBlkSizeY_UV * nDstPitches[1] - nBlkSizeX_UV*nBlkX*pixelsize;

	imul	edx, DWORD PTR _nBlkSizeX_UV$1$[ebp]
	imul	ecx, ebx
	mov	esi, DWORD PTR [eax+80]
	mov	eax, DWORD PTR _nDstPitches$1$[ebp]
	imul	eax, esi
	imul	ecx, edi
	imul	edx, ebx
	sub	eax, ecx
	add	DWORD PTR _pDst$1$[ebp], eax
	mov	eax, DWORD PTR _pDst$1$[ebp]
	mov	DWORD PTR _pDst$[ebp], eax
	mov	eax, DWORD PTR _nDstPitches$2$[ebp]
	imul	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	sub	eax, edx
	add	DWORD PTR _pDst$2$[ebp], eax
	mov	eax, DWORD PTR _pDst$2$[ebp]
	mov	DWORD PTR _pDst$[ebp+4], eax

; 803  :           pDst[2] += nBlkSizeY_UV * nDstPitches[2] - nBlkSizeX_UV*nBlkX*pixelsize;

	mov	eax, DWORD PTR _nDstPitches$[ebp+8]
	imul	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	sub	eax, edx
	add	DWORD PTR _pDst$3$[ebp], eax
	mov	eax, DWORD PTR _pDst$3$[ebp]
	mov	DWORD PTR _pDst$[ebp+8], eax

; 804  :           pRef[0] += nBlkSizeY    * nRefPitches[0] - nBlkSizeX   *nBlkX*pixelsize;

	mov	eax, DWORD PTR _nRefPitches$[ebp]
	imul	eax, esi
	sub	eax, ecx
	add	DWORD PTR _pRef$1$[ebp], eax
	mov	eax, DWORD PTR _pRef$1$[ebp]
	mov	DWORD PTR _pRef$[ebp], eax

; 805  :           pRef[1] += nBlkSizeY_UV * nRefPitches[1] - nBlkSizeX_UV*nBlkX*pixelsize;

	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	imul	eax, DWORD PTR _nRefPitches$[ebp+4]
	sub	eax, edx
	add	DWORD PTR _pRef$3$[ebp], eax
	mov	eax, DWORD PTR _pRef$3$[ebp]
	mov	DWORD PTR _pRef$[ebp+4], eax

; 806  :           pRef[2] += nBlkSizeY_UV * nRefPitches[2] - nBlkSizeX_UV*nBlkX*pixelsize;

	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	imul	eax, DWORD PTR _nRefPitches$[ebp+8]
	sub	eax, edx
	add	DWORD PTR _pRef$4$[ebp], eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	mov	DWORD PTR _pRef$[ebp+8], eax

; 807  :           pSrc[0] += nBlkSizeY    * nSrcPitches[0] - nBlkSizeX   *nBlkX*pixelsize;

	mov	eax, DWORD PTR _nSrcPitches$[ebp]
	imul	eax, esi
	sub	eax, ecx
	mov	ecx, DWORD PTR _pSrc$1$[ebp]
	add	ecx, eax

; 808  :           pSrc[1] += nBlkSizeY_UV * nSrcPitches[1] - nBlkSizeX_UV*nBlkX*pixelsize;

	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	imul	eax, DWORD PTR _nSrcPitches$[ebp+4]
	mov	DWORD PTR _pSrc$1$[ebp], ecx
	mov	DWORD PTR _pSrc$[ebp], ecx

; 809  :           pSrc[2] += nBlkSizeY_UV * nSrcPitches[2] - nBlkSizeX_UV*nBlkX*pixelsize;

	mov	ecx, DWORD PTR _pSrc$4$[ebp]
	sub	eax, edx
	add	DWORD PTR _pSrc$3$[ebp], eax
	mov	eax, DWORD PTR _pSrc$3$[ebp]
	mov	DWORD PTR _pSrc$[ebp+4], eax
	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	imul	eax, DWORD PTR _nSrcPitches$[ebp+8]
	sub	eax, edx
	add	ecx, eax

; 810  :           pMaskFullYB  += nBlkSizeY    * nPitchY  - nBlkSizeX    *nBlkX;

	mov	eax, ebx
	mov	DWORD PTR _pSrc$4$[ebp], ecx
	mov	DWORD PTR _pSrc$[ebp+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, edi
	mov	edx, DWORD PTR [ecx+744]

; 811  :           pMaskFullUVB += nBlkSizeY_UV * nPitchUV - nBlkSizeX_UV *nBlkX;

	mov	ecx, DWORD PTR [ecx+748]
	imul	ecx, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	imul	edx, esi
	sub	edx, eax
	mov	eax, DWORD PTR _nBlkSizeX_UV$1$[ebp]
	add	DWORD PTR _pMaskFullYB$1$[ebp], edx

; 812  :           pMaskFullYF  += nBlkSizeY    * nPitchY  - nBlkSizeX    *nBlkX;

	add	DWORD PTR _pMaskFullYF$1$[ebp], edx
	imul	eax, ebx
	sub	ecx, eax
	add	DWORD PTR _pMaskFullUVB$1$[ebp], ecx

; 813  :           pMaskFullUVF += nBlkSizeY_UV * nPitchUV - nBlkSizeX_UV *nBlkX;

	add	DWORD PTR _pMaskFullUVF$1$[ebp], ecx

; 814  :           pMaskOccY    += nBlkSizeY    * nPitchY  - nBlkSizeX    *nBlkX;

	add	DWORD PTR _pMaskOccY$1$[ebp], edx

; 815  :           pMaskOccUV   += nBlkSizeY_UV * nPitchUV - nBlkSizeX_UV *nBlkX;

	add	DWORD PTR _pMaskOccUV$1$[ebp], ecx
	mov	ebx, DWORD PTR _this$[ebp]
$LN17@GetFrame:

; 712  :     {
; 713  : 
; 714  :     // fetch image blocks
; 715  :       for (int i = 0; i < blocks; i++)

	mov	edx, DWORD PTR tv7290[ebp]
	mov	eax, DWORD PTR _i$1$[ebp]
	add	edx, 20					; 00000014H
	mov	edi, DWORD PTR tv7413[ebp]
	mov	DWORD PTR tv7290[ebp], edx
	cmp	eax, DWORD PTR _blocks$1$[ebp]
	jl	$LL19@GetFrame
$LN18@GetFrame:
	mov	edi, DWORD PTR _nHeightUV$1$[ebp]

; 816  :         }
; 817  :       }
; 818  :       // blend rest bottom with time weight
; 819  :       for (int p = 0; p < 3; p++)

	xor	esi, esi
$LL28@GetFrame:

; 820  :       {
; 821  :         if (needProcessPlanes[p]) {

	cmp	BYTE PTR _needProcessPlanes$[ebp+esi], 0
	je	$LN26@GetFrame

; 822  :           if (pixelsize == 1)

	mov	eax, DWORD PTR [ebx+136]
	cmp	eax, 1
	jne	SHORT $LN85@GetFrame

; 823  :             Blend<uint8_t>(pDst[p], pSrc[p], pRef[p],

	mov	eax, DWORD PTR [ebx+68]
	test	esi, esi
	jne	SHORT $LN161@GetFrame
	mov	edx, DWORD PTR [ebx+92]
	imul	eax, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+96]
	jmp	SHORT $LN1046@GetFrame
$LN161@GetFrame:
	mov	edx, DWORD PTR _nWidthUV$1$[ebp]
	mov	ecx, edi
	imul	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
$LN1046@GetFrame:
	sub	ecx, eax
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR _nRefPitches$[ebp+esi*4]
	push	DWORD PTR _nSrcPitches$[ebp+esi*4]
	push	DWORD PTR _nDstPitches$[ebp+esi*4]
	push	edx
	mov	edx, DWORD PTR _pSrc$[ebp+esi*4]
	push	ecx
	push	DWORD PTR _pRef$[ebp+esi*4]
	mov	ecx, DWORD PTR _pDst$[ebp+esi*4]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>
	jmp	SHORT $LN1047@GetFrame
$LN85@GetFrame:

; 824  :               p == 0 ? nHeight - nBlkSizeY*nBlkY : nHeightUV - nBlkSizeY_UV*nBlkY,
; 825  :               p == 0 ? nWidth : nWidthUV,
; 826  :               nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 827  :           else if (pixelsize == 2)

	cmp	eax, 2
	jne	SHORT $LN26@GetFrame

; 828  :             Blend<uint16_t>(pDst[p], pSrc[p], pRef[p],

	mov	eax, DWORD PTR [ebx+68]
	test	esi, esi
	jne	SHORT $LN165@GetFrame
	mov	edx, DWORD PTR [ebx+92]
	imul	eax, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+96]
	jmp	SHORT $LN1048@GetFrame
$LN165@GetFrame:
	mov	edx, DWORD PTR _nWidthUV$1$[ebp]
	mov	ecx, edi
	imul	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
$LN1048@GetFrame:
	sub	ecx, eax
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR _nRefPitches$[ebp+esi*4]
	push	DWORD PTR _nSrcPitches$[ebp+esi*4]
	push	DWORD PTR _nDstPitches$[ebp+esi*4]
	push	edx
	mov	edx, DWORD PTR _pSrc$[ebp+esi*4]
	push	ecx
	push	DWORD PTR _pRef$[ebp+esi*4]
	mov	ecx, DWORD PTR _pDst$[ebp+esi*4]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
$LN1047@GetFrame:
	add	esp, 32					; 00000020H
$LN26@GetFrame:

; 816  :         }
; 817  :       }
; 818  :       // blend rest bottom with time weight
; 819  :       for (int p = 0; p < 3; p++)

	inc	esi
	cmp	esi, 3
	jl	$LL28@GetFrame

; 829  :               p == 0 ? nHeight - nBlkSizeY*nBlkY : nHeightUV - nBlkSizeY_UV*nBlkY,
; 830  :               p == 0 ? nWidth : nWidthUV,
; 831  :               nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 832  :         }
; 833  :       }
; 834  :     } // overlapx,y == 0
; 835  :     else // overlap

	jmp	$LN112@GetFrame
$LN73@GetFrame:

; 836  :     {
; 837  :       const int nWidth_B_UV = nWidth_B >> nLogxRatioUV;

	mov	esi, DWORD PTR _nWidth_B$1$[ebp]
	mov	ecx, eax

; 838  :       const int nHeight_B_UV = nHeight_B >> nLogyRatioUV;

	mov	eax, DWORD PTR _nHeight_B$1$[ebp]
	sar	esi, cl
	mov	ecx, edx
	mov	edx, eax
	mov	DWORD PTR _nWidth_B_UV$1$[ebp], esi
	sar	edx, cl

; 839  : 
; 840  :       for (int p = 0; p < 3; p++)

	xor	edi, edi
	mov	DWORD PTR _nHeight_B_UV$1$[ebp], edx
$LL31@GetFrame:

; 841  :       {
; 842  :         if (needProcessPlanes[p]) {

	cmp	BYTE PTR _needProcessPlanes$[ebp+edi], 0
	je	$LN29@GetFrame

; 843  :           // blend rest right with time weight
; 844  :           // P.F. 161115 2.5.1.22 bug: pDst[p] + nDstPitches[p]*()
; 845  :           // was:  0 (for U and V)
; 846  :           // need: nWidth_B / xRatioUV (for U and V) (2.5.11.22 bug)
; 847  :           if (pixelsize == 1)

	mov	eax, DWORD PTR [ebx+136]
	cmp	eax, 1
	jne	SHORT $LN89@GetFrame

; 848  :             Blend<uint8_t>(pDst[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),

	mov	ecx, DWORD PTR _nWidth_B$1$[ebp]
	test	edi, edi
	jne	SHORT $LN169@GetFrame
	mov	eax, DWORD PTR [ebx+92]
	sub	eax, ecx
	jmp	SHORT $LN170@GetFrame
$LN169@GetFrame:
	mov	eax, DWORD PTR _nWidthUV$1$[ebp]
	sub	eax, esi
$LN170@GetFrame:
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	test	edi, edi
	push	DWORD PTR _nRefPitches$[ebp+edi*4]
	cmove	esi, ecx
	mov	ecx, DWORD PTR _pDst$[ebp+edi*4]
	push	DWORD PTR _nSrcPitches$[ebp+edi*4]
	push	DWORD PTR _nDstPitches$[ebp+edi*4]
	push	eax
	mov	eax, edx
	mov	edx, DWORD PTR _pSrc$[ebp+edi*4]
	cmove	eax, DWORD PTR _nHeight_B$1$[ebp]
	add	edx, esi
	push	eax
	mov	eax, DWORD PTR _pRef$[ebp+edi*4]
	add	ecx, esi
	add	eax, esi
	push	eax
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>
	jmp	SHORT $LN1049@GetFrame
$LN89@GetFrame:

; 849  :               pSrc[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),   // -"-
; 850  :               pRef[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),   // -"-
; 851  :               p == 0 ? nHeight_B : nHeight_B_UV, // P.F. nHeight_B is enough, bottom will take care of buttom right edge
; 852  :               p == 0 ? nWidth - nWidth_B : nWidthUV - nWidth_B_UV,
; 853  :               nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 854  :           else if (pixelsize == 2)

	cmp	eax, 2
	jne	SHORT $LN29@GetFrame

; 855  :             Blend<uint16_t>(pDst[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),   // PF 161115 nWidth_B / xRatioUV instead of 0 for UV (2.5.11.22 bug)

	mov	ecx, DWORD PTR _nWidth_B$1$[ebp]
	test	edi, edi
	jne	SHORT $LN171@GetFrame
	mov	eax, DWORD PTR [ebx+92]
	sub	eax, ecx
	jmp	SHORT $LN172@GetFrame
$LN171@GetFrame:
	mov	eax, DWORD PTR _nWidthUV$1$[ebp]
	sub	eax, esi
$LN172@GetFrame:
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	test	edi, edi
	push	DWORD PTR _nRefPitches$[ebp+edi*4]
	cmove	esi, ecx
	mov	ecx, DWORD PTR _pDst$[ebp+edi*4]
	push	DWORD PTR _nSrcPitches$[ebp+edi*4]
	add	esi, esi
	test	edi, edi
	push	DWORD PTR _nDstPitches$[ebp+edi*4]
	push	eax
	mov	eax, edx
	mov	edx, DWORD PTR _pSrc$[ebp+edi*4]
	cmove	eax, DWORD PTR _nHeight_B$1$[ebp]
	add	edx, esi
	push	eax
	mov	eax, DWORD PTR _pRef$[ebp+edi*4]
	add	ecx, esi
	add	eax, esi
	push	eax
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
$LN1049@GetFrame:
	mov	esi, DWORD PTR _nWidth_B_UV$1$[ebp]
	add	esp, 32					; 00000020H
	mov	edx, DWORD PTR _nHeight_B_UV$1$[ebp]
$LN29@GetFrame:

; 839  : 
; 840  :       for (int p = 0; p < 3; p++)

	inc	edi
	cmp	edi, 3
	jl	$LL31@GetFrame

; 856  :               pSrc[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),   // -"-
; 857  :               pRef[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),   // -"-
; 858  :               p == 0 ? nHeight_B : nHeight_B_UV,
; 859  :               p == 0 ? nWidth - nWidth_B : nWidthUV - nWidth_B_UV,
; 860  :               nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 861  :         }
; 862  :       }
; 863  :       // blend rest right with time weight
; 864  : 
; 865  :       for (int p = 0; p < 3; p++)

	xor	eax, eax
	mov	DWORD PTR _p$1$[ebp], eax
	jmp	SHORT $LN34@GetFrame
	npad	11
$LL1030@GetFrame:
	mov	edx, DWORD PTR _nHeight_B_UV$1$[ebp]
$LN34@GetFrame:

; 866  :       {
; 867  :         if (needProcessPlanes[p]) {

	cmp	BYTE PTR _needProcessPlanes$[ebp+eax], 0
	je	$LN32@GetFrame

; 868  :           // blend rest bottom with time weight (full width, right fill was full height minus bottom corner)
; 869  :           // P.F. 161116 2.5.1.22 bug: pDst[p] + nDstPitches[p]*()
; 870  :           // was: (nHeight - nHeight_B), e.g. 720-716 = 4th row not O.K.
; 871  :           // need: nHeight_B (that is really the bottom) = 716th row O.K.
; 872  :           if (pixelsize == 1)

	mov	ecx, DWORD PTR [ebx+136]
	cmp	ecx, 1
	jne	$LN93@GetFrame

; 873  :             Blend<uint8_t>(pDst[p] + nDstPitches[p] * (p == 0 ? (/*nHeight -*/ nHeight_B) : (/*nHeight -*/ nHeight_B) / yRatioUV),

	test	eax, eax
	jne	SHORT $LN173@GetFrame
	mov	ecx, DWORD PTR [ebx+92]
	mov	esi, DWORD PTR _nHeight_B$1$[ebp]
	mov	DWORD PTR tv7545[ebp], ecx
	mov	ecx, DWORD PTR [ebx+96]
	sub	ecx, esi
	mov	DWORD PTR tv6939[ebp], esi
	mov	DWORD PTR tv7544[ebp], ecx
	jmp	SHORT $LN178@GetFrame
$LN173@GetFrame:
	mov	eax, DWORD PTR _nWidthUV$1$[ebp]
	mov	DWORD PTR tv7545[ebp], eax
	mov	eax, DWORD PTR _nHeightUV$1$[ebp]
	sub	eax, edx
	mov	DWORD PTR tv7544[ebp], eax
	mov	eax, DWORD PTR _nHeight_B$1$[ebp]
	cdq
	idiv	DWORD PTR [ebx+124]
	mov	DWORD PTR tv6939[ebp], eax
	mov	eax, DWORD PTR _p$1$[ebp]
$LN178@GetFrame:
	mov	ecx, DWORD PTR _nRefPitches$[ebp+eax*4]
	test	eax, eax
	mov	esi, DWORD PTR _nSrcPitches$[ebp+eax*4]
	mov	edi, DWORD PTR _nDstPitches$[ebp+eax*4]
	mov	edx, DWORD PTR _nHeight_B_UV$1$[ebp]
	cmove	edx, DWORD PTR _nHeight_B$1$[ebp]
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	mov	eax, edx
	imul	edx, esi
	push	ecx
	imul	eax, ecx
	mov	ecx, DWORD PTR _p$1$[ebp]
	push	esi
	push	edi
	push	DWORD PTR tv7545[ebp]
	add	eax, DWORD PTR _pRef$[ebp+ecx*4]
	push	DWORD PTR tv7544[ebp]
	add	edx, DWORD PTR _pSrc$[ebp+ecx*4]
	push	eax
	mov	eax, DWORD PTR tv6939[ebp]
	imul	eax, edi
	add	eax, DWORD PTR _pDst$[ebp+ecx*4]
	mov	ecx, eax
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>
	jmp	SHORT $LN1050@GetFrame
$LN93@GetFrame:

; 874  :               pSrc[p] + nSrcPitches[p] * (p == 0 ? nHeight_B : nHeight_B_UV),
; 875  :               pRef[p] + nRefPitches[p] * (p == 0 ? nHeight_B : nHeight_B_UV),
; 876  :               p == 0 ? nHeight - nHeight_B : nHeightUV - nHeight_B_UV,
; 877  :               p == 0 ? nWidth : nWidthUV,
; 878  :               nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 879  :           else if (pixelsize == 2)

	cmp	ecx, 2
	jne	SHORT $LN32@GetFrame

; 880  :             Blend<uint16_t>(pDst[p] + nDstPitches[p] * (p == 0 ? nHeight_B : nHeight_B_UV),

	test	eax, eax
	jne	SHORT $LN179@GetFrame
	mov	edx, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+92]
	sub	edx, DWORD PTR _nHeight_B$1$[ebp]
	jmp	SHORT $LN1051@GetFrame
$LN179@GetFrame:
	mov	edx, DWORD PTR _nHeightUV$1$[ebp]
	mov	ecx, DWORD PTR _nWidthUV$1$[ebp]
	sub	edx, DWORD PTR _nHeight_B_UV$1$[ebp]
$LN1051@GetFrame:
	mov	esi, DWORD PTR _nSrcPitches$[ebp+eax*4]
	test	eax, eax
	mov	edi, DWORD PTR _nDstPitches$[ebp+eax*4]
	mov	ebx, DWORD PTR _nHeight_B_UV$1$[ebp]
	cmove	ebx, DWORD PTR _nHeight_B$1$[ebp]
	mov	DWORD PTR tv7542[ebp], ecx
	mov	ecx, DWORD PTR _nRefPitches$[ebp+eax*4]
	mov	eax, ebx
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	imul	eax, ecx
	push	ecx
	mov	ecx, DWORD PTR _p$1$[ebp]
	push	esi
	push	edi
	push	DWORD PTR tv7542[ebp]
	add	eax, DWORD PTR _pRef$[ebp+ecx*4]
	push	edx
	mov	edx, ebx
	imul	ebx, edi
	imul	edx, esi
	push	eax
	add	ebx, DWORD PTR _pDst$[ebp+ecx*4]
	add	edx, DWORD PTR _pSrc$[ebp+ecx*4]
	mov	ecx, ebx
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
	mov	ebx, DWORD PTR _this$[ebp]
$LN1050@GetFrame:
	mov	eax, DWORD PTR _p$1$[ebp]
	add	esp, 32					; 00000020H
$LN32@GetFrame:

; 856  :               pSrc[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),   // -"-
; 857  :               pRef[p] + pixelsize*(p == 0 ? nWidth_B : nWidth_B_UV),   // -"-
; 858  :               p == 0 ? nHeight_B : nHeight_B_UV,
; 859  :               p == 0 ? nWidth - nWidth_B : nWidthUV - nWidth_B_UV,
; 860  :               nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 861  :         }
; 862  :       }
; 863  :       // blend rest right with time weight
; 864  : 
; 865  :       for (int p = 0; p < 3; p++)

	inc	eax
	mov	DWORD PTR _p$1$[ebp], eax
	cmp	eax, 3
	jl	$LL1030@GetFrame

; 889  :       MemZoneSet(reinterpret_cast<unsigned char*>(DstShort), 0, nWidth_B * sizeof(short)*pixelsize, nHeight_B, 0, 0, dstShortPitch * sizeof(short)*pixelsize);

	mov	edi, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+832]
	mov	esi, DWORD PTR [ebx+820]
	imul	eax, edi
	imul	edi, DWORD PTR _nWidth_B$1$[ebp]
	add	eax, eax
	mov	DWORD PTR _pitch$1$[ebp], eax
	add	edi, edi
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	mov	eax, DWORD PTR _nHeight_B$1$[ebp]
	test	eax, eax
	jle	SHORT $LN548@GetFrame
; File c:\github\mvtools\sources\mvblockfps.cpp

; 889  :       MemZoneSet(reinterpret_cast<unsigned char*>(DstShort), 0, nWidth_B * sizeof(short)*pixelsize, nHeight_B, 0, 0, dstShortPitch * sizeof(short)*pixelsize);

	mov	ebx, eax
$LL549@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 107  : 		memset(ptr, value, width);

	push	edi
	push	0
	push	esi
	call	_memset

; 108  : 		ptr += pitch;

	add	esi, DWORD PTR _pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL549@GetFrame
	mov	ebx, DWORD PTR _this$[ebp]
$LN548@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 890  :       if (nSuperModeYUV & UPLANE) MemZoneSet(reinterpret_cast<unsigned char*>(DstShortU), 0, nWidth_B_UV * sizeof(short) *pixelsize, nHeight_B_UV, 0, 0, dstShortPitchUV * sizeof(short)*pixelsize);

	test	BYTE PTR [ebx+688], 2
	mov	edx, DWORD PTR _nWidth_B_UV$1$[ebp]
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	mov	ecx, DWORD PTR _nHeight_B_UV$1$[ebp]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 890  :       if (nSuperModeYUV & UPLANE) MemZoneSet(reinterpret_cast<unsigned char*>(DstShortU), 0, nWidth_B_UV * sizeof(short) *pixelsize, nHeight_B_UV, 0, 0, dstShortPitchUV * sizeof(short)*pixelsize);

	je	SHORT $LN553@GetFrame
	mov	edi, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+836]
	mov	esi, DWORD PTR [ebx+824]
	imul	eax, edi
	imul	edi, edx
	add	eax, eax
	add	edi, edi
	mov	DWORD PTR _pitch$1$[ebp], eax
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	ecx, ecx
	jle	SHORT $LN553@GetFrame
; File c:\github\mvtools\sources\mvblockfps.cpp

; 890  :       if (nSuperModeYUV & UPLANE) MemZoneSet(reinterpret_cast<unsigned char*>(DstShortU), 0, nWidth_B_UV * sizeof(short) *pixelsize, nHeight_B_UV, 0, 0, dstShortPitchUV * sizeof(short)*pixelsize);

	mov	ebx, ecx
	npad	1
$LL554@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 107  : 		memset(ptr, value, width);

	push	edi
	push	0
	push	esi
	call	_memset

; 108  : 		ptr += pitch;

	add	esi, DWORD PTR _pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL554@GetFrame
	mov	ebx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nHeight_B_UV$1$[ebp]
	mov	edx, DWORD PTR _nWidth_B_UV$1$[ebp]
$LN553@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 891  :       if (nSuperModeYUV & VPLANE) MemZoneSet(reinterpret_cast<unsigned char*>(DstShortV), 0, nWidth_B_UV * sizeof(short) *pixelsize, nHeight_B_UV, 0, 0, dstShortPitchUV * sizeof(short)*pixelsize);

	test	BYTE PTR [ebx+688], 4
	je	SHORT $LN558@GetFrame
	mov	edi, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+836]
	mov	esi, DWORD PTR [ebx+828]
	imul	eax, edi
	imul	edi, edx
	add	eax, eax
	add	edi, edi
	mov	DWORD PTR _pitch$1$[ebp], eax
; File c:\github\mvtools\sources\copycode.cpp

; 105  : 	for (int y=offsetY; y<height+offsetY; y++)

	test	ecx, ecx
	jle	SHORT $LN558@GetFrame
; File c:\github\mvtools\sources\mvblockfps.cpp

; 891  :       if (nSuperModeYUV & VPLANE) MemZoneSet(reinterpret_cast<unsigned char*>(DstShortV), 0, nWidth_B_UV * sizeof(short) *pixelsize, nHeight_B_UV, 0, 0, dstShortPitchUV * sizeof(short)*pixelsize);

	mov	ebx, ecx
	npad	5
$LL559@GetFrame:
; File c:\github\mvtools\sources\copycode.cpp

; 107  : 		memset(ptr, value, width);

	push	edi
	push	0
	push	esi
	call	_memset

; 108  : 		ptr += pitch;

	add	esi, DWORD PTR _pitch$1$[ebp]
	add	esp, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL559@GetFrame
	mov	ebx, DWORD PTR _this$[ebp]
$LN558@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 893  :       pDstShort = DstShort;   // PF: can be used for Int array instead of short for 8+ bits

	mov	eax, DWORD PTR [ebx+820]
	mov	DWORD PTR _pDstShort$1$[ebp], eax

; 894  :       pDstShortU = DstShortU;

	mov	eax, DWORD PTR [ebx+824]
	mov	DWORD PTR _pDstShortU$1$[ebp], eax

; 895  :       pDstShortV = DstShortV;

	mov	eax, DWORD PTR [ebx+828]
	mov	DWORD PTR _pDstShortV$1$[ebp], eax

; 896  : 
; 897  :       for (int by = 0; by < nBlkY; by++)

	xor	eax, eax
	mov	DWORD PTR _by$1$[ebp], eax
	cmp	DWORD PTR [ebx+68], eax
	jle	$LN1031@GetFrame
$LL37@GetFrame:

; 898  :       {
; 899  :         int wby = ((by + nBlkY - 3) / (nBlkY - 2)) * 3;

	mov	ecx, DWORD PTR [ebx+68]
	add	eax, -3					; fffffffdH
	add	eax, ecx

; 900  :         int xx = 0;

	mov	DWORD PTR _xx$1$[ebp], 0
	add	ecx, -2					; fffffffeH
	cdq
	idiv	ecx

; 901  :         int xxUV = 0;

	mov	DWORD PTR _xxUV$1$[ebp], 0
	lea	esi, DWORD PTR [eax+eax*2]

; 902  :         for (int bx = 0; bx < nBlkX; bx++)

	xor	eax, eax
	mov	DWORD PTR _wby$1$[ebp], esi
	mov	DWORD PTR _bx$1$[ebp], eax
	cmp	DWORD PTR [ebx+64], eax
	jle	$LN39@GetFrame
	mov	ecx, 256				; 00000100H
	sub	ecx, DWORD PTR _time256$1$[ebp]
	mov	DWORD PTR tv7412[ebp], ecx
	npad	2
$LL40@GetFrame:

; 903  :         {
; 904  :           // select window
; 905  :           int wbx = (bx + nBlkX - 3) / (nBlkX - 2);

	mov	edi, DWORD PTR [ebx+64]
	add	eax, -3					; fffffffdH
	add	eax, edi
	cdq
	lea	ecx, DWORD PTR [edi-2]
	idiv	ecx

; 906  :           winOver = OverWins->GetWindow(wby + wbx);

	mov	edx, DWORD PTR [ebx+796]
	add	esi, eax
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [edx+20]
	imul	ecx, esi
	lea	eax, DWORD PTR [eax+ecx*2]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 906  :           winOver = OverWins->GetWindow(wby + wbx);

	mov	DWORD PTR [ebx+788], eax

; 907  :           winOverUV = OverWinsUV->GetWindow(wby + wbx);

	mov	eax, DWORD PTR [ebx+800]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	imul	ecx, esi
	lea	eax, DWORD PTR [eax+ecx*2]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 909  :           int i = by*nBlkX + bx;

	mov	ecx, DWORD PTR _by$1$[ebp]
	mov	DWORD PTR [ebx+792], eax
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+240]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 909  :           int i = by*nBlkX + bx;

	imul	ecx, edi

; 914  :           int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	mov	edi, DWORD PTR tv7412[ebp]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 909  :           int i = by*nBlkX + bx;

	add	ecx, DWORD PTR _bx$1$[ebp]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	edx, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [ebx+480]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 2
	add	edx, ecx
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [edx+8]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	esi, DWORD PTR [eax+52]
	add	esi, ecx
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T3[ebp], xmm0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 914  :           int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	imul	edi, DWORD PTR $T3[ebp]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, xmm0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 914  :           int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	mov	ecx, DWORD PTR [ebx+104]
	mov	eax, ecx
	imul	eax, DWORD PTR [edx]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T5[ebp], xmm0
	movq	xmm0, QWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 914  :           int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	sar	edi, 8
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T7[ebp], xmm0
	movq	xmm0, xmm0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 914  :           int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	add	edi, eax
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T9[ebp], xmm0
; File c:\github\mvtools\sources\mvblockfps.cpp

; 914  :           int refxB = blockB.GetX() * nPel + ((blockB.GetMV().x*(256 - time256)) >> 8);

	mov	DWORD PTR _refxB$1$[ebp], edi

; 915  :           int refyB = blockB.GetY() * nPel + ((blockB.GetMV().y*(256 - time256)) >> 8);

	mov	eax, ecx
	imul	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR tv7412[ebp]
	imul	edi, DWORD PTR $T5[ebp+4]

; 916  :           int refxF = blockF.GetX() * nPel + ((blockF.GetMV().x*time256) >> 8);

	mov	edx, DWORD PTR $T7[ebp]
	imul	edx, DWORD PTR _time256$1$[ebp]
	sar	edi, 8
	add	edi, eax
	mov	eax, ecx
	imul	eax, DWORD PTR [esi]

; 917  :           int refyF = blockF.GetY() * nPel + ((blockF.GetMV().y*time256) >> 8);

	imul	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _refyB$1$[ebp], edi
	mov	edi, DWORD PTR $T9[ebp+4]
	imul	edi, DWORD PTR _time256$1$[ebp]
	sar	edx, 8
	add	edx, eax
	mov	DWORD PTR _refxF$1$[ebp], edx
	sar	edi, 8
	add	edi, ecx

; 918  : 
; 919  :           // firstly calculate result block and write it to temporary place, not to dst
; 920  :           // luma
; 921  :           for (int p = 0; p < 3; p++)

	xor	edx, edx
	mov	DWORD PTR _refyF$1$[ebp], edi
	mov	DWORD PTR _p$1$[ebp], edx
$LL43@GetFrame:

; 922  :           {
; 923  :             if (needProcessPlanes[p]) {

	cmp	BYTE PTR _needProcessPlanes$[ebp+edx], 0

; 924  :               int current_xx;
; 925  :               if (p == 0) current_xx = xx; else current_xx = xxUV;

	mov	esi, DWORD PTR _xxUV$1$[ebp]
	mov	ecx, DWORD PTR _xx$1$[ebp]
	je	$LN41@GetFrame
	test	edx, edx
	mov	eax, esi
	cmove	eax, ecx
	mov	DWORD PTR _current_xx$1$[ebp], eax

; 926  :               if (pixelsize == 1) {

	mov	eax, DWORD PTR [ebx+136]
	cmp	eax, 1
	jne	$LN101@GetFrame

; 927  :                 ResultBlock<uint8_t>(TmpBlock, nBlkPitch*pixelsize,

	test	edx, edx
	jne	SHORT $LN183@GetFrame
	mov	eax, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR _refyB$1$[ebp]
	mov	DWORD PTR tv7538[ebp], eax
	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR tv7537[ebp], eax
	mov	eax, DWORD PTR [ebx+744]
	mov	DWORD PTR $T22[ebp], ecx
	mov	ecx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR tv7536[ebp], eax
	mov	eax, DWORD PTR _refxF$1$[ebp]
	mov	DWORD PTR $T21[ebp], ecx
	jmp	SHORT $LN196@GetFrame
$LN183@GetFrame:
	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	mov	edx, DWORD PTR [ebx+132]
	mov	ecx, edx
	mov	esi, DWORD PTR _refxF$1$[ebp]
	mov	DWORD PTR tv7538[ebp], eax
	mov	eax, DWORD PTR _nBlkSizeX_UV$1$[ebp]
	mov	DWORD PTR tv7537[ebp], eax
	mov	eax, DWORD PTR [ebx+748]
	sar	edi, cl
	mov	DWORD PTR tv7536[ebp], eax
	mov	eax, DWORD PTR [ebx+128]
	mov	ecx, eax
	sar	esi, cl
	mov	ecx, edx
	mov	edx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR $T23[ebp], esi
	mov	esi, DWORD PTR _refyB$1$[ebp]
	sar	esi, cl
	mov	ecx, eax
	mov	eax, DWORD PTR $T23[ebp]
	sar	edx, cl
	mov	DWORD PTR $T21[ebp], edx
	mov	edx, DWORD PTR _p$1$[ebp]
	mov	DWORD PTR $T22[ebp], esi
$LN196@GetFrame:
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	esi, DWORD PTR _pPlanesF$11[ebp+edx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T15[ebp], ecx

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	ecx, DWORD PTR [esi+32]
	add	ecx, edi
	mov	edi, DWORD PTR [esi+28]
	add	edi, eax
	mov	DWORD PTR _nY$1$[ebp], ecx

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 1
	jne	SHORT $LN598@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [esi]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN601@GetFrame
$LN598@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, ecx
	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN600@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ecx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1052@GetFrame
$LN600@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ecx, 2
$LN1052@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax

; 69   :       nY >>= NPELL2;

	mov	DWORD PTR _nY$1$[ebp], ecx

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	edx, DWORD PTR _p$1$[ebp]
	add	edi, eax
$LN601@GetFrame:

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	eax, DWORD PTR [ecx+12]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR $T21[ebp]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T19[ebp], eax

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	eax, DWORD PTR [ecx+32]
	add	eax, DWORD PTR $T22[ebp]

; 82   :       if (nPel == 1)

	cmp	DWORD PTR [ecx+56], 1

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[ebp], eax

; 82   :       if (nPel == 1)

	jne	SHORT $LN614@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	esi, cl
	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN617@GetFrame
$LN614@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	DWORD PTR [ecx+56], 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, eax

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, esi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN616@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1053@GetFrame
$LN616@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 2
$LN1053@GetFrame:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	esi, cl
	or	edx, eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	edx, DWORD PTR _p$1$[ebp]
	add	esi, eax
$LN617@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 927  :                 ResultBlock<uint8_t>(TmpBlock, nBlkPitch*pixelsize,

	mov	eax, DWORD PTR _pMaskOccUV$1$[ebp]
	test	edx, edx
	push	ecx
	push	DWORD PTR [ebx+648]
	cmove	eax, DWORD PTR _pMaskOccY$1$[ebp]
	push	DWORD PTR _time256$1$[ebp]
	mov	ecx, DWORD PTR _current_xx$1$[ebp]
	add	eax, ecx
	push	DWORD PTR tv7538[ebp]
	test	edx, edx
	push	DWORD PTR tv7537[ebp]
	push	eax
	mov	eax, DWORD PTR _pMaskFullUVF$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYF$1$[ebp]
	add	eax, ecx
	test	edx, edx
	push	eax
	push	DWORD PTR tv7536[ebp]
	mov	eax, DWORD PTR _pMaskFullUVB$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYB$1$[ebp]
	add	eax, ecx
	push	eax
	push	DWORD PTR _nSrcPitches$[ebp+edx*4]
	mov	eax, DWORD PTR _pSrc$[ebp+edx*4]
	add	eax, ecx
	push	eax
	push	DWORD PTR _nRefPitches$[ebp+edx*4]
	mov	eax, DWORD PTR _pRef$[ebp+edx*4]
	add	eax, ecx
	push	eax
	push	DWORD PTR $T15[ebp]
	push	edi
	push	DWORD PTR $T19[ebp]
	push	esi
	push	DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+728]
	call	??$ResultBlock@E@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ; MVBlockFps::ResultBlock<unsigned char>

; 928  :                   pPlanesB[p]->GetPointer(p == 0 ? refxB : refxB >> nLogxRatioUV, p == 0 ? refyB : refyB >> nLogyRatioUV),
; 929  :                   pPlanesB[p]->GetPitch(),
; 930  :                   pPlanesF[p]->GetPointer(p == 0 ? refxF : refxF >> nLogxRatioUV, p == 0 ? refyF : refyF >> nLogyRatioUV),
; 931  :                   pPlanesF[p]->GetPitch(),
; 932  :                   pRef[p] + current_xx*pixelsize, nRefPitches[p],
; 933  :                   pSrc[p] + current_xx*pixelsize, nSrcPitches[p],
; 934  :                   (p == 0 ? pMaskFullYB : pMaskFullUVB) + current_xx,
; 935  :                   (p == 0 ? nPitchY : nPitchUV),
; 936  :                   (p == 0 ? pMaskFullYF : pMaskFullUVF) + current_xx,
; 937  :                   (p == 0 ? pMaskOccY : pMaskOccUV) + current_xx,
; 938  :                   (p == 0 ? nBlkSizeX : nBlkSizeX_UV),
; 939  :                   (p == 0 ? nBlkSizeY : nBlkSizeY_UV),
; 940  :                   time256, mode, bits_per_pixel);
; 941  :                 // now write result block to short dst with overlap window weight
; 942  :                 switch (p) {

	mov	edx, DWORD PTR _p$1$[ebp]
	mov	eax, edx
	sub	eax, 0
	je	$LN103@GetFrame
	sub	eax, 1
	je	SHORT $LN104@GetFrame
	sub	eax, 1
	jne	$LN1026@GetFrame

; 945  :                 case 2: OVERSCHROMA(pDstShortV + current_xx, dstShortPitchUV, TmpBlock, nBlkPitch * pixelsize, winOverUV, nBlkSizeX_UV); break;

	push	DWORD PTR _nBlkSizeX_UV$1$[ebp]
	mov	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+792]
	mov	ecx, DWORD PTR _pDstShortV$1$[ebp]
	push	eax
	push	DWORD PTR [ebx+728]
	mov	eax, DWORD PTR _current_xx$1$[ebp]
	push	DWORD PTR [ebx+836]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [ebx+808]
	jmp	$LN1057@GetFrame
$LN104@GetFrame:

; 944  :                 case 1: OVERSCHROMA(pDstShortU + current_xx, dstShortPitchUV, TmpBlock, nBlkPitch * pixelsize, winOverUV, nBlkSizeX_UV); break;

	push	DWORD PTR _nBlkSizeX_UV$1$[ebp]
	mov	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+792]
	mov	ecx, DWORD PTR _pDstShortU$1$[ebp]
	push	eax
	push	DWORD PTR [ebx+728]
	mov	eax, DWORD PTR _current_xx$1$[ebp]
	push	DWORD PTR [ebx+836]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [ebx+808]
	jmp	$LN1057@GetFrame
$LN103@GetFrame:

; 943  :                 case 0: OVERSLUMA(pDstShort + current_xx, dstShortPitch, TmpBlock, nBlkPitch * pixelsize, winOver, nBlkSizeX); break;

	push	DWORD PTR [ebx+76]
	mov	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+788]
	mov	ecx, DWORD PTR _pDstShort$1$[ebp]
	push	eax
	push	DWORD PTR [ebx+728]
	mov	eax, DWORD PTR _current_xx$1$[ebp]
	push	DWORD PTR [ebx+832]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [ebx+804]

; 946  :                 }
; 947  :               }
; 948  :               else if (pixelsize == 2) {

	jmp	$LN1057@GetFrame
$LN101@GetFrame:
	cmp	eax, 2
	jne	$LN41@GetFrame

; 949  :                 ResultBlock<uint16_t>(TmpBlock, nBlkPitch*pixelsize,

	test	edx, edx
	jne	SHORT $LN197@GetFrame
	mov	eax, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR _refyB$1$[ebp]
	mov	DWORD PTR tv7535[ebp], eax
	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR tv7534[ebp], eax
	mov	eax, DWORD PTR [ebx+744]
	mov	DWORD PTR $T33[ebp], ecx
	mov	ecx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR tv7533[ebp], eax
	mov	eax, DWORD PTR _refxF$1$[ebp]
	mov	DWORD PTR $T30[ebp], ecx
	jmp	SHORT $LN210@GetFrame
$LN197@GetFrame:
	mov	eax, DWORD PTR _nBlkSizeY_UV$1$[ebp]
	mov	edx, DWORD PTR [ebx+132]
	mov	ecx, edx
	mov	esi, DWORD PTR _refxF$1$[ebp]
	mov	DWORD PTR tv7535[ebp], eax
	mov	eax, DWORD PTR _nBlkSizeX_UV$1$[ebp]
	mov	DWORD PTR tv7534[ebp], eax
	mov	eax, DWORD PTR [ebx+748]
	sar	edi, cl
	mov	DWORD PTR tv7533[ebp], eax
	mov	eax, DWORD PTR [ebx+128]
	mov	ecx, eax
	sar	esi, cl
	mov	ecx, edx
	mov	edx, DWORD PTR _refxB$1$[ebp]
	mov	DWORD PTR $T20[ebp], esi
	mov	esi, DWORD PTR _refyB$1$[ebp]
	sar	esi, cl
	mov	ecx, eax
	mov	eax, DWORD PTR $T20[ebp]
	sar	edx, cl
	mov	DWORD PTR $T30[ebp], edx
	mov	edx, DWORD PTR _p$1$[ebp]
	mov	DWORD PTR $T33[ebp], esi
$LN210@GetFrame:
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	esi, DWORD PTR _pPlanesF$11[ebp+edx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR $T18[ebp], ecx

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	ecx, DWORD PTR [esi+32]
	add	ecx, edi
	mov	edi, DWORD PTR [esi+28]
	add	edi, eax
	mov	DWORD PTR _nY$1$[ebp], ecx

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 1
	jne	SHORT $LN630@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, eax
	mov	eax, DWORD PTR [esi]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN633@GetFrame
$LN630@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, ecx
	mov	eax, edi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN632@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	ecx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1054@GetFrame
$LN632@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	edi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	ecx, 2
$LN1054@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	or	edx, eax

; 69   :       nY >>= NPELL2;

	mov	DWORD PTR _nY$1$[ebp], ecx

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+52]
	shl	edi, cl
	add	edi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	edx, DWORD PTR _p$1$[ebp]
	add	edi, eax
$LN633@GetFrame:

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	eax, DWORD PTR [ecx+12]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	esi, DWORD PTR [ecx+28]
	add	esi, DWORD PTR $T30[ebp]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T14[ebp], eax

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	eax, DWORD PTR [ecx+32]
	add	eax, DWORD PTR $T33[ebp]

; 82   :       if (nPel == 1)

	cmp	DWORD PTR [ecx+56], 1

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[ebp], eax

; 82   :       if (nPel == 1)

	jne	SHORT $LN646@GetFrame

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	esi, cl
	mov	ecx, DWORD PTR _pPlanesB$13[ebp+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN649@GetFrame
$LN646@GetFrame:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	DWORD PTR [ecx+56], 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, eax

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, esi

; 86   :       else if (nPel == 2)

	jne	SHORT $LN648@GetFrame

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 1

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 1
	add	edx, edx
	and	eax, 1

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN1055@GetFrame
$LN648@GetFrame:

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	edx, 3

; 67   : 
; 68   :       nX >>= NPELL2;

	sar	esi, 2
	shl	edx, 2
	and	eax, 3

; 69   :       nY >>= NPELL2;

	sar	DWORD PTR _nY$1$[ebp], 2
$LN1055@GetFrame:

; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	shl	esi, cl
	or	edx, eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	add	esi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, DWORD PTR _nY$1$[ebp]
	mov	edx, DWORD PTR _p$1$[ebp]
	add	esi, eax
$LN649@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 949  :                 ResultBlock<uint16_t>(TmpBlock, nBlkPitch*pixelsize,

	push	DWORD PTR [ebx+140]
	mov	eax, DWORD PTR _current_xx$1$[ebp]
	test	edx, edx
	push	DWORD PTR [ebx+648]
	push	DWORD PTR _time256$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _pMaskOccUV$1$[ebp]
	push	DWORD PTR tv7535[ebp]
	cmove	eax, DWORD PTR _pMaskOccY$1$[ebp]
	push	DWORD PTR tv7534[ebp]
	add	eax, DWORD PTR _current_xx$1$[ebp]
	test	edx, edx
	push	eax
	mov	eax, DWORD PTR _pMaskFullUVF$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYF$1$[ebp]
	add	eax, DWORD PTR _current_xx$1$[ebp]
	test	edx, edx
	push	eax
	push	DWORD PTR tv7533[ebp]
	mov	eax, DWORD PTR _pMaskFullUVB$1$[ebp]
	cmove	eax, DWORD PTR _pMaskFullYB$1$[ebp]
	add	eax, DWORD PTR _current_xx$1$[ebp]
	push	eax
	push	DWORD PTR _nSrcPitches$[ebp+edx*4]
	mov	eax, DWORD PTR _pSrc$[ebp+edx*4]
	add	eax, ecx
	push	eax
	push	DWORD PTR _nRefPitches$[ebp+edx*4]
	mov	eax, DWORD PTR _pRef$[ebp+edx*4]
	add	eax, ecx
	push	eax
	push	DWORD PTR $T18[ebp]
	mov	eax, DWORD PTR [ebx+732]
	push	edi
	push	DWORD PTR $T14[ebp]
	add	eax, eax
	push	esi
	push	eax
	push	DWORD PTR [ebx+728]
	call	??$ResultBlock@G@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ; MVBlockFps::ResultBlock<unsigned short>

; 950  :                   pPlanesB[p]->GetPointer(p == 0 ? refxB : refxB >> nLogxRatioUV, p == 0 ? refyB : refyB >> nLogyRatioUV),
; 951  :                   pPlanesB[p]->GetPitch(),
; 952  :                   pPlanesF[p]->GetPointer(p == 0 ? refxF : refxF >> nLogxRatioUV, p == 0 ? refyF : refyF >> nLogyRatioUV),
; 953  :                   pPlanesF[p]->GetPitch(),
; 954  :                   pRef[p] + current_xx*pixelsize, nRefPitches[p],
; 955  :                   pSrc[p] + current_xx*pixelsize, nSrcPitches[p],
; 956  :                   (p == 0 ? pMaskFullYB : pMaskFullUVB) + current_xx,
; 957  :                   (p == 0 ? nPitchY : nPitchUV),
; 958  :                   (p == 0 ? pMaskFullYF : pMaskFullUVF) + current_xx,
; 959  :                   (p == 0 ? pMaskOccY : pMaskOccUV) + current_xx,
; 960  :                   (p == 0 ? nBlkSizeX : nBlkSizeX_UV),
; 961  :                   (p == 0 ? nBlkSizeY : nBlkSizeY_UV),
; 962  :                   time256, mode, bits_per_pixel);
; 963  :                 // now write result block to short dst with overlap window weight
; 964  :                 switch (p) { // pitch of TmpBlock is byte-level only, regardless of 8/16 bit 

	mov	edx, DWORD PTR _p$1$[ebp]
	mov	eax, edx
	sub	eax, 0
	je	$LN107@GetFrame
	sub	eax, 1
	je	$LN108@GetFrame
	sub	eax, 1
	jne	SHORT $LN1026@GetFrame

; 967  :                 case 2: OVERSCHROMA16((unsigned short *)((int *)(pDstShortV)+current_xx), dstShortPitchUV, TmpBlock, nBlkPitch * pixelsize, winOverUV, nBlkSizeX / xRatioUV); break;

	mov	ecx, DWORD PTR _pDstShortV$1$[ebp]
$LN1060@GetFrame:
	mov	eax, DWORD PTR [ebx+76]
	cdq
	idiv	DWORD PTR [ebx+120]
	push	eax
	mov	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+792]
	push	eax
	push	DWORD PTR [ebx+728]
	mov	eax, DWORD PTR _current_xx$1$[ebp]
	push	DWORD PTR [ebx+836]
	lea	eax, DWORD PTR [ecx+eax*4]
	push	eax
	mov	eax, DWORD PTR [ebx+816]
$LN1057@GetFrame:
	call	eax
	mov	edx, DWORD PTR _p$1$[ebp]
	add	esp, 24					; 00000018H
$LN1026@GetFrame:
	mov	esi, DWORD PTR _xxUV$1$[ebp]
	mov	ecx, DWORD PTR _xx$1$[ebp]
	mov	edi, DWORD PTR _refyF$1$[ebp]
$LN41@GetFrame:

; 918  : 
; 919  :           // firstly calculate result block and write it to temporary place, not to dst
; 920  :           // luma
; 921  :           for (int p = 0; p < 3; p++)

	inc	edx
	mov	DWORD PTR _p$1$[ebp], edx
	cmp	edx, 3
	jl	$LL43@GetFrame

; 968  :                 }
; 969  :               } // pixelsize
; 970  :             } // needprocess
; 971  :           } // planes
; 972  : 
; 973  :           xx += (nBlkSizeX - nOverlapX);

	mov	eax, DWORD PTR [ebx+76]
	sub	eax, DWORD PTR [ebx+108]
	add	ecx, eax
	mov	DWORD PTR _xx$1$[ebp], ecx

; 974  :           xxUV += (nBlkSizeX - nOverlapX) >> nLogxRatioUV; // * pixelsize is at the usage place

	mov	ecx, DWORD PTR [ebx+128]
	sar	eax, cl
	add	esi, eax
	mov	eax, DWORD PTR _bx$1$[ebp]
	inc	eax
	mov	DWORD PTR _xxUV$1$[ebp], esi
	mov	esi, DWORD PTR _wby$1$[ebp]
	mov	DWORD PTR _bx$1$[ebp], eax
	cmp	eax, DWORD PTR [ebx+64]
	jl	$LL40@GetFrame
$LN39@GetFrame:

; 975  : 
; 976  :         } // for bx
; 977  :         // update pDsts
; 978  :         const int nBlkSizeYOverlapDiff = (nBlkSizeY - nOverlapY);
; 979  :         const int nBlkSizeYOverlapDiff_UV = (nBlkSizeY - nOverlapY) >> nLogyRatioUV;

	mov	edx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [ebx+80]
	sub	edi, DWORD PTR [ebx+112]
	mov	ebx, edi

; 980  : 
; 981  :         pDstShort += dstShortPitch*nBlkSizeYOverlapDiff*pixelsize; // pointer is short, 10-16bit: really int *, so mul 2x

	mov	esi, DWORD PTR [edx+136]
	mov	eax, esi
	mov	ecx, DWORD PTR [edx+132]
	imul	eax, edi
	sar	ebx, cl
	mov	ecx, DWORD PTR _pDstShort$1$[ebp]
	imul	eax, DWORD PTR [edx+832]
	lea	ecx, DWORD PTR [ecx+eax*2]

; 982  :         pDstShortU += dstShortPitchUV*nBlkSizeYOverlapDiff_UV*pixelsize;

	mov	eax, DWORD PTR [edx+836]
	mov	edx, DWORD PTR _pDstShortU$1$[ebp]
	mov	DWORD PTR _pDstShort$1$[ebp], ecx
	mov	ecx, esi
	imul	ecx, eax

; 983  :         pDstShortV += dstShortPitchUV*(nBlkSizeY - nOverlapY) / yRatioUV*pixelsize;

	imul	eax, edi
	imul	ecx, ebx
	lea	edx, DWORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pDstShortU$1$[ebp], edx
	cdq
	idiv	DWORD PTR [ecx+124]

; 984  :         pDst[0] += nDstPitches[0] * nBlkSizeYOverlapDiff;

	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
	imul	eax, esi
	mov	esi, DWORD PTR _pDstShortV$1$[ebp]

; 985  :         pDst[1] += nDstPitches[1] * nBlkSizeYOverlapDiff_UV;
; 986  :         pDst[2] += nDstPitches[2] * nBlkSizeYOverlapDiff_UV;
; 987  :         pRef[0] += nRefPitches[0] * nBlkSizeYOverlapDiff;

	mov	ecx, DWORD PTR _pRef$1$[ebp]
	lea	esi, DWORD PTR [esi+eax*2]
	mov	eax, edx
	imul	eax, edi
	mov	DWORD PTR _pDstShortV$1$[ebp], esi
	add	DWORD PTR _pDst$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitches$2$[ebp]
	imul	eax, ebx
	add	DWORD PTR _pDst$2$[ebp], eax
	mov	eax, DWORD PTR _nDstPitches$[ebp+8]
	imul	eax, ebx
	add	DWORD PTR _pDst$3$[ebp], eax
	mov	eax, DWORD PTR _nRefPitches$[ebp]
	imul	eax, edi
	add	ecx, eax

; 988  :         pRef[1] += nRefPitches[1] * nBlkSizeYOverlapDiff_UV;

	mov	eax, DWORD PTR _nRefPitches$[ebp+4]
	imul	eax, ebx
	mov	DWORD PTR _pRef$1$[ebp], ecx
	mov	DWORD PTR _pRef$[ebp], ecx
	mov	ecx, DWORD PTR _pRef$3$[ebp]
	add	ecx, eax

; 989  :         pRef[2] += nRefPitches[2] * nBlkSizeYOverlapDiff_UV;

	mov	eax, DWORD PTR _nRefPitches$[ebp+8]
	imul	eax, ebx
	mov	DWORD PTR _pRef$3$[ebp], ecx
	mov	DWORD PTR _pRef$[ebp+4], ecx
	mov	ecx, DWORD PTR _pRef$4$[ebp]
	add	ecx, eax

; 990  :         pSrc[0] += nSrcPitches[0] * nBlkSizeYOverlapDiff;

	mov	eax, DWORD PTR _nSrcPitches$[ebp]
	imul	eax, edi
	mov	DWORD PTR _pRef$4$[ebp], ecx
	mov	DWORD PTR _pRef$[ebp+8], ecx
	mov	ecx, DWORD PTR _pSrc$1$[ebp]
	add	ecx, eax

; 991  :         pSrc[1] += nSrcPitches[1] * nBlkSizeYOverlapDiff_UV;

	mov	eax, DWORD PTR _nSrcPitches$[ebp+4]
	imul	eax, ebx
	mov	DWORD PTR _pSrc$1$[ebp], ecx
	mov	DWORD PTR _pSrc$[ebp], ecx
	mov	ecx, DWORD PTR _pSrc$3$[ebp]
	add	ecx, eax

; 992  :         pSrc[2] += nSrcPitches[2] * nBlkSizeYOverlapDiff_UV;

	mov	eax, DWORD PTR _nSrcPitches$[ebp+8]
	imul	eax, ebx
	mov	DWORD PTR _pSrc$3$[ebp], ecx
	mov	DWORD PTR _pSrc$[ebp+4], ecx
	mov	ecx, DWORD PTR _pSrc$4$[ebp]
	add	ecx, eax

; 993  :         pMaskFullYB += nPitchY*nBlkSizeYOverlapDiff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pSrc$4$[ebp], ecx
	mov	DWORD PTR _pSrc$[ebp+8], ecx
	mov	ecx, DWORD PTR [eax+744]

; 994  :         pMaskFullUVB += nPitchUV*nBlkSizeYOverlapDiff_UV;

	mov	eax, DWORD PTR [eax+748]
	imul	ecx, edi
	imul	eax, ebx
	add	DWORD PTR _pMaskFullYB$1$[ebp], ecx
	add	DWORD PTR _pMaskFullUVB$1$[ebp], eax

; 995  :         pMaskFullYF += nPitchY*nBlkSizeYOverlapDiff;
; 996  :         pMaskFullUVF += nPitchUV*nBlkSizeYOverlapDiff_UV;

	add	DWORD PTR _pMaskFullUVF$1$[ebp], eax

; 997  :         pMaskOccY += nPitchY*nBlkSizeYOverlapDiff;
; 998  :         pMaskOccUV += nPitchUV*nBlkSizeYOverlapDiff_UV;

	add	DWORD PTR _pMaskOccUV$1$[ebp], eax
	mov	eax, DWORD PTR _by$1$[ebp]
	mov	ebx, DWORD PTR _this$[ebp]
	inc	eax
	add	DWORD PTR _pMaskFullYF$1$[ebp], ecx
	add	DWORD PTR _pMaskOccY$1$[ebp], ecx
	mov	DWORD PTR _by$1$[ebp], eax
	cmp	eax, DWORD PTR [ebx+68]
	jl	$LL37@GetFrame

; 896  : 
; 897  :       for (int by = 0; by < nBlkY; by++)

	jmp	SHORT $LN36@GetFrame
$LN108@GetFrame:

; 966  :                 case 1: OVERSCHROMA16((unsigned short *)((int *)(pDstShortU)+current_xx), dstShortPitchUV, TmpBlock, nBlkPitch * pixelsize, winOverUV, nBlkSizeX / xRatioUV); break;

	mov	ecx, DWORD PTR _pDstShortU$1$[ebp]
	jmp	$LN1060@GetFrame
$LN107@GetFrame:

; 965  :                 case 0: OVERSLUMA16((unsigned short *)((int *)(pDstShort)+current_xx), dstShortPitch, TmpBlock, nBlkPitch * pixelsize, winOver, nBlkSizeX); break;

	push	DWORD PTR [ebx+76]
	mov	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+788]
	mov	ecx, DWORD PTR _pDstShort$1$[ebp]
	push	eax
	push	DWORD PTR [ebx+728]
	mov	eax, DWORD PTR _current_xx$1$[ebp]
	push	DWORD PTR [ebx+832]
	lea	eax, DWORD PTR [ecx+eax*4]
	push	eax
	mov	eax, DWORD PTR [ebx+812]
	jmp	$LN1057@GetFrame
$LN1031@GetFrame:
	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
$LN36@GetFrame:

; 999  :       }  // for by
; 1000 :         // post 2.5.1.22 bug: the copy from internal 16 bit array to destination was missing for overlaps!
; 1001 :       if (pixelsize == 1) {

	mov	eax, DWORD PTR [ebx+136]
	cmp	eax, 1
	jne	SHORT $LN110@GetFrame

; 1002 :         // nWidth_B and nHeight_B, right and bottom was blended
; 1003 :         Short2Bytes(pDstSave[0], nDstPitches[0], DstShort, dstShortPitch, nWidth_B, nHeight_B);

	push	DWORD PTR _nHeight_B$1$[ebp]
	mov	ecx, DWORD PTR _pDstSave$16[ebp]
	push	DWORD PTR _nWidth_B$1$[ebp]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+820]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes

; 1004 :         Short2Bytes(pDstSave[1], nDstPitches[1], DstShortU, dstShortPitchUV, nWidth_B_UV, nHeight_B_UV);

	mov	esi, DWORD PTR _nHeight_B_UV$1$[ebp]
	mov	edi, DWORD PTR _nWidth_B_UV$1$[ebp]
	mov	edx, DWORD PTR _nDstPitches$2$[ebp]
	mov	ecx, DWORD PTR _pDstSave$16[ebp+4]
	push	esi
	push	edi
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+824]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes

; 1005 :         Short2Bytes(pDstSave[2], nDstPitches[2], DstShortV, dstShortPitchUV, nWidth_B_UV, nHeight_B_UV);

	mov	edx, DWORD PTR _nDstPitches$[ebp+8]
	mov	ecx, DWORD PTR _pDstSave$3$[ebp]
	push	esi
	push	edi
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+828]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes
	add	esp, 48					; 00000030H
	jmp	SHORT $LN112@GetFrame
$LN110@GetFrame:

; 1006 :       }
; 1007 :       else if (pixelsize == 2)

	cmp	eax, 2
	jne	SHORT $LN112@GetFrame

; 1008 :       {
; 1009 :         Short2Bytes_Int32toWord16((uint16_t *)(pDstSave[0]), nDstPitches[0], (int *)DstShort, dstShortPitch, nWidth_B, nHeight_B, bits_per_pixel);

	push	DWORD PTR [ebx+140]
	mov	ecx, DWORD PTR _pDstSave$16[ebp]
	push	DWORD PTR _nHeight_B$1$[ebp]
	push	DWORD PTR _nWidth_B$1$[ebp]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+820]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16

; 1010 :         Short2Bytes_Int32toWord16((uint16_t *)(pDstSave[1]), nDstPitches[1], (int *)DstShortU, dstShortPitchUV, nWidth_B_UV, nHeight_B_UV, bits_per_pixel);

	push	DWORD PTR [ebx+140]
	mov	esi, DWORD PTR _nHeight_B_UV$1$[ebp]
	mov	edi, DWORD PTR _nWidth_B_UV$1$[ebp]
	mov	edx, DWORD PTR _nDstPitches$2$[ebp]
	mov	ecx, DWORD PTR _pDstSave$16[ebp+4]
	push	esi
	push	edi
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+824]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16

; 1011 :         Short2Bytes_Int32toWord16((uint16_t *)(pDstSave[2]), nDstPitches[2], (int *)DstShortV, dstShortPitchUV, nWidth_B_UV, nHeight_B_UV, bits_per_pixel);

	push	DWORD PTR [ebx+140]
	mov	edx, DWORD PTR _nDstPitches$[ebp+8]
	mov	ecx, DWORD PTR _pDstSave$3$[ebp]
	push	esi
	push	edi
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+828]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16
	add	esp, 60					; 0000003cH
$LN112@GetFrame:

; 1012 :       }
; 1013 :     }
; 1014 :     PROFILE_STOP(MOTION_PROFILE_COMPENSATION);
; 1015 : 
; 1016 :     PROFILE_START(MOTION_PROFILE_YUY2CONVERT);
; 1017 :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN659@GetFrame
	cmp	BYTE PTR [ebx+669], 0
	jne	$LN659@GetFrame

; 1018 :     {
; 1019 :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	al, BYTE PTR [ebx+668]
	mov	esi, DWORD PTR [ebx+96]
	mov	edi, DWORD PTR [ebx+92]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	test	al, al
	je	SHORT $LN658@GetFrame
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	BYTE PTR _pDstSave$16[ebp], 15		; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	jne	SHORT $LN658@GetFrame

; 155  :     //U and V don't have to be aligned since we user movq to read from those
; 156  :     convert_yv16_to_yuy2_sse2(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	mov	edx, DWORD PTR _pDstSave$16[ebp+4]
	mov	ecx, DWORD PTR _pDstSave$16[ebp]
	push	esi
	push	edi
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	DWORD PTR _pDstSave$3$[ebp]
	call	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_sse2

; 157  :   }
; 158  :   else

	jmp	SHORT $LN1058@GetFrame
$LN658@GetFrame:

; 159  :   {
; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	mov	edx, DWORD PTR _pDstSave$16[ebp+4]
	mov	ecx, DWORD PTR _pDstSave$16[ebp]
	push	esi
	push	edi
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	DWORD PTR _pDstSave$3$[ebp]
	call	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_c
$LN1058@GetFrame:
	add	esp, 28					; 0000001cH
$LN659@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	edx, edx
	je	SHORT $LN665@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN665@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN665@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	edx, edx
	je	SHORT $LN669@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN669@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN669@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	test	edx, edx
	je	SHORT $LN674@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN674@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN674@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	edx, edx
	je	SHORT $LN679@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN679@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN679@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	edx, edx
	je	SHORT $LN684@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN684@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN684@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1024 :     return dst;

	jmp	$LN1036@GetFrame
$LN56@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1029 :     PVideoFrame src = child->GetFrame(nleft, env); // it is easy to use child here - v2.0

	mov	edx, DWORD PTR _nleft$1$[ebp]
	push	ebx
	push	edx
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _src$36[ebp]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H

; 1030 : 
; 1031 :     if (blend) //let's blend src with ref frames like ConvertFPS

	cmp	BYTE PTR [edi+670], 0
	je	$LN114@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1033 :       PVideoFrame ref = child->GetFrame(nright, env);

	lea	edx, DWORD PTR _ref$40[ebp]
	push	ebx
	push	DWORD PTR _nright$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H

; 1035 :       if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [edi+116]
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1035 :       if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN116@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN700@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN700@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$2$[ebp], eax
	jmp	SHORT $LN701@GetFrame
$LN700@GetFrame:
	mov	DWORD PTR _pSrc$2$[ebp], 0
$LN701@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN706@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN706@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$2$[ebp], eax
	jmp	SHORT $LN707@GetFrame
$LN706@GetFrame:
	mov	DWORD PTR _nSrcPitches$2$[ebp], 0
$LN707@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN712@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN712@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$2$[ebp], eax
	jmp	SHORT $LN713@GetFrame
$LN712@GetFrame:
	mov	DWORD PTR _pRef$2$[ebp], 0
$LN713@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN718@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN718@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$2$[ebp], eax
	jmp	SHORT $LN719@GetFrame
$LN718@GetFrame:
	mov	DWORD PTR _nRefPitches$2$[ebp], 0
$LN719@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN724@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN724@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ebx, eax
	jmp	SHORT $LN725@GetFrame
$LN724@GetFrame:
	xor	ebx, ebx
$LN725@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN730@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN730@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN731@GetFrame
$LN730@GetFrame:
	xor	eax, eax
$LN731@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1043 :         Blend<uint8_t>(pDstYUY2, pSrc[0], pRef[0], nHeight, nWidth * 2, nDstPitchYUY2, nSrcPitches[0], nRefPitches[0], time256 /*t256_prov_cst*/, isse_flag);

	mov	edx, DWORD PTR _pSrc$2$[ebp]
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _nRefPitches$2$[ebp]
	push	DWORD PTR _nSrcPitches$2$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+92]
	add	eax, eax
	push	eax
	push	DWORD PTR [edi+96]
	push	DWORD PTR _pRef$2$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>
	add	esp, 32					; 00000020H

; 1044 :       }
; 1045 :       else

	jmp	$LN49@GetFrame
$LN116@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN736@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN736@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN737@GetFrame
$LN736@GetFrame:
	xor	eax, eax
$LN737@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1047 :         pDst[0] = YWPLAN(dst);

	mov	DWORD PTR _pDst$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN742@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN742@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN743@GetFrame
$LN742@GetFrame:
	xor	eax, eax
$LN743@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1048 :         pDst[1] = UWPLAN(dst);

	mov	DWORD PTR _pDst$[ebp+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN748@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN748@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN749@GetFrame
$LN748@GetFrame:
	xor	eax, eax
$LN749@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1049 :         pDst[2] = VWPLAN(dst);

	mov	DWORD PTR _pDst$[ebp+8], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN754@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN754@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN755@GetFrame
$LN754@GetFrame:
	xor	eax, eax
$LN755@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1050 :         nDstPitches[0] = YPITCH(dst);

	mov	DWORD PTR _nDstPitches$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN760@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN760@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN761@GetFrame
$LN760@GetFrame:
	xor	eax, eax
$LN761@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1051 :         nDstPitches[1] = UPITCH(dst);

	mov	DWORD PTR _nDstPitches$[ebp+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN766@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN766@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN767@GetFrame
$LN766@GetFrame:
	xor	eax, eax
$LN767@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1052 :         nDstPitches[2] = VPITCH(dst);

	mov	DWORD PTR _nDstPitches$[ebp+8], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN772@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN772@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN773@GetFrame
$LN772@GetFrame:
	xor	eax, eax
$LN773@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1054 :         pRef[0] = YRPLAN(ref);

	mov	DWORD PTR _pRef$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN778@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN778@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN779@GetFrame
$LN778@GetFrame:
	xor	eax, eax
$LN779@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1055 :         pRef[1] = URPLAN(ref);

	mov	DWORD PTR _pRef$[ebp+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN784@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN784@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN785@GetFrame
$LN784@GetFrame:
	xor	eax, eax
$LN785@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1056 :         pRef[2] = VRPLAN(ref);

	mov	DWORD PTR _pRef$[ebp+8], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN790@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN790@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN791@GetFrame
$LN790@GetFrame:
	xor	eax, eax
$LN791@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1057 :         nRefPitches[0] = YPITCH(ref);

	mov	DWORD PTR _nRefPitches$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN796@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN796@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN797@GetFrame
$LN796@GetFrame:
	xor	eax, eax
$LN797@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1058 :         nRefPitches[1] = UPITCH(ref);

	mov	DWORD PTR _nRefPitches$[ebp+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN802@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN802@GetFrame
	mov	ecx, DWORD PTR _ref$40[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN803@GetFrame
$LN802@GetFrame:
	xor	eax, eax
$LN803@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1059 :         nRefPitches[2] = VPITCH(ref);

	mov	DWORD PTR _nRefPitches$[ebp+8], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN808@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN808@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN809@GetFrame
$LN808@GetFrame:
	xor	eax, eax
$LN809@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1061 :         pSrc[0] = YRPLAN(src);

	mov	DWORD PTR _pSrc$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN814@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN814@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN815@GetFrame
$LN814@GetFrame:
	xor	eax, eax
$LN815@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1062 :         pSrc[1] = URPLAN(src);

	mov	DWORD PTR _pSrc$[ebp+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN820@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN820@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN821@GetFrame
$LN820@GetFrame:
	xor	eax, eax
$LN821@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1063 :         pSrc[2] = VRPLAN(src);

	mov	DWORD PTR _pSrc$[ebp+8], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN826@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN826@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN827@GetFrame
$LN826@GetFrame:
	xor	eax, eax
$LN827@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1064 :         nSrcPitches[0] = YPITCH(src);

	mov	DWORD PTR _nSrcPitches$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN832@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN832@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN833@GetFrame
$LN832@GetFrame:
	xor	eax, eax
$LN833@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1065 :         nSrcPitches[1] = UPITCH(src);

	mov	DWORD PTR _nSrcPitches$[ebp+4], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN838@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN838@GetFrame
	mov	ecx, DWORD PTR _src$36[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	jmp	SHORT $LN839@GetFrame
$LN838@GetFrame:
	xor	eax, eax
$LN839@GetFrame:
	mov	esi, DWORD PTR _nWidthUV$1$[ebp]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1069 :         for (int p = 0; p < 3; p++)

	xor	ebx, ebx
	mov	DWORD PTR _nSrcPitches$[ebp+8], eax
	npad	4
$LL50@GetFrame:

; 1070 :         {
; 1071 :           if (needProcessPlanes[p]) {

	cmp	BYTE PTR _needProcessPlanes$[ebp+ebx], 0
	je	$LN48@GetFrame

; 1072 :             if (pixelsize == 1) {

	mov	eax, DWORD PTR [edi+136]
	cmp	eax, 1
	jne	SHORT $LN119@GetFrame

; 1073 :               Blend<uint8_t>(pDst[p], pSrc[p], pRef[p],

	test	ebx, ebx
	jne	SHORT $LN211@GetFrame
	mov	eax, DWORD PTR [edi+92]
	mov	ecx, DWORD PTR [edi+96]
	jmp	SHORT $LN214@GetFrame
$LN211@GetFrame:
	mov	ecx, DWORD PTR _nHeightUV$1$[ebp]
	mov	eax, esi
$LN214@GetFrame:
	mov	edx, DWORD PTR _pSrc$[ebp+ebx*4]
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR _nRefPitches$[ebp+ebx*4]
	push	DWORD PTR _nSrcPitches$[ebp+ebx*4]
	push	DWORD PTR _nDstPitches$[ebp+ebx*4]
	push	eax
	push	ecx
	push	DWORD PTR _pRef$[ebp+ebx*4]
	mov	ecx, DWORD PTR _pDst$[ebp+ebx*4]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>
	jmp	SHORT $LN1059@GetFrame
$LN119@GetFrame:

; 1074 :                 p == 0 ? nHeight : nHeightUV,
; 1075 :                 p == 0 ? nWidth : nWidthUV,
; 1076 :                 nDstPitches[p], nSrcPitches[p], nRefPitches[p], time256 /*t256_prov_cst*/, isse_flag);
; 1077 :             }
; 1078 :             else if (pixelsize == 2) {

	cmp	eax, 2
	jne	SHORT $LN48@GetFrame

; 1079 :               Blend<uint16_t>(pDst[p], pSrc[p], pRef[p],

	test	ebx, ebx
	jne	SHORT $LN215@GetFrame
	mov	eax, DWORD PTR [edi+92]
	mov	ecx, DWORD PTR [edi+96]
	jmp	SHORT $LN218@GetFrame
$LN215@GetFrame:
	mov	ecx, DWORD PTR _nHeightUV$1$[ebp]
	mov	eax, esi
$LN218@GetFrame:
	mov	edx, DWORD PTR _pSrc$[ebp+ebx*4]
	push	ecx
	push	DWORD PTR _time256$1$[ebp]
	push	DWORD PTR _nRefPitches$[ebp+ebx*4]
	push	DWORD PTR _nSrcPitches$[ebp+ebx*4]
	push	DWORD PTR _nDstPitches$[ebp+ebx*4]
	push	eax
	push	ecx
	push	DWORD PTR _pRef$[ebp+ebx*4]
	mov	ecx, DWORD PTR _pDst$[ebp+ebx*4]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
$LN1059@GetFrame:
	add	esp, 32					; 00000020H
$LN48@GetFrame:

; 1069 :         for (int p = 0; p < 3; p++)

	inc	ebx
	cmp	ebx, 3
	jl	$LL50@GetFrame
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN49@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	test	esi, esi
	je	SHORT $LN842@GetFrame
	cmp	DWORD PTR [esi], 256			; 00000100H
	jbe	SHORT $LN842@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN842@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	test	esi, esi
	je	SHORT $LN846@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN846@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _ref$40[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN846@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	test	esi, esi
	je	SHORT $LN851@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN851@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$36[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN851@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	test	esi, esi
	je	SHORT $LN856@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN856@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN856@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	test	esi, esi
	je	SHORT $LN861@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN861@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN861@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	test	esi, esi
	je	SHORT $LN866@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN866@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN866@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	test	esi, esi
	je	SHORT $LN871@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN871@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN871@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 26		; 0000001aH
	test	esi, esi
	je	SHORT $LN876@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN876@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN876@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1089 :       return dst;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1097 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	lea	esp, DWORD PTR [ebp+104]
	pop	ebp
	ret	16					; 00000010H
$LN114@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	edx, edx
	je	SHORT $LN881@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN881@GetFrame
	lea	eax, DWORD PTR _src$36[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN881@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	test	edx, edx
	je	SHORT $LN885@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN885@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$36[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN885@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	test	edx, edx
	je	SHORT $LN890@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN890@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN890@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	test	edx, edx
	je	SHORT $LN895@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN895@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN895@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	test	edx, edx
	je	SHORT $LN900@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN900@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN900@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	test	edx, edx
	je	SHORT $LN905@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN905@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN905@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 32		; 00000020H
$LN1036@GetFrame:
	test	edx, edx
	je	SHORT $LN910@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN910@GetFrame
	mov	edx, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN910@GetFrame:
; File c:\github\mvtools\sources\mvblockfps.cpp

; 1097 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	lea	esp, DWORD PTR [ebp+104]
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _dst$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR $T38[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$12:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR $T37[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$14:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR _mvF$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	lea	ecx, DWORD PTR _mvB$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7:
	lea	ecx, DWORD PTR _ref$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$8:
	lea	ecx, DWORD PTR $T39[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$15:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$18:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$19:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$20:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9:
	lea	ecx, DWORD PTR _src$36[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10:
	lea	ecx, DWORD PTR _ref$40[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$21:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$25:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$27:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$28:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$29:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$30:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$31:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$32:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$33:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVBlockFps@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVBlockFps::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ??$AlignNumber@H@@YAHHH@Z
_TEXT	SEGMENT
??$AlignNumber@H@@YAHHH@Z PROC				; AlignNumber<int>, COMDAT
; _n$ = ecx
; _align$dead$ = edx

; 137  :   assert(IS_POWER2(align));
; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [ecx+15]
	and	eax, -16				; fffffff0H

; 139  : }

	ret	0
??$AlignNumber@H@@YAHHH@Z ENDP				; AlignNumber<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ??$ResultBlock@E@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z
_TEXT	SEGMENT
tv1914 = -36						; size = 4
tv1901 = -36						; size = 4
tv1879 = -36						; size = 4
tv1899 = -32						; size = 4
tv1892 = -28						; size = 4
tv1890 = -24						; size = 4
tv1925 = -20						; size = 4
tv1908 = -16						; size = 4
tv1906 = -12						; size = 4
tv1913 = -8						; size = 4
tv1918 = -4						; size = 4
_pDst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pMCB8$ = 16						; size = 4
_MCB_pitch$ = 20					; size = 4
_pMCF8$ = 24						; size = 4
_MCF_pitch$ = 28					; size = 4
_maskB$1$ = 32						; size = 4
_nBlkSizeY$1$ = 32					; size = 4
_pRef8$ = 32						; size = 4
tv1924 = 36						; size = 4
_ref_pitch$ = 36					; size = 4
_maskF$2$ = 40						; size = 4
tv1921 = 40						; size = 4
_pSrc8$ = 40						; size = 4
tv1912 = 44						; size = 4
_src_pitch$ = 44					; size = 4
tv1907 = 48						; size = 4
tv1897 = 48						; size = 4
tv1893 = 48						; size = 4
_nBlkSizeY$3$ = 48					; size = 4
_maskB$ = 48						; size = 4
_c$1$ = 52						; size = 1
tv1910 = 52						; size = 4
tv1909 = 52						; size = 4
tv1831 = 52						; size = 4
_mask_pitch$ = 52					; size = 4
_maskF$1$ = 56						; size = 4
tv1930 = 56						; size = 4
tv1917 = 56						; size = 4
_nBlkSizeY$2$ = 56					; size = 4
_maskF$ = 56						; size = 4
tv1932 = 60						; size = 4
tv1898 = 60						; size = 4
tv1891 = 60						; size = 4
tv1846 = 60						; size = 4
_pOcc$ = 60						; size = 4
_nBlkSizeX$ = 64					; size = 4
_b$1$ = 68						; size = 1
tv1920 = 68						; size = 4
tv1919 = 68						; size = 4
tv1916 = 68						; size = 4
tv1894 = 68						; size = 4
tv1828 = 68						; size = 4
_nBlkSizeY$6$ = 68					; size = 4
_nBlkSizeY$ = 68					; size = 4
_time256$ = 72						; size = 4
tv1915 = 76						; size = 4
tv1788 = 76						; size = 4
_nBlkSizeY$5$ = 76					; size = 4
_mode$ = 76						; size = 4
_bits_per_pixel$dead$ = 80				; size = 4
??$ResultBlock@E@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z PROC ; MVBlockFps::ResultBlock<unsigned char>, COMDAT
; _this$dead$ = ecx

; 347  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 348  :   const pixel_t *pMCB = reinterpret_cast<const pixel_t *>(pMCB8);
; 349  :   const pixel_t *pMCF = reinterpret_cast<const pixel_t *>(pMCF8);
; 350  :   const pixel_t *pRef = reinterpret_cast<const pixel_t *>(pRef8);
; 351  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 352  :   dst_pitch /= sizeof(pixel_t);
; 353  :   src_pitch /= sizeof(pixel_t);
; 354  :   ref_pitch /= sizeof(pixel_t);
; 355  :   MCB_pitch /= sizeof(pixel_t);
; 356  :   MCF_pitch /= sizeof(pixel_t);
; 357  : 
; 358  :   if (mode == 0)

	mov	ecx, DWORD PTR _mode$[esp-4]
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR _pMCB8$[esp+32]
	push	ebx
	push	ebp
	push	esi
	push	edi
	test	ecx, ecx
	jne	$LN38@ResultBloc

; 359  :   {
; 360  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	edx, DWORD PTR _nBlkSizeY$[esp+48]
	mov	DWORD PTR _nBlkSizeY$1$[esp+48], edx
	test	edx, edx
	jle	$LN21@ResultBloc
	mov	ebx, DWORD PTR _nBlkSizeX$[esp+48]
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ecx, DWORD PTR _pMCF8$[esp+48]
$LL4@ResultBloc:

; 361  :     {
; 362  :       for (int w = 0; w < nBlkSizeX; w++)

	test	ebx, ebx
	jle	SHORT $LN6@ResultBloc
	sub	ecx, eax
	mov	ebp, 256				; 00000100H
	sub	ebp, DWORD PTR _time256$[esp+48]
	mov	esi, eax
	sub	edi, eax
	mov	DWORD PTR tv1921[esp+48], ecx
	mov	DWORD PTR tv1916[esp+48], edi
	mov	edi, ecx
	mov	eax, DWORD PTR tv1916[esp+48]
$LL7@ResultBloc:

; 363  :       {
; 364  :         int mca = (pMCB[w] * time256 + pMCF[w] * (256 - time256)) >> 8; // MC fetched average

	movzx	edx, BYTE PTR [esi+edi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	imul	ecx, DWORD PTR _time256$[esp+48]
	imul	edx, ebp
	add	edx, ecx
	sar	edx, 8

; 365  :         pDst[w] = mca;

	mov	BYTE PTR [esi+eax-1], dl
	sub	ebx, 1
	jne	SHORT $LL7@ResultBloc
	mov	eax, DWORD PTR _pMCB8$[esp+48]
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ecx, DWORD PTR _pMCF8$[esp+48]
	mov	edx, DWORD PTR _nBlkSizeY$1$[esp+48]
	mov	ebx, DWORD PTR _nBlkSizeX$[esp+48]
$LN6@ResultBloc:

; 366  :       }
; 367  :       pDst += dst_pitch;

	add	edi, DWORD PTR _dst_pitch$[esp+48]

; 368  :       pMCB += MCB_pitch;

	add	eax, DWORD PTR _MCB_pitch$[esp+48]

; 369  :       pMCF += MCF_pitch;

	add	ecx, DWORD PTR _MCF_pitch$[esp+48]
	sub	edx, 1
	mov	DWORD PTR _pDst8$[esp+48], edi
	mov	DWORD PTR _pMCB8$[esp+48], eax
	mov	DWORD PTR _pMCF8$[esp+48], ecx
	mov	DWORD PTR _nBlkSizeY$1$[esp+48], edx
	jne	SHORT $LL4@ResultBloc
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 460  :     }
; 461  :   }
; 462  : }

	add	esp, 36					; 00000024H
	ret	76					; 0000004cH
$LN38@ResultBloc:

; 370  :     }
; 371  :   }
; 372  :   else if (mode == 1) // default, best working mode

	cmp	ecx, 1
	jne	$LN40@ResultBloc

; 373  :   {
; 374  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ebp, DWORD PTR _nBlkSizeY$[esp+48]
	mov	DWORD PTR _nBlkSizeY$2$[esp+48], ebp
	test	ebp, ebp
	jle	$LN21@ResultBloc
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ecx, DWORD PTR _pMCF8$[esp+48]
	mov	edx, DWORD PTR _pRef8$[esp+48]
	mov	ebx, DWORD PTR _pSrc8$[esp+48]
	mov	esi, DWORD PTR _nBlkSizeX$[esp+48]
$LL10@ResultBloc:

; 376  :       for (int w = 0; w < nBlkSizeX; w++)

	test	esi, esi
	jle	$LN12@ResultBloc
	sub	ecx, eax
	sub	ebx, eax
	mov	DWORD PTR tv1920[esp+48], ecx
	mov	ebp, 256				; 00000100H
	sub	ebp, DWORD PTR _time256$[esp+48]
	mov	ecx, edx
	sub	ecx, eax
	mov	DWORD PTR tv1910[esp+48], ebx
	sub	edi, eax
	mov	DWORD PTR tv1907[esp+48], ecx
	mov	esi, eax
	mov	DWORD PTR tv1915[esp+48], edi
	mov	eax, DWORD PTR _nBlkSizeX$[esp+48]
	mov	edi, DWORD PTR tv1920[esp+48]
	mov	DWORD PTR tv1932[esp+48], eax
	mov	eax, ebx
	npad	4
$LL107@ResultBloc:

; 377  :       {
; 378  :         int mca = (pMCB[w] * time256 + pMCF[w] * (256 - time256)) >> 8; // MC fetched average

	movzx	edx, BYTE PTR [esi+edi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ecx, BYTE PTR [esi-1]
	imul	ecx, DWORD PTR _time256$[esp+48]

; 379  :         int sta = MEDIAN<pixel_t>(pRef[w], pSrc[w], mca); // static median

	mov	bh, BYTE PTR [eax+esi-1]
	imul	edx, ebp
	add	edx, ecx
	mov	ecx, DWORD PTR tv1907[esp+48]
	sar	edx, 8
	mov	DWORD PTR tv1828[esp+48], edx
	mov	bl, BYTE PTR [ecx+esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bh, bl
	movzx	ecx, bh
	movzx	edx, bl
	cmovb	edx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	bl, bh

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR tv1831[esp+48], edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	movzx	ecx, bh
	movzx	edx, bl
	cmovb	edx, ecx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, DWORD PTR tv1828[esp+48]
	cmp	BYTE PTR tv1828[esp+48], dl
	movzx	ecx, cl
	movzx	ebx, dl
	cmovb	ebx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR tv1831[esp+48]
	cmp	BYTE PTR tv1831[esp+48], bl
	movzx	edx, cl
	movzx	ecx, bl
	cmovb	edx, ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 376  :       for (int w = 0; w < nBlkSizeX; w++)

	sub	DWORD PTR tv1932[esp+48], 1

; 380  :         pDst[w] = sta;

	mov	ecx, DWORD PTR tv1915[esp+48]
	mov	BYTE PTR [esi+ecx-1], dl
	jne	SHORT $LL107@ResultBloc
	mov	eax, DWORD PTR _pMCB8$[esp+48]
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ecx, DWORD PTR _pMCF8$[esp+48]
	mov	edx, DWORD PTR _pRef8$[esp+48]
	mov	ebx, DWORD PTR _pSrc8$[esp+48]
	mov	ebp, DWORD PTR _nBlkSizeY$2$[esp+48]
	mov	esi, DWORD PTR _nBlkSizeX$[esp+48]
$LN12@ResultBloc:

; 381  : 
; 382  :       }
; 383  :       pDst += dst_pitch;

	add	edi, DWORD PTR _dst_pitch$[esp+48]

; 384  :       pMCB += MCB_pitch;

	add	eax, DWORD PTR _MCB_pitch$[esp+48]

; 385  :       pMCF += MCF_pitch;

	add	ecx, DWORD PTR _MCF_pitch$[esp+48]

; 386  :       pRef += ref_pitch;

	add	edx, DWORD PTR _ref_pitch$[esp+48]

; 387  :       pSrc += src_pitch;

	add	ebx, DWORD PTR _src_pitch$[esp+48]
	sub	ebp, 1
	mov	DWORD PTR _pDst8$[esp+48], edi
	mov	DWORD PTR _pMCB8$[esp+48], eax
	mov	DWORD PTR _pMCF8$[esp+48], ecx
	mov	DWORD PTR _pRef8$[esp+48], edx
	mov	DWORD PTR _pSrc8$[esp+48], ebx
	mov	DWORD PTR _nBlkSizeY$2$[esp+48], ebp
	jne	$LL10@ResultBloc
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 460  :     }
; 461  :   }
; 462  : }

	add	esp, 36					; 00000024H
	ret	76					; 0000004cH
$LN40@ResultBloc:

; 388  :     }
; 389  :   }
; 390  :   else if (mode == 2) // default, best working mode

	cmp	ecx, 2
	jne	$LN42@ResultBloc

; 391  :   {
; 392  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ebp, DWORD PTR _nBlkSizeY$[esp+48]
	mov	DWORD PTR _nBlkSizeY$3$[esp+48], ebp
	test	ebp, ebp
	jle	$LN21@ResultBloc
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ecx, DWORD PTR _pMCF8$[esp+48]
	mov	edx, DWORD PTR _pRef8$[esp+48]
	mov	ebx, DWORD PTR _pSrc8$[esp+48]
	mov	esi, DWORD PTR _nBlkSizeX$[esp+48]
	npad	5
$LL16@ResultBloc:

; 394  :       for (int w = 0; w < nBlkSizeX; w++)

	test	esi, esi
	jle	$LN18@ResultBloc
	sub	ecx, eax
	sub	ebx, eax
	mov	DWORD PTR tv1919[esp+48], ecx
	mov	ebp, 256				; 00000100H
	sub	ebp, DWORD PTR _time256$[esp+48]
	mov	ecx, edx
	sub	ecx, eax
	mov	DWORD PTR tv1909[esp+48], ebx
	sub	edi, eax
	mov	DWORD PTR tv1788[esp+48], ecx
	mov	esi, eax
	mov	DWORD PTR tv1914[esp+52], edi
	mov	eax, DWORD PTR _nBlkSizeX$[esp+48]
	mov	edi, DWORD PTR tv1919[esp+48]
	mov	DWORD PTR tv1930[esp+48], eax
	mov	eax, ebx
	npad	5
$LL109@ResultBloc:

; 395  :       {
; 396  :         int avg = (pRef[w] * time256 + pSrc[w] * (256 - time256)) >> 8; // simple temporal non-MC average
; 397  :         int dyn = MEDIAN<pixel_t>(avg, pMCB[w], pMCF[w]); // dynamic median

	mov	cl, BYTE PTR [esi+edi]
	lea	esi, DWORD PTR [esi+1]
	movzx	ebx, BYTE PTR [esi+eax-1]
	mov	dl, BYTE PTR [esi-1]
	mov	BYTE PTR _c$1$[esp+48], cl
	mov	ecx, DWORD PTR tv1788[esp+48]
	imul	ebx, ebp
	mov	BYTE PTR _b$1$[esp+48], dl
	movzx	ecx, BYTE PTR [esi+ecx-1]
	imul	ecx, DWORD PTR _time256$[esp+48]
	add	ebx, ecx
	sar	ebx, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	dl, bl
	movzx	ecx, bl
	mov	DWORD PTR tv1846[esp+48], ecx
	movzx	ecx, dl
	mov	edx, DWORD PTR tv1846[esp+48]
	cmovb	edx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	bl, BYTE PTR _b$1$[esp+48]
	movzx	ecx, BYTE PTR _b$1$[esp+48]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR tv1846[esp+48], edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	movzx	edx, bl
	cmovb	edx, ecx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	ecx, BYTE PTR _c$1$[esp+48]
	cmp	BYTE PTR _c$1$[esp+48], dl
	movzx	ebx, dl
	cmovb	ebx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR tv1846[esp+48]
	cmp	BYTE PTR tv1846[esp+48], bl
	movzx	edx, cl
	movzx	ecx, bl
	cmovb	edx, ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 394  :       for (int w = 0; w < nBlkSizeX; w++)

	sub	DWORD PTR tv1930[esp+48], 1

; 398  :         pDst[w] = dyn;

	mov	ecx, DWORD PTR tv1914[esp+52]
	mov	BYTE PTR [esi+ecx-1], dl
	jne	$LL109@ResultBloc
	mov	eax, DWORD PTR _pMCB8$[esp+48]
	mov	edi, DWORD PTR _pDst8$[esp+48]
	mov	ecx, DWORD PTR _pMCF8$[esp+48]
	mov	edx, DWORD PTR _pRef8$[esp+48]
	mov	ebx, DWORD PTR _pSrc8$[esp+48]
	mov	ebp, DWORD PTR _nBlkSizeY$3$[esp+48]
	mov	esi, DWORD PTR _nBlkSizeX$[esp+48]
$LN18@ResultBloc:

; 399  :       }
; 400  :       pDst += dst_pitch;

	add	edi, DWORD PTR _dst_pitch$[esp+48]

; 401  :       pMCB += MCB_pitch;

	add	eax, DWORD PTR _MCB_pitch$[esp+48]

; 402  :       pMCF += MCF_pitch;

	add	ecx, DWORD PTR _MCF_pitch$[esp+48]

; 403  :       pRef += ref_pitch;

	add	edx, DWORD PTR _ref_pitch$[esp+48]

; 404  :       pSrc += src_pitch;

	add	ebx, DWORD PTR _src_pitch$[esp+48]
	sub	ebp, 1
	mov	DWORD PTR _pDst8$[esp+48], edi
	mov	DWORD PTR _pMCB8$[esp+48], eax
	mov	DWORD PTR _pMCF8$[esp+48], ecx
	mov	DWORD PTR _pRef8$[esp+48], edx
	mov	DWORD PTR _pSrc8$[esp+48], ebx
	mov	DWORD PTR _nBlkSizeY$3$[esp+48], ebp
	jne	$LL16@ResultBloc
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 460  :     }
; 461  :   }
; 462  : }

	add	esp, 36					; 00000024H
	ret	76					; 0000004cH
$LN42@ResultBloc:

; 405  :     }
; 406  :   }
; 407  :   else if (mode == 3 || mode == 6)

	cmp	ecx, 3
	je	$LN46@ResultBloc
	cmp	ecx, 6
	je	$LN46@ResultBloc

; 423  :     }
; 424  :   }
; 425  :   else if (mode == 4 || mode == 7)

	cmp	ecx, 4
	je	SHORT $LN49@ResultBloc
	cmp	ecx, 7
	je	SHORT $LN49@ResultBloc

; 444  :       pOcc += mask_pitch;
; 445  :     }
; 446  :   }
; 447  :   else if (mode == 5 || mode == 8) // debug modes show mask

	cmp	ecx, 5
	je	SHORT $LN51@ResultBloc
	cmp	ecx, 8
	jne	$LN21@ResultBloc
$LN51@ResultBloc:

; 448  :   {
; 449  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ebx, DWORD PTR _nBlkSizeY$[esp+48]
	test	ebx, ebx
	jle	$LN21@ResultBloc
	mov	ebp, DWORD PTR _nBlkSizeX$[esp+48]
	mov	edi, DWORD PTR _pOcc$[esp+48]
	mov	eax, DWORD PTR _pDst8$[esp+48]
$LL34@ResultBloc:

; 450  :     {
; 451  :       for (int w = 0; w < nBlkSizeX; w++)

	test	ebp, ebp
	jle	SHORT $LN36@ResultBloc
	mov	esi, edi
	mov	ecx, eax
	sub	esi, eax
	mov	edx, ebp
	npad	2
$LL111@ResultBloc:

; 452  :       {
; 453  :         if (sizeof(pixel_t) == 1)
; 454  :           pDst[w] = pOcc[w];

	mov	al, BYTE PTR [esi+ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [ecx-1], al
	sub	edx, 1
	jne	SHORT $LL111@ResultBloc
	mov	eax, DWORD PTR _pDst8$[esp+48]
$LN36@ResultBloc:

; 455  :         else
; 456  :           pDst[w] = (pixel_t)(pOcc[w]) << (bits_per_pixel - 8);
; 457  :       }
; 458  :       pDst += dst_pitch;

	add	eax, DWORD PTR _dst_pitch$[esp+48]

; 459  :       pOcc += mask_pitch;

	add	edi, DWORD PTR _mask_pitch$[esp+48]
	mov	DWORD PTR _pDst8$[esp+48], eax
	sub	ebx, 1
	jne	SHORT $LL34@ResultBloc
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 460  :     }
; 461  :   }
; 462  : }

	add	esp, 36					; 00000024H
	ret	76					; 0000004cH
$LN49@ResultBloc:

; 426  :   {
; 427  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	edi, DWORD PTR _nBlkSizeY$[esp+48]
	mov	DWORD PTR _nBlkSizeY$5$[esp+48], edi
	test	edi, edi
	jle	$LN21@ResultBloc
	mov	ecx, DWORD PTR _maskB$[esp+48]
	mov	esi, DWORD PTR _maskF$[esp+48]
	sub	ecx, esi
	mov	edx, DWORD PTR _pMCF8$[esp+48]
	mov	ebx, DWORD PTR _pRef8$[esp+48]
	mov	ebp, DWORD PTR _pSrc8$[esp+48]
	mov	DWORD PTR tv1893[esp+48], ecx
	mov	ecx, DWORD PTR _pOcc$[esp+48]
	sub	ecx, esi
	mov	DWORD PTR _maskF$1$[esp+48], esi
	mov	DWORD PTR tv1891[esp+48], ecx
	mov	ecx, DWORD PTR _pDst8$[esp+48]
	npad	7
$LL28@ResultBloc:

; 428  :     {
; 429  :       for (int w = 0; w < nBlkSizeX; w++)

	cmp	DWORD PTR _nBlkSizeX$[esp+48], 0
	jle	$LN30@ResultBloc
	mov	ecx, 256				; 00000100H
	mov	DWORD PTR tv1901[esp+52], eax
	sub	ecx, DWORD PTR _time256$[esp+48]
	sub	edx, eax
	mov	DWORD PTR tv1925[esp+52], ecx
	mov	ecx, esi
	sub	ecx, eax
	mov	DWORD PTR tv1918[esp+52], edx
	mov	DWORD PTR tv1899[esp+52], ecx
	mov	ecx, DWORD PTR tv1893[esp+48]
	sub	ecx, eax
	add	ecx, esi
	mov	DWORD PTR tv1892[esp+52], ecx
	mov	ecx, ebp
	sub	ecx, eax
	mov	DWORD PTR tv1908[esp+52], ecx
	mov	ecx, ebx
	sub	ecx, eax
	mov	DWORD PTR tv1906[esp+52], ecx
	mov	ecx, DWORD PTR tv1891[esp+48]
	sub	ecx, eax
	add	ecx, esi
	mov	DWORD PTR tv1890[esp+52], ecx
	mov	ecx, DWORD PTR _pDst8$[esp+48]
	sub	ecx, eax
	mov	eax, DWORD PTR _nBlkSizeX$[esp+48]
	mov	DWORD PTR tv1894[esp+48], eax
	mov	eax, DWORD PTR tv1901[esp+52]
	mov	DWORD PTR tv1913[esp+52], ecx
	npad	8
$LL31@ResultBloc:

; 430  :       {
; 431  :         int f = (maskF[w] * pMCB[w] + (255 - maskF[w])*pMCF[w] + 255) >> 8;

	mov	ecx, DWORD PTR tv1899[esp+52]
	lea	eax, DWORD PTR [eax+1]
	movzx	edi, BYTE PTR [eax+edx-1]

; 432  :         int b = (maskB[w] * pMCF[w] + (255 - maskB[w])*pMCB[w] + 255) >> 8;

	mov	edx, 255				; 000000ffH
	movzx	ebx, BYTE PTR [eax-1]
	movzx	ebp, BYTE PTR [ecx+eax-1]
	mov	ecx, DWORD PTR tv1892[esp+52]
	movzx	esi, BYTE PTR [ecx+eax-1]

; 433  :         int avg = (pRef[w] * time256 + pSrc[w] * (256 - time256) + 255) >> 8; // simple temporal non-MC average
; 434  :         int m = (b*time256 + f*(256 - time256)) >> 8;
; 435  :         pDst[w] = (avg * pOcc[w] + m * (255 - pOcc[w]) + 255) >> 8;

	mov	ecx, DWORD PTR tv1890[esp+52]
	sub	edx, esi
	imul	edx, ebx
	imul	esi, edi
	movzx	ecx, BYTE PTR [ecx+eax-1]
	mov	DWORD PTR tv1879[esp+52], ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, ebp
	add	edx, 255				; 000000ffH
	imul	ecx, edi
	add	esi, edx
	imul	ebp, ebx
	sar	esi, 8
	imul	esi, DWORD PTR _time256$[esp+48]
	add	ecx, 255				; 000000ffH
	add	ecx, ebp
	sar	ecx, 8
	imul	ecx, DWORD PTR tv1925[esp+52]
	add	esi, ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, DWORD PTR tv1879[esp+52]
	sar	esi, 8
	imul	esi, ecx
	mov	ecx, DWORD PTR tv1908[esp+52]
	movzx	edx, BYTE PTR [eax+ecx-1]
	add	esi, 255				; 000000ffH
	mov	ecx, DWORD PTR tv1906[esp+52]
	imul	edx, DWORD PTR tv1925[esp+52]
	movzx	ecx, BYTE PTR [eax+ecx-1]
	imul	ecx, DWORD PTR _time256$[esp+48]
	add	edx, 255				; 000000ffH
	add	ecx, edx
	mov	edx, DWORD PTR tv1913[esp+52]
	sar	ecx, 8
	imul	ecx, DWORD PTR tv1879[esp+52]
	add	ecx, esi
	sar	ecx, 8
	sub	DWORD PTR tv1894[esp+48], 1
	mov	BYTE PTR [eax+edx-1], cl
	mov	edx, DWORD PTR tv1918[esp+52]
	jne	$LL31@ResultBloc
	mov	eax, DWORD PTR _pMCB8$[esp+48]
	mov	ecx, DWORD PTR _pDst8$[esp+48]
	mov	edx, DWORD PTR _pMCF8$[esp+48]
	mov	ebx, DWORD PTR _pRef8$[esp+48]
	mov	ebp, DWORD PTR _pSrc8$[esp+48]
	mov	esi, DWORD PTR _maskF$1$[esp+48]
	mov	edi, DWORD PTR _nBlkSizeY$5$[esp+48]
$LN30@ResultBloc:

; 436  :       }
; 437  :       pDst += dst_pitch;

	add	ecx, DWORD PTR _dst_pitch$[esp+48]

; 438  :       pMCB += MCB_pitch;

	add	eax, DWORD PTR _MCB_pitch$[esp+48]

; 439  :       pMCF += MCF_pitch;

	add	edx, DWORD PTR _MCF_pitch$[esp+48]

; 440  :       pRef += ref_pitch;

	add	ebx, DWORD PTR _ref_pitch$[esp+48]

; 441  :       pSrc += src_pitch;

	add	ebp, DWORD PTR _src_pitch$[esp+48]

; 442  :       maskB += mask_pitch;
; 443  :       maskF += mask_pitch;

	add	esi, DWORD PTR _mask_pitch$[esp+48]
	sub	edi, 1
	mov	DWORD PTR _pDst8$[esp+48], ecx
	mov	DWORD PTR _pMCB8$[esp+48], eax
	mov	DWORD PTR _pMCF8$[esp+48], edx
	mov	DWORD PTR _pRef8$[esp+48], ebx
	mov	DWORD PTR _pSrc8$[esp+48], ebp
	mov	DWORD PTR _maskF$1$[esp+48], esi
	mov	DWORD PTR _nBlkSizeY$5$[esp+48], edi
	jne	$LL28@ResultBloc
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 460  :     }
; 461  :   }
; 462  : }

	add	esp, 36					; 00000024H
	ret	76					; 0000004cH
$LN46@ResultBloc:

; 408  :   {
; 409  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ebx, DWORD PTR _nBlkSizeY$[esp+48]
	mov	DWORD PTR _nBlkSizeY$6$[esp+48], ebx
	test	ebx, ebx
	jle	$LN21@ResultBloc
	mov	esi, DWORD PTR _maskF$[esp+48]
	mov	edi, DWORD PTR _maskB$[esp+48]
	mov	ebp, DWORD PTR _mask_pitch$[esp+48]
	mov	ecx, DWORD PTR _pDst8$[esp+48]
	mov	edx, DWORD PTR _pMCF8$[esp+48]
	mov	DWORD PTR _maskF$2$[esp+48], esi
	mov	DWORD PTR _maskB$1$[esp+48], edi
$LL22@ResultBloc:

; 410  :     {
; 411  :       for (int w = 0; w < nBlkSizeX; w++)

	cmp	DWORD PTR _nBlkSizeX$[esp+48], 0
	jle	$LN24@ResultBloc
	mov	ebx, 256				; 00000100H
	sub	edi, eax
	sub	ebx, DWORD PTR _time256$[esp+48]
	mov	ebp, eax
	mov	DWORD PTR tv1924[esp+48], ebx
	mov	ebx, esi
	sub	ebx, eax
	mov	DWORD PTR tv1897[esp+48], edi
	mov	esi, edx
	mov	DWORD PTR tv1898[esp+48], ebx
	sub	esi, eax
	sub	ecx, eax
	mov	eax, DWORD PTR _nBlkSizeX$[esp+48]
	mov	DWORD PTR tv1917[esp+48], esi
	mov	DWORD PTR tv1912[esp+48], ecx
	npad	3
$LL25@ResultBloc:

; 412  :       {
; 413  :         pDst[w] = (((maskB[w] * pMCF[w] + (255 - maskB[w])*pMCB[w] + 255) >> 8)*time256 +

	movzx	edx, BYTE PTR [ebx+ebp]
	lea	ebp, DWORD PTR [ebp+1]
	movzx	ebx, BYTE PTR [esi+ebp-1]
	mov	ecx, 255				; 000000ffH
	movzx	esi, BYTE PTR [ebp-1]
	sub	ecx, edx
	movzx	edi, BYTE PTR [edi+ebp-1]
	imul	ecx, ebx
	imul	edx, esi
	add	ecx, 255				; 000000ffH
	add	edx, ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, edi
	sar	edx, 8
	imul	edx, DWORD PTR tv1924[esp+48]
	imul	ecx, esi
	mov	esi, DWORD PTR tv1917[esp+48]
	imul	edi, ebx
	mov	ebx, DWORD PTR tv1898[esp+48]
	add	edi, 255				; 000000ffH
	add	ecx, edi
	mov	edi, DWORD PTR tv1897[esp+48]
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[esp+48]
	add	edx, ecx
	mov	ecx, DWORD PTR tv1912[esp+48]
	sar	edx, 8
	mov	BYTE PTR [ecx+ebp-1], dl
	sub	eax, 1
	jne	SHORT $LL25@ResultBloc
	mov	eax, DWORD PTR _pMCB8$[esp+48]
	mov	ecx, DWORD PTR _pDst8$[esp+48]
	mov	edx, DWORD PTR _pMCF8$[esp+48]
	mov	esi, DWORD PTR _maskF$2$[esp+48]
	mov	edi, DWORD PTR _maskB$1$[esp+48]
	mov	ebx, DWORD PTR _nBlkSizeY$6$[esp+48]
	mov	ebp, DWORD PTR _mask_pitch$[esp+48]
$LN24@ResultBloc:

; 414  :           ((maskF[w] * pMCB[w] + (255 - maskF[w])*pMCF[w] + 255) >> 8)*(256 - time256)) >> 8;
; 415  :       }
; 416  :       pDst += dst_pitch;

	add	ecx, DWORD PTR _dst_pitch$[esp+48]

; 417  :       pMCB += MCB_pitch;
; 418  :       pMCF += MCF_pitch;
; 419  : //			pRef += ref_pitch;
; 420  : //			pSrc += src_pitch;
; 421  :       maskB += mask_pitch;

	add	edi, ebp
	add	eax, DWORD PTR _MCB_pitch$[esp+48]

; 422  :       maskF += mask_pitch;

	add	esi, ebp
	add	edx, DWORD PTR _MCF_pitch$[esp+48]
	sub	ebx, 1
	mov	DWORD PTR _pDst8$[esp+48], ecx
	mov	DWORD PTR _pMCB8$[esp+48], eax
	mov	DWORD PTR _pMCF8$[esp+48], edx
	mov	DWORD PTR _maskB$1$[esp+48], edi
	mov	DWORD PTR _maskF$2$[esp+48], esi
	mov	DWORD PTR _nBlkSizeY$6$[esp+48], ebx
	jne	$LL22@ResultBloc
$LN21@ResultBloc:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 460  :     }
; 461  :   }
; 462  : }

	add	esp, 36					; 00000024H
	ret	76					; 0000004cH
??$ResultBlock@E@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ENDP ; MVBlockFps::ResultBlock<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ??$ResultBlock@G@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z
_TEXT	SEGMENT
_nBlkSizeY$6$ = -140					; size = 4
_nBlkSizeY$4$ = -140					; size = 4
tv5214 = -140						; size = 4
tv5213 = -140						; size = 4
tv5169 = -140						; size = 4
tv5168 = -140						; size = 4
tv5160 = -140						; size = 4
tv5155 = -140						; size = 4
tv5137 = -140						; size = 4
tv5102 = -140						; size = 4
_w$1$ = -136						; size = 4
tv5164 = -136						; size = 4
tv5157 = -136						; size = 4
tv5154 = -136						; size = 4
tv5136 = -136						; size = 4
tv5097 = -136						; size = 4
_pOcc$2$ = -132						; size = 4
_nBlkSizeY$3$ = -132					; size = 4
_nBlkSizeY$2$ = -132					; size = 4
tv5165 = -132						; size = 4
tv5159 = -132						; size = 4
tv5156 = -132						; size = 4
_maskB$2$ = -128					; size = 4
_maskB$1$ = -128					; size = 4
tv5201 = -128						; size = 4
tv5189 = -128						; size = 4
tv5181 = -128						; size = 4
tv5205 = -124						; size = 4
tv5204 = -124						; size = 4
tv5178 = -124						; size = 4
tv5133 = -124						; size = 4
tv5100 = -124						; size = 4
_nBlkSizeY$1$ = -124					; size = 4
_w$1$ = -120						; size = 4
_maskF$2$ = -120					; size = 4
tv5194 = -120						; size = 4
tv5184 = -120						; size = 4
tv5148 = -120						; size = 4
_w$1$ = -116						; size = 4
_maskF$1$ = -116					; size = 4
tv5200 = -116						; size = 4
tv5188 = -116						; size = 4
tv5150 = -116						; size = 4
tv5206 = -112						; size = 4
tv5203 = -112						; size = 4
tv5193 = -112						; size = 4
tv5170 = -112						; size = 4
tv5167 = -112						; size = 4
tv5162 = -112						; size = 4
tv5141 = -112						; size = 4
tv5123 = -112						; size = 4
tv5075 = -112						; size = 4
___isa_available$1$ = -108				; size = 4
_nBlkSizeY$5$ = -108					; size = 4
tv5199 = -108						; size = 4
tv5144 = -108						; size = 4
tv5127 = -108						; size = 4
tv5082 = -108						; size = 4
_c$1$ = -104						; size = 4
tv5190 = -104						; size = 4
tv5153 = -104						; size = 4
tv5145 = -104						; size = 4
tv5131 = -104						; size = 4
tv5195 = -100						; size = 4
tv5158 = -100						; size = 4
tv5140 = -100						; size = 4
tv5129 = -100						; size = 4
___isa_available$2$ = -96				; size = 4
tv5198 = -96						; size = 4
tv5182 = -96						; size = 4
tv5138 = -96						; size = 4
tv5180 = -92						; size = 4
tv5092 = -92						; size = 4
tv5079 = -92						; size = 4
tv5077 = -92						; size = 4
tv5185 = -88						; size = 4
tv5143 = -88						; size = 4
tv5094 = -88						; size = 4
tv5186 = -84						; size = 4
tv5152 = -84						; size = 4
tv5124 = -84						; size = 4
tv5191 = -80						; size = 4
tv5122 = -80						; size = 4
tv5111 = -80						; size = 4
tv5196 = -76						; size = 4
tv5125 = -76						; size = 4
tv5095 = -76						; size = 4
tv5146 = -72						; size = 4
tv5121 = -72						; size = 4
tv5112 = -72						; size = 4
tv5147 = -68						; size = 4
tv5128 = -68						; size = 4
tv5119 = -68						; size = 4
tv5197 = -64						; size = 4
tv5173 = -64						; size = 4
tv5114 = -64						; size = 4
tv5192 = -60						; size = 4
tv5151 = -60						; size = 4
tv5126 = -60						; size = 4
tv5187 = -56						; size = 4
tv5118 = -56						; size = 4
tv5115 = -56						; size = 4
tv5202 = -52						; size = 4
tv5183 = -52						; size = 4
tv5090 = -52						; size = 4
tv5139 = -48						; size = 4
tv5116 = -48						; size = 4
tv5142 = -44						; size = 4
tv5120 = -44						; size = 4
tv5113 = -40						; size = 4
tv5117 = -36						; size = 4
tv5219 = -32						; size = 16
tv5172 = -32						; size = 16
tv5174 = -16						; size = 16
_pDst8$ = 8						; size = 4
_dst_pitch$ = 12					; size = 4
_pMCB8$ = 16						; size = 4
_MCB_pitch$ = 20					; size = 4
_pMCF8$ = 24						; size = 4
_MCF_pitch$ = 28					; size = 4
_pRef8$ = 32						; size = 4
_ref_pitch$ = 36					; size = 4
_pSrc8$ = 40						; size = 4
_src_pitch$ = 44					; size = 4
_maskB$ = 48						; size = 4
_mask_pitch$ = 52					; size = 4
_maskF$ = 56						; size = 4
_pOcc$ = 60						; size = 4
_nBlkSizeX$ = 64					; size = 4
_nBlkSizeY$ = 68					; size = 4
_time256$ = 72						; size = 4
_mode$ = 76						; size = 4
_bits_per_pixel$ = 80					; size = 4
??$ResultBlock@G@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z PROC ; MVBlockFps::ResultBlock<unsigned short>, COMDAT
; _this$dead$ = ecx

; 346  : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H
	sub	esp, 148				; 00000094H

; 347  :   pixel_t *pDst = reinterpret_cast<pixel_t *>(pDst8);
; 348  :   const pixel_t *pMCB = reinterpret_cast<const pixel_t *>(pMCB8);
; 349  :   const pixel_t *pMCF = reinterpret_cast<const pixel_t *>(pMCF8);
; 350  :   const pixel_t *pRef = reinterpret_cast<const pixel_t *>(pRef8);
; 351  :   const pixel_t *pSrc = reinterpret_cast<const pixel_t *>(pSrc8);
; 352  :   dst_pitch /= sizeof(pixel_t);
; 353  :   src_pitch /= sizeof(pixel_t);
; 354  :   ref_pitch /= sizeof(pixel_t);
; 355  :   MCB_pitch /= sizeof(pixel_t);

	mov	edx, DWORD PTR _MCB_pitch$[ebp]
	shr	DWORD PTR _src_pitch$[ebp], 1
	shr	DWORD PTR _ref_pitch$[ebp], 1

; 356  :   MCF_pitch /= sizeof(pixel_t);
; 357  : 
; 358  :   if (mode == 0)

	mov	ecx, DWORD PTR _mode$[ebp]
	mov	eax, DWORD PTR _pDst8$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _MCF_pitch$[ebp]
	push	esi
	mov	esi, DWORD PTR _dst_pitch$[ebp]
	push	edi
	mov	edi, DWORD PTR _time256$[ebp]
	shr	esi, 1
	shr	edx, 1
	shr	ebx, 1
	movd	xmm0, edi
	pshufd	xmm7, xmm0, 0
	movaps	XMMWORD PTR tv5219[esp+160], xmm7
	test	ecx, ecx
	jne	$LN38@ResultBloc

; 359  :   {
; 360  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ecx, DWORD PTR _nBlkSizeY$[ebp]
	mov	DWORD PTR _nBlkSizeY$1$[esp+160], ecx
	test	ecx, ecx
	jle	$LN21@ResultBloc
	lea	ecx, DWORD PTR [esi+esi]
	mov	DWORD PTR tv5201[esp+160], ecx
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	DWORD PTR tv5195[esp+160], ecx
	lea	ecx, DWORD PTR [ebx+ebx]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	mov	DWORD PTR tv5190[esp+160], ecx
	mov	ecx, DWORD PTR ___isa_available
	mov	DWORD PTR ___isa_available$1$[esp+160], ecx
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	npad	3
$LL4@ResultBloc:

; 361  :     {
; 362  :       for (int w = 0; w < nBlkSizeX; w++)

	xor	esi, esi
	mov	DWORD PTR _w$1$[esp+160], esi
	test	ecx, ecx
	jle	$LN6@ResultBloc
	cmp	ecx, 8
	jb	$LN108@ResultBloc

; 365  :         pDst[w] = mca;

	cmp	DWORD PTR ___isa_available$1$[esp+160], 2
	jl	$LN108@ResultBloc
	lea	ecx, DWORD PTR [ecx*2-2]
	mov	DWORD PTR _w$1$[esp+160], esi
	lea	ebx, DWORD PTR [ecx+eax]
	mov	DWORD PTR tv5170[esp+160], ecx
	add	ecx, edx
	mov	DWORD PTR tv5168[esp+160], ebx
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN109@ResultBloc
	cmp	DWORD PTR tv5168[esp+160], edx
	jae	$LN174@ResultBloc
$LN109@ResultBloc:
	mov	ecx, DWORD PTR tv5170[esp+160]
	add	ecx, ebx
	cmp	eax, ecx
	ja	SHORT $LN110@ResultBloc
	cmp	DWORD PTR tv5168[esp+160], ebx
	jae	$LN174@ResultBloc
$LN110@ResultBloc:
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN175@ResultBloc
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN175@ResultBloc:
	mov	esi, DWORD PTR _nBlkSizeX$[ebp]

; 363  :       {
; 364  :         int mca = (pMCB[w] * time256 + pMCF[w] * (256 - time256)) >> 8; // MC fetched average

	movaps	xmm2, XMMWORD PTR __xmm@00000100000001000000010000000100
	sub	esi, ecx
	mov	DWORD PTR tv5148[esp+160], esi
	mov	ecx, 8
	mov	esi, ebx
	mov	DWORD PTR tv5162[esp+160], eax
	sub	esi, edx
	psubd	xmm2, xmm7
	mov	DWORD PTR tv5160[esp+160], esi
	mov	esi, eax
	sub	esi, edx
	movd	xmm3, ecx
	lea	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv5156[esp+160], esi
	mov	edx, ebx
	mov	ebx, esi
	sub	edx, eax
	mov	DWORD PTR tv5150[esp+160], edx
	mov	edx, eax
	mov	eax, DWORD PTR tv5160[esp+160]
$LL7@ResultBloc:

; 361  :     {
; 362  :       for (int w = 0; w < nBlkSizeX; w++)

	mov	esi, DWORD PTR tv5150[esp+160]
	lea	edx, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [ecx+16]
	movq	xmm0, QWORD PTR [esi+edx-16]

; 363  :       {
; 364  :         int mca = (pMCB[w] * time256 + pMCF[w] * (256 - time256)) >> 8; // MC fetched average

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ecx-24]
	pmovzxwd xmm0, xmm0
	pmulld	xmm0, xmm7
	pmulld	xmm1, xmm2
	paddd	xmm1, xmm0
	mov	esi, DWORD PTR _w$1$[esp+160]
	psrad	xmm1, xmm3
	add	esi, 8
	pshuflw	xmm0, xmm1, 216				; 000000d8H
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [edx-16], xmm0
	movq	xmm0, QWORD PTR [eax+ecx-16]
	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ecx-16]
	pmovzxwd xmm0, xmm0
	pmulld	xmm0, xmm7
	pmulld	xmm1, xmm2
	paddd	xmm1, xmm0
	mov	DWORD PTR _w$1$[esp+160], esi
	psrad	xmm1, xmm3
	pshuflw	xmm0, xmm1, 216				; 000000d8H
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [ebx+ecx-16], xmm0
	cmp	esi, DWORD PTR tv5148[esp+160]
	jl	$LL7@ResultBloc
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
$LN174@ResultBloc:
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
$LN108@ResultBloc:

; 361  :     {
; 362  :       for (int w = 0; w < nBlkSizeX; w++)

	cmp	esi, ecx
	jge	SHORT $LN6@ResultBloc
	mov	ecx, 256				; 00000100H
	lea	esi, DWORD PTR [edx+esi*2]
	sub	ecx, edi
	sub	eax, edx
	mov	DWORD PTR tv5206[esp+160], ecx
	mov	ecx, ebx
	mov	ebx, DWORD PTR _nBlkSizeX$[ebp]
	sub	ecx, edx
	sub	ebx, DWORD PTR _w$1$[esp+160]
	mov	DWORD PTR tv5155[esp+160], eax
	mov	eax, DWORD PTR tv5206[esp+160]
	mov	DWORD PTR tv5159[esp+160], ecx
$LL107@ResultBloc:

; 363  :       {
; 364  :         int mca = (pMCB[w] * time256 + pMCF[w] * (256 - time256)) >> 8; // MC fetched average

	movzx	edx, WORD PTR [ecx+esi]
	lea	esi, DWORD PTR [esi+2]
	movzx	ecx, WORD PTR [esi-2]
	imul	ecx, edi
	imul	edx, eax
	add	edx, ecx

; 365  :         pDst[w] = mca;

	mov	ecx, DWORD PTR tv5155[esp+160]
	sar	edx, 8
	mov	WORD PTR [ecx+esi-2], dx
	mov	ecx, DWORD PTR tv5159[esp+160]
	sub	ebx, 1
	jne	SHORT $LL107@ResultBloc
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
$LN6@ResultBloc:

; 366  :       }
; 367  :       pDst += dst_pitch;

	add	eax, DWORD PTR tv5201[esp+160]

; 368  :       pMCB += MCB_pitch;

	add	edx, DWORD PTR tv5195[esp+160]

; 369  :       pMCF += MCF_pitch;

	add	ebx, DWORD PTR tv5190[esp+160]
	sub	DWORD PTR _nBlkSizeY$1$[esp+160], 1
	mov	DWORD PTR _pDst8$[ebp], eax
	mov	DWORD PTR _pMCB8$[ebp], edx
	mov	DWORD PTR _pMCF8$[ebp], ebx
	jne	$LL4@ResultBloc

; 460  :     }
; 461  :   }
; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	76					; 0000004cH
$LN38@ResultBloc:

; 370  :     }
; 371  :   }
; 372  :   else if (mode == 1) // default, best working mode

	cmp	ecx, 1
	jne	$LN40@ResultBloc

; 373  :   {
; 374  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ecx, DWORD PTR _nBlkSizeY$[ebp]
	mov	DWORD PTR _nBlkSizeY$2$[esp+160], ecx
	test	ecx, ecx
	jle	$LN21@ResultBloc
	lea	ecx, DWORD PTR [esi+esi]
	mov	esi, DWORD PTR _pRef8$[ebp]
	mov	DWORD PTR tv5200[esp+160], ecx
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _pMCF8$[ebp]
	mov	DWORD PTR tv5194[esp+160], ecx
	lea	ecx, DWORD PTR [ebx+ebx]
	mov	ebx, DWORD PTR _pSrc8$[ebp]
	mov	DWORD PTR tv5189[esp+160], ecx
	mov	ecx, DWORD PTR _ref_pitch$[ebp]
	add	ecx, ecx
	mov	DWORD PTR tv5185[esp+160], ecx
	mov	ecx, DWORD PTR _src_pitch$[ebp]
	add	ecx, ecx
	mov	DWORD PTR tv5182[esp+160], ecx
	mov	ecx, DWORD PTR _pMCB8$[ebp]
	npad	8
$LL10@ResultBloc:

; 376  :       for (int w = 0; w < nBlkSizeX; w++)

	cmp	DWORD PTR _nBlkSizeX$[ebp], 0
	jle	$LN12@ResultBloc
	mov	DWORD PTR tv5154[esp+160], eax
	sub	edx, ecx
	mov	eax, DWORD PTR _nBlkSizeX$[ebp]
	sub	ebx, ecx
	mov	DWORD PTR tv5205[esp+160], 256		; 00000100H
	sub	esi, ecx
	sub	DWORD PTR tv5205[esp+160], edi
	sub	DWORD PTR tv5154[esp+160], ecx
	mov	DWORD PTR tv5213[esp+160], eax
	mov	eax, ecx
	mov	DWORD PTR tv5145[esp+160], ecx
	mov	DWORD PTR tv5158[esp+160], edx
	mov	DWORD PTR tv5144[esp+160], ebx
	mov	DWORD PTR tv5141[esp+160], esi
	npad	3
$LL111@ResultBloc:

; 377  :       {
; 378  :         int mca = (pMCB[w] * time256 + pMCF[w] * (256 - time256)) >> 8; // MC fetched average

	movzx	edx, WORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+2]
	imul	edx, DWORD PTR tv5205[esp+160]
	movzx	ecx, WORD PTR [eax-2]

; 379  :         int sta = MEDIAN<pixel_t>(pRef[w], pSrc[w], mca); // static median

	movzx	esi, WORD PTR [esi+eax-2]
	imul	ecx, edi
	movzx	edi, WORD PTR [ebx+eax-2]
	add	edx, ecx
	sar	edx, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	di, si
; File c:\github\mvtools\sources\mvblockfps.cpp

; 379  :         int sta = MEDIAN<pixel_t>(pRef[w], pSrc[w], mca); // static median

	movzx	ecx, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, esi
; File c:\github\mvtools\sources\mvblockfps.cpp

; 379  :         int sta = MEDIAN<pixel_t>(pRef[w], pSrc[w], mca); // static median

	mov	DWORD PTR _c$1$[esp+160], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, edi
	cmovb	edx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	si, di

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edi, DWORD PTR _c$1$[esp+160]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 334  :   pixel_t			mn = std::min(a, b);

	movzx	ebx, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, esi
	cmovb	edx, ecx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	ecx, di
; File c:\github\mvtools\sources\mvblockfps.cpp

; 335  :   pixel_t			mx = std::max(a, b);

	movzx	edx, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	di, dx
	mov	esi, edx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 376  :       for (int w = 0; w < nBlkSizeX; w++)

	mov	edi, DWORD PTR _time256$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovb	esi, ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 336  :   pixel_t			m = std::min(mx, c);

	movzx	edx, si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	esi, ebx
	cmp	bx, dx
	mov	ecx, edx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 376  :       for (int w = 0; w < nBlkSizeX; w++)

	mov	edx, DWORD PTR tv5158[esp+160]
	mov	ebx, DWORD PTR tv5144[esp+160]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovb	esi, ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 376  :       for (int w = 0; w < nBlkSizeX; w++)

	sub	DWORD PTR tv5213[esp+160], 1

; 380  :         pDst[w] = sta;

	mov	ecx, DWORD PTR tv5154[esp+160]
	mov	WORD PTR [ecx+eax-2], si
	mov	esi, DWORD PTR tv5141[esp+160]
	jne	SHORT $LL111@ResultBloc
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	ecx, DWORD PTR _pMCB8$[ebp]
	mov	edx, DWORD PTR _pMCF8$[ebp]
	mov	ebx, DWORD PTR _pSrc8$[ebp]
	mov	esi, DWORD PTR _pRef8$[ebp]
$LN12@ResultBloc:

; 381  : 
; 382  :       }
; 383  :       pDst += dst_pitch;

	add	eax, DWORD PTR tv5200[esp+160]

; 384  :       pMCB += MCB_pitch;

	add	ecx, DWORD PTR tv5194[esp+160]

; 385  :       pMCF += MCF_pitch;

	add	edx, DWORD PTR tv5189[esp+160]

; 386  :       pRef += ref_pitch;

	add	esi, DWORD PTR tv5185[esp+160]

; 387  :       pSrc += src_pitch;

	add	ebx, DWORD PTR tv5182[esp+160]
	sub	DWORD PTR _nBlkSizeY$2$[esp+160], 1
	mov	DWORD PTR _pDst8$[ebp], eax
	mov	DWORD PTR _pMCB8$[ebp], ecx
	mov	DWORD PTR _pMCF8$[ebp], edx
	mov	DWORD PTR _pRef8$[ebp], esi
	mov	DWORD PTR _pSrc8$[ebp], ebx
	jne	$LL10@ResultBloc

; 460  :     }
; 461  :   }
; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	76					; 0000004cH
$LN40@ResultBloc:

; 388  :     }
; 389  :   }
; 390  :   else if (mode == 2) // default, best working mode

	cmp	ecx, 2
	jne	$LN42@ResultBloc

; 391  :   {
; 392  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ecx, DWORD PTR _nBlkSizeY$[ebp]
	mov	DWORD PTR _nBlkSizeY$3$[esp+160], ecx
	test	ecx, ecx
	jle	$LN21@ResultBloc
	lea	ecx, DWORD PTR [esi+esi]
	mov	esi, DWORD PTR _pRef8$[ebp]
	mov	DWORD PTR tv5199[esp+160], ecx
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _pMCF8$[ebp]
	mov	DWORD PTR tv5193[esp+160], ecx
	lea	ecx, DWORD PTR [ebx+ebx]
	mov	ebx, DWORD PTR _pSrc8$[ebp]
	mov	DWORD PTR tv5188[esp+160], ecx
	mov	ecx, DWORD PTR _ref_pitch$[ebp]
	add	ecx, ecx
	mov	DWORD PTR tv5184[esp+160], ecx
	mov	ecx, DWORD PTR _src_pitch$[ebp]
	add	ecx, ecx
	mov	DWORD PTR tv5181[esp+160], ecx
	mov	ecx, DWORD PTR _pMCB8$[ebp]
	npad	3
$LL16@ResultBloc:

; 394  :       for (int w = 0; w < nBlkSizeX; w++)

	cmp	DWORD PTR _nBlkSizeX$[ebp], 0
	jle	$LN18@ResultBloc
	mov	DWORD PTR tv5204[esp+160], 256		; 00000100H
	sub	edx, ecx
	sub	DWORD PTR tv5204[esp+160], edi
	sub	ebx, ecx
	sub	esi, ecx
	mov	DWORD PTR tv5138[esp+160], ecx
	sub	eax, ecx
	mov	DWORD PTR tv5157[esp+160], edx
	mov	DWORD PTR tv5153[esp+160], eax
	mov	eax, DWORD PTR _nBlkSizeX$[ebp]
	mov	DWORD PTR tv5214[esp+160], eax
	mov	eax, ecx
	mov	DWORD PTR tv5143[esp+160], ebx
	mov	DWORD PTR tv5140[esp+160], esi
	npad	5
$LL113@ResultBloc:

; 396  :         int avg = (pRef[w] * time256 + pSrc[w] * (256 - time256)) >> 8; // simple temporal non-MC average

	movzx	edx, WORD PTR [eax+esi]
	lea	eax, DWORD PTR [eax+2]
	mov	ecx, DWORD PTR tv5143[esp+160]

; 397  :         int dyn = MEDIAN<pixel_t>(avg, pMCB[w], pMCF[w]); // dynamic median

	movzx	ebx, WORD PTR [eax-2]
	imul	edx, edi
	movzx	ecx, WORD PTR [eax+ecx-2]
	imul	ecx, DWORD PTR tv5204[esp+160]
	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, ebx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 396  :         int avg = (pRef[w] * time256 + pSrc[w] * (256 - time256)) >> 8; // simple temporal non-MC average

	sar	edx, 8

; 397  :         int dyn = MEDIAN<pixel_t>(avg, pMCB[w], pMCF[w]); // dynamic median

	movzx	esi, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, si
	mov	edx, esi
	cmovb	edx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	si, bx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 334  :   pixel_t			mn = std::min(a, b);

	movzx	edi, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, esi
	cmovb	edx, ecx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ecx, DWORD PTR tv5157[esp+160]
; File c:\github\mvtools\sources\mvblockfps.cpp

; 335  :   pixel_t			mx = std::max(a, b);

	movzx	edx, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	esi, edx
	movzx	ebx, WORD PTR [ecx+eax-2]
	cmp	bx, dx
	mov	ecx, ebx
	cmovb	esi, ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 336  :   pixel_t			m = std::min(mx, c);

	movzx	edx, si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	esi, edi
	cmp	di, dx
	mov	ecx, edx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 394  :       for (int w = 0; w < nBlkSizeX; w++)

	mov	edi, DWORD PTR _time256$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovb	esi, ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 394  :       for (int w = 0; w < nBlkSizeX; w++)

	sub	DWORD PTR tv5214[esp+160], 1

; 398  :         pDst[w] = dyn;

	mov	ecx, DWORD PTR tv5153[esp+160]
	mov	WORD PTR [ecx+eax-2], si
	mov	esi, DWORD PTR tv5140[esp+160]
	jne	SHORT $LL113@ResultBloc
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	ecx, DWORD PTR _pMCB8$[ebp]
	mov	edx, DWORD PTR _pMCF8$[ebp]
	mov	ebx, DWORD PTR _pSrc8$[ebp]
	mov	esi, DWORD PTR _pRef8$[ebp]
$LN18@ResultBloc:

; 399  :       }
; 400  :       pDst += dst_pitch;

	add	eax, DWORD PTR tv5199[esp+160]

; 401  :       pMCB += MCB_pitch;

	add	ecx, DWORD PTR tv5193[esp+160]

; 402  :       pMCF += MCF_pitch;

	add	edx, DWORD PTR tv5188[esp+160]

; 403  :       pRef += ref_pitch;

	add	esi, DWORD PTR tv5184[esp+160]

; 404  :       pSrc += src_pitch;

	add	ebx, DWORD PTR tv5181[esp+160]
	sub	DWORD PTR _nBlkSizeY$3$[esp+160], 1
	mov	DWORD PTR _pDst8$[ebp], eax
	mov	DWORD PTR _pMCB8$[ebp], ecx
	mov	DWORD PTR _pMCF8$[ebp], edx
	mov	DWORD PTR _pRef8$[ebp], esi
	mov	DWORD PTR _pSrc8$[ebp], ebx
	jne	$LL16@ResultBloc

; 460  :     }
; 461  :   }
; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	76					; 0000004cH
$LN42@ResultBloc:

; 405  :     }
; 406  :   }
; 407  :   else if (mode == 3 || mode == 6)

	cmp	ecx, 3
	je	$LN46@ResultBloc
	cmp	ecx, 6
	je	$LN46@ResultBloc

; 423  :     }
; 424  :   }
; 425  :   else if (mode == 4 || mode == 7)

	cmp	ecx, 4
	je	SHORT $LN49@ResultBloc
	cmp	ecx, 7
	je	SHORT $LN49@ResultBloc

; 445  :     }
; 446  :   }
; 447  :   else if (mode == 5 || mode == 8) // debug modes show mask

	cmp	ecx, 5
	je	SHORT $LN51@ResultBloc
	cmp	ecx, 8
	jne	$LN21@ResultBloc
$LN51@ResultBloc:

; 448  :   {
; 449  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	edx, DWORD PTR _nBlkSizeY$[ebp]
	mov	DWORD PTR _nBlkSizeY$4$[esp+160], edx
	test	edx, edx
	jle	$LN21@ResultBloc

; 452  :       {
; 453  :         if (sizeof(pixel_t) == 1)
; 454  :           pDst[w] = pOcc[w];
; 455  :         else
; 456  :           pDst[w] = (pixel_t)(pOcc[w]) << (bits_per_pixel - 8);

	mov	ecx, DWORD PTR _bits_per_pixel$[ebp]
	lea	ebx, DWORD PTR [esi+esi]
	mov	edi, DWORD PTR _pOcc$[ebp]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR tv5198[esp+160], ebx
	mov	ebx, DWORD PTR _nBlkSizeX$[ebp]
$LL34@ResultBloc:

; 450  :     {
; 451  :       for (int w = 0; w < nBlkSizeX; w++)

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN36@ResultBloc
	npad	5
$LL37@ResultBloc:

; 452  :       {
; 453  :         if (sizeof(pixel_t) == 1)
; 454  :           pDst[w] = pOcc[w];
; 455  :         else
; 456  :           pDst[w] = (pixel_t)(pOcc[w]) << (bits_per_pixel - 8);

	movzx	edx, BYTE PTR [esi+edi]
	shl	dx, cl
	mov	WORD PTR [eax+esi*2], dx
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL37@ResultBloc
	mov	edx, DWORD PTR _nBlkSizeY$4$[esp+160]
$LN36@ResultBloc:

; 457  :       }
; 458  :       pDst += dst_pitch;

	add	eax, DWORD PTR tv5198[esp+160]

; 459  :       pOcc += mask_pitch;

	add	edi, DWORD PTR _mask_pitch$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nBlkSizeY$4$[esp+160], edx
	jne	SHORT $LL34@ResultBloc

; 460  :     }
; 461  :   }
; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	76					; 0000004cH
$LN49@ResultBloc:

; 426  :   {
; 427  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ecx, DWORD PTR _nBlkSizeY$[ebp]
	mov	DWORD PTR _nBlkSizeY$5$[esp+160], ecx
	test	ecx, ecx
	jle	$LN21@ResultBloc
	lea	ecx, DWORD PTR [esi+esi]
	mov	esi, DWORD PTR _pSrc8$[ebp]
	mov	DWORD PTR tv5197[esp+160], ecx
	lea	ecx, DWORD PTR [edx+edx]
	mov	DWORD PTR tv5192[esp+160], ecx
	lea	ecx, DWORD PTR [ebx+ebx]
	mov	DWORD PTR tv5187[esp+160], ecx
	mov	ecx, DWORD PTR _ref_pitch$[ebp]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	add	ecx, ecx
	mov	DWORD PTR tv5183[esp+160], ecx
	mov	ecx, DWORD PTR _src_pitch$[ebp]
	add	ecx, ecx
	mov	DWORD PTR tv5180[esp+160], ecx
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	dec	ecx
	mov	DWORD PTR tv5094[esp+160], ecx
	mov	ecx, DWORD PTR ___isa_available
	mov	DWORD PTR ___isa_available$2$[esp+160], ecx
	mov	ecx, DWORD PTR _pOcc$[ebp]
	mov	DWORD PTR _pOcc$2$[esp+160], ecx
	mov	ecx, DWORD PTR _maskF$[ebp]
	mov	DWORD PTR _maskF$1$[esp+160], ecx
	mov	ecx, DWORD PTR _maskB$[ebp]
	mov	DWORD PTR _maskB$1$[esp+160], ecx
	mov	ecx, DWORD PTR _pRef8$[ebp]
	npad	13
$LL28@ResultBloc:

; 428  :     {
; 429  :       for (int w = 0; w < nBlkSizeX; w++)

	cmp	DWORD PTR _nBlkSizeX$[ebp], 0
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	DWORD PTR _w$1$[esp+160], 0
	jle	$LN30@ResultBloc
	cmp	DWORD PTR _nBlkSizeX$[ebp], 8
	jb	$LN116@ResultBloc

; 435  :         pDst[w] = (avg * pOcc[w] + m * (255 - pOcc[w]) + 255) >> 8;

	cmp	DWORD PTR ___isa_available$2$[esp+160], 2
	jl	$LN116@ResultBloc
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	dec	ecx
	mov	DWORD PTR _w$1$[esp+160], 0
	mov	DWORD PTR tv5178[esp+160], ecx
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR tv5164[esp+160], ecx
	mov	ecx, DWORD PTR _pOcc$2$[esp+160]
	add	ecx, DWORD PTR tv5178[esp+160]
	cmp	eax, ecx
	ja	SHORT $LN117@ResultBloc
	mov	ecx, DWORD PTR _pOcc$2$[esp+160]
	cmp	DWORD PTR tv5164[esp+160], ecx
	jae	$LN168@ResultBloc
$LN117@ResultBloc:
	mov	ebx, DWORD PTR tv5178[esp+160]
	mov	ecx, DWORD PTR _pRef8$[ebp]
	lea	ecx, DWORD PTR [ecx+ebx*2]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN118@ResultBloc
	mov	ecx, DWORD PTR _pRef8$[ebp]
	cmp	DWORD PTR tv5164[esp+160], ecx
	jae	$LN116@ResultBloc
$LN118@ResultBloc:
	mov	ecx, DWORD PTR tv5178[esp+160]
	lea	ecx, DWORD PTR [esi+ecx*2]
	cmp	eax, ecx
	ja	SHORT $LN119@ResultBloc
	cmp	DWORD PTR tv5164[esp+160], esi
	jae	$LN168@ResultBloc
$LN119@ResultBloc:
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	lea	esi, DWORD PTR [ecx*2-2]
	mov	ecx, DWORD PTR _maskB$1$[esp+160]
	add	ecx, DWORD PTR tv5094[esp+160]
	cmp	eax, ecx
	ja	SHORT $LN120@ResultBloc
	mov	ecx, DWORD PTR tv5164[esp+160]
	cmp	ecx, DWORD PTR _maskB$1$[esp+160]
	jae	$LN168@ResultBloc
$LN120@ResultBloc:
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+eax]
	add	ecx, ebx
	mov	DWORD PTR tv5167[esp+160], edx
	mov	edx, DWORD PTR _pMCB8$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN121@ResultBloc
	cmp	DWORD PTR tv5167[esp+160], ebx
	jae	$LN168@ResultBloc
$LN121@ResultBloc:
	mov	ecx, esi
	add	ecx, edx
	cmp	eax, ecx
	ja	SHORT $LN122@ResultBloc
	cmp	DWORD PTR tv5167[esp+160], edx
	jae	$LN168@ResultBloc
$LN122@ResultBloc:
	mov	ecx, DWORD PTR _maskF$1$[esp+160]
	add	ecx, DWORD PTR tv5178[esp+160]
	mov	esi, DWORD PTR _pSrc8$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN123@ResultBloc
	mov	ecx, DWORD PTR _maskF$1$[esp+160]
	cmp	DWORD PTR tv5164[esp+160], ecx
	jae	$LN168@ResultBloc
$LN123@ResultBloc:
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN176@ResultBloc
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN176@ResultBloc:
	mov	ebx, DWORD PTR _nBlkSizeX$[ebp]
	mov	eax, DWORD PTR _pOcc$2$[esp+160]
	sub	ebx, ecx
	mov	DWORD PTR tv5147[esp+160], ebx
	add	eax, 4
	mov	ebx, DWORD PTR _pMCF8$[ebp]

; 433  :         int avg = (pRef[w] * time256 + pSrc[w] * (256 - time256) + 255) >> 8; // simple temporal non-MC average

	movaps	xmm0, XMMWORD PTR __xmm@00000100000001000000010000000100
	mov	DWORD PTR tv5137[esp+160], eax
	psubd	xmm0, xmm7
	mov	eax, DWORD PTR _maskB$1$[esp+160]
	lea	ecx, DWORD PTR [ebx+8]
	movaps	xmm4, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	mov	DWORD PTR tv5131[esp+160], ecx
	mov	ecx, edx
	sub	ecx, ebx
	mov	DWORD PTR tv5136[esp+160], eax
	mov	DWORD PTR tv5129[esp+160], ecx
	mov	ecx, esi
	sub	ecx, ebx
	mov	DWORD PTR tv5133[esp+160], edx
	mov	DWORD PTR tv5125[esp+160], ecx
	mov	ecx, DWORD PTR _pRef8$[ebp]
	mov	eax, ecx
	sub	eax, ebx
	movaps	XMMWORD PTR tv5174[esp+160], xmm0
	mov	DWORD PTR tv5123[esp+160], eax
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	edx, eax
	sub	edx, ebx
	mov	ebx, esi
	mov	esi, DWORD PTR tv5123[esp+160]
	mov	DWORD PTR tv5121[esp+160], edx
	mov	edx, DWORD PTR _pMCB8$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv5139[esp+160], ecx
	sub	eax, edx
	mov	ecx, DWORD PTR _pOcc$2$[esp+160]
	sub	ebx, edx
	sub	ecx, DWORD PTR _maskB$1$[esp+160]
	mov	edx, DWORD PTR tv5129[esp+160]
	mov	DWORD PTR tv5152[esp+160], eax
	mov	eax, DWORD PTR _maskF$1$[esp+160]
	sub	eax, DWORD PTR _maskB$1$[esp+160]
	mov	DWORD PTR tv5113[esp+160], ecx
	mov	ecx, DWORD PTR _maskF$1$[esp+160]
	sub	ecx, DWORD PTR _pOcc$2$[esp+160]
	mov	DWORD PTR tv5142[esp+160], ebx
	mov	ebx, DWORD PTR tv5131[esp+160]
	mov	DWORD PTR tv5117[esp+160], eax
	mov	DWORD PTR tv5111[esp+160], ecx
	npad	2
$LL31@ResultBloc:

; 430  :       {
; 431  :         int f = (maskF[w] * pMCB[w] + (255 - maskF[w])*pMCF[w] + 255) >> 8;

	mov	ecx, DWORD PTR tv5136[esp+160]
	mov	eax, DWORD PTR tv5113[esp+160]
	movaps	xmm6, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	movd	xmm0, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv5117[esp+160]

; 435  :         pDst[w] = (avg * pOcc[w] + m * (255 - pOcc[w]) + 255) >> 8;

	pmovzxbd xmm7, xmm0
	movq	xmm0, QWORD PTR [ebx-8]
	psubd	xmm4, xmm7
	pmovzxwd xmm5, xmm0
	movd	xmm0, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv5133[esp+160]
	mov	eax, DWORD PTR tv5136[esp+160]
	pmovzxbd xmm1, xmm0
	psubd	xmm6, xmm1
	movq	xmm0, QWORD PTR [ecx]
	pmovzxwd xmm3, xmm0
	movd	xmm0, DWORD PTR [eax]
	mov	eax, 8
	pmovzxbd xmm2, xmm0
	pmulld	xmm6, xmm5
	movaps	xmm0, xmm3
	pmulld	xmm0, xmm1
	movaps	xmm1, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	paddd	xmm6, xmm0
	paddd	xmm6, xmm1
	movd	xmm0, eax
	psrad	xmm6, xmm0
	movaps	xmm0, xmm1
	pmulld	xmm6, XMMWORD PTR tv5174[esp+160]
	psubd	xmm0, xmm2
	pmulld	xmm0, xmm3
	movd	xmm3, eax
	mov	eax, DWORD PTR tv5139[esp+160]
	pmulld	xmm5, xmm2
	paddd	xmm0, xmm5
	paddd	xmm0, xmm1
	psrad	xmm0, xmm3
	pmulld	xmm0, XMMWORD PTR tv5219[esp+160]
	paddd	xmm6, xmm0
	movq	xmm0, QWORD PTR [ecx+eax]
	mov	eax, DWORD PTR tv5142[esp+160]
	pmovzxwd xmm1, xmm0
	pmulld	xmm1, XMMWORD PTR tv5219[esp+160]
	psrad	xmm6, xmm3
	movq	xmm0, QWORD PTR [ecx+eax]
	mov	eax, DWORD PTR tv5152[esp+160]
	pmovzxwd xmm0, xmm0
	pmulld	xmm0, XMMWORD PTR tv5174[esp+160]
	paddd	xmm1, xmm0
	pmulld	xmm6, xmm4
	movaps	xmm4, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	paddd	xmm1, xmm4
	psrad	xmm1, xmm3
	pmulld	xmm1, xmm7
	paddd	xmm6, xmm1
	paddd	xmm6, xmm4
	psrad	xmm6, xmm3
	pshuflw	xmm0, xmm6, 216				; 000000d8H
	movaps	xmm6, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [eax+ecx], xmm0
	mov	ecx, DWORD PTR tv5137[esp+160]
	mov	eax, DWORD PTR tv5111[esp+160]
	movd	xmm0, DWORD PTR [ecx]
	pmovzxbd xmm7, xmm0
	movq	xmm0, QWORD PTR [ebx]
	psubd	xmm4, xmm7
	pmovzxwd xmm5, xmm0
	movd	xmm0, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR tv5136[esp+160]
	pmovzxbd xmm1, xmm0
	movq	xmm0, QWORD PTR [edx+ebx]
	psubd	xmm6, xmm1
	pmovzxwd xmm3, xmm0
	movd	xmm0, DWORD PTR [eax+4]
	pmovzxbd xmm2, xmm0
	movaps	xmm0, xmm3
	pmulld	xmm6, xmm5
	pmulld	xmm0, xmm1
	paddd	xmm6, xmm0

; 428  :     {
; 429  :       for (int w = 0; w < nBlkSizeX; w++)

	movaps	xmm1, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	lea	ebx, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR tv5125[esp+160]

; 430  :       {
; 431  :         int f = (maskF[w] * pMCB[w] + (255 - maskF[w])*pMCF[w] + 255) >> 8;

	paddd	xmm6, xmm1
	mov	eax, 8
	add	DWORD PTR tv5136[esp+160], 8

; 432  :         int b = (maskB[w] * pMCF[w] + (255 - maskB[w])*pMCB[w] + 255) >> 8;

	pmulld	xmm5, xmm2
	add	DWORD PTR tv5133[esp+160], 16		; 00000010H
	add	DWORD PTR tv5137[esp+160], 8
	movd	xmm0, eax
	psrad	xmm6, xmm0
	movaps	xmm0, xmm1

; 434  :         int m = (b*time256 + f*(256 - time256)) >> 8;

	pmulld	xmm6, XMMWORD PTR tv5174[esp+160]
	psubd	xmm0, xmm2
	pmulld	xmm0, xmm3
	paddd	xmm0, xmm5
	movd	xmm3, eax
	paddd	xmm0, xmm1
	mov	eax, DWORD PTR tv5121[esp+160]
	psrad	xmm0, xmm3
	pmulld	xmm0, XMMWORD PTR tv5219[esp+160]
	paddd	xmm6, xmm0
	movq	xmm0, QWORD PTR [esi+ebx-16]
	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ecx+ebx-16]
	pmulld	xmm1, XMMWORD PTR tv5219[esp+160]
	psrad	xmm6, xmm3
	pmovzxwd xmm0, xmm0
	pmulld	xmm0, XMMWORD PTR tv5174[esp+160]
	paddd	xmm1, xmm0

; 435  :         pDst[w] = (avg * pOcc[w] + m * (255 - pOcc[w]) + 255) >> 8;

	pmulld	xmm6, xmm4
	movaps	xmm4, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	paddd	xmm1, xmm4
	psrad	xmm1, xmm3
	pmulld	xmm1, xmm7
	paddd	xmm6, xmm1
	paddd	xmm6, xmm4
	psrad	xmm6, xmm3
	pshuflw	xmm0, xmm6, 216				; 000000d8H
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [eax+ebx-16], xmm0
	mov	eax, DWORD PTR _w$1$[esp+160]
	add	eax, 8
	mov	DWORD PTR _w$1$[esp+160], eax
	cmp	eax, DWORD PTR tv5147[esp+160]
	jl	$LL31@ResultBloc
	movaps	xmm7, XMMWORD PTR tv5219[esp+160]
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
$LN168@ResultBloc:
	mov	ecx, DWORD PTR _pRef8$[ebp]
$LN116@ResultBloc:

; 428  :     {
; 429  :       for (int w = 0; w < nBlkSizeX; w++)

	mov	esi, DWORD PTR _w$1$[esp+160]
	cmp	esi, DWORD PTR _nBlkSizeX$[ebp]
	mov	esi, DWORD PTR _pSrc8$[ebp]
	jge	$LN30@ResultBloc
	mov	ecx, 256				; 00000100H
	sub	eax, ebx
	sub	ecx, edi
	mov	DWORD PTR tv5120[esp+160], eax
	mov	edi, DWORD PTR _maskB$1$[esp+160]
	sub	edx, ebx
	mov	eax, DWORD PTR _pOcc$2$[esp+160]
	mov	DWORD PTR tv5203[esp+160], ecx
	sub	eax, edi
	mov	ecx, DWORD PTR _w$1$[esp+160]
	add	ecx, edi
	mov	DWORD PTR tv5112[esp+160], eax
	mov	eax, DWORD PTR _nBlkSizeX$[ebp]
	mov	DWORD PTR tv5102[esp+160], ecx
	mov	ecx, DWORD PTR _w$1$[esp+160]
	mov	DWORD PTR tv5128[esp+160], edx
	mov	edx, DWORD PTR tv5102[esp+160]
	lea	ecx, DWORD PTR [ebx+ecx*2]
	mov	DWORD PTR tv5100[esp+160], ecx
	mov	ecx, esi
	sub	ecx, ebx
	mov	DWORD PTR tv5124[esp+160], ecx
	mov	ecx, DWORD PTR _pRef8$[ebp]
	sub	ecx, ebx
	mov	DWORD PTR tv5122[esp+160], ecx
	mov	ecx, DWORD PTR _maskF$1$[esp+160]
	sub	ecx, edi
	sub	eax, DWORD PTR _w$1$[esp+160]
	mov	DWORD PTR tv5097[esp+160], eax
	mov	eax, DWORD PTR tv5100[esp+160]
	mov	DWORD PTR tv5116[esp+160], ecx
	npad	2
$LL115@ResultBloc:

; 430  :       {
; 431  :         int f = (maskF[w] * pMCB[w] + (255 - maskF[w])*pMCF[w] + 255) >> 8;

	movzx	esi, BYTE PTR [ecx+edx]
	mov	ebx, DWORD PTR tv5128[esp+160]
	movzx	ecx, WORD PTR [eax]
	movzx	edi, WORD PTR [ebx+eax]

; 432  :         int b = (maskB[w] * pMCF[w] + (255 - maskB[w])*pMCB[w] + 255) >> 8;

	movzx	ebx, BYTE PTR [edx]

; 435  :         pDst[w] = (avg * pOcc[w] + m * (255 - pOcc[w]) + 255) >> 8;

	mov	eax, DWORD PTR tv5112[esp+160]
	movzx	edx, BYTE PTR [eax+edx]
	mov	eax, DWORD PTR tv5100[esp+160]
	mov	DWORD PTR tv5095[esp+160], edx
	mov	edx, 255				; 000000ffH
	sub	edx, esi
	imul	esi, edi
	imul	edx, ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, ebx
	imul	ecx, edi
	add	edx, 255				; 000000ffH
	add	esi, edx
	movzx	edx, WORD PTR [eax]
	imul	edx, ebx
	sar	esi, 8
	imul	esi, DWORD PTR tv5203[esp+160]
	add	edx, 255				; 000000ffH
	add	ecx, edx
	sar	ecx, 8
	imul	ecx, DWORD PTR _time256$[ebp]
	add	esi, ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, DWORD PTR tv5095[esp+160]
	sar	esi, 8
	imul	esi, ecx
	mov	ecx, DWORD PTR tv5122[esp+160]
	movzx	edx, WORD PTR [ecx+eax]
	mov	ecx, DWORD PTR tv5124[esp+160]
	imul	edx, DWORD PTR _time256$[ebp]
	movzx	ecx, WORD PTR [ecx+eax]
	imul	ecx, DWORD PTR tv5203[esp+160]
	add	edx, 255				; 000000ffH
	add	ecx, edx
	mov	edx, DWORD PTR tv5120[esp+160]
	sar	ecx, 8
	imul	ecx, DWORD PTR tv5095[esp+160]
	add	ecx, 255				; 000000ffH
	add	ecx, esi
	sar	ecx, 8
	mov	WORD PTR [edx+eax], cx
	add	eax, 2
	mov	edx, DWORD PTR tv5102[esp+160]
	mov	ecx, DWORD PTR tv5116[esp+160]
	inc	edx
	sub	DWORD PTR tv5097[esp+160], 1
	mov	DWORD PTR tv5102[esp+160], edx
	mov	DWORD PTR tv5100[esp+160], eax
	jne	$LL115@ResultBloc
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	mov	edi, DWORD PTR _time256$[ebp]
	mov	esi, DWORD PTR _pSrc8$[ebp]
	mov	ecx, DWORD PTR _pRef8$[ebp]
$LN30@ResultBloc:

; 436  :       }
; 437  :       pDst += dst_pitch;

	add	eax, DWORD PTR tv5197[esp+160]

; 438  :       pMCB += MCB_pitch;

	add	edx, DWORD PTR tv5192[esp+160]

; 439  :       pMCF += MCF_pitch;

	add	ebx, DWORD PTR tv5187[esp+160]

; 440  :       pRef += ref_pitch;

	add	ecx, DWORD PTR tv5183[esp+160]

; 441  :       pSrc += src_pitch;

	add	esi, DWORD PTR tv5180[esp+160]
	mov	DWORD PTR _pDst8$[ebp], eax

; 442  :       maskB += mask_pitch;

	mov	eax, DWORD PTR _mask_pitch$[ebp]
	add	DWORD PTR _maskB$1$[esp+160], eax

; 443  :       maskF += mask_pitch;

	add	DWORD PTR _maskF$1$[esp+160], eax

; 444  :       pOcc += mask_pitch;

	add	DWORD PTR _pOcc$2$[esp+160], eax
	sub	DWORD PTR _nBlkSizeY$5$[esp+160], 1
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	DWORD PTR _pMCB8$[ebp], edx
	mov	DWORD PTR _pMCF8$[ebp], ebx
	mov	DWORD PTR _pRef8$[ebp], ecx
	mov	DWORD PTR _pSrc8$[ebp], esi
	jne	$LL28@ResultBloc

; 460  :     }
; 461  :   }
; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	76					; 0000004cH
$LN46@ResultBloc:

; 408  :   {
; 409  :     for (int h = 0; h < nBlkSizeY; h++)

	mov	ecx, DWORD PTR _nBlkSizeY$[ebp]
	mov	DWORD PTR _nBlkSizeY$6$[esp+160], ecx
	test	ecx, ecx
	jle	$LN21@ResultBloc
	lea	ecx, DWORD PTR [esi+esi]
	mov	DWORD PTR tv5196[esp+160], ecx
	lea	ecx, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	DWORD PTR tv5191[esp+160], ecx
	lea	ecx, DWORD PTR [ebx+ebx]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	mov	DWORD PTR tv5186[esp+160], ecx
	mov	ecx, DWORD PTR _maskF$[ebp]
	mov	DWORD PTR _maskF$2$[esp+160], ecx
	mov	ecx, DWORD PTR _maskB$[ebp]
	mov	DWORD PTR _maskB$2$[esp+160], ecx
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
$LL22@ResultBloc:

; 410  :     {
; 411  :       for (int w = 0; w < nBlkSizeX; w++)

	xor	esi, esi
	mov	DWORD PTR _w$1$[esp+160], esi
	test	ecx, ecx
	jle	$LN24@ResultBloc
	cmp	ecx, 8
	jb	$LN125@ResultBloc

; 412  :       {
; 413  :         pDst[w] = (((maskB[w] * pMCF[w] + (255 - maskB[w])*pMCB[w] + 255) >> 8)*time256 +

	cmp	DWORD PTR ___isa_available, 2
	jl	$LN125@ResultBloc
	mov	DWORD PTR _w$1$[esp+160], esi
	lea	esi, DWORD PTR [ecx*2-2]
	mov	DWORD PTR tv5165[esp+160], esi
	mov	esi, DWORD PTR _maskB$2$[esp+160]
	dec	esi
	add	ecx, esi
	mov	esi, 0
	cmp	eax, ecx
	ja	SHORT $LN126@ResultBloc
	mov	ecx, DWORD PTR tv5165[esp+160]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	add	ecx, eax
	cmp	ecx, DWORD PTR _maskB$2$[esp+160]
	jae	$LN172@ResultBloc
$LN126@ResultBloc:
	mov	ecx, DWORD PTR tv5165[esp+160]
	add	ecx, ebx
	cmp	eax, ecx
	ja	SHORT $LN127@ResultBloc
	mov	ecx, DWORD PTR tv5165[esp+160]
	add	ecx, eax
	cmp	ecx, ebx
	jae	$LN172@ResultBloc
$LN127@ResultBloc:
	mov	ecx, DWORD PTR tv5165[esp+160]
	add	ecx, edx
	cmp	eax, ecx
	ja	SHORT $LN128@ResultBloc
	mov	ecx, DWORD PTR tv5165[esp+160]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	add	ecx, eax
	cmp	ecx, edx
	jae	$LN172@ResultBloc
$LN128@ResultBloc:
	mov	esi, DWORD PTR _maskF$2$[esp+160]
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	dec	esi
	add	ecx, esi
	mov	esi, DWORD PTR _w$1$[esp+160]
	cmp	eax, ecx
	ja	SHORT $LN129@ResultBloc
	mov	ecx, DWORD PTR tv5165[esp+160]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	add	ecx, eax
	cmp	ecx, DWORD PTR _maskF$2$[esp+160]
	jae	$LN172@ResultBloc
$LN129@ResultBloc:
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN177@ResultBloc
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN177@ResultBloc:
	mov	esi, DWORD PTR _nBlkSizeX$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000100000001000000010000000100
	sub	esi, ecx
	movaps	xmm6, XMMWORD PTR __xmm@000000ff000000ff000000ff000000ff
	lea	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR tv5146[esp+160], esi
	psubd	xmm0, xmm7
	mov	esi, edx
	mov	DWORD PTR tv5090[esp+160], edx
	sub	esi, ebx
	movaps	XMMWORD PTR tv5172[esp+160], xmm0
	mov	DWORD PTR tv5127[esp+160], esi
	mov	esi, eax
	sub	esi, ebx
	mov	ebx, eax
	mov	eax, DWORD PTR _maskF$2$[esp+160]
	sub	ebx, edx
	mov	edx, eax
	mov	DWORD PTR tv5119[esp+160], esi
	sub	edx, DWORD PTR _maskB$2$[esp+160]
	add	eax, 4
	mov	esi, DWORD PTR _w$1$[esp+160]
	mov	DWORD PTR tv5115[esp+160], edx
	mov	edx, DWORD PTR tv5090[esp+160]
	mov	DWORD PTR tv5173[esp+160], eax
	mov	eax, DWORD PTR _maskB$2$[esp+160]
	mov	DWORD PTR tv5151[esp+160], ebx
$LL25@ResultBloc:

; 410  :     {
; 411  :       for (int w = 0; w < nBlkSizeX; w++)

	movq	xmm0, QWORD PTR [ecx-8]
	lea	eax, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR tv5115[esp+160]
	lea	edx, DWORD PTR [edx+16]

; 412  :       {
; 413  :         pDst[w] = (((maskB[w] * pMCF[w] + (255 - maskB[w])*pMCB[w] + 255) >> 8)*time256 +

	pmovzxwd xmm5, xmm0
	movaps	xmm4, xmm6
	lea	ecx, DWORD PTR [ecx+16]
	movd	xmm0, DWORD PTR [ebx+eax-8]
	mov	ebx, 8
	pmovzxbd xmm1, xmm0
	movq	xmm0, QWORD PTR [edx-16]
	psubd	xmm4, xmm1
	pmovzxwd xmm3, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm2, xmm0
	movaps	xmm0, xmm3
	pmulld	xmm0, xmm1
	pmulld	xmm4, xmm5
	paddd	xmm4, xmm0
	movd	xmm1, ebx
	mov	ebx, DWORD PTR tv5151[esp+160]
	movaps	xmm0, xmm6
	psubd	xmm0, xmm2
	paddd	xmm4, xmm6
	pmulld	xmm0, xmm3
	pmulld	xmm5, xmm2
	paddd	xmm0, xmm5
	movaps	xmm3, xmm6
	paddd	xmm0, xmm6
	psrad	xmm0, xmm1
	psrad	xmm4, xmm1
	pmulld	xmm0, xmm7
	pmulld	xmm4, XMMWORD PTR tv5172[esp+160]
	paddd	xmm4, xmm0
	psrad	xmm4, xmm1
	pshuflw	xmm0, xmm4, 216				; 000000d8H
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [ebx+edx-16], xmm0
	movq	xmm0, QWORD PTR [ecx-16]
	mov	ebx, DWORD PTR tv5173[esp+160]
	pmovzxwd xmm5, xmm0
	movd	xmm0, DWORD PTR [ebx+esi]
	add	esi, 8
	mov	ebx, DWORD PTR tv5127[esp+160]
	pmovzxbd xmm4, xmm0
	movq	xmm0, QWORD PTR [ecx+ebx-16]
	mov	ebx, 8
	pmovzxwd xmm2, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	pmovzxbd xmm1, xmm0
	psubd	xmm3, xmm1
	movaps	xmm0, xmm5
	pmulld	xmm0, xmm1
	pmulld	xmm3, xmm2
	paddd	xmm3, xmm0
	movaps	xmm0, xmm6
	psubd	xmm0, xmm4
	paddd	xmm3, xmm6
	pmulld	xmm0, xmm5
	pmulld	xmm2, xmm4
	paddd	xmm0, xmm2
	movd	xmm1, ebx
	paddd	xmm0, xmm6
	mov	ebx, DWORD PTR tv5119[esp+160]
	psrad	xmm0, xmm1
	psrad	xmm3, xmm1
	pmulld	xmm0, XMMWORD PTR tv5172[esp+160]
	pmulld	xmm3, xmm7
	paddd	xmm3, xmm0
	psrad	xmm3, xmm1
	pshuflw	xmm0, xmm3, 216				; 000000d8H
	pshufhw	xmm0, xmm0, 216				; 000000d8H
	pshufd	xmm0, xmm0, 216				; 000000d8H
	movq	QWORD PTR [ecx+ebx-16], xmm0
	cmp	esi, DWORD PTR tv5146[esp+160]
	jl	$LL25@ResultBloc
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	mov	DWORD PTR _w$1$[esp+160], esi
$LN172@ResultBloc:
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
$LN125@ResultBloc:

; 410  :     {
; 411  :       for (int w = 0; w < nBlkSizeX; w++)

	cmp	esi, ecx
	jge	$LN24@ResultBloc
	add	esi, DWORD PTR _maskB$2$[esp+160]
	mov	ecx, 256				; 00000100H
	sub	ecx, edi
	mov	DWORD PTR tv5082[esp+160], esi
	mov	edi, DWORD PTR _w$1$[esp+160]
	sub	eax, ebx
	mov	DWORD PTR tv5202[esp+160], ecx
	sub	edx, ebx
	mov	DWORD PTR tv5118[esp+160], eax
	mov	eax, DWORD PTR _nBlkSizeX$[ebp]
	lea	ecx, DWORD PTR [ebx+edi*2]
	mov	DWORD PTR tv5126[esp+160], edx
	mov	DWORD PTR tv5079[esp+160], ecx
	mov	ecx, DWORD PTR _maskF$2$[esp+160]
	sub	ecx, DWORD PTR _maskB$2$[esp+160]
	sub	eax, edi
	mov	DWORD PTR tv5075[esp+160], eax
	mov	eax, DWORD PTR tv5079[esp+160]
	mov	DWORD PTR tv5114[esp+160], ecx
	npad	4
$LL124@ResultBloc:

; 412  :       {
; 413  :         pDst[w] = (((maskB[w] * pMCF[w] + (255 - maskB[w])*pMCB[w] + 255) >> 8)*time256 +

	movzx	ecx, BYTE PTR [ecx+esi]
	lea	eax, DWORD PTR [eax+2]
	movzx	ebx, WORD PTR [edx+eax-2]
	movzx	edx, BYTE PTR [esi]
	mov	esi, 255				; 000000ffH
	movzx	edi, WORD PTR [eax-2]
	sub	esi, edx
	mov	DWORD PTR tv5077[esp+160], ecx
	mov	ecx, 255				; 000000ffH
	sub	ecx, DWORD PTR tv5077[esp+160]
	imul	ecx, edi
	imul	esi, ebx
	imul	ebx, DWORD PTR tv5077[esp+160]
	imul	edx, edi
	add	ecx, 255				; 000000ffH
	add	esi, 255				; 000000ffH
	add	ecx, ebx
	add	edx, esi
	sar	ecx, 8
	imul	ecx, DWORD PTR tv5202[esp+160]
	mov	esi, DWORD PTR tv5082[esp+160]
	sar	edx, 8
	inc	esi
	imul	edx, DWORD PTR _time256$[ebp]
	mov	DWORD PTR tv5082[esp+160], esi
	add	edx, ecx
	mov	ecx, DWORD PTR tv5118[esp+160]
	sar	edx, 8
	sub	DWORD PTR tv5075[esp+160], 1
	mov	WORD PTR [ecx+eax-2], dx
	mov	edx, DWORD PTR tv5126[esp+160]
	mov	ecx, DWORD PTR tv5114[esp+160]
	jne	SHORT $LL124@ResultBloc
	mov	eax, DWORD PTR _pDst8$[ebp]
	mov	edx, DWORD PTR _pMCB8$[ebp]
	mov	ebx, DWORD PTR _pMCF8$[ebp]
	mov	edi, DWORD PTR _time256$[ebp]
	mov	ecx, DWORD PTR _nBlkSizeX$[ebp]
$LN24@ResultBloc:

; 414  :           ((maskF[w] * pMCB[w] + (255 - maskF[w])*pMCF[w] + 255) >> 8)*(256 - time256)) >> 8;
; 415  :       }
; 416  :       pDst += dst_pitch;
; 417  :       pMCB += MCB_pitch;
; 418  :       pMCF += MCF_pitch;
; 419  : //			pRef += ref_pitch;
; 420  : //			pSrc += src_pitch;
; 421  :       maskB += mask_pitch;

	mov	esi, DWORD PTR _mask_pitch$[ebp]
	add	eax, DWORD PTR tv5196[esp+160]
	add	edx, DWORD PTR tv5191[esp+160]
	add	ebx, DWORD PTR tv5186[esp+160]
	add	DWORD PTR _maskB$2$[esp+160], esi

; 422  :       maskF += mask_pitch;

	add	DWORD PTR _maskF$2$[esp+160], esi
	sub	DWORD PTR _nBlkSizeY$6$[esp+160], 1
	mov	DWORD PTR _pDst8$[ebp], eax
	mov	DWORD PTR _pMCB8$[ebp], edx
	mov	DWORD PTR _pMCF8$[ebp], ebx
	jne	$LL22@ResultBloc
$LN21@ResultBloc:

; 460  :     }
; 461  :   }
; 462  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	76					; 0000004cH
??$ResultBlock@G@MVBlockFps@@AAEXPAEHPBEH1H1H1H0H00HHHHH@Z ENDP ; MVBlockFps::ResultBlock<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ??$MEDIAN@E@@YAEEEE@Z
_TEXT	SEGMENT
tv88 = -4						; size = 4
_c$ = 8							; size = 1
??$MEDIAN@E@@YAEEEE@Z PROC				; MEDIAN<unsigned char>, COMDAT
; _a$ = cl
; _b$ = dl

; 333  : {

	push	ecx
	push	ebx
	mov	bl, dl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	edx, cl
	cmp	bl, cl
	movzx	eax, bl
	cmovb	edx, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	cl, bl
	movzx	eax, bl

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	DWORD PTR tv88[esp+8], edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	movzx	edx, cl

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	ecx, BYTE PTR _c$[esp+4]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovb	edx, eax

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	BYTE PTR _c$[esp+4], dl
	movzx	ebx, dl

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, DWORD PTR tv88[esp+8]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovb	ebx, ecx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	dl, bl
	movzx	ecx, bl
	movzx	eax, dl
	cmovb	eax, ecx
	pop	ebx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 340  : }

	pop	ecx
	ret	0
??$MEDIAN@E@@YAEEEE@Z ENDP				; MEDIAN<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvblockfps.cpp
;	COMDAT ??$MEDIAN@G@@YAGGGG@Z
_TEXT	SEGMENT
_c$ = 8							; size = 2
??$MEDIAN@G@@YAGGGG@Z PROC				; MEDIAN<unsigned short>, COMDAT
; _a$ = cx
; _b$ = dx

; 333  : {

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	dx, cx
	movzx	eax, dx
	movzx	esi, cx
	cmovb	esi, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	movzx	eax, dx
	cmp	cx, dx
	push	edi
; File c:\github\mvtools\sources\mvblockfps.cpp

; 334  :   pixel_t			mn = std::min(a, b);

	movzx	edi, si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	movzx	esi, cx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movzx	ecx, WORD PTR _c$[esp+4]

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovb	esi, eax
; File c:\github\mvtools\sources\mvblockfps.cpp

; 335  :   pixel_t			mx = std::max(a, b);

	movzx	edx, si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	WORD PTR _c$[esp+4], dx
	mov	esi, edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, edi

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovb	esi, ecx
; File c:\github\mvtools\sources\mvblockfps.cpp

; 336  :   pixel_t			m = std::min(mx, c);

	movzx	ecx, si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	di, cx
	mov	eax, ecx
	pop	edi
	cmovb	edx, eax
; File c:\github\mvtools\sources\mvblockfps.cpp

; 337  :   m = std::max(mn, m);

	movzx	eax, dx
	pop	esi

; 338  : 
; 339  :   return m;
; 340  : }

	ret	0
??$MEDIAN@G@@YAGGGG@Z ENDP				; MEDIAN<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$min@E@std@@YAABEABE0@Z
_TEXT	SEGMENT
??$min@E@std@@YAABEABE0@Z PROC				; std::min<unsigned char>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [ecx]
	cmovb	ecx, edx
	mov	eax, ecx

; 3650 : 	}

	ret	0
??$min@E@std@@YAABEABE0@Z ENDP				; std::min<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$max@E@std@@YAABEABE0@Z
_TEXT	SEGMENT
??$max@E@std@@YAABEABE0@Z PROC				; std::max<unsigned char>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	cmovb	ecx, edx
	mov	eax, ecx

; 3613 : 	}

	ret	0
??$max@E@std@@YAABEABE0@Z ENDP				; std::max<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$min@G@std@@YAABGABG0@Z
_TEXT	SEGMENT
??$min@G@std@@YAABGABG0@Z PROC				; std::min<unsigned short>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	ax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	cmovb	ecx, edx
	mov	eax, ecx

; 3650 : 	}

	ret	0
??$min@G@std@@YAABGABG0@Z ENDP				; std::min<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$max@G@std@@YAABGABG0@Z
_TEXT	SEGMENT
??$max@G@std@@YAABGABG0@Z PROC				; std::max<unsigned short>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ax, WORD PTR [ecx]
	cmp	ax, WORD PTR [edx]
	cmovb	ecx, edx
	mov	eax, ecx

; 3613 : 	}

	ret	0
??$max@G@std@@YAABGABG0@Z ENDP				; std::max<unsigned short>
_TEXT	ENDS
END
