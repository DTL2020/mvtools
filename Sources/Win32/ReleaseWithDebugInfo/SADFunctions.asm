; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\sadfunctions.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	_x264_pixel_satd_8x16_sse2:PROC
EXTRN	_x264_pixel_satd_8x4_sse2:PROC
EXTRN	_Sad4x2_iSSE:PROC
EXTRN	_x264_pixel_sad_8x16_mmx2:PROC
EXTRN	_Sad8x1_iSSE:PROC
EXTRN	_x264_pixel_satd_16x8_sse2:PROC
EXTRN	_x264_pixel_satd_16x16_ssse3:PROC
EXTRN	_x264_pixel_sad_8x8_mmx2:PROC
EXTRN	_Sad32x8_iSSE:PROC
EXTRN	_x264_pixel_sad_16x16_sse2:PROC
EXTRN	_Sad8x2_iSSE:PROC
EXTRN	_x264_pixel_sad_4x4_mmx2:PROC
EXTRN	_x264_pixel_sad_4x8_mmx2:PROC
EXTRN	_x264_pixel_sad_16x8_sse2:PROC
EXTRN	_Sad2x2_iSSE:PROC
EXTRN	_x264_pixel_satd_8x8_sse2:PROC
EXTRN	_x264_pixel_satd_16x16_sse2:PROC
EXTRN	_Sad16x32_iSSE:PROC
EXTRN	_x264_pixel_sad_16x4_mmx2:PROC
EXTRN	_x264_pixel_satd_16x8_ssse3:PROC
EXTRN	_Sad2x4_iSSE:PROC
EXTRN	_Sad32x16_iSSE:PROC
EXTRN	_x264_pixel_sad_8x4_mmx2:PROC
EXTRN	_Sad32x32_iSSE:PROC
EXTRN	_x264_pixel_sad_16x2_mmx2:PROC
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
PUBLIC	??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
PUBLIC	??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)><std::tuple<int,int,int,enum arch_t> &&>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_first
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getal
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::max_size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator--
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
PUBLIC	??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &>
PUBLIC	??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Mysize
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator--
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::size
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Freenode0
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator--
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > &>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$?0U_Exact_args_t@std@@AAHW4arch_t@@$0A@@?$tuple@HW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH$$QAW4arch_t@@@Z ; std::tuple<int,enum arch_t>::tuple<int,enum arch_t><std::_Exact_args_t,int &,enum arch_t,0>
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_first
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getcomp
PUBLIC	?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Compare
PUBLIC	??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>
PUBLIC	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > &,bool,void,0>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool,void,0>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
PUBLIC	??$?0U_Exact_args_t@std@@AAHAAHW4arch_t@@$0A@@?$tuple@HHW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH1$$QAW4arch_t@@@Z ; std::tuple<int,int,enum arch_t>::tuple<int,int,enum arch_t><std::_Exact_args_t,int &,int &,enum arch_t,0>
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Kfn
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_first
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::lower_bound
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Key
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getcomp
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1><>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
PUBLIC	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
PUBLIC	??$?0AAHAAHAAHW4arch_t@@$0A@@?$tuple@HHHW4arch_t@@@std@@QAE@AAH00$$QAW4arch_t@@@Z ; std::tuple<int,int,int,enum arch_t>::tuple<int,int,int,enum arch_t><int &,int &,int &,enum arch_t,0>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
PUBLIC	??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
PUBLIC	??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
PUBLIC	??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::try_emplace<>
PUBLIC	??$make_tuple@AAHAAHAAHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00$$QAW4arch_t@@@Z ; std::make_tuple<int &,int &,int &,enum arch_t>
PUBLIC	??$Sad16_sse2@$03$01G@@YAIPBEH0H@Z		; Sad16_sse2<4,2,unsigned short>
PUBLIC	??$Sad16_sse2@$03$03G@@YAIPBEH0H@Z		; Sad16_sse2<4,4,unsigned short>
PUBLIC	??$Sad16_sse2@$03$07G@@YAIPBEH0H@Z		; Sad16_sse2<4,8,unsigned short>
PUBLIC	??$Sad16_sse2@$07$00G@@YAIPBEH0H@Z		; Sad16_sse2<8,1,unsigned short>
PUBLIC	??$Sad16_sse2@$07$01G@@YAIPBEH0H@Z		; Sad16_sse2<8,2,unsigned short>
PUBLIC	??$Sad16_sse2@$07$03G@@YAIPBEH0H@Z		; Sad16_sse2<8,4,unsigned short>
PUBLIC	??$Sad16_sse2@$07$07G@@YAIPBEH0H@Z		; Sad16_sse2<8,8,unsigned short>
PUBLIC	??$Sad16_sse2@$07$0BA@G@@YAIPBEH0H@Z		; Sad16_sse2<8,16,unsigned short>
PUBLIC	??$Sad16_sse2@$0BA@$00G@@YAIPBEH0H@Z		; Sad16_sse2<16,1,unsigned short>
PUBLIC	??$Sad16_sse2@$0BA@$01G@@YAIPBEH0H@Z		; Sad16_sse2<16,2,unsigned short>
PUBLIC	??$Sad16_sse2@$0BA@$03G@@YAIPBEH0H@Z		; Sad16_sse2<16,4,unsigned short>
PUBLIC	??$Sad16_sse2@$0BA@$07G@@YAIPBEH0H@Z		; Sad16_sse2<16,8,unsigned short>
PUBLIC	??$Sad16_sse2@$0BA@$0BA@G@@YAIPBEH0H@Z		; Sad16_sse2<16,16,unsigned short>
PUBLIC	??$Sad16_sse2@$0BA@$0CA@G@@YAIPBEH0H@Z		; Sad16_sse2<16,32,unsigned short>
PUBLIC	??$Sad16_sse2@$0CA@$07G@@YAIPBEH0H@Z		; Sad16_sse2<32,8,unsigned short>
PUBLIC	??$Sad16_sse2@$0CA@$0BA@G@@YAIPBEH0H@Z		; Sad16_sse2<32,16,unsigned short>
PUBLIC	??$Sad16_sse2@$0CA@$0CA@G@@YAIPBEH0H@Z		; Sad16_sse2<32,32,unsigned short>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::allocate
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_second
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Get_data
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::allocate
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Isnil
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Min
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator++
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rrotate
PUBLIC	?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Color
PUBLIC	?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Isnil
PUBLIC	?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myval
PUBLIC	?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Max
PUBLIC	?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Min
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myhead
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Mysize
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::deallocate
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Myval
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator++
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_second
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Mynode
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::clear
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lmost
PUBLIC	?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Parent
PUBLIC	?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Right
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Construct
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::deallocate
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::end
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Freeheadnode
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myhead
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator*
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@AAU32@@Z ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> *>::pointer_to
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tidy
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator->
PUBLIC	??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >
PUBLIC	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
PUBLIC	_x264_pixel_satd_32x16_sse2
PUBLIC	_x264_pixel_satd_32x32_sse2
PUBLIC	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >
PUBLIC	_x264_pixel_satd_uint16_32x16_c
PUBLIC	_x264_pixel_satd_uint16_32x32_c
PUBLIC	?SADABS@@YAIH@Z					; SADABS
PUBLIC	?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_satd_function
PUBLIC	?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_sad_function
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$120
__catchsym$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$120 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$71
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$71 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
_TEXT	SEGMENT
$T2 = -60						; size = 16
$T3 = -44						; size = 16
$T4 = -28						; size = 16
__$EHRec$ = -12						; size = 12
$T5 = 0							; size = 16
$T6 = 0							; size = 16
$T7 = 16						; size = 16
$T8 = 16						; size = 16
_archlist$ = 32						; size = 20
$T9 = 36						; size = 16
_BlockX$ = 52						; size = 4
_BlockY$ = 56						; size = 4
$T10 = 60						; size = 16
$T11 = 60						; size = 16
$T12 = 60						; size = 16
$T13 = 60						; size = 16
$T14 = 60						; size = 16
$T15 = 60						; size = 16
$T16 = 60						; size = 16
$T17 = 60						; size = 16
$T18 = 60						; size = 16
$T19 = 60						; size = 16
$T20 = 60						; size = 16
$T21 = 60						; size = 16
$T22 = 60						; size = 16
$T23 = 60						; size = 16
$T24 = 60						; size = 16
$T25 = 60						; size = 16
$T26 = 60						; size = 16
$T27 = 60						; size = 16
$T28 = 60						; size = 16
$T29 = 60						; size = 16
$T30 = 60						; size = 16
$T31 = 60						; size = 16
$T32 = 60						; size = 16
$T33 = 60						; size = 16
$T34 = 60						; size = 16
$T35 = 60						; size = 16
$T36 = 60						; size = 16
$T37 = 60						; size = 16
$T38 = 60						; size = 16
$T39 = 60						; size = 16
$T40 = 60						; size = 16
$T41 = 60						; size = 16
$T42 = 60						; size = 16
$T43 = 60						; size = 16
$T44 = 60						; size = 16
$T45 = 60						; size = 16
$T46 = 60						; size = 16
$T47 = 60						; size = 16
$T48 = 60						; size = 16
$T49 = 60						; size = 16
$T50 = 60						; size = 16
$T51 = 60						; size = 16
$T52 = 60						; size = 16
$T53 = 60						; size = 16
$T54 = 60						; size = 16
$T55 = 60						; size = 16
$T56 = 60						; size = 16
$T57 = 60						; size = 16
$T58 = 60						; size = 16
$T59 = 60						; size = 16
$T60 = 60						; size = 16
$T61 = 60						; size = 16
$T62 = 60						; size = 16
$T63 = 60						; size = 16
$T64 = 60						; size = 16
$T65 = 60						; size = 16
$T66 = 60						; size = 16
$T67 = 60						; size = 16
$T68 = 60						; size = 16
$T69 = 60						; size = 16
$T70 = 60						; size = 16
$T71 = 60						; size = 16
$T72 = 60						; size = 16
$T73 = 60						; size = 16
$T74 = 60						; size = 16
$T75 = 60						; size = 16
$T76 = 60						; size = 16
$T77 = 60						; size = 16
$T78 = 60						; size = 16
$T79 = 60						; size = 16
$T80 = 60						; size = 16
$T81 = 60						; size = 16
$T82 = 60						; size = 16
$T83 = 60						; size = 16
$T84 = 60						; size = 16
$T85 = 60						; size = 16
$T86 = 60						; size = 16
$T87 = 60						; size = 16
$T88 = 60						; size = 16
$T89 = 60						; size = 16
$T90 = 60						; size = 16
$T91 = 60						; size = 16
$T92 = 60						; size = 16
$T93 = 60						; size = 16
$T94 = 60						; size = 16
$T95 = 60						; size = 16
$T96 = 60						; size = 16
$T97 = 60						; size = 16
$T98 = 60						; size = 16
$T99 = 60						; size = 16
$T100 = 60						; size = 16
$T101 = 60						; size = 16
$T102 = 60						; size = 16
$T103 = 60						; size = 16
$T104 = 60						; size = 16
$T105 = 60						; size = 16
$T106 = 60						; size = 16
$T107 = 60						; size = 16
$T108 = 60						; size = 16
$T109 = 60						; size = 16
$T110 = 60						; size = 16
_func_sad$ = 76						; size = 8
$T111 = 84						; size = 8
$T112 = 84						; size = 8
$T113 = 84						; size = 8
$T114 = 84						; size = 8
$T115 = 84						; size = 8
$T116 = 84						; size = 8
$T117 = 84						; size = 8
$T118 = 84						; size = 8
$T119 = 84						; size = 8
$T120 = 84						; size = 8
$T121 = 84						; size = 8
$T122 = 84						; size = 8
$T123 = 84						; size = 8
$T124 = 84						; size = 8
$T125 = 84						; size = 8
$T126 = 84						; size = 8
$T127 = 84						; size = 8
$T128 = 84						; size = 8
$T129 = 84						; size = 8
$T130 = 84						; size = 8
$T131 = 84						; size = 8
$T132 = 84						; size = 8
$T133 = 84						; size = 8
$T134 = 84						; size = 8
$T135 = 84						; size = 8
$T136 = 84						; size = 8
$T137 = 84						; size = 8
$T138 = 84						; size = 8
$T139 = 84						; size = 8
$T140 = 84						; size = 8
$T141 = 84						; size = 8
$T142 = 84						; size = 8
$T143 = 84						; size = 8
$T144 = 84						; size = 8
$T145 = 84						; size = 8
$T146 = 84						; size = 8
$T147 = 84						; size = 8
$T148 = 84						; size = 8
$T149 = 84						; size = 8
$T150 = 84						; size = 8
$T151 = 84						; size = 8
$T152 = 84						; size = 8
$T153 = 84						; size = 8
$T154 = 84						; size = 8
$T155 = 84						; size = 8
$T156 = 84						; size = 8
$T157 = 84						; size = 8
$T158 = 88						; size = 4
$T159 = 88						; size = 4
$T160 = 88						; size = 4
$T161 = 88						; size = 4
$T162 = 88						; size = 4
$T163 = 88						; size = 4
$T164 = 88						; size = 4
$T165 = 88						; size = 4
$T166 = 88						; size = 4
$T167 = 88						; size = 4
$T168 = 88						; size = 4
$T169 = 88						; size = 4
$T170 = 88						; size = 4
$T171 = 88						; size = 4
$T172 = 88						; size = 4
$T173 = 88						; size = 4
$T174 = 88						; size = 4
$T175 = 88						; size = 4
$T176 = 88						; size = 4
$T177 = 88						; size = 4
$T178 = 88						; size = 4
$T179 = 88						; size = 4
$T180 = 88						; size = 4
$T181 = 88						; size = 4
$T182 = 88						; size = 4
$T183 = 88						; size = 4
$T184 = 88						; size = 4
$T185 = 88						; size = 4
$T186 = 88						; size = 4
$T187 = 88						; size = 4
$T188 = 88						; size = 4
$T189 = 88						; size = 4
$T190 = 88						; size = 4
$T191 = 88						; size = 4
$T192 = 88						; size = 4
$T193 = 88						; size = 4
$T194 = 88						; size = 4
$T195 = 88						; size = 4
$T196 = 88						; size = 4
$T197 = 88						; size = 4
$T198 = 88						; size = 4
$T199 = 88						; size = 4
$T200 = 88						; size = 4
$T201 = 88						; size = 4
$T202 = 88						; size = 4
$T203 = 88						; size = 4
$T204 = 88						; size = 4
$T205 = 88						; size = 4
$T206 = 88						; size = 4
$T207 = 88						; size = 4
$T208 = 88						; size = 4
$T209 = 88						; size = 4
$T210 = 88						; size = 4
$T211 = 88						; size = 4
$T212 = 88						; size = 4
$T213 = 88						; size = 4
$T214 = 88						; size = 4
$T215 = 88						; size = 4
$T216 = 88						; size = 4
$T217 = 88						; size = 4
$T218 = 92						; size = 4
$T219 = 92						; size = 4
$T220 = 92						; size = 4
$T221 = 92						; size = 4
$T222 = 92						; size = 4
$T223 = 92						; size = 4
$T224 = 92						; size = 4
$T225 = 92						; size = 4
$T226 = 92						; size = 4
$T227 = 92						; size = 4
$T228 = 92						; size = 4
$T229 = 92						; size = 4
$T230 = 92						; size = 4
$T231 = 92						; size = 4
$T232 = 92						; size = 4
$T233 = 92						; size = 4
$T234 = 92						; size = 4
$T235 = 92						; size = 4
$T236 = 92						; size = 4
$T237 = 92						; size = 4
$T238 = 92						; size = 4
$T239 = 92						; size = 4
$T240 = 92						; size = 4
$T241 = 92						; size = 4
$T242 = 92						; size = 4
$T243 = 92						; size = 4
$T244 = 92						; size = 4
$T245 = 92						; size = 4
$T246 = 92						; size = 4
$T247 = 92						; size = 4
$T248 = 92						; size = 4
$T249 = 92						; size = 4
$T250 = 92						; size = 4
$T251 = 92						; size = 4
$T252 = 92						; size = 4
$T253 = 92						; size = 4
$T254 = 92						; size = 4
$T255 = 92						; size = 4
$T256 = 92						; size = 4
$T257 = 92						; size = 4
$T258 = 92						; size = 4
$T259 = 92						; size = 4
$T260 = 92						; size = 4
$T261 = 92						; size = 4
$T262 = 92						; size = 4
$T263 = 92						; size = 4
$T264 = 92						; size = 4
$T265 = 92						; size = 4
$T266 = 92						; size = 4
$T267 = 92						; size = 4
$T268 = 92						; size = 4
$T269 = 92						; size = 4
$T270 = 92						; size = 4
$T271 = 92						; size = 4
$T272 = 92						; size = 4
$T273 = 92						; size = 4
$T274 = 92						; size = 4
$T275 = 92						; size = 4
$T276 = 92						; size = 4
tv7297 = 96						; size = 4
$T277 = 96						; size = 4
$T278 = 96						; size = 4
$T279 = 96						; size = 4
$T280 = 96						; size = 4
$T281 = 96						; size = 4
$T282 = 96						; size = 4
$T283 = 96						; size = 4
$T284 = 96						; size = 4
$T285 = 96						; size = 4
$T286 = 96						; size = 4
$T287 = 96						; size = 4
$T288 = 96						; size = 4
$T289 = 96						; size = 4
$T290 = 96						; size = 4
$T291 = 96						; size = 4
$T292 = 96						; size = 4
$T293 = 96						; size = 4
$T294 = 96						; size = 4
$T295 = 96						; size = 4
$T296 = 96						; size = 4
$T297 = 96						; size = 4
$T298 = 96						; size = 4
$T299 = 96						; size = 4
$T300 = 96						; size = 4
$T301 = 96						; size = 4
$T302 = 96						; size = 4
$T303 = 96						; size = 4
$T304 = 96						; size = 4
$T305 = 96						; size = 4
$T306 = 96						; size = 4
$T307 = 96						; size = 4
$T308 = 96						; size = 4
$T309 = 96						; size = 4
$T310 = 96						; size = 4
$T311 = 96						; size = 4
$T312 = 96						; size = 4
$T313 = 96						; size = 4
$T314 = 96						; size = 4
$T315 = 96						; size = 4
$T316 = 96						; size = 4
$T317 = 96						; size = 4
$T318 = 96						; size = 4
$T319 = 96						; size = 4
$T320 = 96						; size = 4
$T321 = 96						; size = 4
$T322 = 96						; size = 4
$T323 = 96						; size = 4
$T324 = 96						; size = 4
$T325 = 96						; size = 4
$T326 = 96						; size = 4
$T327 = 96						; size = 4
$T328 = 96						; size = 4
$T329 = 96						; size = 4
$T330 = 96						; size = 4
$T331 = 96						; size = 4
$T332 = 96						; size = 4
$T333 = 96						; size = 4
$T334 = 96						; size = 4
$T335 = 96						; size = 4
_current_arch_try$336 = 100				; size = 4
$T337 = 100						; size = 4
$T338 = 100						; size = 4
$T339 = 100						; size = 4
$T340 = 100						; size = 4
$T341 = 100						; size = 4
$T342 = 100						; size = 4
$T343 = 100						; size = 4
$T344 = 100						; size = 4
$T345 = 100						; size = 4
$T346 = 100						; size = 4
$T347 = 100						; size = 4
$T348 = 100						; size = 4
$T349 = 100						; size = 4
$T350 = 100						; size = 4
$T351 = 100						; size = 4
$T352 = 100						; size = 4
$T353 = 100						; size = 4
$T354 = 100						; size = 4
$T355 = 100						; size = 4
$T356 = 100						; size = 4
$T357 = 100						; size = 4
$T358 = 100						; size = 4
$T359 = 100						; size = 4
$T360 = 100						; size = 4
$T361 = 100						; size = 4
$T362 = 100						; size = 4
$T363 = 100						; size = 4
$T364 = 100						; size = 4
$T365 = 100						; size = 4
$T366 = 100						; size = 4
$T367 = 100						; size = 4
$T368 = 100						; size = 4
$T369 = 100						; size = 4
$T370 = 100						; size = 4
$T371 = 100						; size = 4
$T372 = 100						; size = 4
$T373 = 100						; size = 4
$T374 = 100						; size = 4
$T375 = 100						; size = 4
$T376 = 100						; size = 4
$T377 = 100						; size = 4
$T378 = 100						; size = 4
$T379 = 100						; size = 4
$T380 = 100						; size = 4
$T381 = 100						; size = 4
$T382 = 100						; size = 4
$T383 = 100						; size = 4
$T384 = 100						; size = 4
$T385 = 100						; size = 4
$T386 = 100						; size = 4
$T387 = 100						; size = 4
$T388 = 100						; size = 4
$T389 = 100						; size = 4
$T390 = 100						; size = 4
$T391 = 100						; size = 4
$T392 = 100						; size = 4
$T393 = 100						; size = 4
$T394 = 100						; size = 4
$T395 = 100						; size = 4
_pixelsize$ = 112					; size = 4
_arch$ = 116						; size = 4
?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z PROC	; get_sad_function, COMDAT
; _BlockX$ = ecx
; _BlockY$ = edx

; 158  : {

	push	ebp
	lea	ebp, DWORD PTR [esp-104]
	sub	esp, 104				; 00000068H
	push	-1
	push	__ehhandler$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	mov	ebx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR _func_sad$[ebp], 0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 158  : {

	mov	esi, ecx
	mov	DWORD PTR _BlockY$[ebp], ebx
	push	edi
	mov	DWORD PTR _BlockX$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR _func_sad$[ebp+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR _func_sad$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T110[ebp]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 162  :     std::map<std::tuple<int, int, int, arch_t>, SADFunction*> func_sad;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	lea	eax, DWORD PTR $T157[ebp]
	push	eax
	movups	XMMWORD PTR $T110[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 164  :     func_sad[make_tuple(32, 32, 1, NO_SIMD)] = Sad_C<32, 32,uint8_t>;

	mov	eax, DWORD PTR $T157[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 164  :     func_sad[make_tuple(32, 32, 1, NO_SIMD)] = Sad_C<32, 32,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0CA@$0CA@E@@YAIPBEH0H@Z ; Sad_C<32,32,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T109[ebp]
	push	eax
	lea	eax, DWORD PTR $T156[ebp]
	push	eax
	movups	XMMWORD PTR $T109[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 165  :     func_sad[make_tuple(32, 16, 1, NO_SIMD)] = Sad_C<32, 16,uint8_t>;

	mov	eax, DWORD PTR $T156[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 165  :     func_sad[make_tuple(32, 16, 1, NO_SIMD)] = Sad_C<32, 16,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0CA@$0BA@E@@YAIPBEH0H@Z ; Sad_C<32,16,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T108[ebp]
	push	eax
	lea	eax, DWORD PTR $T155[ebp]
	push	eax
	movups	XMMWORD PTR $T108[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 166  :     func_sad[make_tuple(32, 8 , 1, NO_SIMD)] = Sad_C<32, 8,uint8_t>;

	mov	eax, DWORD PTR $T155[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 166  :     func_sad[make_tuple(32, 8 , 1, NO_SIMD)] = Sad_C<32, 8,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0CA@$07E@@YAIPBEH0H@Z ; Sad_C<32,8,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T107[ebp]
	push	eax
	lea	eax, DWORD PTR $T154[ebp]
	push	eax
	movups	XMMWORD PTR $T107[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 167  :     func_sad[make_tuple(16, 32, 1, NO_SIMD)] = Sad_C<16, 32,uint8_t>;

	mov	eax, DWORD PTR $T154[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 167  :     func_sad[make_tuple(16, 32, 1, NO_SIMD)] = Sad_C<16, 32,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$0CA@E@@YAIPBEH0H@Z ; Sad_C<16,32,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T106[ebp]
	push	eax
	lea	eax, DWORD PTR $T153[ebp]
	push	eax
	movups	XMMWORD PTR $T106[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 168  :     func_sad[make_tuple(16, 16, 1, NO_SIMD)] = Sad_C<16, 16,uint8_t>;

	mov	eax, DWORD PTR $T153[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 168  :     func_sad[make_tuple(16, 16, 1, NO_SIMD)] = Sad_C<16, 16,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$0BA@E@@YAIPBEH0H@Z ; Sad_C<16,16,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T105[ebp]
	push	eax
	lea	eax, DWORD PTR $T152[ebp]
	push	eax
	movups	XMMWORD PTR $T105[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 169  :     func_sad[make_tuple(16, 8 , 1, NO_SIMD)] = Sad_C<16, 8,uint8_t>;

	mov	eax, DWORD PTR $T152[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 169  :     func_sad[make_tuple(16, 8 , 1, NO_SIMD)] = Sad_C<16, 8,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$07E@@YAIPBEH0H@Z ; Sad_C<16,8,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T104[ebp]
	push	eax
	lea	eax, DWORD PTR $T151[ebp]
	push	eax
	movups	XMMWORD PTR $T104[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 170  :     func_sad[make_tuple(16, 4 , 1, NO_SIMD)] = Sad_C<16, 4,uint8_t>;

	mov	eax, DWORD PTR $T151[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 170  :     func_sad[make_tuple(16, 4 , 1, NO_SIMD)] = Sad_C<16, 4,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$03E@@YAIPBEH0H@Z ; Sad_C<16,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T103[ebp]
	push	eax
	lea	eax, DWORD PTR $T150[ebp]
	push	eax
	movups	XMMWORD PTR $T103[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 171  :     func_sad[make_tuple(16, 2 , 1, NO_SIMD)] = Sad_C<16, 2,uint8_t>;

	mov	eax, DWORD PTR $T150[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 171  :     func_sad[make_tuple(16, 2 , 1, NO_SIMD)] = Sad_C<16, 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$01E@@YAIPBEH0H@Z ; Sad_C<16,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T102[ebp]
	push	eax
	lea	eax, DWORD PTR $T149[ebp]
	push	eax
	movups	XMMWORD PTR $T102[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 172  :     func_sad[make_tuple(16, 1 , 1, NO_SIMD)] = Sad_C<16, 1,uint8_t>;

	mov	eax, DWORD PTR $T149[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 172  :     func_sad[make_tuple(16, 1 , 1, NO_SIMD)] = Sad_C<16, 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$00E@@YAIPBEH0H@Z ; Sad_C<16,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T101[ebp]
	push	eax
	lea	eax, DWORD PTR $T148[ebp]
	push	eax
	movups	XMMWORD PTR $T101[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 173  :     func_sad[make_tuple(8 , 16, 1, NO_SIMD)] = Sad_C<8 , 16,uint8_t>;

	mov	eax, DWORD PTR $T148[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 173  :     func_sad[make_tuple(8 , 16, 1, NO_SIMD)] = Sad_C<8 , 16,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$0BA@E@@YAIPBEH0H@Z ; Sad_C<8,16,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T100[ebp]
	push	eax
	lea	eax, DWORD PTR $T147[ebp]
	push	eax
	movups	XMMWORD PTR $T100[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 174  :     func_sad[make_tuple(8 , 8 , 1, NO_SIMD)] = Sad_C<8 , 8,uint8_t>;

	mov	eax, DWORD PTR $T147[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 174  :     func_sad[make_tuple(8 , 8 , 1, NO_SIMD)] = Sad_C<8 , 8,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$07E@@YAIPBEH0H@Z ; Sad_C<8,8,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T99[ebp]
	push	eax
	lea	eax, DWORD PTR $T146[ebp]
	push	eax
	movups	XMMWORD PTR $T99[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 175  :     func_sad[make_tuple(8 , 4 , 1, NO_SIMD)] = Sad_C<8 , 4,uint8_t>;

	mov	eax, DWORD PTR $T146[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 175  :     func_sad[make_tuple(8 , 4 , 1, NO_SIMD)] = Sad_C<8 , 4,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$03E@@YAIPBEH0H@Z ; Sad_C<8,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T98[ebp]
	push	eax
	lea	eax, DWORD PTR $T145[ebp]
	push	eax
	movups	XMMWORD PTR $T98[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 176  :     func_sad[make_tuple(8 , 2 , 1, NO_SIMD)] = Sad_C<8 , 2,uint8_t>;

	mov	eax, DWORD PTR $T145[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 176  :     func_sad[make_tuple(8 , 2 , 1, NO_SIMD)] = Sad_C<8 , 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$01E@@YAIPBEH0H@Z ; Sad_C<8,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T97[ebp]
	push	eax
	lea	eax, DWORD PTR $T144[ebp]
	push	eax
	movups	XMMWORD PTR $T97[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 177  :     func_sad[make_tuple(8 , 1 , 1, NO_SIMD)] = Sad_C<8 , 1,uint8_t>;

	mov	eax, DWORD PTR $T144[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 177  :     func_sad[make_tuple(8 , 1 , 1, NO_SIMD)] = Sad_C<8 , 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$00E@@YAIPBEH0H@Z ; Sad_C<8,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T96[ebp]
	push	eax
	lea	eax, DWORD PTR $T143[ebp]
	push	eax
	movups	XMMWORD PTR $T96[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 178  :     func_sad[make_tuple(4 , 8 , 1, NO_SIMD)] = Sad_C<4 , 8,uint8_t>;

	mov	eax, DWORD PTR $T143[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000040000000100000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 178  :     func_sad[make_tuple(4 , 8 , 1, NO_SIMD)] = Sad_C<4 , 8,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$07E@@YAIPBEH0H@Z ; Sad_C<4,8,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T95[ebp]
	push	eax
	lea	eax, DWORD PTR $T142[ebp]
	push	eax
	movups	XMMWORD PTR $T95[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 179  :     func_sad[make_tuple(4 , 4 , 1, NO_SIMD)] = Sad_C<4 , 4,uint8_t>;

	mov	eax, DWORD PTR $T142[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000020000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 179  :     func_sad[make_tuple(4 , 4 , 1, NO_SIMD)] = Sad_C<4 , 4,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$03E@@YAIPBEH0H@Z ; Sad_C<4,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T94[ebp]
	push	eax
	lea	eax, DWORD PTR $T141[ebp]
	push	eax
	movups	XMMWORD PTR $T94[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 180  :     func_sad[make_tuple(4 , 2 , 1, NO_SIMD)] = Sad_C<4 , 2,uint8_t>;

	mov	eax, DWORD PTR $T141[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 180  :     func_sad[make_tuple(4 , 2 , 1, NO_SIMD)] = Sad_C<4 , 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$01E@@YAIPBEH0H@Z ; Sad_C<4,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T93[ebp]
	push	eax
	lea	eax, DWORD PTR $T140[ebp]
	push	eax
	movups	XMMWORD PTR $T93[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 181  :     func_sad[make_tuple(4 , 1 , 1, NO_SIMD)] = Sad_C<4 , 1,uint8_t>;

	mov	eax, DWORD PTR $T140[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000040000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 181  :     func_sad[make_tuple(4 , 1 , 1, NO_SIMD)] = Sad_C<4 , 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$00E@@YAIPBEH0H@Z ; Sad_C<4,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T92[ebp]
	push	eax
	lea	eax, DWORD PTR $T139[ebp]
	push	eax
	movups	XMMWORD PTR $T92[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 182  :     func_sad[make_tuple(2 , 4 , 1, NO_SIMD)] = Sad_C<2 , 4,uint8_t>;

	mov	eax, DWORD PTR $T139[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000020000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 182  :     func_sad[make_tuple(2 , 4 , 1, NO_SIMD)] = Sad_C<2 , 4,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$01$03E@@YAIPBEH0H@Z ; Sad_C<2,4,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T91[ebp]
	push	eax
	lea	eax, DWORD PTR $T138[ebp]
	push	eax
	movups	XMMWORD PTR $T91[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 183  :     func_sad[make_tuple(2 , 2 , 1, NO_SIMD)] = Sad_C<2 , 2,uint8_t>;

	mov	eax, DWORD PTR $T138[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000010000000100000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 183  :     func_sad[make_tuple(2 , 2 , 1, NO_SIMD)] = Sad_C<2 , 2,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$01$01E@@YAIPBEH0H@Z ; Sad_C<2,2,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T90[ebp]
	push	eax
	lea	eax, DWORD PTR $T137[ebp]
	push	eax
	movups	XMMWORD PTR $T90[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 184  :     func_sad[make_tuple(2 , 1 , 1, NO_SIMD)] = Sad_C<2 , 1,uint8_t>;

	mov	eax, DWORD PTR $T137[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 184  :     func_sad[make_tuple(2 , 1 , 1, NO_SIMD)] = Sad_C<2 , 1,uint8_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$01$00E@@YAIPBEH0H@Z ; Sad_C<2,1,unsigned char>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T89[ebp]
	push	eax
	lea	eax, DWORD PTR $T136[ebp]
	push	eax
	movups	XMMWORD PTR $T89[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 186  :     func_sad[make_tuple(32, 32, 2, NO_SIMD)] = Sad_C<32, 32,uint16_t>;

	mov	eax, DWORD PTR $T136[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 186  :     func_sad[make_tuple(32, 32, 2, NO_SIMD)] = Sad_C<32, 32,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0CA@$0CA@G@@YAIPBEH0H@Z ; Sad_C<32,32,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T88[ebp]
	push	eax
	lea	eax, DWORD PTR $T135[ebp]
	push	eax
	movups	XMMWORD PTR $T88[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 187  :     func_sad[make_tuple(32, 16, 2, NO_SIMD)] = Sad_C<32, 16,uint16_t>;

	mov	eax, DWORD PTR $T135[ebp]
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0CA@$0BA@G@@YAIPBEH0H@Z ; Sad_C<32,16,unsigned short>
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000200000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T87[ebp]
	push	eax
	lea	eax, DWORD PTR $T134[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	movups	XMMWORD PTR $T87[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 188  :     func_sad[make_tuple(32, 8 , 2, NO_SIMD)] = Sad_C<32, 8,uint16_t>;

	mov	eax, DWORD PTR $T134[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 188  :     func_sad[make_tuple(32, 8 , 2, NO_SIMD)] = Sad_C<32, 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0CA@$07G@@YAIPBEH0H@Z ; Sad_C<32,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T86[ebp]
	push	eax
	lea	eax, DWORD PTR $T133[ebp]
	push	eax
	movups	XMMWORD PTR $T86[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 189  :     func_sad[make_tuple(16, 32, 2, NO_SIMD)] = Sad_C<16, 32,uint16_t>;

	mov	eax, DWORD PTR $T133[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 189  :     func_sad[make_tuple(16, 32, 2, NO_SIMD)] = Sad_C<16, 32,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$0CA@G@@YAIPBEH0H@Z ; Sad_C<16,32,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T85[ebp]
	push	eax
	lea	eax, DWORD PTR $T132[ebp]
	push	eax
	movups	XMMWORD PTR $T85[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 190  :     func_sad[make_tuple(16, 16, 2, NO_SIMD)] = Sad_C<16, 16,uint16_t>;

	mov	eax, DWORD PTR $T132[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 190  :     func_sad[make_tuple(16, 16, 2, NO_SIMD)] = Sad_C<16, 16,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$0BA@G@@YAIPBEH0H@Z ; Sad_C<16,16,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T84[ebp]
	push	eax
	lea	eax, DWORD PTR $T131[ebp]
	push	eax
	movups	XMMWORD PTR $T84[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 191  :     func_sad[make_tuple(16, 8 , 2, NO_SIMD)] = Sad_C<16, 8,uint16_t>;

	mov	eax, DWORD PTR $T131[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000040000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 191  :     func_sad[make_tuple(16, 8 , 2, NO_SIMD)] = Sad_C<16, 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$07G@@YAIPBEH0H@Z ; Sad_C<16,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T83[ebp]
	push	eax
	lea	eax, DWORD PTR $T130[ebp]
	push	eax
	movups	XMMWORD PTR $T83[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 192  :     func_sad[make_tuple(16, 4 , 2, NO_SIMD)] = Sad_C<16, 4,uint16_t>;

	mov	eax, DWORD PTR $T130[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 192  :     func_sad[make_tuple(16, 4 , 2, NO_SIMD)] = Sad_C<16, 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$03G@@YAIPBEH0H@Z ; Sad_C<16,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T82[ebp]
	push	eax
	lea	eax, DWORD PTR $T129[ebp]
	push	eax
	movups	XMMWORD PTR $T82[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 193  :     func_sad[make_tuple(16, 2 , 2, NO_SIMD)] = Sad_C<16, 2,uint16_t>;

	mov	eax, DWORD PTR $T129[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 193  :     func_sad[make_tuple(16, 2 , 2, NO_SIMD)] = Sad_C<16, 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$01G@@YAIPBEH0H@Z ; Sad_C<16,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T81[ebp]
	push	eax
	lea	eax, DWORD PTR $T128[ebp]
	push	eax
	movups	XMMWORD PTR $T81[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 194  :     func_sad[make_tuple(16, 1 , 2, NO_SIMD)] = Sad_C<16, 1,uint16_t>;

	mov	eax, DWORD PTR $T128[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 194  :     func_sad[make_tuple(16, 1 , 2, NO_SIMD)] = Sad_C<16, 1,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$0BA@$00G@@YAIPBEH0H@Z ; Sad_C<16,1,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T80[ebp]
	push	eax
	lea	eax, DWORD PTR $T127[ebp]
	push	eax
	movups	XMMWORD PTR $T80[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 195  :     func_sad[make_tuple(8 , 16, 2, NO_SIMD)] = Sad_C<8 , 16,uint16_t>;

	mov	eax, DWORD PTR $T127[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$0BA@G@@YAIPBEH0H@Z ; Sad_C<8,16,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T79[ebp]
	push	eax
	lea	eax, DWORD PTR $T126[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	movups	XMMWORD PTR $T79[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 196  :     func_sad[make_tuple(8 , 8 , 2, NO_SIMD)] = Sad_C<8 , 8,uint16_t>;

	mov	eax, DWORD PTR $T126[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 196  :     func_sad[make_tuple(8 , 8 , 2, NO_SIMD)] = Sad_C<8 , 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$07G@@YAIPBEH0H@Z ; Sad_C<8,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T78[ebp]
	push	eax
	lea	eax, DWORD PTR $T125[ebp]
	push	eax
	movups	XMMWORD PTR $T78[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 197  :     func_sad[make_tuple(8 , 4 , 2, NO_SIMD)] = Sad_C<8 , 4,uint16_t>;

	mov	eax, DWORD PTR $T125[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 197  :     func_sad[make_tuple(8 , 4 , 2, NO_SIMD)] = Sad_C<8 , 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$03G@@YAIPBEH0H@Z ; Sad_C<8,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T77[ebp]
	push	eax
	lea	eax, DWORD PTR $T124[ebp]
	push	eax
	movups	XMMWORD PTR $T77[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 198  :     func_sad[make_tuple(8 , 2 , 2, NO_SIMD)] = Sad_C<8 , 2,uint16_t>;

	mov	eax, DWORD PTR $T124[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 198  :     func_sad[make_tuple(8 , 2 , 2, NO_SIMD)] = Sad_C<8 , 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$01G@@YAIPBEH0H@Z ; Sad_C<8,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T76[ebp]
	push	eax
	lea	eax, DWORD PTR $T123[ebp]
	push	eax
	movups	XMMWORD PTR $T76[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 199  :     func_sad[make_tuple(8 , 1 , 2, NO_SIMD)] = Sad_C<8 , 1,uint16_t>;

	mov	eax, DWORD PTR $T123[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000080000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 199  :     func_sad[make_tuple(8 , 1 , 2, NO_SIMD)] = Sad_C<8 , 1,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$07$00G@@YAIPBEH0H@Z ; Sad_C<8,1,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T75[ebp]
	push	eax
	lea	eax, DWORD PTR $T122[ebp]
	push	eax
	movups	XMMWORD PTR $T75[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 200  :     func_sad[make_tuple(4 , 8 , 2, NO_SIMD)] = Sad_C<4 , 8,uint16_t>;

	mov	eax, DWORD PTR $T122[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000040000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 200  :     func_sad[make_tuple(4 , 8 , 2, NO_SIMD)] = Sad_C<4 , 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$07G@@YAIPBEH0H@Z ; Sad_C<4,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T74[ebp]
	push	eax
	lea	eax, DWORD PTR $T121[ebp]
	push	eax
	movups	XMMWORD PTR $T74[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 201  :     func_sad[make_tuple(4 , 4 , 2, NO_SIMD)] = Sad_C<4 , 4,uint16_t>;

	mov	eax, DWORD PTR $T121[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 201  :     func_sad[make_tuple(4 , 4 , 2, NO_SIMD)] = Sad_C<4 , 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$03G@@YAIPBEH0H@Z ; Sad_C<4,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T73[ebp]
	push	eax
	lea	eax, DWORD PTR $T120[ebp]
	push	eax
	movups	XMMWORD PTR $T73[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 202  :     func_sad[make_tuple(4 , 2 , 2, NO_SIMD)] = Sad_C<4 , 2,uint16_t>;

	mov	eax, DWORD PTR $T120[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 202  :     func_sad[make_tuple(4 , 2 , 2, NO_SIMD)] = Sad_C<4 , 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$01G@@YAIPBEH0H@Z ; Sad_C<4,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T72[ebp]
	push	eax
	lea	eax, DWORD PTR $T119[ebp]
	push	eax
	movups	XMMWORD PTR $T72[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 203  :     func_sad[make_tuple(4 , 1 , 2, NO_SIMD)] = Sad_C<4 , 1,uint16_t>;

	mov	eax, DWORD PTR $T119[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000040000000200000000
	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$03$00G@@YAIPBEH0H@Z ; Sad_C<4,1,unsigned short>
	movups	XMMWORD PTR $T71[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T71[ebp]
	push	eax
	lea	eax, DWORD PTR $T118[ebp]
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 204  :     func_sad[make_tuple(2 , 4 , 2, NO_SIMD)] = Sad_C<2 , 4,uint16_t>;

	mov	eax, DWORD PTR $T118[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000020000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 204  :     func_sad[make_tuple(2 , 4 , 2, NO_SIMD)] = Sad_C<2 , 4,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$01$03G@@YAIPBEH0H@Z ; Sad_C<2,4,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T70[ebp]
	push	eax
	lea	eax, DWORD PTR $T117[ebp]
	push	eax
	movups	XMMWORD PTR $T70[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 205  :     func_sad[make_tuple(2 , 2 , 2, NO_SIMD)] = Sad_C<2 , 2,uint16_t>;

	mov	eax, DWORD PTR $T117[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000010000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 205  :     func_sad[make_tuple(2 , 2 , 2, NO_SIMD)] = Sad_C<2 , 2,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$01$01G@@YAIPBEH0H@Z ; Sad_C<2,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T69[ebp]
	push	eax
	lea	eax, DWORD PTR $T116[ebp]
	push	eax
	movups	XMMWORD PTR $T69[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 206  :     func_sad[make_tuple(2 , 1 , 2, NO_SIMD)] = Sad_C<2 , 1,uint16_t>;

	mov	eax, DWORD PTR $T116[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000200000005
; File c:\github\mvtools\sources\sadfunctions.cpp

; 206  :     func_sad[make_tuple(2 , 1 , 2, NO_SIMD)] = Sad_C<2 , 1,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad_C@$01$00G@@YAIPBEH0H@Z ; Sad_C<2,1,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T68[ebp]
	push	eax
	lea	eax, DWORD PTR $T115[ebp]
	push	eax
	movups	XMMWORD PTR $T68[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 211  :     func_sad[make_tuple(32, 32, 2, USE_AVX)] = Sad16_sse2_avx<32, 32,uint16_t>;

	mov	eax, DWORD PTR $T115[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000200000005
; File c:\github\mvtools\sources\sadfunctions.cpp

; 211  :     func_sad[make_tuple(32, 32, 2, USE_AVX)] = Sad16_sse2_avx<32, 32,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad16_sse2_avx@$0CA@$0CA@G@@YAIPBEH0H@Z ; Sad16_sse2_avx<32,32,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T67[ebp]
	push	eax
	lea	eax, DWORD PTR $T114[ebp]
	push	eax
	movups	XMMWORD PTR $T67[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 212  :     func_sad[make_tuple(32, 16, 2, USE_AVX)] = Sad16_sse2_avx<32, 16,uint16_t>;

	mov	eax, DWORD PTR $T114[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000080000000200000005
; File c:\github\mvtools\sources\sadfunctions.cpp

; 212  :     func_sad[make_tuple(32, 16, 2, USE_AVX)] = Sad16_sse2_avx<32, 16,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad16_sse2_avx@$0CA@$0BA@G@@YAIPBEH0H@Z ; Sad16_sse2_avx<32,16,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T66[ebp]
	push	eax
	lea	eax, DWORD PTR $T113[ebp]
	push	eax
	movups	XMMWORD PTR $T66[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 213  :     func_sad[make_tuple(32, 8 , 2, USE_AVX)] = Sad16_sse2_avx<32, 8,uint16_t>;

	mov	eax, DWORD PTR $T113[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000200000000200000005
; File c:\github\mvtools\sources\sadfunctions.cpp

; 213  :     func_sad[make_tuple(32, 8 , 2, USE_AVX)] = Sad16_sse2_avx<32, 8,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad16_sse2_avx@$0CA@$07G@@YAIPBEH0H@Z ; Sad16_sse2_avx<32,8,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T65[ebp]
	push	eax
	lea	eax, DWORD PTR $T112[ebp]
	push	eax
	movups	XMMWORD PTR $T65[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 214  :     func_sad[make_tuple(16, 32, 2, USE_AVX)] = Sad16_sse2_avx<16, 32,uint16_t>;

	mov	eax, DWORD PTR $T112[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_sad$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000200000005
; File c:\github\mvtools\sources\sadfunctions.cpp

; 214  :     func_sad[make_tuple(16, 32, 2, USE_AVX)] = Sad16_sse2_avx<16, 32,uint16_t>;

	mov	DWORD PTR [eax+32], OFFSET ??$Sad16_sse2_avx@$0BA@$0CA@G@@YAIPBEH0H@Z ; Sad16_sse2_avx<16,32,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T64[ebp]
	push	eax
	lea	eax, DWORD PTR $T111[ebp]
	push	eax
	movups	XMMWORD PTR $T64[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 215  :     func_sad[make_tuple(16, 16, 2, USE_AVX)] = Sad16_sse2_avx<16, 16,uint16_t>;

	mov	eax, DWORD PTR $T111[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000200000005
	mov	DWORD PTR [eax+32], OFFSET ??$Sad16_sse2_avx@$0BA@$0BA@G@@YAIPBEH0H@Z ; Sad16_sse2_avx<16,16,unsigned short>

; 216  :     func_sad[make_tuple(16, 8 , 2, USE_AVX)] = Sad16_sse2_avx<16, 8,uint16_t>;

	lea	eax, DWORD PTR $T63[ebp]
	movups	XMMWORD PTR $T63[ebp], xmm0
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 217  :     func_sad[make_tuple(16, 4 , 2, USE_AVX)] = Sad16_sse2_avx<16, 4,uint16_t>;

	lea	edx, DWORD PTR $T217[ebp]
	mov	DWORD PTR $T395[ebp], 5
	lea	ecx, DWORD PTR $T62[ebp]
	mov	DWORD PTR $T276[ebp], 2
	mov	DWORD PTR $T335[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$0BA@$07G@@YAIPBEH0H@Z ; Sad16_sse2_avx<16,8,unsigned short>
	lea	eax, DWORD PTR $T395[ebp]
	push	eax
	lea	eax, DWORD PTR $T276[ebp]
	mov	DWORD PTR $T217[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T335[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 218  :     func_sad[make_tuple(16, 2 , 2, USE_AVX)] = Sad16_sse2_avx<16, 2,uint16_t>;

	lea	edx, DWORD PTR $T394[ebp]
	mov	DWORD PTR $T216[ebp], 5
	lea	ecx, DWORD PTR $T61[ebp]
	mov	DWORD PTR $T334[ebp], 2
	mov	DWORD PTR $T275[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$0BA@$03G@@YAIPBEH0H@Z ; Sad16_sse2_avx<16,4,unsigned short>
	lea	eax, DWORD PTR $T216[ebp]
	push	eax
	lea	eax, DWORD PTR $T334[ebp]
	mov	DWORD PTR $T394[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T275[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 219  :     func_sad[make_tuple(16, 1 , 2, USE_AVX)] = Sad16_sse2_avx<16, 1,uint16_t>;

	lea	edx, DWORD PTR $T393[ebp]
	mov	DWORD PTR $T215[ebp], 5
	lea	ecx, DWORD PTR $T60[ebp]
	mov	DWORD PTR $T333[ebp], 2
	mov	DWORD PTR $T274[ebp], 1
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$0BA@$01G@@YAIPBEH0H@Z ; Sad16_sse2_avx<16,2,unsigned short>
	lea	eax, DWORD PTR $T215[ebp]
	push	eax
	lea	eax, DWORD PTR $T333[ebp]
	mov	DWORD PTR $T393[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T274[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 220  :     func_sad[make_tuple(8 , 16, 2, USE_AVX)] = Sad16_sse2_avx<8 , 16,uint16_t>;

	lea	edx, DWORD PTR $T392[ebp]
	mov	DWORD PTR $T214[ebp], 5
	lea	ecx, DWORD PTR $T59[ebp]
	mov	DWORD PTR $T332[ebp], 2
	mov	DWORD PTR $T273[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$0BA@$00G@@YAIPBEH0H@Z ; Sad16_sse2_avx<16,1,unsigned short>
	lea	eax, DWORD PTR $T214[ebp]
	push	eax
	lea	eax, DWORD PTR $T332[ebp]
	mov	DWORD PTR $T392[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T273[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 221  :     func_sad[make_tuple(8 , 8 , 2, USE_AVX)] = Sad16_sse2_avx<8 , 8,uint16_t>;

	mov	DWORD PTR $T213[ebp], 5
	mov	DWORD PTR $T331[ebp], 2
	mov	DWORD PTR $T272[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$07$0BA@G@@YAIPBEH0H@Z ; Sad16_sse2_avx<8,16,unsigned short>
	lea	eax, DWORD PTR $T213[ebp]
	mov	DWORD PTR $T391[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T331[ebp]
	push	eax
	lea	eax, DWORD PTR $T272[ebp]
	push	eax
	lea	edx, DWORD PTR $T391[ebp]
	lea	ecx, DWORD PTR $T58[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 222  :     func_sad[make_tuple(8 , 4 , 2, USE_AVX)] = Sad16_sse2_avx<8 , 4,uint16_t>;

	lea	edx, DWORD PTR $T390[ebp]
	mov	DWORD PTR $T212[ebp], 5
	lea	ecx, DWORD PTR $T57[ebp]
	mov	DWORD PTR $T330[ebp], 2
	mov	DWORD PTR $T271[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$07$07G@@YAIPBEH0H@Z ; Sad16_sse2_avx<8,8,unsigned short>
	lea	eax, DWORD PTR $T212[ebp]
	push	eax
	lea	eax, DWORD PTR $T330[ebp]
	mov	DWORD PTR $T390[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T271[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 223  :     func_sad[make_tuple(8 , 2 , 2, USE_AVX)] = Sad16_sse2_avx<8 , 2,uint16_t>;

	lea	edx, DWORD PTR $T389[ebp]
	mov	DWORD PTR $T211[ebp], 5
	lea	ecx, DWORD PTR $T56[ebp]
	mov	DWORD PTR $T329[ebp], 2
	mov	DWORD PTR $T270[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$07$03G@@YAIPBEH0H@Z ; Sad16_sse2_avx<8,4,unsigned short>
	lea	eax, DWORD PTR $T211[ebp]
	push	eax
	lea	eax, DWORD PTR $T329[ebp]
	mov	DWORD PTR $T389[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T270[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 224  :     func_sad[make_tuple(8 , 1 , 2, USE_AVX)] = Sad16_sse2_avx<8 , 1,uint16_t>;

	lea	edx, DWORD PTR $T388[ebp]
	mov	DWORD PTR $T210[ebp], 5
	lea	ecx, DWORD PTR $T55[ebp]
	mov	DWORD PTR $T328[ebp], 2
	mov	DWORD PTR $T269[ebp], 1
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$07$01G@@YAIPBEH0H@Z ; Sad16_sse2_avx<8,2,unsigned short>
	lea	eax, DWORD PTR $T210[ebp]
	push	eax
	lea	eax, DWORD PTR $T328[ebp]
	mov	DWORD PTR $T388[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T269[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 225  :     func_sad[make_tuple(4 , 8 , 2, USE_AVX)] = Sad16_sse2_avx<4 , 8,uint16_t>;

	lea	edx, DWORD PTR $T387[ebp]
	mov	DWORD PTR $T209[ebp], 5
	lea	ecx, DWORD PTR $T54[ebp]
	mov	DWORD PTR $T327[ebp], 2
	mov	DWORD PTR $T268[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$07$00G@@YAIPBEH0H@Z ; Sad16_sse2_avx<8,1,unsigned short>
	lea	eax, DWORD PTR $T209[ebp]
	push	eax
	lea	eax, DWORD PTR $T327[ebp]
	mov	DWORD PTR $T387[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T268[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 226  :     func_sad[make_tuple(4 , 4 , 2, USE_AVX)] = Sad16_sse2_avx<4 , 4,uint16_t>;

	lea	edx, DWORD PTR $T386[ebp]
	mov	DWORD PTR $T208[ebp], 5
	lea	ecx, DWORD PTR $T53[ebp]
	mov	DWORD PTR $T326[ebp], 2
	mov	DWORD PTR $T267[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$03$07G@@YAIPBEH0H@Z ; Sad16_sse2_avx<4,8,unsigned short>
	lea	eax, DWORD PTR $T208[ebp]
	push	eax
	lea	eax, DWORD PTR $T326[ebp]
	mov	DWORD PTR $T386[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T267[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 227  :     func_sad[make_tuple(4 , 2 , 2, USE_AVX)] = Sad16_sse2_avx<4 , 2,uint16_t>;

	lea	edx, DWORD PTR $T385[ebp]
	mov	DWORD PTR $T207[ebp], 5
	lea	ecx, DWORD PTR $T52[ebp]
	mov	DWORD PTR $T325[ebp], 2
	mov	DWORD PTR $T266[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$03$03G@@YAIPBEH0H@Z ; Sad16_sse2_avx<4,4,unsigned short>
	lea	eax, DWORD PTR $T207[ebp]
	push	eax
	lea	eax, DWORD PTR $T325[ebp]
	mov	DWORD PTR $T385[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T266[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 228  :     //func_sad[make_tuple(4 , 1 , 2, USE_AVX)] = Sad16_sse2_avx<4 , 1,uint16_t>; // 8 bytes with height=1 not supported for SSE2
; 229  : 
; 230  :     // PF SAD 16 SIMD intrinsic functions
; 231  :     // only for >=8 bytes widths
; 232  :     func_sad[make_tuple(32, 32, 2, USE_SSE2)] = Sad16_sse2<32, 32,uint16_t>;

	lea	edx, DWORD PTR $T384[ebp]
	mov	DWORD PTR $T206[ebp], 2
	lea	ecx, DWORD PTR $T51[ebp]
	mov	DWORD PTR $T324[ebp], 2
	mov	DWORD PTR $T265[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2_avx@$03$01G@@YAIPBEH0H@Z ; Sad16_sse2_avx<4,2,unsigned short>
	lea	eax, DWORD PTR $T206[ebp]
	push	eax
	lea	eax, DWORD PTR $T324[ebp]
	mov	DWORD PTR $T384[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T265[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 233  :     func_sad[make_tuple(32, 16, 2, USE_SSE2)] = Sad16_sse2<32, 16,uint16_t>;

	lea	edx, DWORD PTR $T383[ebp]
	mov	DWORD PTR $T205[ebp], 2
	lea	ecx, DWORD PTR $T50[ebp]
	mov	DWORD PTR $T323[ebp], 2
	mov	DWORD PTR $T264[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0CA@$0CA@G@@YAIPBEH0H@Z ; Sad16_sse2<32,32,unsigned short>
	lea	eax, DWORD PTR $T205[ebp]
	push	eax
	lea	eax, DWORD PTR $T323[ebp]
	mov	DWORD PTR $T383[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T264[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 234  :     func_sad[make_tuple(32, 8 , 2, USE_SSE2)] = Sad16_sse2<32, 8,uint16_t>;

	mov	DWORD PTR $T204[ebp], 2
	mov	DWORD PTR $T322[ebp], 2
	mov	DWORD PTR $T263[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0CA@$0BA@G@@YAIPBEH0H@Z ; Sad16_sse2<32,16,unsigned short>
	lea	eax, DWORD PTR $T204[ebp]
	mov	DWORD PTR $T382[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T322[ebp]
	push	eax
	lea	eax, DWORD PTR $T263[ebp]
	push	eax
	lea	edx, DWORD PTR $T382[ebp]
	lea	ecx, DWORD PTR $T49[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 235  :     func_sad[make_tuple(16, 32, 2, USE_SSE2)] = Sad16_sse2<16, 32,uint16_t>;

	lea	edx, DWORD PTR $T381[ebp]
	mov	DWORD PTR $T203[ebp], 2
	lea	ecx, DWORD PTR $T48[ebp]
	mov	DWORD PTR $T321[ebp], 2
	mov	DWORD PTR $T262[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0CA@$07G@@YAIPBEH0H@Z ; Sad16_sse2<32,8,unsigned short>
	lea	eax, DWORD PTR $T203[ebp]
	push	eax
	lea	eax, DWORD PTR $T321[ebp]
	mov	DWORD PTR $T381[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T262[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 236  :     func_sad[make_tuple(16, 16, 2, USE_SSE2)] = Sad16_sse2<16, 16,uint16_t>;

	lea	edx, DWORD PTR $T380[ebp]
	mov	DWORD PTR $T202[ebp], 2
	lea	ecx, DWORD PTR $T47[ebp]
	mov	DWORD PTR $T320[ebp], 2
	mov	DWORD PTR $T261[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0BA@$0CA@G@@YAIPBEH0H@Z ; Sad16_sse2<16,32,unsigned short>
	lea	eax, DWORD PTR $T202[ebp]
	push	eax
	lea	eax, DWORD PTR $T320[ebp]
	mov	DWORD PTR $T380[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T261[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 237  :     func_sad[make_tuple(16, 8 , 2, USE_SSE2)] = Sad16_sse2<16, 8,uint16_t>;

	lea	edx, DWORD PTR $T379[ebp]
	mov	DWORD PTR $T201[ebp], 2
	lea	ecx, DWORD PTR $T46[ebp]
	mov	DWORD PTR $T319[ebp], 2
	mov	DWORD PTR $T260[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0BA@$0BA@G@@YAIPBEH0H@Z ; Sad16_sse2<16,16,unsigned short>
	lea	eax, DWORD PTR $T201[ebp]
	push	eax
	lea	eax, DWORD PTR $T319[ebp]
	mov	DWORD PTR $T379[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T260[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 238  :     func_sad[make_tuple(16, 4 , 2, USE_SSE2)] = Sad16_sse2<16, 4,uint16_t>;

	lea	edx, DWORD PTR $T378[ebp]
	mov	DWORD PTR $T200[ebp], 2
	lea	ecx, DWORD PTR $T45[ebp]
	mov	DWORD PTR $T318[ebp], 2
	mov	DWORD PTR $T259[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0BA@$07G@@YAIPBEH0H@Z ; Sad16_sse2<16,8,unsigned short>
	lea	eax, DWORD PTR $T200[ebp]
	push	eax
	lea	eax, DWORD PTR $T318[ebp]
	mov	DWORD PTR $T378[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T259[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 239  :     func_sad[make_tuple(16, 2 , 2, USE_SSE2)] = Sad16_sse2<16, 2,uint16_t>;

	lea	edx, DWORD PTR $T377[ebp]
	mov	DWORD PTR $T199[ebp], 2
	lea	ecx, DWORD PTR $T44[ebp]
	mov	DWORD PTR $T317[ebp], 2
	mov	DWORD PTR $T258[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0BA@$03G@@YAIPBEH0H@Z ; Sad16_sse2<16,4,unsigned short>
	lea	eax, DWORD PTR $T199[ebp]
	push	eax
	lea	eax, DWORD PTR $T317[ebp]
	mov	DWORD PTR $T377[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T258[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 240  :     func_sad[make_tuple(16, 1 , 2, USE_SSE2)] = Sad16_sse2<16, 1,uint16_t>;

	lea	edx, DWORD PTR $T376[ebp]
	mov	DWORD PTR $T198[ebp], 2
	lea	ecx, DWORD PTR $T43[ebp]
	mov	DWORD PTR $T316[ebp], 2
	mov	DWORD PTR $T257[ebp], 1
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0BA@$01G@@YAIPBEH0H@Z ; Sad16_sse2<16,2,unsigned short>
	lea	eax, DWORD PTR $T198[ebp]
	push	eax
	lea	eax, DWORD PTR $T316[ebp]
	mov	DWORD PTR $T376[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T257[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 241  :     func_sad[make_tuple(8 , 16, 2, USE_SSE2)] = Sad16_sse2<8 , 16,uint16_t>;

	lea	edx, DWORD PTR $T375[ebp]
	mov	DWORD PTR $T197[ebp], 2
	lea	ecx, DWORD PTR $T42[ebp]
	mov	DWORD PTR $T315[ebp], 2
	mov	DWORD PTR $T256[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$0BA@$00G@@YAIPBEH0H@Z ; Sad16_sse2<16,1,unsigned short>
	lea	eax, DWORD PTR $T197[ebp]
	push	eax
	lea	eax, DWORD PTR $T315[ebp]
	mov	DWORD PTR $T375[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T256[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 242  :     func_sad[make_tuple(8 , 8 , 2, USE_SSE2)] = Sad16_sse2<8 , 8,uint16_t>;

	lea	edx, DWORD PTR $T374[ebp]
	mov	DWORD PTR $T196[ebp], 2
	lea	ecx, DWORD PTR $T41[ebp]
	mov	DWORD PTR $T314[ebp], 2
	mov	DWORD PTR $T255[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$07$0BA@G@@YAIPBEH0H@Z ; Sad16_sse2<8,16,unsigned short>
	lea	eax, DWORD PTR $T196[ebp]
	push	eax
	lea	eax, DWORD PTR $T314[ebp]
	mov	DWORD PTR $T374[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T255[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 243  :     func_sad[make_tuple(8 , 4 , 2, USE_SSE2)] = Sad16_sse2<8 , 4,uint16_t>;

	mov	DWORD PTR $T195[ebp], 2
	mov	DWORD PTR $T313[ebp], 2
	mov	DWORD PTR $T254[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$07$07G@@YAIPBEH0H@Z ; Sad16_sse2<8,8,unsigned short>
	lea	eax, DWORD PTR $T195[ebp]
	mov	DWORD PTR $T373[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T313[ebp]
	push	eax
	lea	eax, DWORD PTR $T254[ebp]
	push	eax
	lea	edx, DWORD PTR $T373[ebp]
	lea	ecx, DWORD PTR $T40[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 244  :     func_sad[make_tuple(8 , 2 , 2, USE_SSE2)] = Sad16_sse2<8 , 2,uint16_t>;

	lea	edx, DWORD PTR $T372[ebp]
	mov	DWORD PTR $T194[ebp], 2
	lea	ecx, DWORD PTR $T39[ebp]
	mov	DWORD PTR $T312[ebp], 2
	mov	DWORD PTR $T253[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$07$03G@@YAIPBEH0H@Z ; Sad16_sse2<8,4,unsigned short>
	lea	eax, DWORD PTR $T194[ebp]
	push	eax
	lea	eax, DWORD PTR $T312[ebp]
	mov	DWORD PTR $T372[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T253[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 245  :     func_sad[make_tuple(8 , 1 , 2, USE_SSE2)] = Sad16_sse2<8 , 1,uint16_t>;

	lea	edx, DWORD PTR $T371[ebp]
	mov	DWORD PTR $T193[ebp], 2
	lea	ecx, DWORD PTR $T38[ebp]
	mov	DWORD PTR $T311[ebp], 2
	mov	DWORD PTR $T252[ebp], 1
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$07$01G@@YAIPBEH0H@Z ; Sad16_sse2<8,2,unsigned short>
	lea	eax, DWORD PTR $T193[ebp]
	push	eax
	lea	eax, DWORD PTR $T311[ebp]
	mov	DWORD PTR $T371[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T252[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 246  :     func_sad[make_tuple(4 , 8 , 2, USE_SSE2)] = Sad16_sse2<4 , 8,uint16_t>;

	lea	edx, DWORD PTR $T370[ebp]
	mov	DWORD PTR $T192[ebp], 2
	lea	ecx, DWORD PTR $T37[ebp]
	mov	DWORD PTR $T310[ebp], 2
	mov	DWORD PTR $T251[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$07$00G@@YAIPBEH0H@Z ; Sad16_sse2<8,1,unsigned short>
	lea	eax, DWORD PTR $T192[ebp]
	push	eax
	lea	eax, DWORD PTR $T310[ebp]
	mov	DWORD PTR $T370[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T251[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 247  :     func_sad[make_tuple(4 , 4 , 2, USE_SSE2)] = Sad16_sse2<4 , 4,uint16_t>;

	lea	edx, DWORD PTR $T369[ebp]
	mov	DWORD PTR $T191[ebp], 2
	lea	ecx, DWORD PTR $T36[ebp]
	mov	DWORD PTR $T309[ebp], 2
	mov	DWORD PTR $T250[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$03$07G@@YAIPBEH0H@Z ; Sad16_sse2<4,8,unsigned short>
	lea	eax, DWORD PTR $T191[ebp]
	push	eax
	lea	eax, DWORD PTR $T309[ebp]
	mov	DWORD PTR $T369[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T250[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 248  :     func_sad[make_tuple(4 , 2 , 2, USE_SSE2)] = Sad16_sse2<4 , 2,uint16_t>;

	lea	edx, DWORD PTR $T368[ebp]
	mov	DWORD PTR $T190[ebp], 2
	lea	ecx, DWORD PTR $T35[ebp]
	mov	DWORD PTR $T308[ebp], 2
	mov	DWORD PTR $T249[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$03$03G@@YAIPBEH0H@Z ; Sad16_sse2<4,4,unsigned short>
	lea	eax, DWORD PTR $T190[ebp]
	push	eax
	lea	eax, DWORD PTR $T308[ebp]
	mov	DWORD PTR $T368[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T249[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 249  :     //func_sad[make_tuple(4 , 1 , 2, USE_SSE2)] = Sad16_sse2<4 , 1,uint16_t>; // 8 bytes with height=1 not supported for SSE2
; 250  :     
; 251  :     // PF uint8_t sse2 versions. test. 
; 252  :     // a bit slower than the existing external asm. At least for MSVC
; 253  :     // >=8 bytes
; 254  : #ifdef SAD_8BIT_INSTINSICS
; 255  :     func_sad[make_tuple(32, 32, 1, USE_SSE2)] = Sad16_sse2<32, 32,uint8_t>;
; 256  :     func_sad[make_tuple(32, 16, 1, USE_SSE2)] = Sad16_sse2<32, 16,uint8_t>;
; 257  :     func_sad[make_tuple(32, 8 , 1, USE_SSE2)] = Sad16_sse2<32, 8,uint8_t>;
; 258  :     func_sad[make_tuple(16, 32, 1, USE_SSE2)] = Sad16_sse2<16, 32,uint8_t>;
; 259  :     func_sad[make_tuple(16, 16, 1, USE_SSE2)] = Sad16_sse2<16, 16,uint8_t>;
; 260  :     func_sad[make_tuple(16, 8 , 1, USE_SSE2)] = Sad16_sse2<16, 8,uint8_t>;
; 261  :     func_sad[make_tuple(16, 4 , 1, USE_SSE2)] = Sad16_sse2<16, 4,uint8_t>;
; 262  :     func_sad[make_tuple(16, 2 , 1, USE_SSE2)] = Sad16_sse2<16, 2,uint8_t>;
; 263  :     func_sad[make_tuple(16, 1 , 1, USE_SSE2)] = Sad16_sse2<16, 1,uint8_t>;
; 264  :     func_sad[make_tuple(8 , 16, 1, USE_SSE2)] = Sad16_sse2<8 , 16,uint8_t>;
; 265  :     func_sad[make_tuple(8 , 8 , 1, USE_SSE2)] = Sad16_sse2<8 , 8,uint8_t>;
; 266  :     func_sad[make_tuple(8 , 4 , 1, USE_SSE2)] = Sad16_sse2<8 , 4,uint8_t>;
; 267  :     func_sad[make_tuple(8 , 2 , 1, USE_SSE2)] = Sad16_sse2<8 , 2,uint8_t>;
; 268  :     func_sad[make_tuple(8 , 1 , 1, USE_SSE2)] = Sad16_sse2<8 , 1,uint8_t>;
; 269  : #else
; 270  :     func_sad[make_tuple(32, 32, 1, USE_SSE2)] = Sad32x32_iSSE;

	lea	edx, DWORD PTR $T367[ebp]
	mov	DWORD PTR $T189[ebp], 2
	lea	ecx, DWORD PTR $T34[ebp]
	mov	DWORD PTR $T307[ebp], 1
	mov	DWORD PTR $T248[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_sse2@$03$01G@@YAIPBEH0H@Z ; Sad16_sse2<4,2,unsigned short>
	lea	eax, DWORD PTR $T189[ebp]
	push	eax
	lea	eax, DWORD PTR $T307[ebp]
	mov	DWORD PTR $T367[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T248[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 271  :     func_sad[make_tuple(32, 16, 1, USE_SSE2)] = Sad32x16_iSSE;

	lea	edx, DWORD PTR $T366[ebp]
	mov	DWORD PTR $T188[ebp], 2
	lea	ecx, DWORD PTR $T33[ebp]
	mov	DWORD PTR $T306[ebp], 1
	mov	DWORD PTR $T247[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET _Sad32x32_iSSE
	lea	eax, DWORD PTR $T188[ebp]
	push	eax
	lea	eax, DWORD PTR $T306[ebp]
	mov	DWORD PTR $T366[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T247[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 272  :     func_sad[make_tuple(32, 8 , 1, USE_SSE2)] = Sad32x8_iSSE;

	lea	edx, DWORD PTR $T365[ebp]
	mov	DWORD PTR $T187[ebp], 2
	lea	ecx, DWORD PTR $T32[ebp]
	mov	DWORD PTR $T305[ebp], 1
	mov	DWORD PTR $T246[ebp], 8
	mov	DWORD PTR [eax], OFFSET _Sad32x16_iSSE
	lea	eax, DWORD PTR $T187[ebp]
	push	eax
	lea	eax, DWORD PTR $T305[ebp]
	mov	DWORD PTR $T365[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T246[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 273  :     func_sad[make_tuple(16, 32, 1, USE_SSE2)] = Sad16x32_iSSE;

	mov	DWORD PTR $T186[ebp], 2
	mov	DWORD PTR $T304[ebp], 1
	mov	DWORD PTR $T245[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET _Sad32x8_iSSE
	lea	eax, DWORD PTR $T186[ebp]
	mov	DWORD PTR $T364[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T304[ebp]
	push	eax
	lea	eax, DWORD PTR $T245[ebp]
	push	eax
	lea	edx, DWORD PTR $T364[ebp]
	lea	ecx, DWORD PTR $T31[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 274  :     func_sad[make_tuple(16, 16, 1, USE_SSE2)] = x264_pixel_sad_16x16_sse2;

	lea	edx, DWORD PTR $T363[ebp]
	mov	DWORD PTR $T185[ebp], 2
	lea	ecx, DWORD PTR $T30[ebp]
	mov	DWORD PTR $T303[ebp], 1
	mov	DWORD PTR $T244[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET _Sad16x32_iSSE
	lea	eax, DWORD PTR $T185[ebp]
	push	eax
	lea	eax, DWORD PTR $T303[ebp]
	mov	DWORD PTR $T363[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T244[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 275  :     func_sad[make_tuple(16, 8 , 1, USE_SSE2)] = x264_pixel_sad_16x8_sse2;

	lea	edx, DWORD PTR $T362[ebp]
	mov	DWORD PTR $T184[ebp], 2
	lea	ecx, DWORD PTR $T29[ebp]
	mov	DWORD PTR $T302[ebp], 1
	mov	DWORD PTR $T243[ebp], 8
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_16x16_sse2
	lea	eax, DWORD PTR $T184[ebp]
	push	eax
	lea	eax, DWORD PTR $T302[ebp]
	mov	DWORD PTR $T362[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T243[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 276  :     func_sad[make_tuple(16, 4 , 1, USE_SSE2)] = x264_pixel_sad_16x4_mmx2;

	lea	edx, DWORD PTR $T361[ebp]
	mov	DWORD PTR $T183[ebp], 2
	lea	ecx, DWORD PTR $T28[ebp]
	mov	DWORD PTR $T301[ebp], 1
	mov	DWORD PTR $T242[ebp], 4
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_16x8_sse2
	lea	eax, DWORD PTR $T183[ebp]
	push	eax
	lea	eax, DWORD PTR $T301[ebp]
	mov	DWORD PTR $T361[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T242[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 277  :     func_sad[make_tuple(16, 2 , 1, USE_SSE2)] = x264_pixel_sad_16x2_mmx2;

	lea	edx, DWORD PTR $T360[ebp]
	mov	DWORD PTR $T182[ebp], 2
	lea	ecx, DWORD PTR $T27[ebp]
	mov	DWORD PTR $T300[ebp], 1
	mov	DWORD PTR $T241[ebp], 2
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_16x4_mmx2
	lea	eax, DWORD PTR $T182[ebp]
	push	eax
	lea	eax, DWORD PTR $T300[ebp]
	mov	DWORD PTR $T360[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T241[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 278  :     func_sad[make_tuple(8,  16, 1, USE_SSE2)] = x264_pixel_sad_8x16_mmx2;

	lea	edx, DWORD PTR $T359[ebp]
	mov	DWORD PTR $T181[ebp], 2
	lea	ecx, DWORD PTR $T26[ebp]
	mov	DWORD PTR $T299[ebp], 1
	mov	DWORD PTR $T240[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_16x2_mmx2
	lea	eax, DWORD PTR $T181[ebp]
	push	eax
	lea	eax, DWORD PTR $T299[ebp]
	mov	DWORD PTR $T359[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T240[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 279  :     func_sad[make_tuple(8 , 8,  1, USE_SSE2)] = x264_pixel_sad_8x8_mmx2;

	lea	edx, DWORD PTR $T358[ebp]
	mov	DWORD PTR $T180[ebp], 2
	lea	ecx, DWORD PTR $T25[ebp]
	mov	DWORD PTR $T298[ebp], 1
	mov	DWORD PTR $T239[ebp], 8
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_8x16_mmx2
	lea	eax, DWORD PTR $T180[ebp]
	push	eax
	lea	eax, DWORD PTR $T298[ebp]
	mov	DWORD PTR $T358[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T239[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 280  :     func_sad[make_tuple(8 , 4 , 1, USE_SSE2)] = x264_pixel_sad_8x4_mmx2;

	lea	edx, DWORD PTR $T357[ebp]
	mov	DWORD PTR $T179[ebp], 2
	lea	ecx, DWORD PTR $T24[ebp]
	mov	DWORD PTR $T297[ebp], 1
	mov	DWORD PTR $T238[ebp], 4
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_8x8_mmx2
	lea	eax, DWORD PTR $T179[ebp]
	push	eax
	lea	eax, DWORD PTR $T297[ebp]
	mov	DWORD PTR $T357[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T238[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 281  :     func_sad[make_tuple(8 , 2 , 1, USE_SSE2)] = Sad8x2_iSSE;

	lea	edx, DWORD PTR $T356[ebp]
	mov	DWORD PTR $T178[ebp], 2
	lea	ecx, DWORD PTR $T23[ebp]
	mov	DWORD PTR $T296[ebp], 1
	mov	DWORD PTR $T237[ebp], 2
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_8x4_mmx2
	lea	eax, DWORD PTR $T178[ebp]
	push	eax
	lea	eax, DWORD PTR $T296[ebp]
	mov	DWORD PTR $T356[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T237[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 282  :     func_sad[make_tuple(8 , 1 , 1, USE_SSE2)] = Sad8x1_iSSE;

	mov	DWORD PTR $T177[ebp], 2
	mov	DWORD PTR $T295[ebp], 1
	mov	DWORD PTR $T236[ebp], 1
	mov	DWORD PTR [eax], OFFSET _Sad8x2_iSSE
	lea	eax, DWORD PTR $T177[ebp]
	mov	DWORD PTR $T355[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T295[ebp]
	push	eax
	lea	eax, DWORD PTR $T236[ebp]
	push	eax
	lea	edx, DWORD PTR $T355[ebp]
	lea	ecx, DWORD PTR $T22[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 283  : #endif
; 284  :     func_sad[make_tuple(4 , 8 , 1, USE_SSE2)] = x264_pixel_sad_4x8_mmx2;

	lea	edx, DWORD PTR $T354[ebp]
	mov	DWORD PTR $T176[ebp], 2
	lea	ecx, DWORD PTR $T21[ebp]
	mov	DWORD PTR $T294[ebp], 1
	mov	DWORD PTR $T235[ebp], 8
	mov	DWORD PTR [eax], OFFSET _Sad8x1_iSSE
	lea	eax, DWORD PTR $T176[ebp]
	push	eax
	lea	eax, DWORD PTR $T294[ebp]
	mov	DWORD PTR $T354[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T235[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 285  :     func_sad[make_tuple(4 , 4 , 1, USE_SSE2)] = x264_pixel_sad_4x4_mmx2;

	lea	edx, DWORD PTR $T353[ebp]
	mov	DWORD PTR $T175[ebp], 2
	lea	ecx, DWORD PTR $T20[ebp]
	mov	DWORD PTR $T293[ebp], 1
	mov	DWORD PTR $T234[ebp], 4
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_4x8_mmx2
	lea	eax, DWORD PTR $T175[ebp]
	push	eax
	lea	eax, DWORD PTR $T293[ebp]
	mov	DWORD PTR $T353[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T234[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 286  :     func_sad[make_tuple(4 , 2 , 1, USE_SSE2)] = Sad4x2_iSSE;

	lea	edx, DWORD PTR $T352[ebp]
	mov	DWORD PTR $T174[ebp], 2
	lea	ecx, DWORD PTR $T19[ebp]
	mov	DWORD PTR $T292[ebp], 1
	mov	DWORD PTR $T233[ebp], 2
	mov	DWORD PTR [eax], OFFSET _x264_pixel_sad_4x4_mmx2
	lea	eax, DWORD PTR $T174[ebp]
	push	eax
	lea	eax, DWORD PTR $T292[ebp]
	mov	DWORD PTR $T352[ebp], 4
	push	eax
	lea	eax, DWORD PTR $T233[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 287  :     func_sad[make_tuple(2 , 4 , 1, USE_SSE2)] = Sad2x4_iSSE;

	lea	edx, DWORD PTR $T351[ebp]
	mov	DWORD PTR $T173[ebp], 2
	lea	ecx, DWORD PTR $T18[ebp]
	mov	DWORD PTR $T291[ebp], 1
	mov	DWORD PTR $T232[ebp], 4
	mov	DWORD PTR [eax], OFFSET _Sad4x2_iSSE
	lea	eax, DWORD PTR $T173[ebp]
	push	eax
	lea	eax, DWORD PTR $T291[ebp]
	mov	DWORD PTR $T351[ebp], 2
	push	eax
	lea	eax, DWORD PTR $T232[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 288  :     func_sad[make_tuple(2 , 2 , 1, USE_SSE2)] = Sad2x2_iSSE;

	lea	edx, DWORD PTR $T350[ebp]
	mov	DWORD PTR $T172[ebp], 2
	lea	ecx, DWORD PTR $T17[ebp]
	mov	DWORD PTR $T290[ebp], 1
	mov	DWORD PTR $T231[ebp], 2
	mov	DWORD PTR [eax], OFFSET _Sad2x4_iSSE
	lea	eax, DWORD PTR $T172[ebp]
	push	eax
	lea	eax, DWORD PTR $T290[ebp]
	mov	DWORD PTR $T350[ebp], 2
	push	eax
	lea	eax, DWORD PTR $T231[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 289  : #undef SAD_8BIT_INSTINSICS
; 290  :     //---------------- AVX2
; 291  :     // PF SAD 16 SIMD intrinsic functions
; 292  :     // only for >=16 bytes widths (2x16 byte still OK)
; 293  :     // templates in SADFunctions_avx2
; 294  :     func_sad[make_tuple(32, 32, 2, USE_AVX2)] = Sad16_avx2<32, 32,uint16_t>;

	lea	edx, DWORD PTR $T349[ebp]
	mov	DWORD PTR $T171[ebp], 6
	lea	ecx, DWORD PTR $T16[ebp]
	mov	DWORD PTR $T289[ebp], 2
	mov	DWORD PTR $T230[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET _Sad2x2_iSSE
	lea	eax, DWORD PTR $T171[ebp]
	push	eax
	lea	eax, DWORD PTR $T289[ebp]
	mov	DWORD PTR $T349[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T230[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 295  :     func_sad[make_tuple(32, 16, 2, USE_AVX2)] = Sad16_avx2<32, 16,uint16_t>;

	lea	edx, DWORD PTR $T348[ebp]
	mov	DWORD PTR $T170[ebp], 6
	lea	ecx, DWORD PTR $T15[ebp]
	mov	DWORD PTR $T288[ebp], 2
	mov	DWORD PTR $T229[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0CA@$0CA@G@@YAIPBEH0H@Z ; Sad16_avx2<32,32,unsigned short>
	lea	eax, DWORD PTR $T170[ebp]
	push	eax
	lea	eax, DWORD PTR $T288[ebp]
	mov	DWORD PTR $T348[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T229[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 296  :     func_sad[make_tuple(32, 8 , 2, USE_AVX2)] = Sad16_avx2<32, 8,uint16_t>;

	lea	edx, DWORD PTR $T347[ebp]
	mov	DWORD PTR $T169[ebp], 6
	lea	ecx, DWORD PTR $T14[ebp]
	mov	DWORD PTR $T287[ebp], 2
	mov	DWORD PTR $T228[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0CA@$0BA@G@@YAIPBEH0H@Z ; Sad16_avx2<32,16,unsigned short>
	lea	eax, DWORD PTR $T169[ebp]
	push	eax
	lea	eax, DWORD PTR $T287[ebp]
	mov	DWORD PTR $T347[ebp], 32		; 00000020H
	push	eax
	lea	eax, DWORD PTR $T228[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 297  :     func_sad[make_tuple(16, 32, 2, USE_AVX2)] = Sad16_avx2<16, 32,uint16_t>;

	mov	DWORD PTR $T168[ebp], 6
	mov	DWORD PTR $T286[ebp], 2
	mov	DWORD PTR $T227[ebp], 32		; 00000020H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0CA@$07G@@YAIPBEH0H@Z ; Sad16_avx2<32,8,unsigned short>
	lea	eax, DWORD PTR $T168[ebp]
	mov	DWORD PTR $T346[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T286[ebp]
	push	eax
	lea	eax, DWORD PTR $T227[ebp]
	push	eax
	lea	edx, DWORD PTR $T346[ebp]
	lea	ecx, DWORD PTR $T13[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 298  :     func_sad[make_tuple(16, 16, 2, USE_AVX2)] = Sad16_avx2<16, 16,uint16_t>;

	lea	edx, DWORD PTR $T345[ebp]
	mov	DWORD PTR $T167[ebp], 6
	lea	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR $T285[ebp], 2
	mov	DWORD PTR $T226[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0BA@$0CA@G@@YAIPBEH0H@Z ; Sad16_avx2<16,32,unsigned short>
	lea	eax, DWORD PTR $T167[ebp]
	push	eax
	lea	eax, DWORD PTR $T285[ebp]
	mov	DWORD PTR $T345[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T226[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 299  :     func_sad[make_tuple(16, 8 , 2, USE_AVX2)] = Sad16_avx2<16, 8,uint16_t>;

	lea	edx, DWORD PTR $T344[ebp]
	mov	DWORD PTR $T166[ebp], 6
	lea	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T284[ebp], 2
	mov	DWORD PTR $T225[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0BA@$0BA@G@@YAIPBEH0H@Z ; Sad16_avx2<16,16,unsigned short>
	lea	eax, DWORD PTR $T166[ebp]
	push	eax
	lea	eax, DWORD PTR $T284[ebp]
	mov	DWORD PTR $T344[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T225[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 300  :     func_sad[make_tuple(16, 4 , 2, USE_AVX2)] = Sad16_avx2<16, 4,uint16_t>;

	lea	edx, DWORD PTR $T343[ebp]
	mov	DWORD PTR $T165[ebp], 6
	lea	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T283[ebp], 2
	mov	DWORD PTR $T224[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0BA@$07G@@YAIPBEH0H@Z ; Sad16_avx2<16,8,unsigned short>
	lea	eax, DWORD PTR $T165[ebp]
	push	eax
	lea	eax, DWORD PTR $T283[ebp]
	mov	DWORD PTR $T343[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T224[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 301  :     func_sad[make_tuple(16, 2 , 2, USE_AVX2)] = Sad16_avx2<16, 2,uint16_t>;

	lea	edx, DWORD PTR $T342[ebp]
	mov	DWORD PTR $T164[ebp], 6
	lea	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T282[ebp], 2
	mov	DWORD PTR $T223[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0BA@$03G@@YAIPBEH0H@Z ; Sad16_avx2<16,4,unsigned short>
	lea	eax, DWORD PTR $T164[ebp]
	push	eax
	lea	eax, DWORD PTR $T282[ebp]
	mov	DWORD PTR $T342[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T223[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 302  :     func_sad[make_tuple(16, 1 , 2, USE_AVX2)] = Sad16_avx2<16, 1,uint16_t>; // 32 bytes with height=1 is OK for AVX2

	lea	edx, DWORD PTR $T341[ebp]
	mov	DWORD PTR $T163[ebp], 6
	lea	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T281[ebp], 2
	mov	DWORD PTR $T222[ebp], 1
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0BA@$01G@@YAIPBEH0H@Z ; Sad16_avx2<16,2,unsigned short>
	lea	eax, DWORD PTR $T163[ebp]
	push	eax
	lea	eax, DWORD PTR $T281[ebp]
	mov	DWORD PTR $T341[ebp], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T222[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 303  :     func_sad[make_tuple(8 , 16, 2, USE_AVX2)] = Sad16_avx2<8 , 16,uint16_t>;

	lea	edx, DWORD PTR $T340[ebp]
	mov	DWORD PTR $T162[ebp], 6
	lea	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T280[ebp], 2
	mov	DWORD PTR $T221[ebp], 16		; 00000010H
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$0BA@$00G@@YAIPBEH0H@Z ; Sad16_avx2<16,1,unsigned short>
	lea	eax, DWORD PTR $T162[ebp]
	push	eax
	lea	eax, DWORD PTR $T280[ebp]
	mov	DWORD PTR $T340[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T221[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 304  :     func_sad[make_tuple(8 , 8 , 2, USE_AVX2)] = Sad16_avx2<8 , 8,uint16_t>;

	lea	edx, DWORD PTR $T339[ebp]
	mov	DWORD PTR $T161[ebp], 6
	lea	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T279[ebp], 2
	mov	DWORD PTR $T220[ebp], 8
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$07$0BA@G@@YAIPBEH0H@Z ; Sad16_avx2<8,16,unsigned short>
	lea	eax, DWORD PTR $T161[ebp]
	push	eax
	lea	eax, DWORD PTR $T279[ebp]
	mov	DWORD PTR $T339[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T220[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 305  :     func_sad[make_tuple(8 , 4 , 2, USE_AVX2)] = Sad16_avx2<8 , 4,uint16_t>;

	lea	edx, DWORD PTR $T338[ebp]
	mov	DWORD PTR $T160[ebp], 6
	lea	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T278[ebp], 2
	mov	DWORD PTR $T219[ebp], 4
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$07$07G@@YAIPBEH0H@Z ; Sad16_avx2<8,8,unsigned short>
	lea	eax, DWORD PTR $T160[ebp]
	push	eax
	lea	eax, DWORD PTR $T278[ebp]
	mov	DWORD PTR $T338[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T219[ebp]
	push	eax
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 306  :     func_sad[make_tuple(8 , 2 , 2, USE_AVX2)] = Sad16_avx2<8 , 2,uint16_t>;

	mov	DWORD PTR $T159[ebp], 6
	mov	DWORD PTR $T277[ebp], 2
	mov	DWORD PTR $T218[ebp], 2
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$07$03G@@YAIPBEH0H@Z ; Sad16_avx2<8,4,unsigned short>
	lea	eax, DWORD PTR $T159[ebp]
	mov	DWORD PTR $T337[ebp], 8
	push	eax
	lea	eax, DWORD PTR $T277[ebp]
	push	eax
	lea	eax, DWORD PTR $T218[ebp]
	push	eax
	lea	edx, DWORD PTR $T337[ebp]
	lea	ecx, DWORD PTR $T6[ebp]
	call	??$make_tuple@HHHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@$$QAH00$$QAW4arch_t@@@Z ; std::make_tuple<int,int,int,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000030000000500000006
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	lea	ecx, DWORD PTR _archlist$[ebp]
	movups	XMMWORD PTR _archlist$[ebp], xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 322  :     arch_t archlist[] = { USE_AVX2, USE_AVX, USE_SSE41, USE_SSE2, NO_SIMD };

	mov	DWORD PTR _archlist$[ebp+16], 0
	mov	DWORD PTR [eax], OFFSET ??$Sad16_avx2@$07$01G@@YAIPBEH0H@Z ; Sad16_avx2<8,2,unsigned short>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	eax, DWORD PTR _arch$[ebp]
	jmp	SHORT $LL2@get_sad_fu
$LL4735@get_sad_fu:
	mov	esi, DWORD PTR _BlockX$[ebp]
$LL2@get_sad_fu:
; File c:\github\mvtools\sources\sadfunctions.cpp

; 325  :       arch_t current_arch_try = archlist[index++];

	mov	edi, DWORD PTR [ecx]
	add	ecx, 4
	mov	DWORD PTR _current_arch_try$336[ebp], edi
	mov	DWORD PTR tv7297[ebp], ecx

; 326  :       if (current_arch_try > arch) continue;

	cmp	edi, eax
	jg	SHORT $LL2@get_sad_fu

; 327  :       if (result == nullptr && current_arch_try == NO_SIMD) {

	test	edi, edi
	jne	SHORT $LN5@get_sad_fu

; 328  :         if(arch==USE_AVX2)

	cmp	eax, 6
	jne	SHORT $LN7@get_sad_fu

; 329  :           result = get_sad_avx2_C_function(BlockX, BlockY, pixelsize, NO_SIMD);

	push	ecx
	push	DWORD PTR _pixelsize$[ebp]
	mov	edx, ebx
	mov	ecx, esi
	call	?get_sad_avx2_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_sad_avx2_C_function
	add	esp, 8
	mov	esi, eax
	jmp	SHORT $LN6@get_sad_fu
$LN7@get_sad_fu:

; 330  :         else if(arch==USE_AVX)

	cmp	eax, 5
	jne	SHORT $LN9@get_sad_fu

; 331  :           result = get_sad_avx_C_function(BlockX, BlockY, pixelsize, NO_SIMD);

	push	ecx
	push	DWORD PTR _pixelsize$[ebp]
	mov	edx, ebx
	mov	ecx, esi
	call	?get_sad_avx_C_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ; get_sad_avx_C_function
	add	esp, 8
	mov	esi, eax

; 332  :         else

	jmp	SHORT $LN6@get_sad_fu
$LN9@get_sad_fu:

; 333  :           result = func_sad[make_tuple(BlockX, BlockY, pixelsize, NO_SIMD)];

	lea	eax, DWORD PTR $T158[ebp]
	mov	DWORD PTR $T158[ebp], 0
	push	eax
	lea	eax, DWORD PTR _pixelsize$[ebp]
	push	eax
	lea	eax, DWORD PTR _BlockY$[ebp]
	push	eax
	lea	edx, DWORD PTR _BlockX$[ebp]
	lea	ecx, DWORD PTR $T5[ebp]
	call	??$make_tuple@AAHAAHAAHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00$$QAW4arch_t@@@Z ; std::make_tuple<int &,int &,int &,enum arch_t>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]

; 334  :       }
; 335  :       else {

	jmp	SHORT $LN4738@get_sad_fu
$LN5@get_sad_fu:

; 336  :         result = func_sad[make_tuple(BlockX, BlockY, pixelsize, current_arch_try)];

	lea	eax, DWORD PTR _current_arch_try$336[ebp]
	push	eax
	lea	eax, DWORD PTR _pixelsize$[ebp]
	push	eax
	lea	eax, DWORD PTR _BlockY$[ebp]
	push	eax
	lea	edx, DWORD PTR _BlockX$[ebp]
	lea	ecx, DWORD PTR $T7[ebp]
	call	??$make_tuple@AAHAAHAAHAAW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00AAW4arch_t@@@Z ; std::make_tuple<int &,int &,int &,enum arch_t &>
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _func_sad$[ebp]
	push	eax
	call	??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]
	mov	edi, DWORD PTR _current_arch_try$336[ebp]
$LN4738@get_sad_fu:
	mov	ebx, DWORD PTR _BlockY$[ebp]
	mov	esi, DWORD PTR [eax]
$LN6@get_sad_fu:

; 337  :       }
; 338  :       if (result == nullptr && current_arch_try == NO_SIMD) {

	test	esi, esi
	jne	SHORT $LN4731@get_sad_fu
	mov	eax, DWORD PTR _arch$[ebp]
	mov	ecx, DWORD PTR tv7297[ebp]
	test	edi, edi
	jne	$LL4735@get_sad_fu
$LN4731@get_sad_fu:

; 339  :         break;
; 340  :       }
; 341  :     }
; 342  : 
; 343  : #if 0
; 344  :     result = func_sad[make_tuple(BlockX, BlockY, pixelsize, arch)];
; 345  : 
; 346  :     arch_t arch_orig = arch;
; 347  : 
; 348  :     // no AVX2 -> try AVX
; 349  :     if (result == nullptr && (arch==USE_AVX2 || arch_orig==USE_AVX)) {
; 350  :       arch = USE_AVX;
; 351  :       result = func_sad[make_tuple(BlockX, BlockY, pixelsize, USE_AVX)];
; 352  :     }
; 353  :     // no AVX -> try SSE2
; 354  :     if (result == nullptr && (arch==USE_AVX || arch_orig==USE_SSE2)) {
; 355  :       arch = USE_SSE2;
; 356  :       result = func_sad[make_tuple(BlockX, BlockY, pixelsize, USE_SSE2)];
; 357  :     }
; 358  :     // no SSE2 -> try C
; 359  :     if (result == nullptr && (arch==USE_SSE2 || arch_orig==NO_SIMD)) {
; 360  :       arch = NO_SIMD;
; 361  :       // priority: C version compiled to avx2, avx
; 362  :       if(arch_orig==USE_AVX2)
; 363  :         result = get_sad_avx2_C_function(BlockX, BlockY, pixelsize, NO_SIMD);
; 364  :       else if(arch_orig==USE_AVX)
; 365  :         result = get_sad_avx_C_function(BlockX, BlockY, pixelsize, NO_SIMD);
; 366  : 
; 367  :       if(result == nullptr)
; 368  :         result = func_sad[make_tuple(BlockX, BlockY, pixelsize, NO_SIMD)]; // fallback to C
; 369  :     }
; 370  : #endif
; 371  :     return result;

	lea	ecx, DWORD PTR _func_sad$[ebp]
	call	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ

; 372  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	lea	esp, DWORD PTR [ebp+104]
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z$0:
	lea	ecx, DWORD PTR _func_sad$[ebp]
	jmp	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ
__ehhandler$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_sad_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ENDP	; get_sad_function
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sadfunctions.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
_TEXT	SEGMENT
_archlist$ = -96					; size = 20
$T2 = -76						; size = 16
$T3 = -76						; size = 16
$T4 = -76						; size = 16
$T5 = -76						; size = 16
$T6 = -76						; size = 16
$T7 = -76						; size = 16
$T8 = -76						; size = 16
$T9 = -76						; size = 16
$T10 = -76						; size = 16
$T11 = -76						; size = 16
$T12 = -76						; size = 16
$T13 = -76						; size = 16
$T14 = -76						; size = 16
$T15 = -76						; size = 16
$T16 = -76						; size = 16
$T17 = -60						; size = 16
$T18 = -44						; size = 8
$T19 = -36						; size = 8
$T20 = -36						; size = 8
$T21 = -36						; size = 8
$T22 = -36						; size = 8
$T23 = -36						; size = 8
$T24 = -36						; size = 8
$T25 = -36						; size = 8
$T26 = -36						; size = 8
$T27 = -36						; size = 8
$T28 = -36						; size = 8
$T29 = -36						; size = 8
$T30 = -36						; size = 8
$T31 = -36						; size = 8
$T32 = -36						; size = 8
$T33 = -36						; size = 8
_func_satd$ = -28					; size = 8
_BlockY$1$ = -20					; size = 4
$T34 = -20						; size = 4
_BlockX$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pixelsize$ = 8						; size = 4
_arch$ = 12						; size = 4
?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z PROC	; get_satd_function, COMDAT
; _BlockX$ = ecx
; _BlockY$ = edx

; 375  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	mov	esi, edx
	mov	DWORD PTR _BlockX$1$[ebp], ecx
	push	edi
	mov	DWORD PTR _BlockY$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR _func_satd$[ebp], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR _func_satd$[ebp+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR _func_satd$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T16[ebp]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 378  :     std::map<std::tuple<int, int, int, arch_t>, SADFunction*> func_satd;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000100000002
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	push	eax
	lea	eax, DWORD PTR $T33[ebp]
	push	eax
	movups	XMMWORD PTR $T16[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 383  :     func_satd[make_tuple(32, 32, 1, USE_SSE2)] = x264_pixel_satd_32x32_sse2;

	mov	eax, DWORD PTR $T33[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000100000002
; File c:\github\mvtools\sources\sadfunctions.cpp

; 383  :     func_satd[make_tuple(32, 32, 1, USE_SSE2)] = x264_pixel_satd_32x32_sse2;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_32x32_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	movups	XMMWORD PTR $T15[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 384  :     func_satd[make_tuple(32, 16, 1, USE_SSE2)] = x264_pixel_satd_32x16_sse2;

	mov	eax, DWORD PTR $T32[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000100000002
; File c:\github\mvtools\sources\sadfunctions.cpp

; 384  :     func_satd[make_tuple(32, 16, 1, USE_SSE2)] = x264_pixel_satd_32x16_sse2;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_32x16_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	lea	eax, DWORD PTR $T31[ebp]
	push	eax
	movups	XMMWORD PTR $T14[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 385  :     func_satd[make_tuple(16, 16, 1, USE_SSE2)] = x264_pixel_satd_16x16_sse2;

	mov	eax, DWORD PTR $T31[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000100000002
; File c:\github\mvtools\sources\sadfunctions.cpp

; 385  :     func_satd[make_tuple(16, 16, 1, USE_SSE2)] = x264_pixel_satd_16x16_sse2;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_16x16_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	lea	eax, DWORD PTR $T30[ebp]
	push	eax
	movups	XMMWORD PTR $T13[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 386  :     func_satd[make_tuple(16, 8 , 1, USE_SSE2)] = x264_pixel_satd_16x8_sse2;

	mov	eax, DWORD PTR $T30[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000100000002
; File c:\github\mvtools\sources\sadfunctions.cpp

; 386  :     func_satd[make_tuple(16, 8 , 1, USE_SSE2)] = x264_pixel_satd_16x8_sse2;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_16x8_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	movups	XMMWORD PTR $T12[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 387  :     func_satd[make_tuple(8 , 16, 1, USE_SSE2)] = x264_pixel_satd_8x16_sse2;

	mov	eax, DWORD PTR $T29[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000100000002
; File c:\github\mvtools\sources\sadfunctions.cpp

; 387  :     func_satd[make_tuple(8 , 16, 1, USE_SSE2)] = x264_pixel_satd_8x16_sse2;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_8x16_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	lea	eax, DWORD PTR $T28[ebp]
	push	eax
	movups	XMMWORD PTR $T11[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 388  :     func_satd[make_tuple(8 , 8 , 1, USE_SSE2)] = x264_pixel_satd_8x8_sse2;

	mov	eax, DWORD PTR $T28[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000100000002
; File c:\github\mvtools\sources\sadfunctions.cpp

; 388  :     func_satd[make_tuple(8 , 8 , 1, USE_SSE2)] = x264_pixel_satd_8x8_sse2;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_8x8_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	movups	XMMWORD PTR $T10[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 389  :     func_satd[make_tuple(8 , 4 , 1, USE_SSE2)] = x264_pixel_satd_8x4_sse2;

	mov	eax, DWORD PTR $T27[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000200000000200000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 389  :     func_satd[make_tuple(8 , 4 , 1, USE_SSE2)] = x264_pixel_satd_8x4_sse2;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_8x4_sse2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	movups	XMMWORD PTR $T9[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 391  :     func_satd[make_tuple(32, 32, 2, NO_SIMD)] = x264_pixel_satd_uint16_32x32_c;

	mov	eax, DWORD PTR $T26[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000020000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 391  :     func_satd[make_tuple(32, 32, 2, NO_SIMD)] = x264_pixel_satd_uint16_32x32_c;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_uint16_32x32_c
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	eax, DWORD PTR $T25[ebp]
	push	eax
	movups	XMMWORD PTR $T8[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 392  :     func_satd[make_tuple(32, 16, 2, NO_SIMD)] = x264_pixel_satd_uint16_32x16_c;

	mov	eax, DWORD PTR $T25[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 392  :     func_satd[make_tuple(32, 16, 2, NO_SIMD)] = x264_pixel_satd_uint16_32x16_c;

	mov	DWORD PTR [eax+32], OFFSET _x264_pixel_satd_uint16_32x16_c
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	eax, DWORD PTR $T24[ebp]
	push	eax
	movups	XMMWORD PTR $T7[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 393  :     func_satd[make_tuple(16, 16, 2, NO_SIMD)] = x264_pixel_satd_uint16_16x16_c;

	mov	eax, DWORD PTR $T24[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000010000000080000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 393  :     func_satd[make_tuple(16, 16, 2, NO_SIMD)] = x264_pixel_satd_uint16_16x16_c;

	mov	DWORD PTR [eax+32], OFFSET ?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x16_c
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	eax, DWORD PTR $T23[ebp]
	push	eax
	movups	XMMWORD PTR $T6[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 394  :     func_satd[make_tuple(16, 8 , 2, NO_SIMD)] = x264_pixel_satd_uint16_16x8_c;

	mov	eax, DWORD PTR $T23[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000100000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 394  :     func_satd[make_tuple(16, 8 , 2, NO_SIMD)] = x264_pixel_satd_uint16_16x8_c;

	mov	DWORD PTR [eax+32], OFFSET ?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x8_c
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T22[ebp]
	push	eax
	movups	XMMWORD PTR $T5[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 395  :     func_satd[make_tuple(8 , 16, 2, NO_SIMD)] = x264_pixel_satd_uint16_8x16_c;

	mov	eax, DWORD PTR $T22[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000080000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 395  :     func_satd[make_tuple(8 , 16, 2, NO_SIMD)] = x264_pixel_satd_uint16_8x16_c;

	mov	DWORD PTR [eax+32], OFFSET ?x264_pixel_satd_uint16_8x16_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x16_c
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	movups	XMMWORD PTR $T4[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 396  :     func_satd[make_tuple(8 , 8 , 2, NO_SIMD)] = x264_pixel_satd_uint16_8x8_c;

	mov	eax, DWORD PTR $T21[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000040000000200000000
; File c:\github\mvtools\sources\sadfunctions.cpp

; 396  :     func_satd[make_tuple(8 , 8 , 2, NO_SIMD)] = x264_pixel_satd_uint16_8x8_c;

	mov	DWORD PTR [eax+32], OFFSET ?x264_pixel_satd_uint16_8x8_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x8_c
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T20[ebp]
	push	eax
	movups	XMMWORD PTR $T3[ebp], xmm0
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 397  :     func_satd[make_tuple(8 , 4 , 2, NO_SIMD)] = x264_pixel_satd_uint16_8x4_c;

	mov	eax, DWORD PTR $T20[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	lea	ebx, DWORD PTR _archlist$[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000002000000030000000500000006
	movups	XMMWORD PTR _archlist$[ebp], xmm0
; File c:\github\mvtools\sources\sadfunctions.cpp

; 400  :     arch_t archlist[] = { USE_AVX2, USE_AVX, USE_SSE41, USE_SSE2, NO_SIMD };

	mov	DWORD PTR _archlist$[ebp+16], 0
	mov	DWORD PTR [eax+32], OFFSET ?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	jmp	SHORT $LL2@get_satd_f
$LL1774@get_satd_f:
	mov	esi, DWORD PTR _BlockY$1$[ebp]
$LL2@get_satd_f:

; 401  :     int index = 0;
; 402  :     while (result == nullptr) {
; 403  :       arch_t current_arch_try = archlist[index++];

	mov	edi, DWORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+4]

; 404  :       if (current_arch_try > arch) continue;

	cmp	edi, DWORD PTR _arch$[ebp]
	jg	SHORT $LL2@get_satd_f
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR _pixelsize$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	ecx, DWORD PTR _func_satd$[ebp]
; File c:\github\mvtools\sources\sadfunctions.cpp

; 405  :       if (result == nullptr && current_arch_try == NO_SIMD) {

	test	edi, edi
	jne	SHORT $LN5@get_satd_f
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T17[ebp+4], eax
	mov	eax, DWORD PTR _BlockX$1$[ebp]
	mov	DWORD PTR $T17[ebp+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	lea	eax, DWORD PTR $T19[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T17[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T17[ebp+8], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 412  :           result = func_satd[make_tuple(BlockX, BlockY, pixelsize, NO_SIMD)];

	mov	esi, DWORD PTR $T19[ebp]

; 413  :       }
; 414  :       else {

	jmp	SHORT $LN1777@get_satd_f
$LN5@get_satd_f:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp+4], eax
	mov	eax, DWORD PTR _BlockX$1$[ebp]
	mov	DWORD PTR $T2[ebp+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T18[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp+8], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
; File c:\github\mvtools\sources\sadfunctions.cpp

; 415  :         result = func_satd[make_tuple(BlockX, BlockY, pixelsize, current_arch_try)];

	mov	esi, DWORD PTR $T18[ebp]
$LN1777@get_satd_f:
	mov	esi, DWORD PTR [esi+32]

; 416  :       }
; 417  :       if (result == nullptr && current_arch_try == NO_SIMD) {

	test	esi, esi
	jne	SHORT $LN1770@get_satd_f
	test	edi, edi
	jne	SHORT $LL1774@get_satd_f
$LN1770@get_satd_f:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2168 : 		erase(begin(), end());

	mov	eax, DWORD PTR _func_satd$[ebp]
	lea	ecx, DWORD PTR _func_satd$[ebp]
	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T34[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR _func_satd$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\github\mvtools\sources\sadfunctions.cpp

; 422  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\github\mvtools\sources\sadfunctions.cpp

; 421  :     return result;

	mov	eax, esi

; 422  : }

	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z$0:
	lea	ecx, DWORD PTR _func_satd$[ebp]
	jmp	??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ
__ehhandler$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_satd_function@@YAP6AIPBEH0H@ZHHHW4arch_t@@@Z ENDP	; get_satd_function
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?SADABS@@YAIH@Z
_TEXT	SEGMENT
?SADABS@@YAIH@Z PROC					; SADABS, COMDAT
; _x$ = ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	ret	0
?SADABS@@YAIH@Z ENDP					; SADABS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?abs2@@YA_K_K@Z
_TEXT	SEGMENT
_a$ = 8							; size = 8
?abs2@@YA_K_K@Z PROC					; abs2, COMDAT

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	ecx, DWORD PTR _a$[esp-4]
	mov	eax, DWORD PTR _a$[esp]
	push	esi
	shrd	ecx, eax, 31
	push	0
	shr	eax, 31					; 0000001fH
	and	ecx, 1
	push	-1
	and	eax, 1
	push	eax
	push	ecx
	call	__allmul

; 57   :   return (a+s)^s;

	mov	esi, eax
	mov	ecx, edx
	add	esi, DWORD PTR _a$[esp]
	adc	edx, DWORD PTR _a$[esp+4]
	xor	eax, esi
	xor	edx, ecx

; 58   : }

	pop	esi
	ret	0
?abs2@@YA_K_K@Z ENDP					; abs2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z
_TEXT	SEGMENT
_a2$16$ = -144						; size = 4
_a2$15$ = -144						; size = 4
_a2$14$ = -144						; size = 4
_a2$5$ = -144						; size = 4
_a1$4$ = -144						; size = 4
_a1$3$ = -144						; size = 4
_a1$2$ = -144						; size = 4
_a1$1$ = -144						; size = 4
_sum$2$ = -140						; size = 4
_a3$13$ = -140						; size = 4
_a3$5$ = -136						; size = 4
_sum$1$ = -136						; size = 4
_tmp$27$ = -132						; size = 4
_t3$7$ = -132						; size = 4
_t3$6$ = -132						; size = 4
_t3$5$ = -132						; size = 4
_a2$8$ = -132						; size = 4
_a2$7$ = -132						; size = 4
_a3$8$ = -128						; size = 4
_t3$4$ = -124						; size = 4
_t3$3$ = -124						; size = 4
_t3$2$ = -124						; size = 4
_a2$13$ = -124						; size = 4
_a2$6$ = -124						; size = 4
_t3$4$ = -120						; size = 4
_a3$16$ = -116						; size = 4
_a3$7$ = -112						; size = 4
_a3$15$ = -108						; size = 4
_tmp$32$ = -104						; size = 4
_s$1$ = -100						; size = 4
_s$8$ = -100						; size = 4
_s$7$ = -100						; size = 4
_s$6$ = -100						; size = 4
_tmp$10$ = -100						; size = 4
_tmp$9$ = -96						; size = 4
_a1$13$ = -96						; size = 4
_a0$8$ = -96						; size = 4
_a0$7$ = -96						; size = 4
_a0$6$ = -96						; size = 4
_tmp$16$ = -92						; size = 4
_t3$8$ = -88						; size = 4
_a3$14$ = -84						; size = 4
_a3$6$ = -80						; size = 4
_t3$3$ = -76						; size = 4
_tmp$30$ = -72						; size = 4
tv435 = -72						; size = 4
tv371 = -72						; size = 4
tv293 = -72						; size = 4
_a0$16$ = -68						; size = 4
_a0$15$ = -68						; size = 4
_a0$14$ = -68						; size = 4
_a0$13$ = -68						; size = 4
_s$5$ = -64						; size = 4
_s$4$ = -64						; size = 4
_s$3$ = -64						; size = 4
_s$2$ = -64						; size = 4
_a1$8$ = -60						; size = 4
_a1$7$ = -60						; size = 4
_a1$6$ = -60						; size = 4
_a0$5$ = -60						; size = 4
_s$8$ = -56						; size = 4
_s$7$ = -56						; size = 4
_s$6$ = -56						; size = 4
_tmp$13$ = -56						; size = 4
_tmp$14$ = -52						; size = 4
_a1$16$ = -52						; size = 4
_a1$15$ = -52						; size = 4
_a1$14$ = -52						; size = 4
_s$4$ = -48						; size = 4
_s$3$ = -48						; size = 4
_s$2$ = -48						; size = 4
_tmp$29$ = -48						; size = 4
_t3$7$ = -44						; size = 4
_t3$1$ = -40						; size = 4
_a1$5$ = -40						; size = 4
_s$1$ = -36						; size = 4
_t3$5$ = -36						; size = 4
_tmp$31$ = -32						; size = 4
_tmp$15$ = -28						; size = 4
_tmp$11$ = -24						; size = 4
_t3$1$ = -24						; size = 4
_t3$2$ = -20						; size = 4
_tmp$12$ = -16						; size = 4
_tmp$28$ = -12						; size = 4
_t3$6$ = -8						; size = 4
_s$5$ = -4						; size = 4
_t3$8$ = -4						; size = 4
_pix1$ = 8						; size = 4
_i_pix1$ = 12						; size = 4
_pix2$ = 16						; size = 4
_i_pix2$ = 20						; size = 4
?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z PROC		; x264_pixel_satd_uint16_8x4_c, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 148				; 00000094H
	push	ebx

; 92   :   sum2_t tmp[4][4];
; 93   :   sum2_t a0, a1, a2, a3;
; 94   :   sum2_t sum = 0;
; 95   :   for( int i = 0; i < 4; i++, pix1 += i_pix1, pix2 += i_pix2 )
; 96   :   {
; 97   :     a0 = (reinterpret_cast<const uint16_t *>(pix1)[0] - reinterpret_cast<const uint16_t *>(pix2)[0]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[4] - reinterpret_cast<const uint16_t *>(pix2)[4]) << BITS_PER_SUM);

	mov	ebx, DWORD PTR _pix1$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pix2$[ebp]
	xor	esi, esi
	movzx	eax, WORD PTR [ebx+8]
	movzx	ecx, WORD PTR [edi+8]
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi]
	cdq
	mov	DWORD PTR _a3$8$[esp+160], eax
	movzx	eax, WORD PTR [ebx]
	sub	eax, ecx

; 98   :     a1 = (reinterpret_cast<const uint16_t *>(pix1)[1] - reinterpret_cast<const uint16_t *>(pix2)[1]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[5] - reinterpret_cast<const uint16_t *>(pix2)[5]) << BITS_PER_SUM);

	movzx	ecx, WORD PTR [edi+10]
	cdq
	add	esi, eax
	movzx	eax, WORD PTR [ebx+10]
	mov	DWORD PTR _a3$16$[esp+160], esi
	adc	DWORD PTR _a3$8$[esp+160], edx
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi+2]
	xor	ebx, ebx
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	eax, WORD PTR [eax+2]
	sub	eax, ecx

; 99   :     a2 = (reinterpret_cast<const uint16_t *>(pix1)[2] - reinterpret_cast<const uint16_t *>(pix2)[2]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[6] - reinterpret_cast<const uint16_t *>(pix2)[6]) << BITS_PER_SUM);

	movzx	ecx, WORD PTR [edi+12]
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	adc	esi, edx
	mov	DWORD PTR _a1$1$[esp+160], esi
	xor	esi, esi
	movzx	eax, WORD PTR [eax+12]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	ecx, WORD PTR [ecx+4]
	movzx	eax, WORD PTR [eax+4]
	sub	eax, ecx

; 100  :     a3 = (reinterpret_cast<const uint16_t *>(pix1)[3] - reinterpret_cast<const uint16_t *>(pix2)[3]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[7] - reinterpret_cast<const uint16_t *>(pix2)[7]) << BITS_PER_SUM);

	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	add	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	mov	DWORD PTR _t3$5$[esp+160], esi
	movzx	ecx, WORD PTR [ecx+14]
	adc	edi, edx
	mov	DWORD PTR _t3$1$[esp+160], edi
	xor	esi, esi
	movzx	eax, WORD PTR [eax+14]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	ecx, WORD PTR [ecx+6]
	movzx	eax, WORD PTR [eax+6]
	sub	eax, ecx
	cdq
	add	esi, eax

; 101  :     HADAMARD4( tmp[i][0], tmp[i][1], tmp[i][2], tmp[i][3], a0,a1,a2,a3 );

	mov	eax, ebx
	adc	edi, edx
	mov	edx, DWORD PTR _a3$16$[esp+160]
	add	eax, edx
	mov	DWORD PTR _a3$15$[esp+160], eax
	mov	eax, DWORD PTR _a1$1$[esp+160]
	mov	ecx, eax
	adc	ecx, DWORD PTR _a3$8$[esp+160]
	sub	edx, ebx
	mov	ebx, DWORD PTR _t3$1$[esp+160]
	sbb	DWORD PTR _a3$8$[esp+160], eax
	mov	eax, esi
	mov	DWORD PTR _a3$16$[esp+160], edx
	mov	edx, DWORD PTR _t3$5$[esp+160]
	add	eax, edx
	mov	DWORD PTR _a3$7$[esp+160], ecx
	mov	ecx, edi
	adc	ecx, ebx
	sub	edx, esi
	mov	esi, eax
	sbb	ebx, edi
	mov	edi, DWORD PTR _a3$15$[esp+160]
	add	esi, edi
	mov	DWORD PTR _a3$13$[esp+160], esi
	mov	esi, ecx
	adc	esi, DWORD PTR _a3$7$[esp+160]
	sub	edi, eax
	mov	eax, edx
	mov	DWORD PTR _a3$5$[esp+160], esi
	sbb	DWORD PTR _a3$7$[esp+160], ecx
	mov	ecx, DWORD PTR _a3$16$[esp+160]
	add	eax, ecx
	mov	esi, DWORD PTR _a3$8$[esp+160]
	mov	DWORD PTR _a3$14$[esp+160], eax
	mov	eax, ebx
	adc	eax, esi
	mov	DWORD PTR _a3$15$[esp+160], edi
	mov	edi, DWORD PTR _pix2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _a3$6$[esp+160], eax
	sbb	esi, ebx
	mov	DWORD PTR _a3$16$[esp+160], ecx
	add	edi, DWORD PTR _i_pix2$[ebp]
	mov	ebx, DWORD PTR _pix1$[ebp]
	add	ebx, DWORD PTR _i_pix1$[ebp]
	mov	DWORD PTR _a3$8$[esp+160], esi
	xor	esi, esi
	movzx	ecx, WORD PTR [edi+8]
	mov	DWORD PTR _pix1$[ebp], ebx
	movzx	eax, WORD PTR [ebx+8]
	sub	eax, ecx
	mov	DWORD PTR _pix2$[ebp], edi
	movzx	ecx, WORD PTR [edi]
	cdq
	mov	DWORD PTR _tmp$16$[esp+160], eax
	movzx	eax, WORD PTR [ebx]
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi+10]
	cdq
	add	esi, eax
	movzx	eax, WORD PTR [ebx+10]
	mov	DWORD PTR _tmp$15$[esp+160], esi
	adc	DWORD PTR _tmp$16$[esp+160], edx
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi+2]
	xor	ebx, ebx
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	eax, WORD PTR [eax+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi+12]
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	adc	esi, edx
	mov	DWORD PTR _a1$2$[esp+160], esi
	xor	esi, esi
	movzx	eax, WORD PTR [eax+12]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	ecx, WORD PTR [ecx+4]
	movzx	eax, WORD PTR [eax+4]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	add	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	mov	DWORD PTR _t3$6$[esp+160], esi
	movzx	ecx, WORD PTR [ecx+14]
	adc	edi, edx
	mov	DWORD PTR _t3$2$[esp+160], edi
	movzx	eax, WORD PTR [eax+14]
	sub	eax, ecx
	cdq

; 100  :     a3 = (reinterpret_cast<const uint16_t *>(pix1)[3] - reinterpret_cast<const uint16_t *>(pix2)[3]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[7] - reinterpret_cast<const uint16_t *>(pix2)[7]) << BITS_PER_SUM);

	mov	ecx, DWORD PTR _pix2$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	xor	esi, esi
	movzx	ecx, WORD PTR [ecx+6]
	movzx	eax, WORD PTR [eax+6]
	sub	eax, ecx
	cdq
	add	esi, eax

; 101  :     HADAMARD4( tmp[i][0], tmp[i][1], tmp[i][2], tmp[i][3], a0,a1,a2,a3 );

	mov	eax, ebx
	adc	edi, edx
	mov	edx, DWORD PTR _tmp$15$[esp+160]
	add	eax, edx
	mov	DWORD PTR _tmp$11$[esp+160], eax
	mov	eax, DWORD PTR _a1$2$[esp+160]
	mov	ecx, eax
	adc	ecx, DWORD PTR _tmp$16$[esp+160]
	sub	edx, ebx
	mov	ebx, DWORD PTR _t3$2$[esp+160]
	sbb	DWORD PTR _tmp$16$[esp+160], eax
	mov	eax, esi
	mov	DWORD PTR _tmp$12$[esp+160], ecx
	mov	ecx, edi
	mov	DWORD PTR _tmp$15$[esp+160], edx
	mov	edx, DWORD PTR _t3$6$[esp+160]
	add	eax, edx
	adc	ecx, ebx
	sub	edx, esi
	mov	esi, eax
	sbb	ebx, edi
	mov	edi, DWORD PTR _tmp$11$[esp+160]
	add	esi, edi
	mov	DWORD PTR _tmp$9$[esp+160], esi
	mov	esi, ecx
	adc	esi, DWORD PTR _tmp$12$[esp+160]
	sub	edi, eax
	mov	eax, edx
	mov	DWORD PTR _tmp$10$[esp+160], esi
	sbb	DWORD PTR _tmp$12$[esp+160], ecx
	mov	ecx, DWORD PTR _tmp$15$[esp+160]
	add	eax, ecx
	mov	esi, DWORD PTR _tmp$16$[esp+160]
	mov	DWORD PTR _tmp$13$[esp+160], eax
	mov	eax, ebx
	adc	eax, esi
	mov	DWORD PTR _tmp$11$[esp+160], edi
	mov	edi, DWORD PTR _pix2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _tmp$14$[esp+160], eax
	sbb	esi, ebx
	mov	DWORD PTR _tmp$15$[esp+160], ecx
	add	edi, DWORD PTR _i_pix2$[ebp]
	mov	ebx, DWORD PTR _pix1$[ebp]
	add	ebx, DWORD PTR _i_pix1$[ebp]
	mov	DWORD PTR _tmp$16$[esp+160], esi
	xor	esi, esi
	movzx	ecx, WORD PTR [edi+8]
	mov	DWORD PTR _pix1$[ebp], ebx
	movzx	eax, WORD PTR [ebx+8]
	sub	eax, ecx
	mov	DWORD PTR _pix2$[ebp], edi
	movzx	ecx, WORD PTR [edi]
	cdq
	mov	DWORD PTR _t3$4$[esp+160], eax
	movzx	eax, WORD PTR [ebx]
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi+10]
	cdq
	add	esi, eax
	movzx	eax, WORD PTR [ebx+10]
	mov	DWORD PTR _t3$8$[esp+160], esi
	adc	DWORD PTR _t3$4$[esp+160], edx
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi+2]
	xor	ebx, ebx
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	eax, WORD PTR [eax+2]
	sub	eax, ecx
	cdq

; 99   :     a2 = (reinterpret_cast<const uint16_t *>(pix1)[2] - reinterpret_cast<const uint16_t *>(pix2)[2]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[6] - reinterpret_cast<const uint16_t *>(pix2)[6]) << BITS_PER_SUM);

	add	ebx, eax
	movzx	ecx, WORD PTR [edi+12]
	mov	eax, DWORD PTR _pix1$[ebp]
	adc	esi, edx
	mov	DWORD PTR _a1$3$[esp+160], esi
	xor	esi, esi
	movzx	eax, WORD PTR [eax+12]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	ecx, WORD PTR [ecx+4]
	movzx	eax, WORD PTR [eax+4]
	sub	eax, ecx

; 100  :     a3 = (reinterpret_cast<const uint16_t *>(pix1)[3] - reinterpret_cast<const uint16_t *>(pix2)[3]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[7] - reinterpret_cast<const uint16_t *>(pix2)[7]) << BITS_PER_SUM);

	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	add	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	mov	DWORD PTR _t3$7$[esp+160], esi
	movzx	ecx, WORD PTR [ecx+14]
	adc	edi, edx
	mov	DWORD PTR _t3$3$[esp+160], edi
	xor	esi, esi
	movzx	eax, WORD PTR [eax+14]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	ecx, WORD PTR [ecx+6]
	movzx	eax, WORD PTR [eax+6]
	sub	eax, ecx
	cdq
	add	esi, eax

; 101  :     HADAMARD4( tmp[i][0], tmp[i][1], tmp[i][2], tmp[i][3], a0,a1,a2,a3 );

	mov	eax, ebx
	adc	edi, edx
	mov	edx, DWORD PTR _t3$8$[esp+160]
	add	eax, edx
	mov	DWORD PTR _t3$7$[esp+160], eax
	mov	eax, DWORD PTR _a1$3$[esp+160]
	mov	ecx, eax
	adc	ecx, DWORD PTR _t3$4$[esp+160]
	sub	edx, ebx
	mov	ebx, DWORD PTR _t3$3$[esp+160]
	sbb	DWORD PTR _t3$4$[esp+160], eax
	mov	eax, esi
	mov	DWORD PTR _t3$3$[esp+160], ecx
	mov	ecx, edi
	mov	DWORD PTR _t3$8$[esp+160], edx
	mov	edx, DWORD PTR _t3$7$[esp+160]
	add	eax, edx
	adc	ecx, ebx
	sub	edx, esi
	mov	esi, eax
	sbb	ebx, edi
	mov	edi, DWORD PTR _t3$7$[esp+160]
	add	esi, edi
	mov	DWORD PTR _t3$5$[esp+160], esi
	mov	esi, ecx
	adc	esi, DWORD PTR _t3$3$[esp+160]
	sub	edi, eax
	mov	eax, edx
	mov	DWORD PTR _t3$1$[esp+160], esi
	sbb	DWORD PTR _t3$3$[esp+160], ecx
	mov	ecx, DWORD PTR _t3$8$[esp+160]
	add	eax, ecx
	mov	esi, DWORD PTR _t3$4$[esp+160]
	mov	DWORD PTR _t3$6$[esp+160], eax
	mov	eax, ebx
	adc	eax, esi
	mov	DWORD PTR _t3$7$[esp+160], edi
	mov	edi, DWORD PTR _pix2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _t3$2$[esp+160], eax
	sbb	esi, ebx
	mov	DWORD PTR _t3$8$[esp+160], ecx
	mov	ebx, DWORD PTR _pix1$[ebp]
	add	ebx, DWORD PTR _i_pix1$[ebp]
	mov	DWORD PTR _t3$4$[esp+160], esi
	mov	DWORD PTR _pix1$[ebp], ebx

; 92   :   sum2_t tmp[4][4];
; 93   :   sum2_t a0, a1, a2, a3;
; 94   :   sum2_t sum = 0;
; 95   :   for( int i = 0; i < 4; i++, pix1 += i_pix1, pix2 += i_pix2 )
; 96   :   {
; 97   :     a0 = (reinterpret_cast<const uint16_t *>(pix1)[0] - reinterpret_cast<const uint16_t *>(pix2)[0]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[4] - reinterpret_cast<const uint16_t *>(pix2)[4]) << BITS_PER_SUM);

	add	edi, DWORD PTR _i_pix2$[ebp]
	xor	esi, esi
	movzx	eax, WORD PTR [ebx+8]
	mov	DWORD PTR _pix2$[ebp], edi
	movzx	ecx, WORD PTR [edi+8]
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi]
	cdq
	mov	DWORD PTR _tmp$32$[esp+160], eax
	movzx	eax, WORD PTR [ebx]
	sub	eax, ecx

; 98   :     a1 = (reinterpret_cast<const uint16_t *>(pix1)[1] - reinterpret_cast<const uint16_t *>(pix2)[1]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[5] - reinterpret_cast<const uint16_t *>(pix2)[5]) << BITS_PER_SUM);

	movzx	ecx, WORD PTR [edi+10]
	cdq
	add	esi, eax
	movzx	eax, WORD PTR [ebx+10]
	mov	DWORD PTR _tmp$31$[esp+160], esi
	adc	DWORD PTR _tmp$32$[esp+160], edx
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi+2]
	xor	ebx, ebx
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	eax, WORD PTR [eax+2]
	sub	eax, ecx

; 99   :     a2 = (reinterpret_cast<const uint16_t *>(pix1)[2] - reinterpret_cast<const uint16_t *>(pix2)[2]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[6] - reinterpret_cast<const uint16_t *>(pix2)[6]) << BITS_PER_SUM);

	movzx	ecx, WORD PTR [edi+12]
	cdq
	add	ebx, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	adc	esi, edx
	mov	DWORD PTR _a1$4$[esp+160], esi
	xor	esi, esi
	movzx	eax, WORD PTR [eax+12]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	ecx, WORD PTR [ecx+4]
	movzx	eax, WORD PTR [eax+4]
	sub	eax, ecx

; 100  :     a3 = (reinterpret_cast<const uint16_t *>(pix1)[3] - reinterpret_cast<const uint16_t *>(pix2)[3]) + ((sum2_t)(reinterpret_cast<const uint16_t *>(pix1)[7] - reinterpret_cast<const uint16_t *>(pix2)[7]) << BITS_PER_SUM);

	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	add	esi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	mov	DWORD PTR _t3$8$[esp+160], esi
	movzx	ecx, WORD PTR [ecx+14]
	adc	edi, edx
	mov	DWORD PTR _t3$4$[esp+160], edi
	xor	esi, esi
	movzx	eax, WORD PTR [eax+14]
	sub	eax, ecx
	mov	ecx, DWORD PTR _pix2$[ebp]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR _pix1$[ebp]
	movzx	ecx, WORD PTR [ecx+6]
	movzx	eax, WORD PTR [eax+6]
	sub	eax, ecx
	cdq
	add	esi, eax

; 101  :     HADAMARD4( tmp[i][0], tmp[i][1], tmp[i][2], tmp[i][3], a0,a1,a2,a3 );

	mov	eax, ebx
	adc	edi, edx
	mov	edx, DWORD PTR _tmp$31$[esp+160]
	add	eax, edx
	mov	DWORD PTR _tmp$27$[esp+160], eax
	mov	eax, DWORD PTR _a1$4$[esp+160]
	mov	ecx, eax
	adc	ecx, DWORD PTR _tmp$32$[esp+160]
	sub	edx, ebx
	mov	ebx, DWORD PTR _t3$8$[esp+160]
	sbb	DWORD PTR _tmp$32$[esp+160], eax
	mov	eax, esi
	add	eax, ebx
	mov	DWORD PTR _tmp$28$[esp+160], ecx
	mov	DWORD PTR _tmp$31$[esp+160], edx
	mov	ecx, edi
	mov	edx, DWORD PTR _t3$4$[esp+160]
	adc	ecx, edx
	sub	ebx, esi
	sbb	edx, edi
	mov	edi, DWORD PTR _tmp$27$[esp+160]
	mov	esi, ecx
	mov	DWORD PTR _t3$4$[esp+160], edx
	mov	edx, eax
	add	edx, edi

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	0

; 101  :     HADAMARD4( tmp[i][0], tmp[i][1], tmp[i][2], tmp[i][3], a0,a1,a2,a3 );

	adc	esi, DWORD PTR _tmp$28$[esp+164]
	sub	edi, eax
	mov	DWORD PTR _tmp$27$[esp+164], edi
	mov	eax, ebx
	sbb	DWORD PTR _tmp$28$[esp+164], ecx
	mov	edi, DWORD PTR _tmp$31$[esp+164]
	add	eax, edi
	mov	DWORD PTR _tmp$29$[esp+164], eax
	mov	eax, DWORD PTR _t3$4$[esp+164]
	mov	ecx, eax
	adc	ecx, DWORD PTR _tmp$32$[esp+164]
	sub	edi, ebx
	mov	DWORD PTR _tmp$30$[esp+164], ecx
	sbb	DWORD PTR _tmp$32$[esp+164], eax

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	eax, DWORD PTR _tmp$9$[esp+164]
	mov	ebx, eax
	add	ebx, DWORD PTR _a3$13$[esp+164]
	mov	ecx, DWORD PTR _tmp$10$[esp+164]
	mov	DWORD PTR _tmp$31$[esp+164], edi
	mov	edi, ecx
	adc	edi, DWORD PTR _a3$5$[esp+164]
	sub	DWORD PTR _a3$13$[esp+164], eax
	mov	eax, edx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	-1

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	sbb	DWORD PTR _a3$5$[esp+168], ecx
	mov	ecx, esi
	add	eax, DWORD PTR _t3$5$[esp+168]
	adc	ecx, DWORD PTR _t3$1$[esp+168]
	sub	DWORD PTR _t3$5$[esp+168], edx
	mov	edx, eax
	sbb	DWORD PTR _t3$1$[esp+168], esi
	add	edx, ebx
	mov	esi, ecx
	mov	DWORD PTR _a0$13$[esp+168], edx
	adc	esi, edi
	sub	ebx, eax
	mov	eax, DWORD PTR _t3$5$[esp+168]
	sbb	edi, ecx
	mov	DWORD PTR _a2$13$[esp+168], ebx
	mov	ecx, DWORD PTR _t3$1$[esp+168]
	mov	ebx, eax
	add	ebx, DWORD PTR _a3$13$[esp+168]
	mov	DWORD PTR _a2$5$[esp+168], edi
	mov	edi, ecx
	adc	edi, DWORD PTR _a3$5$[esp+168]
	sub	DWORD PTR _a3$13$[esp+168], eax

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	eax, esi

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a0$5$[esp+168], esi
	sbb	DWORD PTR _a3$5$[esp+168], ecx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	ecx, edx
	shrd	ecx, eax, 31

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a1$13$[esp+168], ebx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	shr	eax, 31					; 0000001fH
	and	ecx, 1
	and	eax, 1

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a1$5$[esp+168], edi

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	eax
	push	ecx
	call	__allmul
	mov	esi, ebx
	mov	DWORD PTR _s$1$[esp+160], eax
	mov	ecx, edi
	mov	DWORD PTR _s$5$[esp+160], edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul
	mov	esi, DWORD PTR _a2$13$[esp+160]
	mov	DWORD PTR _s$1$[esp+160], eax
	mov	DWORD PTR _s$5$[esp+160], edx
	mov	ecx, DWORD PTR _a2$5$[esp+160]
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul
	mov	esi, DWORD PTR _a3$13$[esp+160]
	mov	edi, eax
	mov	ecx, DWORD PTR _a3$5$[esp+160]
	mov	ebx, edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul

; 57   :   return (a+s)^s;

	mov	esi, eax
	mov	ecx, edx
	add	esi, DWORD PTR _a3$13$[esp+160]
	adc	ecx, DWORD PTR _a3$5$[esp+160]
	xor	esi, eax
	xor	ecx, edx
	mov	eax, ebx
	mov	DWORD PTR _sum$2$[esp+160], ecx
	mov	ecx, edi
	add	ecx, DWORD PTR _a2$13$[esp+160]

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	edx, DWORD PTR _a3$14$[esp+160]

; 57   :   return (a+s)^s;

	adc	eax, DWORD PTR _a2$5$[esp+160]
	xor	ecx, edi

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	mov	edi, DWORD PTR _sum$2$[esp+160]

; 57   :   return (a+s)^s;

	xor	eax, ebx

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	esi, ecx

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$1$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	mov	ebx, esi
	mov	esi, DWORD PTR _a3$6$[esp+160]
	adc	edi, eax

; 57   :   return (a+s)^s;

	add	ecx, DWORD PTR _a1$13$[esp+160]
	mov	eax, DWORD PTR _s$5$[esp+160]
	adc	eax, DWORD PTR _a1$5$[esp+160]
	xor	ecx, DWORD PTR _s$1$[esp+160]
	xor	eax, DWORD PTR _s$5$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	ebx, ecx

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$1$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	adc	edi, eax

; 57   :   return (a+s)^s;

	add	ecx, DWORD PTR _a0$13$[esp+160]
	mov	eax, DWORD PTR _s$5$[esp+160]
	adc	eax, DWORD PTR _a0$5$[esp+160]
	xor	ecx, DWORD PTR _s$1$[esp+160]
	xor	eax, DWORD PTR _s$5$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	ebx, ecx
	mov	DWORD PTR _sum$1$[esp+160], ebx
	mov	ebx, DWORD PTR _tmp$13$[esp+160]
	adc	edi, eax
	add	ebx, edx
	mov	DWORD PTR _sum$2$[esp+160], edi
	mov	edi, DWORD PTR _tmp$14$[esp+160]
	adc	edi, esi
	sub	edx, DWORD PTR _tmp$13$[esp+160]
	mov	DWORD PTR _a3$14$[esp+160], edx
	sbb	esi, DWORD PTR _tmp$14$[esp+160]
	mov	edx, DWORD PTR _tmp$29$[esp+160]
	mov	eax, edx
	add	eax, DWORD PTR _t3$6$[esp+160]
	mov	DWORD PTR _a3$6$[esp+160], esi
	mov	esi, DWORD PTR _tmp$30$[esp+160]
	mov	ecx, esi
	adc	ecx, DWORD PTR _t3$2$[esp+160]
	sub	DWORD PTR _t3$6$[esp+160], edx
	mov	edx, eax
	sbb	DWORD PTR _t3$2$[esp+160], esi
	add	edx, ebx
	mov	esi, ecx
	mov	DWORD PTR _a0$14$[esp+160], edx
	adc	esi, edi

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	sub	ebx, eax
	mov	DWORD PTR _a0$6$[esp+160], esi
	mov	eax, DWORD PTR _t3$6$[esp+160]
	sbb	edi, ecx
	mov	DWORD PTR _a2$14$[esp+160], ebx
	mov	ecx, DWORD PTR _t3$2$[esp+160]
	mov	ebx, eax
	add	ebx, DWORD PTR _a3$14$[esp+160]
	mov	DWORD PTR _a2$6$[esp+160], edi
	mov	edi, ecx
	adc	edi, DWORD PTR _a3$6$[esp+160]
	sub	DWORD PTR _a3$14$[esp+160], eax

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	eax, esi
	push	0

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	sbb	DWORD PTR _a3$6$[esp+164], ecx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	ecx, edx
	shrd	ecx, eax, 31
	push	-1
	shr	eax, 31					; 0000001fH
	and	ecx, 1
	and	eax, 1

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a1$14$[esp+168], ebx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	eax
	push	ecx

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a1$6$[esp+176], edi

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	call	__allmul
	mov	esi, ebx
	mov	DWORD PTR _s$2$[esp+160], eax
	mov	ecx, edi
	mov	DWORD PTR _s$6$[esp+160], edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul
	mov	esi, DWORD PTR _a2$14$[esp+160]
	mov	ecx, DWORD PTR _a2$6$[esp+160]
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	mov	DWORD PTR _s$2$[esp+168], eax
	push	ecx
	push	esi
	mov	DWORD PTR _s$6$[esp+176], edx
	call	__allmul
	mov	esi, DWORD PTR _a3$14$[esp+160]
	mov	edi, eax
	mov	ecx, DWORD PTR _a3$6$[esp+160]
	mov	ebx, edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul

; 57   :   return (a+s)^s;

	mov	ecx, eax
	mov	esi, edx
	add	ecx, DWORD PTR _a3$14$[esp+160]
	adc	esi, DWORD PTR _a3$6$[esp+160]
	xor	ecx, eax
	mov	DWORD PTR tv293[esp+160], ecx
	xor	esi, edx

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	mov	edx, DWORD PTR tv293[esp+160]

; 57   :   return (a+s)^s;

	mov	ecx, edi
	add	ecx, DWORD PTR _a2$14$[esp+160]
	mov	eax, ebx
	adc	eax, DWORD PTR _a2$6$[esp+160]
	xor	ecx, edi
	xor	eax, ebx

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx
	adc	esi, eax

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$2$[esp+160]
	add	ecx, DWORD PTR _a1$14$[esp+160]
	mov	eax, DWORD PTR _s$6$[esp+160]
	adc	eax, DWORD PTR _a1$6$[esp+160]
	xor	eax, DWORD PTR _s$6$[esp+160]
	xor	ecx, DWORD PTR _s$2$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx
	mov	ebx, DWORD PTR _tmp$11$[esp+160]

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$2$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	adc	esi, eax
	mov	edi, DWORD PTR _tmp$12$[esp+160]

; 57   :   return (a+s)^s;

	add	ecx, DWORD PTR _a0$14$[esp+160]
	mov	eax, DWORD PTR _s$6$[esp+160]
	adc	eax, DWORD PTR _a0$6$[esp+160]
	xor	ecx, DWORD PTR _s$2$[esp+160]
	xor	eax, DWORD PTR _s$6$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	0

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	adc	esi, eax
	add	DWORD PTR _sum$1$[esp+164], edx
	mov	edx, DWORD PTR _a3$15$[esp+164]
	adc	DWORD PTR _sum$2$[esp+164], esi
	add	ebx, edx
	mov	esi, DWORD PTR _a3$7$[esp+164]
	adc	edi, esi
	sub	edx, DWORD PTR _tmp$11$[esp+164]
	mov	DWORD PTR _a3$15$[esp+164], edx
	sbb	esi, DWORD PTR _tmp$12$[esp+164]
	mov	edx, DWORD PTR _tmp$27$[esp+164]
	mov	eax, edx
	add	eax, DWORD PTR _t3$7$[esp+164]
	mov	DWORD PTR _a3$7$[esp+164], esi
	mov	esi, DWORD PTR _tmp$28$[esp+164]
	mov	ecx, esi
	adc	ecx, DWORD PTR _t3$3$[esp+164]
	sub	DWORD PTR _t3$7$[esp+164], edx
	mov	edx, eax

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	-1

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	sbb	DWORD PTR _t3$3$[esp+168], esi
	add	edx, ebx
	mov	esi, ecx
	mov	DWORD PTR _a0$15$[esp+168], edx
	adc	esi, edi
	sub	ebx, eax
	mov	eax, DWORD PTR _t3$7$[esp+168]
	sbb	edi, ecx
	mov	DWORD PTR _a2$15$[esp+168], ebx
	mov	ecx, DWORD PTR _t3$3$[esp+168]
	mov	ebx, eax
	add	ebx, DWORD PTR _a3$15$[esp+168]
	mov	DWORD PTR _a2$7$[esp+168], edi
	mov	edi, ecx
	adc	edi, DWORD PTR _a3$7$[esp+168]
	sub	DWORD PTR _a3$15$[esp+168], eax

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	eax, esi

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a0$7$[esp+168], esi
	sbb	DWORD PTR _a3$7$[esp+168], ecx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	ecx, edx
	shrd	ecx, eax, 31

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a1$15$[esp+168], ebx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	shr	eax, 31					; 0000001fH
	and	ecx, 1
	and	eax, 1

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a1$7$[esp+168], edi

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	eax
	push	ecx
	call	__allmul
	mov	esi, ebx
	mov	DWORD PTR _s$3$[esp+160], eax
	mov	ecx, edi
	mov	DWORD PTR _s$7$[esp+160], edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul
	mov	DWORD PTR _s$3$[esp+160], eax
	mov	esi, DWORD PTR _a2$15$[esp+160]
	mov	ecx, DWORD PTR _a2$7$[esp+160]
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	mov	DWORD PTR _s$7$[esp+168], edx
	push	ecx
	push	esi
	call	__allmul
	mov	esi, DWORD PTR _a3$15$[esp+160]
	mov	edi, eax
	mov	ecx, DWORD PTR _a3$7$[esp+160]
	mov	ebx, edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul

; 57   :   return (a+s)^s;

	mov	ecx, eax
	mov	esi, edx
	add	ecx, DWORD PTR _a3$15$[esp+160]
	adc	esi, DWORD PTR _a3$7$[esp+160]
	xor	ecx, eax
	xor	esi, edx
	mov	DWORD PTR tv371[esp+160], ecx

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	mov	edx, ecx

; 57   :   return (a+s)^s;

	mov	ecx, edi
	add	ecx, DWORD PTR _a2$15$[esp+160]
	mov	eax, ebx
	adc	eax, DWORD PTR _a2$7$[esp+160]
	xor	ecx, edi
	xor	eax, ebx

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	edi, DWORD PTR _tmp$16$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx
	mov	ebx, DWORD PTR _tmp$15$[esp+160]

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$3$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	adc	esi, eax

; 57   :   return (a+s)^s;

	add	ecx, DWORD PTR _a1$15$[esp+160]
	mov	eax, DWORD PTR _s$7$[esp+160]
	adc	eax, DWORD PTR _a1$7$[esp+160]
	xor	ecx, DWORD PTR _s$3$[esp+160]
	xor	eax, DWORD PTR _s$7$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$3$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	adc	esi, eax

; 57   :   return (a+s)^s;

	add	ecx, DWORD PTR _a0$15$[esp+160]
	mov	eax, DWORD PTR _s$7$[esp+160]
	adc	eax, DWORD PTR _a0$7$[esp+160]
	xor	ecx, DWORD PTR _s$3$[esp+160]
	xor	eax, DWORD PTR _s$7$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx
	mov	ecx, DWORD PTR _a3$16$[esp+160]
	adc	esi, eax
	add	DWORD PTR _sum$1$[esp+160], edx
	mov	edx, DWORD PTR _tmp$31$[esp+160]
	mov	eax, edx
	adc	DWORD PTR _sum$2$[esp+160], esi
	add	ebx, ecx
	mov	esi, DWORD PTR _a3$8$[esp+160]
	adc	edi, esi
	sub	ecx, DWORD PTR _tmp$15$[esp+160]
	mov	DWORD PTR _a3$16$[esp+160], ecx
	sbb	esi, DWORD PTR _tmp$16$[esp+160]
	add	eax, DWORD PTR _t3$8$[esp+160]
	mov	DWORD PTR _a3$8$[esp+160], esi
	mov	esi, DWORD PTR _tmp$32$[esp+160]
	mov	ecx, esi
	adc	ecx, DWORD PTR _t3$4$[esp+160]
	sub	DWORD PTR _t3$8$[esp+160], edx
	mov	edx, eax
	sbb	DWORD PTR _t3$4$[esp+160], esi
	add	edx, ebx
	mov	DWORD PTR _a0$16$[esp+160], edx
	mov	esi, ecx

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	adc	esi, edi
	sub	ebx, eax
	mov	eax, DWORD PTR _t3$8$[esp+160]
	sbb	edi, ecx
	mov	DWORD PTR _a2$16$[esp+160], ebx
	mov	ecx, DWORD PTR _t3$4$[esp+160]
	mov	ebx, eax
	add	ebx, DWORD PTR _a3$16$[esp+160]
	mov	DWORD PTR _a2$8$[esp+160], edi
	mov	edi, ecx
	adc	edi, DWORD PTR _a3$8$[esp+160]
	sub	DWORD PTR _a3$16$[esp+160], eax

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	eax, esi
	push	0

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	sbb	DWORD PTR _a3$8$[esp+164], ecx

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	mov	ecx, edx
	shrd	ecx, eax, 31
	push	-1
	shr	eax, 31					; 0000001fH
	and	ecx, 1
	and	eax, 1

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a0$8$[esp+168], esi

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	push	eax
	push	ecx

; 102  :   }
; 103  :   for( int i = 0; i < 4; i++ )
; 104  :   {
; 105  :     HADAMARD4( a0, a1, a2, a3, tmp[0][i], tmp[1][i], tmp[2][i], tmp[3][i] );

	mov	DWORD PTR _a1$16$[esp+176], ebx
	mov	DWORD PTR _a1$8$[esp+176], edi

; 56   :   sum2_t s = ((a>>(BITS_PER_SUM-1))&(((sum2_t)1<<BITS_PER_SUM)+1))*((sum_t)-1);

	call	__allmul
	mov	esi, ebx
	mov	DWORD PTR _s$4$[esp+160], eax
	mov	ecx, edi
	mov	DWORD PTR _s$8$[esp+160], edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul
	mov	esi, DWORD PTR _a2$16$[esp+160]
	mov	ecx, DWORD PTR _a2$8$[esp+160]
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	mov	DWORD PTR _s$4$[esp+168], eax
	push	ecx
	push	esi
	mov	DWORD PTR _s$8$[esp+176], edx
	call	__allmul
	mov	esi, DWORD PTR _a3$16$[esp+160]
	mov	edi, eax
	mov	ecx, DWORD PTR _a3$8$[esp+160]
	mov	ebx, edx
	shrd	esi, ecx, 31
	push	0
	shr	ecx, 31					; 0000001fH
	and	esi, 1
	push	-1
	and	ecx, 1
	push	ecx
	push	esi
	call	__allmul

; 57   :   return (a+s)^s;

	mov	ecx, eax
	mov	esi, edx
	add	ecx, DWORD PTR _a3$16$[esp+160]
	adc	esi, DWORD PTR _a3$8$[esp+160]
	xor	ecx, eax
	mov	DWORD PTR tv435[esp+160], ecx
	xor	esi, edx

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	mov	edx, DWORD PTR tv435[esp+160]

; 57   :   return (a+s)^s;

	mov	ecx, edi
	add	ecx, DWORD PTR _a2$16$[esp+160]
	mov	eax, ebx
	adc	eax, DWORD PTR _a2$8$[esp+160]
	xor	ecx, edi
	xor	eax, ebx

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$4$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	adc	esi, eax

; 57   :   return (a+s)^s;

	add	ecx, DWORD PTR _a1$16$[esp+160]
	mov	eax, DWORD PTR _s$8$[esp+160]
	adc	eax, DWORD PTR _a1$8$[esp+160]
	xor	ecx, DWORD PTR _s$4$[esp+160]
	xor	eax, DWORD PTR _s$8$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx

; 57   :   return (a+s)^s;

	mov	ecx, DWORD PTR _s$4$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	adc	esi, eax

; 57   :   return (a+s)^s;

	add	ecx, DWORD PTR _a0$16$[esp+160]
	mov	eax, DWORD PTR _s$8$[esp+160]
	adc	eax, DWORD PTR _a0$8$[esp+160]
	xor	ecx, DWORD PTR _s$4$[esp+160]
	xor	eax, DWORD PTR _s$8$[esp+160]

; 106  :     sum += abs2(a0) + abs2(a1) + abs2(a2) + abs2(a3);

	add	edx, ecx

; 107  :   }
; 108  :   return (((sum_t)sum) + (sum>>BITS_PER_SUM)) >> 1; // (low_32 + high_32)/2 (8 bit: (low_16 + high_16)/2)
; 109  : }

	pop	edi
	adc	esi, eax
	mov	eax, DWORD PTR _sum$1$[esp+156]
	add	eax, edx
	mov	edx, DWORD PTR _sum$2$[esp+156]
	adc	edx, esi
	xor	ecx, ecx
	add	eax, edx
	pop	esi
	adc	ecx, ecx
	shrd	eax, ecx, 1
	pop	ebx
	shr	ecx, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ENDP		; x264_pixel_satd_uint16_8x4_c
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv367 = -8						; size = 4
tv375 = -4						; size = 4
_pix1$ = 8						; size = 4
_i_pix1$ = 12						; size = 4
_pix2$ = 16						; size = 4
_i_pix2$ = 20						; size = 4
?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z PROC	; x264_pixel_satd_uint16_16x16_c, COMDAT

; 128  : PIXEL_SATD_UINT16_C(16,16,x264_pixel_satd_uint16_8x4_c )

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _i_pix1$[ebp]
	mov	edx, DWORD PTR _i_pix2$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _pix1$[ebp]
	push	esi
	mov	esi, DWORD PTR _pix2$[ebp]
	lea	eax, DWORD PTR [edx+edx*2]
	push	edi
	lea	edi, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _pix2$[ebp]
	push	edx
	lea	esi, DWORD PTR [esi+edx*4]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _pix1$[ebp]
	mov	DWORD PTR tv375[esp+28], eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	ebx, DWORD PTR [ebx+eax*4]
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	ecx
	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	mov	ecx, DWORD PTR _pix2$[ebp]
	mov	DWORD PTR tv367[esp+40], eax
	mov	eax, DWORD PTR _i_pix2$[ebp]
	push	eax
	lea	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _i_pix1$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _pix1$[ebp]
	push	eax
	lea	ecx, DWORD PTR [ecx+eax*8]
	add	ecx, 16					; 00000010H
	push	ecx
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	add	DWORD PTR tv367[esp+56], eax
	push	DWORD PTR _i_pix2$[ebp]
	mov	eax, DWORD PTR tv375[esp+60]
	add	eax, 16					; 00000010H
	push	eax
	push	DWORD PTR _i_pix1$[ebp]
	lea	eax, DWORD PTR [ebx+16]
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	add	DWORD PTR tv367[esp+72], eax
	push	DWORD PTR _i_pix2$[ebp]
	mov	eax, DWORD PTR _pix2$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR _pix1$[ebp]
	push	DWORD PTR _i_pix1$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	add	DWORD PTR tv367[esp+88], eax
	add	esp, 64					; 00000040H
	push	DWORD PTR _i_pix2$[ebp]
	push	esi
	push	DWORD PTR _i_pix1$[ebp]
	push	edi
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	mov	ecx, DWORD PTR _i_pix2$[ebp]
	mov	edx, DWORD PTR _pix2$[ebp]
	mov	esi, DWORD PTR tv367[esp+40]
	mov	edi, DWORD PTR _i_pix1$[ebp]
	add	esi, eax
	push	ecx
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _pix1$[ebp]
	push	eax
	push	edi
	lea	eax, DWORD PTR [ecx+edi*8]
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	push	DWORD PTR _i_pix2$[ebp]
	add	esi, eax
	push	DWORD PTR tv375[esp+60]
	push	edi
	push	ebx
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	push	DWORD PTR _i_pix2$[ebp]
	add	esi, eax
	push	DWORD PTR _pix2$[ebp]
	push	edi
	push	DWORD PTR _pix1$[ebp]
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	add	esp, 64					; 00000040H
	add	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z ENDP	; x264_pixel_satd_uint16_16x16_c
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pix1$ = 8						; size = 4
_i_pix1$ = 12						; size = 4
_pix2$ = 16						; size = 4
_i_pix2$ = 20						; size = 4
?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z PROC	; x264_pixel_satd_uint16_16x8_c, COMDAT

; 129  : PIXEL_SATD_UINT16_C(16,8,x264_pixel_satd_uint16_8x4_c )

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	mov	eax, DWORD PTR _i_pix2$[ebp]
	mov	ecx, DWORD PTR _pix2$[ebp]
	mov	edx, DWORD PTR _pix1$[ebp]
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _i_pix1$[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+16]
	push	eax
	lea	esi, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	push	DWORD PTR _i_pix2$[ebp]
	mov	ecx, DWORD PTR _pix2$[ebp]
	mov	ebx, eax
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _pix1$[ebp]
	push	DWORD PTR _i_pix1$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	push	DWORD PTR _i_pix2$[ebp]
	add	ebx, eax
	push	edi
	mov	edi, DWORD PTR _i_pix1$[ebp]
	push	edi
	push	esi
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	push	DWORD PTR _i_pix2$[ebp]
	add	ebx, eax
	push	DWORD PTR _pix2$[ebp]
	push	edi
	push	DWORD PTR _pix1$[ebp]
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	add	esp, 64					; 00000040H
	add	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z ENDP	; x264_pixel_satd_uint16_16x8_c
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?x264_pixel_satd_uint16_8x16_c@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pix1$ = 8						; size = 4
_i_pix1$ = 12						; size = 4
_pix2$ = 16						; size = 4
_i_pix2$ = 20						; size = 4
?x264_pixel_satd_uint16_8x16_c@@YAIPBEH0H@Z PROC	; x264_pixel_satd_uint16_8x16_c, COMDAT

; 130  : PIXEL_SATD_UINT16_C(8,16,x264_pixel_satd_uint16_8x4_c )

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	mov	eax, DWORD PTR _i_pix2$[ebp]
	mov	ecx, DWORD PTR _pix2$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _i_pix1$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pix1$[ebp]
	push	eax
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	push	eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [edi+eax*4]
	push	ebx
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	mov	ecx, DWORD PTR _i_pix2$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _pix2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [eax+ecx*8]
	push	ecx
	lea	ecx, DWORD PTR [edi+ebx*8]
	push	ebx
	push	ecx
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	mov	ecx, DWORD PTR _i_pix2$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR _pix2$[ebp]
	push	ecx
	lea	eax, DWORD PTR [eax+ecx*4]
	push	eax
	lea	eax, DWORD PTR [edi+ebx*4]
	push	ebx
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	mov	ecx, DWORD PTR _i_pix2$[ebp]
	add	esi, eax
	push	ecx
	push	DWORD PTR _pix2$[ebp]
	push	ebx
	push	edi
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	add	esp, 64					; 00000040H
	add	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?x264_pixel_satd_uint16_8x16_c@@YAIPBEH0H@Z ENDP	; x264_pixel_satd_uint16_8x16_c
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ?x264_pixel_satd_uint16_8x8_c@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pix1$ = 8						; size = 4
_i_pix1$ = 12						; size = 4
_pix2$ = 16						; size = 4
_i_pix2$ = 20						; size = 4
?x264_pixel_satd_uint16_8x8_c@@YAIPBEH0H@Z PROC		; x264_pixel_satd_uint16_8x8_c, COMDAT

; 131  : PIXEL_SATD_UINT16_C(8,8,x264_pixel_satd_uint16_8x4_c )

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	mov	ecx, DWORD PTR _i_pix2$[ebp]
	mov	eax, DWORD PTR _pix2$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _i_pix1$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _pix1$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
	push	ecx
	push	eax
	push	ebx
	lea	eax, DWORD PTR [edi+ebx*4]
	push	eax
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	push	DWORD PTR _i_pix2$[ebp]
	mov	esi, eax
	push	DWORD PTR _pix2$[ebp]
	push	ebx
	push	edi
	call	?x264_pixel_satd_uint16_8x4_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_8x4_c
	add	esp, 32					; 00000020H
	add	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?x264_pixel_satd_uint16_8x8_c@@YAIPBEH0H@Z ENDP		; x264_pixel_satd_uint16_8x8_c
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT _x264_pixel_satd_uint16_32x32_c
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
_x264_pixel_satd_uint16_32x32_c PROC			; COMDAT

; 150  : SATD_REC_FUNC_UINT16 (32, 32, 16, 16, c)

	mov	edx, DWORD PTR _nRefPitch$[esp-4]
	mov	ecx, DWORD PTR _nSrcPitch$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+4]
	mov	ebx, edx
	push	esi
	shl	ebx, 4
	mov	esi, ecx
	add	ebx, DWORD PTR _pRef$[esp+8]
	push	edi
	shl	esi, 4
	push	edx
	add	esi, ebp
	lea	eax, DWORD PTR [ebx+32]
	push	eax
	push	ecx
	lea	eax, DWORD PTR [esi+32]
	push	eax
	call	?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x16_c
	push	DWORD PTR _nRefPitch$[esp+28]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	mov	edi, eax
	add	ecx, 32					; 00000020H
	push	ecx
	push	DWORD PTR _nSrcPitch$[esp+36]
	lea	ecx, DWORD PTR [ebp+32]
	push	ecx
	call	?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x16_c
	push	DWORD PTR _nRefPitch$[esp+44]
	add	edi, eax
	push	ebx
	mov	ebx, DWORD PTR _nSrcPitch$[esp+52]
	push	ebx
	push	esi
	call	?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x16_c
	push	DWORD PTR _nRefPitch$[esp+60]
	add	edi, eax
	push	DWORD PTR _pRef$[esp+64]
	push	ebx
	push	ebp
	call	?x264_pixel_satd_uint16_16x16_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x16_c
	add	esp, 64					; 00000040H
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_x264_pixel_satd_uint16_32x32_c ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT _x264_pixel_satd_uint16_32x16_c
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
_x264_pixel_satd_uint16_32x16_c PROC			; COMDAT

; 151  : SATD_REC_FUNC_UINT16 (32, 16, 16,  8, c)

	mov	eax, DWORD PTR _nRefPitch$[esp-4]
	mov	ecx, DWORD PTR _pRef$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nSrcPitch$[esp+4]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _pSrc$[esp+12]
	push	eax
	lea	eax, DWORD PTR [edi+32]
	push	eax
	lea	esi, DWORD PTR [ecx+ebp*8]
	lea	eax, DWORD PTR [esi+32]
	push	ebp
	push	eax
	call	?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x8_c
	push	DWORD PTR _nRefPitch$[esp+28]
	mov	ecx, DWORD PTR _pRef$[esp+32]
	mov	ebx, eax
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _pSrc$[esp+36]
	add	ecx, 32					; 00000020H
	push	ebp
	push	ecx
	call	?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x8_c
	push	DWORD PTR _nRefPitch$[esp+44]
	add	ebx, eax
	push	edi
	push	ebp
	push	esi
	call	?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x8_c
	push	DWORD PTR _nRefPitch$[esp+60]
	add	ebx, eax
	push	DWORD PTR _pRef$[esp+64]
	push	ebp
	push	DWORD PTR _pSrc$[esp+72]
	call	?x264_pixel_satd_uint16_16x8_c@@YAIPBEH0H@Z ; x264_pixel_satd_uint16_16x8_c
	add	esp, 64					; 00000040H
	add	eax, ebx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_x264_pixel_satd_uint16_32x16_c ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >, COMDAT
; _this$ = ecx
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
	pop	ecx
	ret	0
??1?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::~map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT _x264_pixel_satd_32x32_sse2
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
_x264_pixel_satd_32x32_sse2 PROC			; COMDAT

; 440  : SATD_REC_FUNC (32, 32, 16, 16, sse2)

	mov	edx, DWORD PTR _nRefPitch$[esp-4]
	mov	ecx, DWORD PTR _nSrcPitch$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+4]
	mov	ebx, edx
	push	esi
	push	edi
	shl	ebx, 4
	mov	edi, ecx
	add	ebx, DWORD PTR _pRef$[esp+12]
	shl	edi, 4
	push	edx
	add	edi, ebp
	lea	eax, DWORD PTR [ebx+16]
	push	eax
	push	ecx
	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	_x264_pixel_satd_16x16_sse2
	push	DWORD PTR _nRefPitch$[esp+28]
	mov	esi, eax
	push	ebx
	mov	ebx, DWORD PTR _nSrcPitch$[esp+36]
	push	ebx
	push	edi
	call	_x264_pixel_satd_16x16_sse2
	mov	edi, DWORD PTR _pRef$[esp+44]
	add	esi, eax
	push	DWORD PTR _nRefPitch$[esp+44]
	lea	eax, DWORD PTR [edi+16]
	push	eax
	lea	eax, DWORD PTR [ebp+16]
	push	ebx
	push	eax
	call	_x264_pixel_satd_16x16_sse2
	push	DWORD PTR _nRefPitch$[esp+60]
	add	esi, eax
	push	edi
	push	ebx
	push	ebp
	call	_x264_pixel_satd_16x16_sse2
	add	esp, 64					; 00000040H
	add	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_x264_pixel_satd_32x32_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT _x264_pixel_satd_32x16_sse2
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
_x264_pixel_satd_32x16_sse2 PROC			; COMDAT

; 441  : SATD_REC_FUNC (32, 16, 16,  8, sse2)

	mov	eax, DWORD PTR _nRefPitch$[esp-4]
	mov	ecx, DWORD PTR _pRef$[esp-4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nSrcPitch$[esp+4]
	push	esi
	push	edi
	lea	ebx, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _pSrc$[esp+12]
	push	eax
	lea	eax, DWORD PTR [ebx+16]
	push	eax
	lea	edi, DWORD PTR [ecx+ebp*8]
	lea	eax, DWORD PTR [edi+16]
	push	ebp
	push	eax
	call	_x264_pixel_satd_16x8_sse2
	push	DWORD PTR _nRefPitch$[esp+28]
	mov	esi, eax
	push	ebx
	push	ebp
	push	edi
	call	_x264_pixel_satd_16x8_sse2
	mov	ebx, DWORD PTR _nRefPitch$[esp+44]
	add	esi, eax
	mov	eax, DWORD PTR _pRef$[esp+44]
	mov	edi, DWORD PTR _pSrc$[esp+44]
	add	eax, 16					; 00000010H
	push	ebx
	push	eax
	push	ebp
	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	_x264_pixel_satd_16x8_sse2
	push	ebx
	push	DWORD PTR _pRef$[esp+64]
	add	esi, eax
	push	ebp
	push	edi
	call	_x264_pixel_satd_16x8_sse2
	add	esp, 64					; 00000040H
	add	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
_x264_pixel_satd_32x16_sse2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

	push	ecx
	push	esi
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [esi]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1092 : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Keyval$ = 8						; size = 4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[], COMDAT
; _this$ = ecx

; 177  : 		{	// find element matching _Keyval or insert with default mapped

	sub	esp, 8

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp+4]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >

; 178  : 		return (try_emplace(_STD move(_Keyval)).first->second);

	mov	eax, DWORD PTR $T1[esp+8]
	add	eax, 32					; 00000020H

; 179  : 		}

	add	esp, 8
	ret	4
??A?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAEAAP6AIPBEH0H@Z$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >, COMDAT
; _this$ = ecx

; 100  : 		{	// construct empty map from defaults

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 101  : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	0
??0?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator->, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 407  : 		return (pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 727  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[esp+12]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase

; 2169 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+8], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1005 : 		}

	mov	eax, esi
	pop	esi
	pop	ecx
	ret	4
??0?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> *>::pointer_to, COMDAT
; __Val$ = ecx

; 280  : 		return (_STD addressof(_Val));

	mov	eax, ecx

; 281  : 		}

	ret	0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@SAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Freeheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 846  : 		}

	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

	push	esi
	mov	esi, ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 705  : 		_Construct();
; 706  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

	push	ecx

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp]

; 1445 : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	esi, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	edx, esi

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN176@erase

; 1446 : 			{	// erase all
; 1447 : 			clear();

	call	?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::clear

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN176@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 279  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN133@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN178@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN188@erase
	npad	7
$LL144@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL144@erase

; 65   : 		else

	jmp	SHORT $LN188@erase
$LN178@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN188@erase
$LL128@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN188@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[esp+8], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL128@erase
$LN188@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[esp+8], edx
$LN133@erase:

; 1453 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T1[esp+16]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[esp+8]
	cmp	eax, DWORD PTR __Last$[esp+8]

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

	mov	eax, ecx

; 1455 : 			}
; 1456 : 		}

	pop	ecx
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::end, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1122 : 		}

	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::begin, COMDAT
; _this$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1112 : 		}

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 385  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 279  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], edx

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator++

; 280  : 		++*this;
; 281  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 282  : 		}

	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));
; 250  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 911  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

	push	esi
	mov	esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 722  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 684  : 		}

	ret	0
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 679  : 		}

	ret	0
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Left, COMDAT
; __Pnode$ = ecx

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, ecx

; 674  : 		}

	ret	0
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2078 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+4]

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	esi, ebx

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN23@clear
	npad	6
$LL24@clear:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL24@clear
$LN23@clear:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1477 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1473 : 		_Root() = this->_Myhead();
; 1474 : 		_Lmost() = this->_Myhead();
; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1477 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1195 = -12						; size = 4
tv1197 = -8						; size = 4
tv1196 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 123  : 		return (_Ptr);

	mov	ebp, DWORD PTR __Where$[esp+16]

; 1259 : 		{	// erase element at _Where

	mov	ebx, ecx
	push	esi
	push	edi

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[esp+24]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator++

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [ebp]

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1270 : 		++_Where;	// save successor iterator for return
; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN691@erase
$LN5@erase:
	mov	eax, DWORD PTR [ebp+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, ecx

; 1281 : 		else

	jmp	SHORT $LN691@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[esp+24]

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

	cmp	edx, ebp
	jne	$LN9@erase
$LN691@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1297 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [ebx]

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [edx], ebp
	jne	SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	ecx, esi
	jmp	SHORT $LN166@erase
$LN42@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, edi

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
	npad	3
$LL165@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx], ecx
$LN16@erase:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR [ebx]

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [edx+8], ebp
	jne	$LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	ecx, esi
	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN44@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, edi

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
	npad	1
$LL217@erase:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [edx+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [ecx+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ebp+8]
	jne	SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1320 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebp+4]

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 50   : 	_Left = _STD move(_Right);

	mov	al, BYTE PTR [ebp+12]
	mov	cl, BYTE PTR [edx+12]
	mov	BYTE PTR [edx+12], al

; 51   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ebp+12], cl
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ebp+12], 1
	jne	$LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	4
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	edx, esi
	mov	DWORD PTR tv1195[esp+28], edx
	mov	DWORD PTR tv1197[esp+28], esi
	mov	DWORD PTR tv1196[esp+28], esi
	jne	$LN3@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, esi
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN694@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN3@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR tv1195[esp+28]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN694@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1197[esp+28]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1196[esp+28]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebp
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[esp+24]

; 1436 : 		if (0 < this->_Mysize())

	test	eax, eax
	je	SHORT $LN693@erase

; 1437 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN693@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,
; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

	add	esp, 12					; 0000000cH
	ret	8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rrotate
	jmp	SHORT $LN3@erase
?erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

	mov	eax, esi
	pop	esi

; 275  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 604  : 		}

	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Right, COMDAT
; __Pnode$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [ecx+8]

; 599  : 		}

	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Parent, COMDAT
; __Pnode$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [ecx+4]

; 594  : 		}

	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Left, COMDAT
; __Pnode$ = ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, ecx

; 589  : 		}

	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 941  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN61@Buyheadnod
	mov	DWORD PTR [eax], eax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 832  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
$LL4@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 699  : 		}

	ret	0
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
	npad	7
$LL4@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 694  : 		}

	ret	0
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myval, COMDAT
; __Pnode$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [ecx+16]

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 689  : 		}

	ret	0
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 669  : 		}

	ret	0
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 664  : 		}

	ret	0
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN3@Rrotate:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Root, COMDAT
; _this$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2107 : 		return (this->_Parent(this->_Myhead()));
; 2108 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2102 : 		return (this->_Right(this->_Myhead()));
; 2103 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN3@Lrotate:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	mov	ebx, ecx
	mov	esi, edi

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN3@Erase
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL4@Erase
$LN3@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 2038 : 			this->_Getal().destroy(
; 2039 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2040 : 
; 2041 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2042 : 			}
; 2043 : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Min, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

	mov	eax, ecx

; 618  : 		}

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Max, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
	npad	7
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Isnil, COMDAT
; __Pnode$ = ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	lea	eax, DWORD PTR [ecx+13]

; 584  : 		}

	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Color, COMDAT
; __Pnode$ = ecx

; 578  : 		return ((char&)_Pnode->_Color);

	lea	eax, DWORD PTR [ecx+12]

; 579  : 		}

	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	ret	4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0CA@$0CA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv658 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0CA@$0CA@E@@YAIPBEH0H@Z PROC			; Sad_C<32,32,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 32					; 00000020H
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv658[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv658[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 32					; 00000020H
	jge	$LN21@Sad_C
	mov	eax, 32					; 00000020H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv658[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv658[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0CA@$0CA@E@@YAIPBEH0H@Z ENDP			; Sad_C<32,32,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0CA@$0BA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv659 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0CA@$0BA@E@@YAIPBEH0H@Z PROC			; Sad_C<32,16,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 16					; 00000010H
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv659[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv659[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 32					; 00000020H
	jge	$LN21@Sad_C
	mov	eax, 32					; 00000020H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv659[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv659[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0CA@$0BA@E@@YAIPBEH0H@Z ENDP			; Sad_C<32,16,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0CA@$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv659 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0CA@$07E@@YAIPBEH0H@Z PROC			; Sad_C<32,8,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 8
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv659[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv659[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 32					; 00000020H
	jge	$LN21@Sad_C
	mov	eax, 32					; 00000020H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv659[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv659[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0CA@$07E@@YAIPBEH0H@Z ENDP			; Sad_C<32,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$0CA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv659 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$0CA@E@@YAIPBEH0H@Z PROC			; Sad_C<16,32,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 32					; 00000020H
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv659[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv659[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv659[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv659[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$0CA@E@@YAIPBEH0H@Z ENDP			; Sad_C<16,32,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$0BA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv658 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$0BA@E@@YAIPBEH0H@Z PROC			; Sad_C<16,16,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 16					; 00000010H
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv658[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv658[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv658[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv658[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$0BA@E@@YAIPBEH0H@Z ENDP			; Sad_C<16,16,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv659 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$07E@@YAIPBEH0H@Z PROC			; Sad_C<16,8,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 8
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv659[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv659[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv659[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv659[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$07E@@YAIPBEH0H@Z ENDP			; Sad_C<16,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv659 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$03E@@YAIPBEH0H@Z PROC			; Sad_C<16,4,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 4
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv659[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv659[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv659[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv659[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$03E@@YAIPBEH0H@Z ENDP			; Sad_C<16,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv659 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$01E@@YAIPBEH0H@Z PROC			; Sad_C<16,2,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	esi, DWORD PTR _pSrc$[esp+24]
	xor	edx, edx
	xorps	xmm3, xmm3
	mov	DWORD PTR _sum$1$[esp+28], edx
	mov	eax, 2
	movaps	xmm2, xmm3
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	DWORD PTR tv659[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
	npad	11
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv659[esp+32]
$LN16@Sad_C:
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], ebx
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	ebx, DWORD PTR [ecx+edi]
	sub	ebp, edi
	mov	edi, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	edx, BYTE PTR [ebx+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	edi, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], edi
	mov	edi, DWORD PTR _pRef$[esp+28]
	mov	ebx, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+edi]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [ebx+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv659[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	edi, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], edi
	mov	DWORD PTR tv659[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$01E@@YAIPBEH0H@Z ENDP			; Sad_C<16,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv580 = -8						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$00E@@YAIPBEH0H@Z PROC			; Sad_C<16,1,unsigned char>, COMDAT

; 15   : {

	sub	esp, 8
	xorps	xmm3, xmm3

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	movaps	xmm2, xmm3
	push	ebx
	mov	ebx, DWORD PTR _pRef$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+12]
	push	esi
	xor	esi, esi
	cmp	DWORD PTR ___isa_available, 2
	push	edi
	jl	SHORT $LN16@Sad_C
	mov	edx, ebp
	mov	eax, ebx
	sub	edx, ebx
	npad	8
$LL7@Sad_C:
	movd	xmm0, DWORD PTR [edx+eax]
	lea	eax, DWORD PTR [eax+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-8]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [ecx+ebp+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [eax-4]
	add	ecx, 8
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
$LN16@Sad_C:
	xor	edi, edi
	mov	DWORD PTR $T1[esp+24], esi
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	esi, ebp
	lea	eax, DWORD PTR [ebp+1]
	sub	esi, ebx
	mov	DWORD PTR tv580[esp+24], eax
	lea	edi, DWORD PTR [ecx+ebx]
	xor	ebx, ebx
	xor	ebp, ebp
	npad	5
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+esi-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebx, eax
	mov	eax, DWORD PTR tv580[esp+24]
	movzx	edx, BYTE PTR [eax+ecx]
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebp, eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	DWORD PTR $T2[esp+24], ebx
	xor	esi, esi
	mov	ebx, DWORD PTR _pRef$[esp+20]
	mov	edi, DWORD PTR $T2[esp+24]
	mov	DWORD PTR $T1[esp+24], ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
$LC22@Sad_C:

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+ebp]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
$LN23@Sad_C:
	mov	eax, DWORD PTR $T1[esp+24]
	add	eax, edi
	add	esi, eax
$LN21@Sad_C:
	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	paddd	xmm2, xmm0
	movd	eax, xmm2
	pop	edi

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 8
	ret	0
??$Sad_C@$0BA@$00E@@YAIPBEH0H@Z ENDP			; Sad_C<16,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$0BA@E@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv605 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$0BA@E@@YAIPBEH0H@Z PROC			; Sad_C<8,16,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 16					; 00000010H
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv605[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx+4]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	edi, DWORD PTR [ecx+ebx]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	ebx, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv605[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv605[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$0BA@E@@YAIPBEH0H@Z ENDP			; Sad_C<8,16,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv604 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$07E@@YAIPBEH0H@Z PROC			; Sad_C<8,8,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 8
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv604[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx+4]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	edi, DWORD PTR [ecx+ebx]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	ebx, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv604[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv604[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$07E@@YAIPBEH0H@Z ENDP			; Sad_C<8,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv605 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$03E@@YAIPBEH0H@Z PROC			; Sad_C<8,4,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 4
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv605[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx+4]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	edi, DWORD PTR [ecx+ebx]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	ebx, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv605[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv605[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$03E@@YAIPBEH0H@Z ENDP			; Sad_C<8,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv605 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$01E@@YAIPBEH0H@Z PROC			; Sad_C<8,2,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 2
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv605[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movd	xmm0, DWORD PTR [esi+4]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx+4]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	ebp, esi
	lea	edi, DWORD PTR [ecx+ebx]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	ebx, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv605[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv605[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$01E@@YAIPBEH0H@Z ENDP			; Sad_C<8,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv506 = -8						; size = 4
$T1 = -8						; size = 4
tv504 = -4						; size = 4
$T2 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$00E@@YAIPBEH0H@Z PROC			; Sad_C<8,1,unsigned char>, COMDAT

; 15   : {

	mov	ecx, DWORD PTR _pSrc$[esp-4]
	sub	esp, 8
	xorps	xmm3, xmm3
	movaps	xmm2, xmm3
	push	ebx
	push	ebp

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	ebp, DWORD PTR _pRef$[esp+12]
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [ecx]
	mov	esi, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebp]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0
	movd	xmm0, DWORD PTR [ecx+4]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm3, xmm1

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebp+4]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm2, xmm1
$LN16@Sad_C:
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+24], ebx
	cmp	esi, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	eax, ecx
	lea	ebx, DWORD PTR [esi+ebp]
	sub	eax, ebp
	inc	ecx
	xor	ebp, ebp
	mov	DWORD PTR tv504[esp+24], eax
	mov	DWORD PTR tv506[esp+24], ecx
	xor	edi, edi
	npad	1
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, BYTE PTR [eax+ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	eax, BYTE PTR [ebx-2]
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebp, eax
	mov	eax, DWORD PTR tv506[esp+24]
	movzx	ecx, BYTE PTR [eax+esi]
	add	esi, 2
	movzx	eax, BYTE PTR [ebx-1]
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	edi, eax
	mov	eax, DWORD PTR tv504[esp+24]
	cmp	esi, 7
	jl	SHORT $LL24@Sad_C
	mov	DWORD PTR $T2[esp+24], ebp
	mov	ebp, DWORD PTR _pRef$[esp+20]
	mov	ebx, DWORD PTR $T2[esp+24]
	mov	DWORD PTR $T1[esp+24], edi
	xor	edi, edi
$LC22@Sad_C:

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	esi, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	eax, DWORD PTR _pSrc$[esp+20]
	movzx	ecx, BYTE PTR [esi+eax]
	movzx	eax, BYTE PTR [esi+ebp]
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
$LN23@Sad_C:
	mov	eax, DWORD PTR $T1[esp+24]
	add	eax, ebx
	add	edi, eax
$LN21@Sad_C:
	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	paddd	xmm2, xmm0
	movd	eax, xmm2

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 8
	ret	0
??$Sad_C@$07$00E@@YAIPBEH0H@Z ENDP			; Sad_C<8,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$07E@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv494 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$07E@@YAIPBEH0H@Z PROC			; Sad_C<4,8,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	mov	eax, 8
	push	edi
	mov	DWORD PTR _sum$1$[esp+32], edx
	xorps	xmm2, xmm2
	mov	DWORD PTR tv494[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [esi]
	mov	ecx, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	mov	ebp, esi
	lea	edi, DWORD PTR [ecx+ebx]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
	npad	4
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	ebx, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 3
	jl	SHORT $LL23@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC21@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN22@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv494[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN20@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv494[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$03$07E@@YAIPBEH0H@Z ENDP			; Sad_C<4,8,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv493 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$03E@@YAIPBEH0H@Z PROC			; Sad_C<4,4,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	mov	eax, 4
	push	edi
	mov	DWORD PTR _sum$1$[esp+32], edx
	xorps	xmm2, xmm2
	mov	DWORD PTR tv493[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [esi]
	mov	ecx, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	mov	ebp, esi
	lea	edi, DWORD PTR [ecx+ebx]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
	npad	4
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	ebx, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 3
	jl	SHORT $LL23@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC21@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN22@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv493[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN20@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv493[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$03$03E@@YAIPBEH0H@Z ENDP			; Sad_C<4,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv494 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$01E@@YAIPBEH0H@Z PROC			; Sad_C<4,2,unsigned char>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	mov	eax, 2
	push	edi
	mov	DWORD PTR _sum$1$[esp+32], edx
	xorps	xmm2, xmm2
	mov	DWORD PTR tv494[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [esi]
	mov	ecx, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	mov	ebp, esi
	lea	edi, DWORD PTR [ecx+ebx]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
	npad	4
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [edi+ebp-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, BYTE PTR [ecx+esi+1]
	add	ebx, eax
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 3
	jl	SHORT $LL23@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC21@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+esi]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN22@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv494[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN20@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv494[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$03$01E@@YAIPBEH0H@Z ENDP			; Sad_C<4,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv468 = -8						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$00E@@YAIPBEH0H@Z PROC			; Sad_C<4,1,unsigned char>, COMDAT

; 15   : {

	sub	esp, 8

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	xorps	xmm2, xmm2
	push	ebx
	mov	ebx, DWORD PTR _pRef$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _pSrc$[esp+12]
	push	esi
	xor	esi, esi
	cmp	DWORD PTR ___isa_available, 2
	push	edi
	jl	SHORT $LN16@Sad_C
	movd	xmm0, DWORD PTR [ebp]
	mov	ecx, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxbd xmm1, xmm0
	movd	xmm0, DWORD PTR [ebx]
	pmovzxbd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm2, xmm1
$LN16@Sad_C:
	xor	edi, edi
	mov	DWORD PTR $T1[esp+24], esi
	cmp	ecx, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, ecx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	mov	esi, ebp
	lea	eax, DWORD PTR [ebp+1]
	sub	esi, ebx
	mov	DWORD PTR tv468[esp+24], eax
	lea	edi, DWORD PTR [ecx+ebx]
	xor	ebx, ebx
	xor	ebp, ebp
	npad	3
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	edx, BYTE PTR [esi+edi-2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebx, eax
	mov	eax, DWORD PTR tv468[esp+24]
	movzx	edx, BYTE PTR [eax+ecx]
	add	ecx, 2
	movzx	eax, BYTE PTR [edi-1]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebp, eax
	cmp	ecx, 3
	jl	SHORT $LL23@Sad_C
	mov	DWORD PTR $T2[esp+24], ebx
	xor	esi, esi
	mov	ebx, DWORD PTR _pRef$[esp+20]
	mov	edi, DWORD PTR $T2[esp+24]
	mov	DWORD PTR $T1[esp+24], ebp
	mov	ebp, DWORD PTR _pSrc$[esp+20]
$LC21@Sad_C:

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ecx+ebx]
	movzx	edx, BYTE PTR [ecx+ebp]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
$LN22@Sad_C:
	mov	eax, DWORD PTR $T1[esp+24]
	add	eax, edi
	add	esi, eax
$LN20@Sad_C:
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	paddd	xmm2, xmm0
	movd	eax, xmm2
	pop	edi

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 8
	ret	0
??$Sad_C@$03$00E@@YAIPBEH0H@Z ENDP			; Sad_C<4,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$01$03E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$01$03E@@YAIPBEH0H@Z PROC			; Sad_C<2,4,unsigned char>, COMDAT

; 15   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+16]

; 21   :     pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, BYTE PTR [esi+1]
	add	ebp, esi
	movzx	ecx, BYTE PTR [edi+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [edi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [esi]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
	sub	ebx, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebx, eax
	movzx	eax, BYTE PTR [ebp+1]
	mov	DWORD PTR _sum$1$[esp+20], ebx

; 22   :     pRef += nRefPitch;

	mov	ebx, DWORD PTR _nRefPitch$[esp+16]
	add	ebx, edi
	movzx	ecx, BYTE PTR [ebx+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [ebx]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	edi, eax

; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+16]
	movzx	eax, BYTE PTR [ebp]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	edi, edx

; 21   :     pSrc += nSrcPitch;

	add	ebp, DWORD PTR _nSrcPitch$[esp+16]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	edi, edx
	cdq

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, BYTE PTR [ebx+1]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, DWORD PTR _sum$1$[esp+20]
	add	edi, eax
	movzx	eax, BYTE PTR [ebp+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [ebx]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [ebp]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	edi, eax
	mov	eax, DWORD PTR _nRefPitch$[esp+16]
	add	edi, esi
	movzx	ecx, BYTE PTR [ebx+eax+1]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, BYTE PTR [eax+ebp+1]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	eax, DWORD PTR _nRefPitch$[esp+16]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, BYTE PTR [ebx+eax]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, BYTE PTR [eax+ebp]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, edi
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 23   :   }
; 24   :   return sum;
; 25   : }

	pop	ecx
	ret	0
??$Sad_C@$01$03E@@YAIPBEH0H@Z ENDP			; Sad_C<2,4,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$01$01E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$01$01E@@YAIPBEH0H@Z PROC			; Sad_C<2,2,unsigned char>, COMDAT

; 15   : {

	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	ebx, DWORD PTR _pRef$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, BYTE PTR [ebx+1]
	push	edi

; 21   :     pSrc += nSrcPitch;

	mov	edi, DWORD PTR _nSrcPitch$[esp+12]
	movzx	eax, BYTE PTR [esi+1]
	add	edi, esi
	sub	eax, ecx
	movzx	ecx, BYTE PTR [ebx]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebp, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [esi]

; 22   :     pRef += nRefPitch;

	mov	esi, DWORD PTR _nRefPitch$[esp+12]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebp, edx

; 22   :     pRef += nRefPitch;

	add	esi, ebx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebp, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, BYTE PTR [esi+1]
	add	ebp, eax
	movzx	eax, BYTE PTR [edi+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [esi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebp
	pop	ebp
	add	eax, ebx
	pop	ebx

; 23   :   }
; 24   :   return sum;
; 25   : }

	ret	0
??$Sad_C@$01$01E@@YAIPBEH0H@Z ENDP			; Sad_C<2,2,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$01$00E@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$01$00E@@YAIPBEH0H@Z PROC			; Sad_C<2,1,unsigned char>, COMDAT

; 15   : {

	push	ebx
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pRef$[esp+4]
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, BYTE PTR [esi+1]
	movzx	eax, BYTE PTR [edi+1]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [esi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, BYTE PTR [edi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebx
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	ret	0
??$Sad_C@$01$00E@@YAIPBEH0H@Z ENDP			; Sad_C<2,1,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0CA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv713 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0CA@$0CA@G@@YAIPBEH0H@Z PROC			; Sad_C<32,32,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 32					; 00000020H
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv713[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv713[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 32					; 00000020H
	jge	$LN21@Sad_C
	mov	eax, 32					; 00000020H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv713[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv713[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0CA@$0CA@G@@YAIPBEH0H@Z ENDP			; Sad_C<32,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0CA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv714 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0CA@$0BA@G@@YAIPBEH0H@Z PROC			; Sad_C<32,16,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 16					; 00000010H
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv714[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv714[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 32					; 00000020H
	jge	$LN21@Sad_C
	mov	eax, 32					; 00000020H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv714[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv714[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0CA@$0BA@G@@YAIPBEH0H@Z ENDP			; Sad_C<32,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0CA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv714 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0CA@$07G@@YAIPBEH0H@Z PROC			; Sad_C<32,8,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 8
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv714[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv714[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 32					; 00000020H
	jge	$LN21@Sad_C
	mov	eax, 32					; 00000020H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 31					; 0000001fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv714[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv714[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0CA@$07G@@YAIPBEH0H@Z ENDP			; Sad_C<32,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv714 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$0CA@G@@YAIPBEH0H@Z PROC			; Sad_C<16,32,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 32					; 00000020H
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv714[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv714[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv714[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv714[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$0CA@G@@YAIPBEH0H@Z ENDP			; Sad_C<16,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv713 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$0BA@G@@YAIPBEH0H@Z PROC			; Sad_C<16,16,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 16					; 00000010H
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv713[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv713[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv713[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv713[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$0BA@G@@YAIPBEH0H@Z ENDP			; Sad_C<16,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv714 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$07G@@YAIPBEH0H@Z PROC			; Sad_C<16,8,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 8
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv714[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv714[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv714[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv714[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$07G@@YAIPBEH0H@Z ENDP			; Sad_C<16,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv714 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$03G@@YAIPBEH0H@Z PROC			; Sad_C<16,4,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 4
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv714[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv714[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv714[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv714[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$03G@@YAIPBEH0H@Z ENDP			; Sad_C<16,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
tv714 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$01G@@YAIPBEH0H@Z PROC			; Sad_C<16,2,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 2
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv714[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	mov	edx, esi
	lea	eax, DWORD PTR [ebx+8]
	sub	edx, ebx
	npad	10
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [esi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	eax, DWORD PTR tv714[esp+32]
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN28@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
	jmp	SHORT $LN23@Sad_C
$LN28@Sad_C:
	mov	edx, DWORD PTR _sum$1$[esp+32]
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv714[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv714[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$0BA@$01G@@YAIPBEH0H@Z ENDP			; Sad_C<16,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$0BA@$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv705 = -8						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$0BA@$00G@@YAIPBEH0H@Z PROC			; Sad_C<16,1,unsigned short>, COMDAT

; 15   : {

	sub	esp, 8
	xorps	xmm3, xmm3

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	movaps	xmm2, xmm3
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _pRef$[esp+12]
	push	esi
	xor	esi, esi
	cmp	DWORD PTR ___isa_available, 2
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+20]
	jl	SHORT $LN16@Sad_C
	mov	edx, edi
	lea	eax, DWORD PTR [ebp+8]
	sub	edx, ebp
	npad	7
$LL7@Sad_C:
	movq	xmm0, QWORD PTR [edi+ecx*2]
	lea	eax, DWORD PTR [eax+16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-24]
	add	ecx, 8
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [edx+eax-16]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [eax-16]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jl	SHORT $LL7@Sad_C
$LN16@Sad_C:
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+24], ebx
	cmp	ecx, 16					; 00000010H
	jge	$LN21@Sad_C
	mov	eax, 16					; 00000010H
	sub	eax, ecx
	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	eax, edi
	lea	ebx, DWORD PTR [ebp+2]
	sub	eax, ebp
	lea	ebx, DWORD PTR [ebx+ecx*2]
	xor	ebp, ebp
	mov	DWORD PTR tv705[esp+24], eax
	xor	esi, esi
	npad	5
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx-2]
	lea	ebx, DWORD PTR [ebx+4]
	movzx	edx, WORD PTR [edi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebp, eax
	mov	eax, DWORD PTR tv705[esp+24]
	movzx	edx, WORD PTR [ebx+eax-4]
	movzx	eax, WORD PTR [ebx-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	esi, eax
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LL24@Sad_C
	mov	DWORD PTR $T2[esp+24], ebp
	mov	ebp, DWORD PTR _pRef$[esp+20]
	mov	ebx, DWORD PTR $T2[esp+24]
	mov	DWORD PTR $T1[esp+24], esi
	xor	esi, esi
$LC22@Sad_C:

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebp+ecx*2]
	movzx	edx, WORD PTR [edi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
$LN23@Sad_C:
	mov	eax, DWORD PTR $T1[esp+24]
	add	eax, ebx
	add	esi, eax
$LN21@Sad_C:
	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	paddd	xmm2, xmm0
	movd	eax, xmm2
	pop	edi

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 8
	ret	0
??$Sad_C@$0BA@$00G@@YAIPBEH0H@Z ENDP			; Sad_C<16,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv596 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$0BA@G@@YAIPBEH0H@Z PROC			; Sad_C<8,16,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 16					; 00000010H
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv596[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [esi+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx+8]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv596[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv596[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$0BA@G@@YAIPBEH0H@Z ENDP			; Sad_C<8,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv595 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$07G@@YAIPBEH0H@Z PROC			; Sad_C<8,8,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 8
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv595[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [esi+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx+8]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv595[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv595[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$07G@@YAIPBEH0H@Z ENDP			; Sad_C<8,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv596 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$03G@@YAIPBEH0H@Z PROC			; Sad_C<8,4,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 4
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv596[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [esi+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx+8]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv596[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv596[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$03G@@YAIPBEH0H@Z ENDP			; Sad_C<8,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv596 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$01G@@YAIPBEH0H@Z PROC			; Sad_C<8,2,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	xorps	xmm3, xmm3
	mov	eax, 2
	mov	DWORD PTR _sum$1$[esp+28], edx
	push	edi
	movaps	xmm2, xmm3
	mov	DWORD PTR tv596[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [esi]
	mov	ecx, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm3, xmm0
	movq	xmm0, QWORD PTR [esi+8]

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx+8]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 7
	jl	SHORT $LL24@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC22@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN23@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv596[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN21@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv596[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$07$01G@@YAIPBEH0H@Z ENDP			; Sad_C<8,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$07$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv549 = -4						; size = 4
$T2 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$07$00G@@YAIPBEH0H@Z PROC			; Sad_C<8,1,unsigned short>, COMDAT

; 15   : {

	mov	ecx, DWORD PTR _pRef$[esp-4]
	sub	esp, 8
	xorps	xmm3, xmm3
	movaps	xmm2, xmm3
	push	ebx
	push	ebp

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	ebp, DWORD PTR _pSrc$[esp+12]
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [ebp]
	mov	esi, 8

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ecx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0
	movq	xmm0, QWORD PTR [ebp+8]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm3, xmm1

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ecx+8]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm2, xmm1
$LN16@Sad_C:
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+24], ebx
	cmp	esi, 8
	jge	$LN21@Sad_C
	mov	eax, 8
	sub	eax, esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC22@Sad_C
	mov	eax, ebp
	lea	ebx, DWORD PTR [esi+1]
	sub	eax, ecx
	lea	ebx, DWORD PTR [ecx+ebx*2]
	mov	DWORD PTR tv549[esp+24], eax
	xor	edi, edi
	npad	5
$LL24@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx-2]
	lea	ebx, DWORD PTR [ebx+4]
	movzx	ecx, WORD PTR [ebp+esi*2]
	add	esi, 2
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	edi, eax
	mov	eax, DWORD PTR tv549[esp+24]
	movzx	ecx, WORD PTR [eax+ebx-4]
	movzx	eax, WORD PTR [ebx-4]
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T1[esp+24], eax
	cmp	esi, 7
	jl	SHORT $LL24@Sad_C
	mov	DWORD PTR $T2[esp+24], edi
	xor	edi, edi
	mov	ebx, DWORD PTR $T2[esp+24]
$LC22@Sad_C:

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	esi, 8
	jge	SHORT $LN23@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	eax, DWORD PTR _pRef$[esp+20]
	movzx	ecx, WORD PTR [ebp+esi*2]
	movzx	eax, WORD PTR [eax+esi*2]
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
$LN23@Sad_C:
	mov	eax, DWORD PTR $T1[esp+24]
	add	eax, ebx
	add	edi, eax
$LN21@Sad_C:
	paddd	xmm2, xmm3
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	paddd	xmm2, xmm0
	movd	eax, xmm2

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 8
	ret	0
??$Sad_C@$07$00G@@YAIPBEH0H@Z ENDP			; Sad_C<8,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv503 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$07G@@YAIPBEH0H@Z PROC			; Sad_C<4,8,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	mov	eax, 8
	push	edi
	mov	DWORD PTR _sum$1$[esp+32], edx
	xorps	xmm2, xmm2
	mov	DWORD PTR tv503[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [esi]
	mov	ecx, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
	npad	1
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 3
	jl	SHORT $LL23@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC21@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN22@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv503[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN20@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv503[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$03$07G@@YAIPBEH0H@Z ENDP			; Sad_C<4,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv501 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$03G@@YAIPBEH0H@Z PROC			; Sad_C<4,4,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	mov	eax, 4
	push	edi
	mov	DWORD PTR _sum$1$[esp+32], edx
	xorps	xmm2, xmm2
	mov	DWORD PTR tv501[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [esi]
	mov	ecx, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
	npad	1
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 3
	jl	SHORT $LL23@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC21@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN22@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv501[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN20@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv501[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$03$03G@@YAIPBEH0H@Z ENDP			; Sad_C<4,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_sum$1$ = -8						; size = 4
tv503 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$01G@@YAIPBEH0H@Z PROC			; Sad_C<4,2,unsigned short>, COMDAT

; 15   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32

	mov	ebx, DWORD PTR _pRef$[esp+16]
	xor	edx, edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+24]
	mov	eax, 2
	push	edi
	mov	DWORD PTR _sum$1$[esp+32], edx
	xorps	xmm2, xmm2
	mov	DWORD PTR tv503[esp+32], eax
$LL4@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	xor	ecx, ecx
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [esi]
	mov	ecx, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ebx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm0, xmm1
	paddd	xmm2, xmm0
$LN16@Sad_C:
	xor	edi, edi
	xor	ebp, ebp
	mov	DWORD PTR $T1[esp+32], edi
	mov	DWORD PTR $T2[esp+32], ebp
	cmp	ecx, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, ecx

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	lea	edi, DWORD PTR [ecx+1]
	mov	ebp, esi
	lea	edi, DWORD PTR [ebx+edi*2]
	sub	ebp, ebx
	mov	ebx, DWORD PTR $T1[esp+32]
	npad	1
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi-2]
	lea	edi, DWORD PTR [edi+4]
	movzx	edx, WORD PTR [esi+ecx*2]
	add	ecx, 2
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	edx, WORD PTR [edi+ebp-4]
	add	ebx, eax
	movzx	eax, WORD PTR [edi-4]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T2[esp+32], eax
	cmp	ecx, 3
	jl	SHORT $LL23@Sad_C
	mov	ebp, DWORD PTR $T2[esp+32]
	mov	edx, DWORD PTR _sum$1$[esp+32]
	mov	DWORD PTR $T1[esp+32], ebx
	mov	ebx, DWORD PTR _pRef$[esp+28]
	mov	edi, DWORD PTR $T1[esp+32]
$LC21@Sad_C:

; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	ecx, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx+ecx*2]
	movzx	edx, WORD PTR [esi+ecx*2]
	sub	edx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	edx, DWORD PTR _sum$1$[esp+32]
	add	edx, eax
$LN22@Sad_C:
	lea	eax, DWORD PTR [edi+ebp]
	add	edx, eax
	mov	eax, DWORD PTR tv503[esp+32]
	mov	DWORD PTR _sum$1$[esp+32], edx
$LN20@Sad_C:

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+28]
	add	esi, DWORD PTR _nSrcPitch$[esp+28]
	sub	eax, 1
	mov	DWORD PTR _pRef$[esp+28], ebx
	mov	DWORD PTR tv503[esp+32], eax
	jne	$LL4@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	pop	edi
	paddd	xmm2, xmm0
	pop	esi
	movd	eax, xmm2
	pop	ebp
	pop	ebx
	add	eax, edx

; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 16					; 00000010H
	ret	0
??$Sad_C@$03$01G@@YAIPBEH0H@Z ENDP			; Sad_C<4,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$03$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv507 = -4						; size = 4
$T2 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$03$00G@@YAIPBEH0H@Z PROC			; Sad_C<4,1,unsigned short>, COMDAT

; 15   : {

	mov	ecx, DWORD PTR _pRef$[esp-4]
	sub	esp, 8
	xorps	xmm2, xmm2
	push	ebx
	push	ebp

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	mov	ebp, DWORD PTR _pSrc$[esp+12]
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN16@Sad_C
	movq	xmm0, QWORD PTR [ebp]
	mov	esi, 4

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	pmovzxwd xmm1, xmm0
	movq	xmm0, QWORD PTR [ecx]
	pmovzxwd xmm0, xmm0
	psubd	xmm1, xmm0

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	pabsd	xmm2, xmm1
$LN16@Sad_C:
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+24], ebx
	cmp	esi, 4
	jge	$LN20@Sad_C
	mov	eax, 4
	sub	eax, esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	eax, 2
	jl	SHORT $LC21@Sad_C
	mov	eax, ebp
	lea	ebx, DWORD PTR [esi+1]
	sub	eax, ecx
	lea	ebx, DWORD PTR [ecx+ebx*2]
	mov	DWORD PTR tv507[esp+24], eax
	xor	edi, edi
	npad	5
$LL23@Sad_C:

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebx-2]
	lea	ebx, DWORD PTR [ebx+4]
	movzx	ecx, WORD PTR [ebp+esi*2]
	add	esi, 2
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	edi, eax
	mov	eax, DWORD PTR tv507[esp+24]
	movzx	ecx, WORD PTR [eax+ebx-4]
	movzx	eax, WORD PTR [ebx-4]
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	DWORD PTR $T1[esp+24], eax
	cmp	esi, 3
	jl	SHORT $LL23@Sad_C
	mov	DWORD PTR $T2[esp+24], edi
	xor	edi, edi
	mov	ebx, DWORD PTR $T2[esp+24]
$LC21@Sad_C:

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )

	cmp	esi, 4
	jge	SHORT $LN22@Sad_C

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	eax, DWORD PTR _pRef$[esp+20]
	movzx	ecx, WORD PTR [ebp+esi*2]
	movzx	eax, WORD PTR [eax+esi*2]
	sub	ecx, eax

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	mov	eax, ecx
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
$LN22@Sad_C:
	mov	eax, DWORD PTR $T1[esp+24]
	add	eax, ebx
	add	edi, eax
$LN20@Sad_C:
	movaps	xmm0, xmm2
	psrldq	xmm0, 8
	paddd	xmm2, xmm0
	movaps	xmm0, xmm2
	psrldq	xmm0, 4
	paddd	xmm2, xmm0
	movd	eax, xmm2

; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	add	esp, 8
	ret	0
??$Sad_C@$03$00G@@YAIPBEH0H@Z ENDP			; Sad_C<4,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$01$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_sum$1$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$01$03G@@YAIPBEH0H@Z PROC			; Sad_C<2,4,unsigned short>, COMDAT

; 15   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pSrc$[esp+12]
	push	edi
	mov	edi, DWORD PTR _pRef$[esp+16]

; 21   :     pSrc += nSrcPitch;

	mov	ebp, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, WORD PTR [esi+2]
	add	ebp, esi
	movzx	ecx, WORD PTR [edi+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [edi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [esi]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx
	sub	ebx, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	ebx, eax
	movzx	eax, WORD PTR [ebp+2]
	mov	DWORD PTR _sum$1$[esp+20], ebx

; 22   :     pRef += nRefPitch;

	mov	ebx, DWORD PTR _nRefPitch$[esp+16]
	add	ebx, edi
	movzx	ecx, WORD PTR [ebx+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [ebx]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	edi, eax

; 22   :     pRef += nRefPitch;

	add	ebx, DWORD PTR _nRefPitch$[esp+16]
	movzx	eax, WORD PTR [ebp]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	edi, edx

; 21   :     pSrc += nSrcPitch;

	add	ebp, DWORD PTR _nSrcPitch$[esp+16]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	edi, edx
	cdq

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, WORD PTR [ebx+2]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, DWORD PTR _sum$1$[esp+20]
	add	edi, eax
	movzx	eax, WORD PTR [ebp+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [ebx]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [ebp]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	edi, eax
	mov	eax, DWORD PTR _nRefPitch$[esp+16]
	add	edi, esi
	movzx	ecx, WORD PTR [ebx+eax+2]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, WORD PTR [eax+ebp+2]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	esi, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	eax, DWORD PTR _nRefPitch$[esp+16]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	esi, edx
	sub	esi, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, WORD PTR [ebx+eax]
	mov	eax, DWORD PTR _nSrcPitch$[esp+16]
	movzx	eax, WORD PTR [eax+ebp]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, edi
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 23   :   }
; 24   :   return sum;
; 25   : }

	pop	ecx
	ret	0
??$Sad_C@$01$03G@@YAIPBEH0H@Z ENDP			; Sad_C<2,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$01$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$01$01G@@YAIPBEH0H@Z PROC			; Sad_C<2,2,unsigned short>, COMDAT

; 15   : {

	push	ebx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	ebx, DWORD PTR _pRef$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, WORD PTR [ebx+2]
	push	edi

; 21   :     pSrc += nSrcPitch;

	mov	edi, DWORD PTR _nSrcPitch$[esp+12]
	movzx	eax, WORD PTR [esi+2]
	add	edi, esi
	sub	eax, ecx
	movzx	ecx, WORD PTR [ebx]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebp, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [esi]

; 22   :     pRef += nRefPitch;

	mov	esi, DWORD PTR _nRefPitch$[esp+12]
	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebp, edx

; 22   :     pRef += nRefPitch;

	add	esi, ebx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebp, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	ecx, WORD PTR [esi+2]
	add	ebp, eax
	movzx	eax, WORD PTR [edi+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [esi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebp
	pop	ebp
	add	eax, ebx
	pop	ebx

; 23   :   }
; 24   :   return sum;
; 25   : }

	ret	0
??$Sad_C@$01$01G@@YAIPBEH0H@Z ENDP			; Sad_C<2,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.cpp
;	COMDAT ??$Sad_C@$01$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad_C@$01$00G@@YAIPBEH0H@Z PROC			; Sad_C<2,1,unsigned short>, COMDAT

; 15   : {

	push	ebx
	push	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	mov	esi, DWORD PTR _pRef$[esp+4]
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+8]
	movzx	ecx, WORD PTR [esi+2]
	movzx	eax, WORD PTR [edi+2]
	sub	eax, ecx
	movzx	ecx, WORD PTR [esi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	cdq
	mov	ebx, eax

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	movzx	eax, WORD PTR [edi]

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	xor	ebx, edx

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	sub	eax, ecx

; 9    : inline unsigned int SADABS(int x) {	return ( x < 0 ) ? -x : x; }

	sub	ebx, edx
	cdq
	xor	eax, edx
	pop	edi
	sub	eax, edx
	pop	esi

; 16   :   unsigned int sum = 0; // int is probably enough for 32x32
; 17   :   for ( int y = 0; y < nBlkHeight; y++ )
; 18   :   {
; 19   :     for ( int x = 0; x < nBlkWidth; x++ )
; 20   :       sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);

	add	eax, ebx
	pop	ebx

; 21   :     pSrc += nSrcPitch;
; 22   :     pRef += nRefPitch;
; 23   :   }
; 24   :   return sum;
; 25   : }

	ret	0
??$Sad_C@$01$00G@@YAIPBEH0H@Z ENDP			; Sad_C<2,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0CA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0CA@$0CA@G@@YAIPBEH0H@Z PROC		; Sad16_sse2<32,32,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 32		; 00000020H
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 4
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0CA@$0CA@G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<32,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0CA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0CA@$0BA@G@@YAIPBEH0H@Z PROC		; Sad16_sse2<32,16,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 16		; 00000010H
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 4
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0CA@$0BA@G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<32,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0CA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0CA@$07G@@YAIPBEH0H@Z PROC		; Sad16_sse2<32,8,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 8
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 4
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0CA@$07G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<32,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0BA@$0CA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0BA@$0CA@G@@YAIPBEH0H@Z PROC		; Sad16_sse2<16,32,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 32		; 00000020H
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 2
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0BA@$0CA@G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<16,32,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0BA@$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0BA@$0BA@G@@YAIPBEH0H@Z PROC		; Sad16_sse2<16,16,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 16		; 00000010H
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 2
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0BA@$0BA@G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<16,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0BA@$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0BA@$07G@@YAIPBEH0H@Z PROC		; Sad16_sse2<16,8,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 8
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 2
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0BA@$07G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<16,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0BA@$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0BA@$03G@@YAIPBEH0H@Z PROC		; Sad16_sse2<16,4,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 4
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 2
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0BA@$03G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<16,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0BA@$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv565 = -12						; size = 4
tv562 = -8						; size = 4
tv561 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0BA@$01G@@YAIPBEH0H@Z PROC		; Sad16_sse2<16,2,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	edx, DWORD PTR _pRef$[ebp]
	add	eax, eax
	mov	DWORD PTR tv562[esp+16], eax

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	push	esi
	add	eax, eax
	mov	DWORD PTR tv565[esp+20], 2
	push	edi
	mov	edi, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR tv561[esp+24], eax
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	esi, edi
	mov	eax, edx
	mov	edi, DWORD PTR _nSrcPitch$[ebp]
	sub	esi, edx
	mov	edx, 2
	npad	1
$LL7@Sad16_sse2:

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	lea	ecx, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [eax+16]
	movups	xmm1, XMMWORD PTR [ecx]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm3, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));

	movups	xmm1, XMMWORD PTR [ecx+edi]

; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));

	mov	ecx, DWORD PTR _nRefPitch$[ebp]

; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	psubusw	xmm2, xmm0

; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3

; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0
	punpcklwd xmm1, xmm4

; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3

; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	mov	edi, DWORD PTR _pSrc$[ebp]

; 193  :         pRef += nRefPitch * 2;

	mov	edx, DWORD PTR _pRef$[ebp]
	add	edi, DWORD PTR tv562[esp+24]
	add	edx, DWORD PTR tv561[esp+24]
	sub	DWORD PTR tv565[esp+24], 1
	mov	DWORD PTR _pSrc$[ebp], edi
	mov	DWORD PTR _pRef$[ebp], edx
	jne	$LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0BA@$01G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<16,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$0BA@$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$0BA@$00G@@YAIPBEH0H@Z PROC		; Sad16_sse2<16,1,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();
; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32
; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)

	mov	ecx, DWORD PTR _pSrc$[ebp]
	xorps	xmm3, xmm3
	mov	eax, DWORD PTR _pRef$[ebp]
	movaps	xmm4, xmm3
	sub	ecx, eax
	mov	edx, 2
	npad	7
$LL7@Sad16_sse2:
	lea	eax, DWORD PTR [eax+16]

; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));

	movups	xmm1, XMMWORD PTR [ecx+eax-16]

; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));

	movups	xmm0, XMMWORD PTR [eax-16]

; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	psubusw	xmm2, xmm0

; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0

; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2

; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm3
	punpcklwd xmm0, xmm3
	paddd	xmm4, xmm0
	paddd	xmm4, xmm2
	sub	edx, 1
	jne	SHORT $LL7@Sad16_sse2

; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;
; 193  :         pRef += nRefPitch * 2;
; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm4
	punpckldq xmm4, xmm3
	punpckhdq xmm1, xmm3

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm4

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm3

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);

	movd	eax, xmm0

; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$0BA@$00G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<16,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$07$0BA@G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv488 = -8						; size = 4
tv487 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$07$0BA@G@@YAIPBEH0H@Z PROC		; Sad16_sse2<8,16,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	ecx, DWORD PTR _pSrc$[ebp]

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv488[esp+12], eax
	push	edi
	lea	eax, DWORD PTR [esi+esi]
	mov	edi, 16					; 00000010H
	mov	DWORD PTR tv487[esp+16], eax
	mov	eax, DWORD PTR _pRef$[ebp]
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x

	movups	xmm1, XMMWORD PTR [ecx]

; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));

	movups	xmm0, XMMWORD PTR [eax]

; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x

	movups	xmm1, XMMWORD PTR [ecx+edx]

; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	add	ecx, DWORD PTR tv488[esp+16]
	por	xmm3, xmm0
	movups	xmm0, XMMWORD PTR [eax+esi]

; 193  :         pRef += nRefPitch * 2;

	add	eax, DWORD PTR tv487[esp+16]
	movaps	xmm2, xmm1
	psubusw	xmm2, xmm0
	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3
	por	xmm2, xmm0
	punpcklwd xmm1, xmm4
	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3
	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edi, 1
	jne	SHORT $LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$07$0BA@G@@YAIPBEH0H@Z ENDP		; Sad16_sse2<8,16,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$07$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv488 = -8						; size = 4
tv487 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$07$07G@@YAIPBEH0H@Z PROC			; Sad16_sse2<8,8,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	ecx, DWORD PTR _pSrc$[ebp]

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv488[esp+12], eax
	push	edi
	lea	eax, DWORD PTR [esi+esi]
	mov	edi, 8
	mov	DWORD PTR tv487[esp+16], eax
	mov	eax, DWORD PTR _pRef$[ebp]
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x

	movups	xmm1, XMMWORD PTR [ecx]

; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));

	movups	xmm0, XMMWORD PTR [eax]

; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x

	movups	xmm1, XMMWORD PTR [ecx+edx]

; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	add	ecx, DWORD PTR tv488[esp+16]
	por	xmm3, xmm0
	movups	xmm0, XMMWORD PTR [eax+esi]

; 193  :         pRef += nRefPitch * 2;

	add	eax, DWORD PTR tv487[esp+16]
	movaps	xmm2, xmm1
	psubusw	xmm2, xmm0
	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3
	por	xmm2, xmm0
	punpcklwd xmm1, xmm4
	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3
	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edi, 1
	jne	SHORT $LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$07$07G@@YAIPBEH0H@Z ENDP			; Sad16_sse2<8,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$07$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv488 = -8						; size = 4
tv487 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$07$03G@@YAIPBEH0H@Z PROC			; Sad16_sse2<8,4,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	ecx, DWORD PTR _pSrc$[ebp]

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv488[esp+12], eax
	push	edi
	lea	eax, DWORD PTR [esi+esi]
	mov	edi, 4
	mov	DWORD PTR tv487[esp+16], eax
	mov	eax, DWORD PTR _pRef$[ebp]
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x

	movups	xmm1, XMMWORD PTR [ecx]

; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));

	movups	xmm0, XMMWORD PTR [eax]

; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x

	movups	xmm1, XMMWORD PTR [ecx+edx]

; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	add	ecx, DWORD PTR tv488[esp+16]
	por	xmm3, xmm0
	movups	xmm0, XMMWORD PTR [eax+esi]

; 193  :         pRef += nRefPitch * 2;

	add	eax, DWORD PTR tv487[esp+16]
	movaps	xmm2, xmm1
	psubusw	xmm2, xmm0
	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3
	por	xmm2, xmm0
	punpcklwd xmm1, xmm4
	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3
	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edi, 1
	jne	SHORT $LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$07$03G@@YAIPBEH0H@Z ENDP			; Sad16_sse2<8,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$07$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv488 = -8						; size = 4
tv487 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$07$01G@@YAIPBEH0H@Z PROC			; Sad16_sse2<8,2,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	mov	edx, DWORD PTR _nSrcPitch$[ebp]
	xorps	xmm4, xmm4

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	ecx, DWORD PTR _pSrc$[ebp]

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	push	esi
	mov	esi, DWORD PTR _nRefPitch$[ebp]
	lea	eax, DWORD PTR [edx+edx]
	mov	DWORD PTR tv488[esp+12], eax
	push	edi
	lea	eax, DWORD PTR [esi+esi]
	mov	edi, 2
	mov	DWORD PTR tv487[esp+16], eax
	mov	eax, DWORD PTR _pRef$[ebp]
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x

	movups	xmm1, XMMWORD PTR [ecx]

; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));

	movups	xmm0, XMMWORD PTR [eax]

; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm3, xmm1
	psubusw	xmm3, xmm0

; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x

	movups	xmm1, XMMWORD PTR [ecx+edx]

; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	add	ecx, DWORD PTR tv488[esp+16]
	por	xmm3, xmm0
	movups	xmm0, XMMWORD PTR [eax+esi]

; 193  :         pRef += nRefPitch * 2;

	add	eax, DWORD PTR tv487[esp+16]
	movaps	xmm2, xmm1
	psubusw	xmm2, xmm0
	psubusw	xmm0, xmm1
	movaps	xmm1, xmm3
	por	xmm2, xmm0
	punpcklwd xmm1, xmm4
	movaps	xmm0, xmm2
	punpckhwd xmm3, xmm4
	paddd	xmm5, xmm1
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm3
	punpckhwd xmm2, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm2
	sub	edi, 1
	jne	SHORT $LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$07$01G@@YAIPBEH0H@Z ENDP			; Sad16_sse2<8,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$07$00G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$07$00G@@YAIPBEH0H@Z PROC			; Sad16_sse2<8,1,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();
; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32
; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x

	mov	eax, DWORD PTR _pSrc$[ebp]
	xorps	xmm3, xmm3
	movups	xmm1, XMMWORD PTR [eax]

; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));

	mov	eax, DWORD PTR _pRef$[ebp]

; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm2, xmm1
	movups	xmm0, XMMWORD PTR [eax]
	psubusw	xmm2, xmm0

; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm0, xmm1

; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm2, xmm0

; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm0, xmm2

; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm2, xmm3
	punpcklwd xmm0, xmm3
	paddd	xmm0, xmm2

; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;
; 193  :         pRef += nRefPitch * 2;
; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm0
	punpckldq xmm0, xmm3
	punpckhdq xmm1, xmm3

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm0

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm3

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);

	movd	eax, xmm0

; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$07$00G@@YAIPBEH0H@Z ENDP			; Sad16_sse2<8,1,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$03$07G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv493 = -8						; size = 4
tv492 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$03$07G@@YAIPBEH0H@Z PROC			; Sad16_sse2<4,8,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	ecx, DWORD PTR _pSrc$[ebp]
	xorps	xmm4, xmm4
	push	esi
	mov	esi, DWORD PTR _nSrcPitch$[ebp]

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	push	edi
	mov	edi, DWORD PTR _nRefPitch$[ebp]
	mov	edx, 4
	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR tv493[esp+16], eax
	lea	eax, DWORD PTR [edi+edi]
	mov	DWORD PTR tv492[esp+16], eax
	mov	eax, DWORD PTR _pRef$[ebp]
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));

	movq	xmm0, QWORD PTR [ecx+esi]
	movq	xmm2, QWORD PTR [ecx]

; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));

	movq	xmm1, QWORD PTR [eax]

; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	add	ecx, DWORD PTR tv493[esp+16]
	punpcklwd xmm2, xmm0
	movq	xmm0, QWORD PTR [eax+edi]
	movaps	xmm3, xmm2

; 193  :         pRef += nRefPitch * 2;

	add	eax, DWORD PTR tv492[esp+16]
	punpcklwd xmm1, xmm0
	psubusw	xmm3, xmm1
	psubusw	xmm1, xmm2
	por	xmm3, xmm1
	movaps	xmm0, xmm3
	punpckhwd xmm3, xmm4
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm3
	sub	edx, 1
	jne	SHORT $LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$03$07G@@YAIPBEH0H@Z ENDP			; Sad16_sse2<4,8,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$03$03G@@YAIPBEH0H@Z
_TEXT	SEGMENT
tv493 = -8						; size = 4
tv492 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$03$03G@@YAIPBEH0H@Z PROC			; Sad16_sse2<4,4,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();

	mov	ecx, DWORD PTR _pSrc$[ebp]
	xorps	xmm4, xmm4
	push	esi
	mov	esi, DWORD PTR _nSrcPitch$[ebp]

; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32

	movaps	xmm5, xmm4
	push	edi
	mov	edi, DWORD PTR _nRefPitch$[ebp]
	mov	edx, 2
	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR tv493[esp+16], eax
	lea	eax, DWORD PTR [edi+edi]
	mov	DWORD PTR tv492[esp+16], eax
	mov	eax, DWORD PTR _pRef$[ebp]
$LL4@Sad16_sse2:

; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));

	movq	xmm0, QWORD PTR [ecx+esi]
	movq	xmm2, QWORD PTR [ecx]

; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));

	movq	xmm1, QWORD PTR [eax]

; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;

	add	ecx, DWORD PTR tv493[esp+16]
	punpcklwd xmm2, xmm0
	movq	xmm0, QWORD PTR [eax+edi]
	movaps	xmm3, xmm2

; 193  :         pRef += nRefPitch * 2;

	add	eax, DWORD PTR tv492[esp+16]
	punpcklwd xmm1, xmm0
	psubusw	xmm3, xmm1
	psubusw	xmm1, xmm2
	por	xmm3, xmm1
	movaps	xmm0, xmm3
	punpckhwd xmm3, xmm4
	punpcklwd xmm0, xmm4
	paddd	xmm5, xmm0
	paddd	xmm5, xmm3
	sub	edx, 1
	jne	SHORT $LL4@Sad16_sse2

; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm5
	punpckldq xmm5, xmm4
	punpckhdq xmm1, xmm4

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm5

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm4

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);
; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	pop	edi
	movd	eax, xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$03$03G@@YAIPBEH0H@Z ENDP			; Sad16_sse2<4,4,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sadfunctions.h
;	COMDAT ??$Sad16_sse2@$03$01G@@YAIPBEH0H@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcPitch$ = 12					; size = 4
_pRef$ = 16						; size = 4
_nRefPitch$ = 20					; size = 4
??$Sad16_sse2@$03$01G@@YAIPBEH0H@Z PROC			; Sad16_sse2<4,2,unsigned short>, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 64   : #if 0
; 65   :   // check result against C
; 66   :   unsigned int result2 = Sad16_C<nBlkWidth, nBlkHeight, pixel_t>(pSrc, nSrcPitch, pRef, nRefPitch);
; 67   : #endif
; 68   : 
; 69   :   __m128i zero = _mm_setzero_si128();
; 70   :   __m128i sum = _mm_setzero_si128(); // 2x or 4x int is probably enough for 32x32
; 71   :   const bool two_8byte_rows = (sizeof(pixel_t) == 2 && nBlkWidth <= 4) || (sizeof(pixel_t) == 1 && nBlkWidth <= 8);
; 72   :   const bool one_cycle = (sizeof(pixel_t) * nBlkWidth) == 16;
; 73   :   const bool unroll_by2 = !two_8byte_rows && nBlkHeight>=2; // unroll by 4: slower
; 74   : 
; 75   :     for (int y = 0; y < nBlkHeight; y += (two_8byte_rows ? 2 : 1))
; 76   :     {
; 77   :       if (two_8byte_rows) { // no x cycle
; 78   :         __m128i src1, src2;
; 79   :         // (8 bytes or 4 words) * 2 rows
; 80   : #if 0
; 81   :         src1 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)), 8));
; 82   :         src2 = _mm_or_si128(_mm_loadl_epi64((__m128i *) (pRef)), _mm_slli_si128(_mm_loadl_epi64((__m128i *) (pRef + nRefPitch)), 8));
; 83   : #else
; 84   :         // 16.12.01 unpack
; 85   :         if (sizeof(pixel_t) == 1) {
; 86   :           src1 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));
; 87   :           src2 = _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));
; 88   :         }
; 89   :         else if (sizeof(pixel_t) == 2) {
; 90   :           src1 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pSrc)), _mm_loadl_epi64((__m128i *) (pSrc + nSrcPitch)));

	mov	ecx, DWORD PTR _pSrc$[ebp]
	xorps	xmm3, xmm3
	mov	eax, DWORD PTR _nSrcPitch$[ebp]
	movq	xmm2, QWORD PTR [ecx]
	movq	xmm0, QWORD PTR [ecx+eax]

; 91   :           src2 = _mm_unpacklo_epi16(_mm_loadl_epi64((__m128i *) (pRef)), _mm_loadl_epi64((__m128i *) (pRef + nRefPitch)));

	mov	ecx, DWORD PTR _pRef$[ebp]
	mov	eax, DWORD PTR _nRefPitch$[ebp]
	punpcklwd xmm2, xmm0
	movq	xmm1, QWORD PTR [ecx]
	movq	xmm0, QWORD PTR [ecx+eax]
	punpcklwd xmm1, xmm0

; 92   :         }
; 93   : #endif
; 94   :         if (sizeof(pixel_t) == 1) {
; 95   :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 96   :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 97   :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 98   :         }
; 99   :         else {
; 100  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation

	movaps	xmm0, xmm2
	psubusw	xmm0, xmm1

; 101  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);

	psubusw	xmm1, xmm2

; 102  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))

	por	xmm0, xmm1

; 103  :           // 8 x uint16 absolute differences
; 104  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));

	movaps	xmm2, xmm0

; 105  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));

	punpckhwd xmm0, xmm3
	punpcklwd xmm2, xmm3
	paddd	xmm2, xmm0

; 106  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 107  :         }
; 108  :       }
; 109  :       else if (one_cycle)
; 110  :       {
; 111  :         __m128i src1, src2;
; 112  :         src1 = _mm_loadu_si128((__m128i *) (pSrc)); // no x
; 113  :         src2 = _mm_loadu_si128((__m128i *) (pRef));
; 114  :         if (sizeof(pixel_t) == 1) {
; 115  :           // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 116  :           sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 117  :                                                               // result in two 32 bit areas at the upper and lower 64 bytes
; 118  :         }
; 119  :         else {
; 120  :           __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 121  :           __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 122  :           __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 123  :                                                                 // 8 x uint16 absolute differences
; 124  :           sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 125  :           sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 126  :           // sum1_32, sum2_32, sum3_32, sum4_32
; 127  :         }
; 128  :         if (unroll_by2) {
; 129  :           // unroll#2
; 130  :           src1 = _mm_loadu_si128((__m128i *) (pSrc+nSrcPitch)); // no x
; 131  :           src2 = _mm_loadu_si128((__m128i *) (pRef+nRefPitch));
; 132  :           if (sizeof(pixel_t) == 1) {
; 133  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 134  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 135  :                                                                 // result in two 32 bit areas at the upper and lower 64 bytes
; 136  :           }
; 137  :           else {
; 138  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 139  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 140  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 141  :                                                                   // 8 x uint16 absolute differences
; 142  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 143  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 144  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 145  :           }
; 146  :         }
; 147  :       }
; 148  :       else {
; 149  :         for (int x = 0; x < nBlkWidth * sizeof(pixel_t); x += 16)
; 150  :         {
; 151  :           __m128i src1, src2;
; 152  :           src1 = _mm_loadu_si128((__m128i *) (pSrc + x));
; 153  :           src2 = _mm_loadu_si128((__m128i *) (pRef + x));
; 154  :           if (sizeof(pixel_t) == 1) {
; 155  :             // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 156  :             sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 157  :             // result in two 32 bit areas at the upper and lower 64 bytes
; 158  :           }
; 159  :           else {
; 160  :             __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 161  :             __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 162  :             __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 163  :             // 8 x uint16 absolute differences
; 164  :             sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 165  :             sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 166  :             // sum1_32, sum2_32, sum3_32, sum4_32
; 167  :           }
; 168  :           // sum += SADABS(reinterpret_cast<const pixel_t *>(pSrc)[x] - reinterpret_cast<const pixel_t *>(pRef)[x]);
; 169  :           if (unroll_by2)
; 170  :           {
; 171  :             // unroll#2
; 172  :             src1 = _mm_loadu_si128((__m128i *) (pSrc + nSrcPitch + x));
; 173  :             src2 = _mm_loadu_si128((__m128i *) (pRef + nRefPitch + x));
; 174  :             if (sizeof(pixel_t) == 1) {
; 175  :               // this is uint_16 specific, but will test on uint8_t against external .asm SAD functions)
; 176  :               sum = _mm_add_epi32(sum, _mm_sad_epu8(src1, src2)); // yihhaaa, existing SIMD   sum1_32, 0, sum2_32, 0
; 177  :                                                                   // result in two 32 bit areas at the upper and lower 64 bytes
; 178  :             }
; 179  :             else {
; 180  :               __m128i greater_t = _mm_subs_epu16(src1, src2); // unsigned sub with saturation
; 181  :               __m128i smaller_t = _mm_subs_epu16(src2, src1);
; 182  :               __m128i absdiff = _mm_or_si128(greater_t, smaller_t); //abs(s1-s2)  == (satsub(s1,s2) | satsub(s2,s1))
; 183  :                                                                     // 8 x uint16 absolute differences
; 184  :               sum = _mm_add_epi32(sum, _mm_unpacklo_epi16(absdiff, zero));
; 185  :               sum = _mm_add_epi32(sum, _mm_unpackhi_epi16(absdiff, zero));
; 186  :               // sum1_32, sum2_32, sum3_32, sum4_32
; 187  :             }
; 188  :           }
; 189  :         }
; 190  :       }
; 191  :       if (two_8byte_rows || unroll_by2) {
; 192  :         pSrc += nSrcPitch * 2;
; 193  :         pRef += nRefPitch * 2;
; 194  :       }
; 195  :       else {
; 196  :         pSrc += nSrcPitch;
; 197  :         pRef += nRefPitch;
; 198  :       }
; 199  :     }
; 200  :   /*
; 201  :                                               [Low64, Hi64]
; 202  :   _mm_unpacklo_epi64(_mm_setzero_si128(), x)  [0, x0]
; 203  :   _mm_unpackhi_epi64(_mm_setzero_si128(), x)  [0, x1]
; 204  :   _mm_move_epi64(x)                           [x0, 0]
; 205  :   _mm_unpackhi_epi64(x, _mm_setzero_si128())  [x1, 0]
; 206  :   */
; 207  :   if(sizeof(pixel_t) == 2) {
; 208  :     // at 16 bits: we have 4 integers for sum: a0 a1 a2 a3
; 209  :     __m128i a0_a1 = _mm_unpacklo_epi32(sum, zero); // a0 0 a1 0
; 210  :     __m128i a2_a3 = _mm_unpackhi_epi32(sum, zero); // a2 0 a3 0

	movaps	xmm1, xmm2
	punpckldq xmm2, xmm3
	punpckhdq xmm1, xmm3

; 211  :     sum = _mm_add_epi32( a0_a1, a2_a3 ); // a0+a2, 0, a1+a3, 0

	paddd	xmm1, xmm2

; 212  :     // hadd: shower
; 213  :   }
; 214  :   // sum here: two 32 bit partial result: sum1 0 sum2 0
; 215  :   __m128i sum_hi = _mm_unpackhi_epi64(sum, zero); // a1 + a3. 2 dwords right 

	movaps	xmm0, xmm1
	punpckhqdq xmm0, xmm3

; 216  :   sum = _mm_add_epi32(sum, sum_hi);  // a0 + a2 + a1 + a3

	paddd	xmm0, xmm1

; 217  :   
; 218  :   unsigned int result = _mm_cvtsi128_si32(sum);

	movd	eax, xmm0

; 219  : 
; 220  : #if 0
; 221  :   // check result against C
; 222  :   if (result != result2) {
; 223  :     result = result2;
; 224  :   }
; 225  : #endif
; 226  : 
; 227  :   return result;
; 228  : } // end of SSE2 Sad16

	mov	esp, ebp
	pop	ebp
	ret	0
??$Sad16_sse2@$03$01G@@YAIPBEH0H@Z ENDP			; Sad16_sse2<4,2,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$make_tuple@AAHAAHAAHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00$$QAW4arch_t@@@Z
_TEXT	SEGMENT
_<_Args_1>$ = 8						; size = 4
_<_Args_2>$ = 12					; size = 4
_<_Args_3>$ = 16					; size = 4
??$make_tuple@AAHAAHAAHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00$$QAW4arch_t@@@Z PROC ; std::make_tuple<int &,int &,int &,enum arch_t>, COMDAT
; ___$ReturnUdt$ = ecx
; _<_Args_0>$ = edx

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR _<_Args_3>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Args_2>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+12], eax

; 967  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 968  : 	return (_Ttype(_STD forward<_Types>(_Args)...));

	mov	eax, ecx

; 969  : 	}

	ret	0
??$make_tuple@AAHAAHAAHW4arch_t@@@std@@YA?AV?$tuple@HHHW4arch_t@@@0@AAH00$$QAW4arch_t@@@Z ENDP ; std::make_tuple<int &,int &,int &,enum arch_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::try_emplace<>, COMDAT
; _this$ = ecx

; 244  : 		return (_Try_emplace(_STD move(_Keyval),

	push	DWORD PTR __Keyval$[esp-4]
	push	DWORD PTR ___$ReturnUdt$[esp]
	call	??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 245  : 			_STD forward<_Mappedty>(_Mapval)...));
; 246  : 		}

	ret	8
??$try_emplace@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::try_emplace<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z PROC ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$tuple@HHHW4arch_t@@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1><std::less<std::tuple<int,int,int,enum arch_t> > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0AAHAAHAAHW4arch_t@@$0A@@?$tuple@HHHW4arch_t@@@std@@QAE@AAH00$$QAW4arch_t@@@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
_<_Rest_arg_1>$ = 16					; size = 4
_<_Rest_arg_2>$ = 20					; size = 4
??$?0AAHAAHAAHW4arch_t@@$0A@@?$tuple@HHHW4arch_t@@@std@@QAE@AAH00$$QAW4arch_t@@@Z PROC ; std::tuple<int,int,int,enum arch_t>::tuple<int,int,int,enum arch_t><int &,int &,int &,enum arch_t,0>, COMDAT
; _this$ = ecx

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR _<_Rest_arg_2>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Rest_arg_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+12], eax

; 470  : 		}

	mov	eax, ecx
	ret	16					; 00000010H
??$?0AAHAAHAAHW4arch_t@@$0A@@?$tuple@HHHW4arch_t@@@std@@QAE@AAH00$$QAW4arch_t@@@Z ENDP ; std::tuple<int,int,int,enum arch_t>::tuple<int,int,int,enum arch_t><int &,int &,int &,enum arch_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 208  : 		{	// fail if _Keyval present, else emplace

	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	edi, DWORD PTR __Keyval$[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 208  : 		{	// fail if _Keyval present, else emplace

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	edi
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	esi, eax

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 211  : 			|| _DEBUG_LT_PRED(_Mybase::_Getcomp(),

	je	SHORT $LN4@Try_emplac
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [esi+24]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+20]
	cmp	eax, ecx
	jl	SHORT $LN4@Try_emplac
	cmp	ecx, eax
	jl	SHORT $LN177@Try_emplac
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LN4@Try_emplac
$LN177@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
$LN4@Try_emplac:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	lea	eax, DWORD PTR $T2[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[esp+12], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, ebx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, ebx
	push	eax
	push	esi
	lea	eax, DWORD PTR $T1[esp+20]
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	ecx, DWORD PTR $T1[esp+8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 223  : 		}

	ret	8
??$_Try_emplace@V?$tuple@HHHW4arch_t@@@std@@$$V@?$map@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@$$QAV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::map<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Try_emplace<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 570  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 901  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Key, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2179 : 		}

	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	DWORD PTR __Keyval$[esp-4]
	call	??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	eax, ecx

; 1539 : 		}

	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@2@ABV?$tuple@HHHW4arch_t@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Kfn, COMDAT
; _this$dead$ = ecx

; 2173 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[esp-4]

; 2174 : 		}

	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEABV?$tuple@HHHW4arch_t@@@2@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AAHAAHW4arch_t@@$0A@@?$tuple@HHW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH1$$QAW4arch_t@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
_<_Rest_arg_1>$ = 20					; size = 4
??$?0U_Exact_args_t@std@@AAHAAHW4arch_t@@$0A@@?$tuple@HHW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH1$$QAW4arch_t@@@Z PROC ; std::tuple<int,int,enum arch_t>::tuple<int,int,enum arch_t><std::_Exact_args_t,int &,int &,enum arch_t,0>, COMDAT
; _this$ = ecx

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR _<_Rest_arg_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], eax

; 305  : 		}

	mov	eax, ecx
	ret	16					; 00000010H
??$?0U_Exact_args_t@std@@AAHAAHW4arch_t@@$0A@@?$tuple@HHW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH1$$QAW4arch_t@@@Z ENDP ; std::tuple<int,int,enum arch_t>::tuple<int,int,enum arch_t><std::_Exact_args_t,int &,int &,enum arch_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$dead$ = 16					; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$dead$ = 24					; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1083 : 		{	// insert value_type(_Val...) at _Where

	push	edi

; 1084 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	ecx
	push	DWORD PTR _<_Val_1>$[esp+4]
	mov	edi, ecx
	push	ecx
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >

; 1085 : 		return (_Insert_hint(_Where,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1085 : 		return (_Insert_hint(_Where,

	mov	ecx, edi
	push	eax
	push	DWORD PTR __Where$[esp+8]
	push	DWORD PTR ___$ReturnUdt$[esp+12]
	call	??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	pop	edi

; 1086 : 			this->_Myval(_Newnode), _Newnode));
; 1087 : 		}

	ret	20					; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::destroy<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >, COMDAT
; _this$ = ecx

; 2059 : 		{	// find leftmost node not less than _Keyval

	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [ecx]

; 2060 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [edi+4]

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN110@Lbound
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	esi, DWORD PTR __Keyval$[esp+8]
	mov	ebx, DWORD PTR [esi+12]
$LL2@Lbound:
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, ebx
	jl	SHORT $LN66@Lbound
	cmp	ebx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [esi+8]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [esi+4]
	cmp	ecx, edx
	jl	SHORT $LN66@Lbound
	cmp	edx, ecx
	jl	SHORT $LN4@Lbound
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LN66@Lbound
$LN4@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2068 : 				_Wherenode = _Pnode;

	mov	edi, eax

; 2069 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN5@Lbound
$LN66@Lbound:

; 2064 : 			if (_Compare(this->_Key(_Pnode), _Keyval))
; 2065 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN5@Lbound:

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Lbound
	pop	esi
	pop	ebx
$LN110@Lbound:

; 2070 : 				}
; 2071 : 
; 2072 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, edi
	pop	edi

; 2073 : 		}

	ret	4
??$_Lbound@V?$tuple@HHHW4arch_t@@@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABV?$tuple@HHHW4arch_t@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lbound<std::tuple<int,int,int,enum arch_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z PROC ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>, COMDAT
; __Val$ = ecx

; 62   : 		return (_Val.first);

	mov	eax, ecx

; 63   : 		}

	ret	0
??$_Kfn@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@SAABV?$tuple@HHHW4arch_t@@@1@ABU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ENDP ; std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0>::_Kfn<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Compare, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	push	esi
	mov	edx, DWORD PTR [eax+12]
	mov	esi, DWORD PTR [ecx+12]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx+4]
	cmp	edx, esi
	jl	SHORT $LN16@Compare
	cmp	esi, edx
	jl	SHORT $LN15@Compare
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ecx]
	jl	SHORT $LN16@Compare
$LN15@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	xor	al, al
	pop	esi

; 2048 : 		}

	ret	8
$LN16@Compare:

; 2047 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

	mov	al, 1
	pop	esi

; 2048 : 		}

	ret	8
?_Compare@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$tuple@HHHW4arch_t@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 906  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::tuple<int,int,int,enum arch_t> >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AAHW4arch_t@@$0A@@?$tuple@HW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH$$QAW4arch_t@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@AAHW4arch_t@@$0A@@?$tuple@HW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH$$QAW4arch_t@@@Z PROC ; std::tuple<int,enum arch_t>::tuple<int,enum arch_t><std::_Exact_args_t,int &,enum arch_t,0>, COMDAT
; _this$ = ecx

; 163  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 305  : 		}

	mov	eax, ecx
	ret	12					; 0000000cH
??$?0U_Exact_args_t@std@@AAHW4arch_t@@$0A@@?$tuple@HW4arch_t@@@std@@QAE@U_Exact_args_t@1@AAH$$QAW4arch_t@@@Z ENDP ; std::tuple<int,enum arch_t>::tuple<int,enum arch_t><std::_Exact_args_t,int &,enum arch_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$dead$ = 8					; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$dead$ = 16					; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

	push	esi

; 881  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode0
	mov	edx, eax

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edx+16]

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN65@Buynode
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	ecx, DWORD PTR _<_Val_1>$[esp]
	mov	ecx, DWORD PTR [ecx]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 895  : 		return (_Pnode);

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [esi+16], 0
$LN65@Buynode:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 896  : 		}

	pop	esi
	ret	12					; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
$T2 = -24						; size = 8
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1655 : 		{	// try to insert node using _Where as a hint

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx

; 1656 : 		const_iterator _Next;
; 1657 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1658 : 
; 1659 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1660 : 
; 1661 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1662 : 		if (_Where._Getcont() != &this->_Get_data())
; 1663 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1664 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1665 : 
; 1666 : 		if (size() == 0)

	cmp	DWORD PTR [ebx+4], 0
	mov	DWORD PTR _this$1$[ebp], ebx
	jne	SHORT $LN3@Insert_hin

; 1667 : 			return (_Insert_at(true, this->_Myhead(),

	push	DWORD PTR __Newnode$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	push	DWORD PTR [ebx]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@Insert_hin:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edi, DWORD PTR [ebx]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	esi, DWORD PTR __Where$[ebp]
	cmp	esi, DWORD PTR [edi]

; 1668 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1669 : 		else if (this->_Multi)
; 1670 : 			{	// insert even if duplicate
; 1671 : 			if (_Where == begin())
; 1672 : 				{	// insert at beginning if before first element
; 1673 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1674 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1675 : 					return (_Insert_at(true, _Where._Mynode(),
; 1676 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1677 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1678 : 				}
; 1679 : 			else if (_Where == end())
; 1680 : 				{	// insert at end if after last element
; 1681 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1682 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1683 : 					return (_Insert_at(false, _Rmost(),
; 1684 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1685 : 				}
; 1686 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1687 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1688 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1689 : 					this->_Kfn(_Val),
; 1690 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1691 : 				{	// insert before _Where
; 1692 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1693 : 					return (_Insert_at(false, _Next._Mynode(),
; 1694 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1695 : 				else
; 1696 : 					return (_Insert_at(true, _Where._Mynode(),
; 1697 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1698 : 				}
; 1699 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1701 : 				&& (++(_Next = _Where) == end()
; 1702 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1703 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1704 : 				{	// insert after _Where
; 1705 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1706 : 					return (_Insert_at(false, _Where._Mynode(),
; 1707 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1708 : 				else
; 1709 : 					return (_Insert_at(true, _Next._Mynode(),
; 1710 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1711 : 				}
; 1712 : 			else
; 1713 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1714 : 			}
; 1715 : 		else
; 1716 : 			{	// insert only if unique
; 1717 : 			if (_Where == begin())

	jne	SHORT $LN22@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1719 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1720 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1721 : 					return (_Insert_at(true, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN22@Insert_hin:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi

; 1722 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1723 : 				}
; 1724 : 			else if (_Where == end())

	jne	SHORT $LN25@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	esi, DWORD PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1726 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 1727 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1728 : 					return (_Insert_at(false, _Rmost(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN25@Insert_hin:

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	ebx, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	push	ebx
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN28@Insert_hin

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	mov	DWORD PTR __Next$[ebp], esi

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator--

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	ebx, DWORD PTR __Next$[ebp]
	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1733 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN761@Insert_hin

; 1734 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1735 : 					this->_Kfn(_Val)))
; 1736 : 				{	// insert before _Where
; 1737 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

	mov	eax, DWORD PTR [ebx+8]

; 1738 : 					return (_Insert_at(false, _Next._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN30@Insert_hin
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN30@Insert_hin:

; 1739 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1740 : 				else
; 1741 : 					return (_Insert_at(true, _Where._Mynode(),

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN761@Insert_hin:
	mov	ebx, DWORD PTR __Val$[ebp]
$LN28@Insert_hin:

; 1746 : 				&& (++(_Next = _Where) == end()

	push	ebx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	$LN35@Insert_hin

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Next$[ebp]

; 1746 : 				&& (++(_Next = _Where) == end()

	mov	DWORD PTR __Next$[ebp], esi

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator++

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR __Next$[ebp]
	cmp	ebx, edi

; 1746 : 				&& (++(_Next = _Where) == end()

	je	SHORT $LN33@Insert_hin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1746 : 				&& (++(_Next = _Where) == end()

	push	eax
	push	DWORD PTR __Val$[ebp]
	call	??R?$less@V?$tuple@HHHW4arch_t@@@std@@@std@@QBE_NABV?$tuple@HHHW4arch_t@@@1@0@Z ; std::less<std::tuple<int,int,int,enum arch_t> >::operator()
	test	al, al
	je	SHORT $LN35@Insert_hin
$LN33@Insert_hin:

; 1747 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1748 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1749 : 				{	// insert after _Where
; 1750 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

	mov	eax, DWORD PTR [esi+8]

; 1751 : 					return (_Insert_at(false, _Where._Mynode(),

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	cmp	BYTE PTR [eax+13], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	je	SHORT $LN34@Insert_hin
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	0
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN34@Insert_hin:

; 1752 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1753 : 				else
; 1754 : 					return (_Insert_at(true, _Next._Mynode(),

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	1
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	mov	eax, esi

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1760 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN764@Insert_hin:
$LN35@Insert_hin:

; 1761 : 		_CATCH_END
; 1762 : 
; 1763 : 		return (_Insert_nohint(_Leftish,

	push	DWORD PTR __Newnode$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	push	DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx

; 1764 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1765 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN763@Insert_hin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_hint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

	mov	eax, esi
	pop	esi

; 314  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 210  : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Freenode0, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 876  : 		}

	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 849  : 		{	// allocate a non-value node

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN73@Buynode0
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
$LN73@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN187@Buynode0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN187@Buynode0:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 864  : 		return (_Pnode);

	mov	eax, esi
	pop	esi

; 865  : 		}

	ret	0
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[esp-4]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1645 : 		}

	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::size, COMDAT
; _this$ = ecx

; 1171 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1172 : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 946  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN25@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN25@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z PROC ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@YAAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@0@AAU10@@Z ENDP ; std::forward<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$dead$ = 20					; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	push	edi
	mov	edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 119304646				; 071c71c6H
	jb	SHORT $LN5@Insert_at
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Node$[esp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1831 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN716@Insert_at:
$LN5@Insert_at:
	push	ebx

; 1832 : 			}
; 1833 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1834 : 			_STD forward<_Valty>(_Val));
; 1835 : 
; 1836 : 		++this->_Mysize();
; 1837 : 		_Newnode->_Parent = _Wherenode;

	mov	ebx, DWORD PTR __Node$[esp+4]
	inc	eax
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Wherenode$[esp+4]
	push	esi
	mov	DWORD PTR [ebx+4], eax

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1842 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+8], 0
	je	SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	ecx, DWORD PTR [edi]

; 1848 : 			if (_Wherenode == _Lmost())

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1850 : 			}
; 1851 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	ecx, DWORD PTR [edi]

; 1854 : 			if (_Wherenode == _Rmost())

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1855 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
	npad	1
$LL2@Insert_at:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN714@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1878 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN361@Insert_at

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN361@Insert_at:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2119 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN362@Insert_at

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN362@Insert_at:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN364@Insert_at

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN713@Insert_at
$LN364@Insert_at:

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	SHORT $LN713@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN714@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1904 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN560@Insert_at

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN560@Insert_at:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2089 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN561@Insert_at

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN564@Insert_at
$LN561@Insert_at:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN563@Insert_at

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2093 : 		else

	jmp	SHORT $LN564@Insert_at
$LN563@Insert_at:

; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN564@Insert_at:

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN713@Insert_at:

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ebx
	pop	ebx
	pop	edi

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1916 : 		}

	ret	20					; 00000014H
$LN715@Insert_at:
??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
tv1241 = -28						; size = 4
_this$1$ = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Leftish$dead$ = 12					; size = 1
$T3 = 16						; size = 4
__Where$4 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	mov	eax, ecx

; 1772 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	ebx
	push	esi
	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR [eax]

; 1773 : 		_Nodeptr _Trynode = _Root();
; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1771 : 		{	// try to insert node, on left if _Leftish

	mov	DWORD PTR _this$1$[ebp], eax

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	al, 1
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, DWORD PTR [ecx+4]

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv1241[ebp], ecx

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], al

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN3@Insert_noh
	mov	esi, DWORD PTR [edi+12]
$LL2@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1779 : 			_Wherenode = _Trynode;

	mov	ebx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	cmp	esi, eax
	jl	SHORT $LN142@Insert_noh
	cmp	eax, esi
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edx+24]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edx+20]
	cmp	eax, ecx
	jl	SHORT $LN142@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN141@Insert_noh
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN142@Insert_noh
$LN141@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	mov	edx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	xor	al, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	jmp	SHORT $LN420@Insert_noh
$LN142@Insert_noh:
	mov	edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	al, 1
$LN420@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [edx+13], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	BYTE PTR __Addleft$2[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1777 : 		while (!this->_Isnil(_Trynode))

	je	SHORT $LL2@Insert_noh
	mov	ecx, DWORD PTR tv1241[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	esi, ebx
	mov	DWORD PTR __Where$4[ebp], esi

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1798 : 			if (!_Addleft)

	test	al, al
	je	SHORT $LN12@Insert_noh

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ebx, DWORD PTR [ecx]

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	1
$LN421@Insert_noh:
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$_Insert_at@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_at<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator--
	mov	esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 586  : 		return (_Myfirst._Val < _Right._Myfirst._Val

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edi+4]
	cmp	eax, ecx
	jl	SHORT $LN296@Insert_noh
	cmp	ecx, eax
	jl	SHORT $LN13@Insert_noh
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edi]
	jl	SHORT $LN296@Insert_noh
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN296@Insert_noh:

; 1802 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1803 : 			else
; 1804 : 				--_Where;	// need to test if insert before is okay
; 1805 : 
; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	ebx
	push	DWORD PTR __Addleft$2[ebp]
	jmp	$LN421@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	edx, 1
	push	36					; 00000024H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1819 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN422@Insert_noh:
$LN419@Insert_noh:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Insert_nohint<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &,std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,std::_Iterator_base0>::operator--

; 425  : 		--static_cast<_Mybase&>(*this);
; 426  : 		return (*this);

	mov	eax, esi
	pop	esi

; 427  : 		}

	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1176 : 		return (this->_Getal().max_size());

	mov	eax, 119304647				; 071c71c7H

; 1177 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 119304647				; 071c71c7H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 119304647				; 071c71c7H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 119304647				; 071c71c7H

; 750  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Args_0>$dead$ = 8					; size = 4
_<_Args_1>$ = 12					; size = 4
_<_Args_2>$dead$ = 16					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN14@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN14@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> > >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &>, COMDAT
; _this$dead$ = ecx

; 1630 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[esp-4]

; 1631 : 		}

	ret	8
??$_Buynode_if_nil@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@ZU?$less@V?$tuple@HHHW4arch_t@@@std@@@2@V?$allocator@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::tuple<int,int,int,enum arch_t>,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int),std::less<std::tuple<int,int,int,enum arch_t> >,std::allocator<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> >,0> >::_Buynode_if_nil<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$dead$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$dead$ = 20					; size = 4
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	test	edx, edx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+16], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	16					; 00000010H
??$construct@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@2@V?$tuple@$$V@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,void *> >::construct<std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>,std::piecewise_construct_t const &,std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)><std::tuple<int,int,int,enum arch_t> &&>, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1197 : 		}

	mov	eax, ecx

; 1179 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+16], 0

; 1197 : 		}

	ret	12					; 0000000cH
??$?0$$QAV?$tuple@HHHW4arch_t@@@std@@$$Z$$V@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)><std::tuple<int,int,int,enum arch_t> &&>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
; File c:\github\mvtools\sources\copycode.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple
;	COMDAT ??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 908  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [eax]
; File c:\github\mvtools\sources\copycode.cpp

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\tuple

; 1183 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+16], 0
	ret	16					; 00000010H
??$?0V?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBV?$tuple@HHHW4arch_t@@@std@@P6AIPBEH0H@Z@std@@QAE@AAV?$tuple@$$QAV?$tuple@HHHW4arch_t@@@std@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)>::pair<std::tuple<int,int,int,enum arch_t> const ,unsigned int (__cdecl*)(unsigned char const *,int,unsigned char const *,int)><std::tuple<std::tuple<int,int,int,enum arch_t> &&>,std::tuple<>,0>
_TEXT	ENDS
END
