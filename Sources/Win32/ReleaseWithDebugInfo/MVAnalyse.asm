; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvanalyse.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`vftable'
PUBLIC	??_R2?$CellPool@PAVDCTClass@@@conc@@8		; conc::CellPool<DCTClass *>::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$AioAdd@I@conc@@@8			; conc::AioAdd<unsigned int> `RTTI Type Descriptor'
PUBLIC	??_7?$ObjPool@VDCTClass@@@conc@@6B@		; conc::ObjPool<DCTClass>::`vftable'
PUBLIC	??_R2MVAnalyse@@8				; MVAnalyse::`RTTI Base Class Array'
PUBLIC	??_R3?$LockFreeStack@PAVDCTClass@@@conc@@8	; conc::LockFreeStack<DCTClass *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$ObjPool@VDCTClass@@@conc@@8		; conc::ObjPool<DCTClass>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$AioMax@H@conc@@8				; conc::AioMax<int>::`RTTI Base Class Array'
PUBLIC	??_R4?$AioMax@H@conc@@6B@			; conc::AioMax<int>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMVAnalyse@@@8				; MVAnalyse `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$ObjPool@VDCTClass@@@conc@@8	; conc::ObjPool<DCTClass>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$LockFreeStack@PAVDCTClass@@@conc@@@8	; conc::LockFreeStack<DCTClass *> `RTTI Type Descriptor'
PUBLIC	??_R3?$AioAdd@I@conc@@8				; conc::AioAdd<unsigned int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Base Class Array'
PUBLIC	??_7MVAnalyse@@6B@				; MVAnalyse::`vftable'
PUBLIC	??_R1A@?0A@EA@?$CellPool@PAVDCTClass@@@conc@@8	; conc::CellPool<DCTClass *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$AioAdd@I@conc@@6B@			; conc::AioAdd<unsigned int>::`vftable'
PUBLIC	??_R4?$AioAdd@I@conc@@6B@			; conc::AioAdd<unsigned int>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$AioMax@H@conc@@8		; conc::AioMax<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AioMax@H@conc@@@8			; conc::AioMax<int> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@MVAnalyse@@8			; MVAnalyse::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$AioAdd@I@conc@@8				; conc::AioAdd<unsigned int>::`RTTI Base Class Array'
PUBLIC	??_7?$AioMax@H@conc@@6B@			; conc::AioMax<int>::`vftable'
PUBLIC	??_R0?AV?$ObjPool@VDCTClass@@@conc@@@8		; conc::ObjPool<DCTClass> `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$CellPool@PAVDCTClass@@@conc@@@8	; conc::CellPool<DCTClass *> `RTTI Type Descriptor'
PUBLIC	??_R3MVAnalyse@@8				; MVAnalyse::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$LockFreeStack@PAVDCTClass@@@conc@@6B@	; conc::LockFreeStack<DCTClass *>::`RTTI Complete Object Locator'
PUBLIC	??_7?$CellPool@PAVDCTClass@@@conc@@6B@		; conc::CellPool<DCTClass *>::`vftable'
PUBLIC	??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$AioAdd@I@conc@@8		; conc::AioAdd<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MVAnalyse@@6B@				; MVAnalyse::`RTTI Complete Object Locator'
PUBLIC	??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@	; conc::LockFreeStack<DCTClass *>::`vftable'
PUBLIC	??_R2?$LockFreeStack@PAVDCTClass@@@conc@@8	; conc::LockFreeStack<DCTClass *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$LockFreeStack@PAVDCTClass@@@conc@@8 ; conc::LockFreeStack<DCTClass *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ObjPool@VDCTClass@@@conc@@6B@		; conc::ObjPool<DCTClass>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$AioMax@H@conc@@8				; conc::AioMax<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$CellPool@PAVDCTClass@@@conc@@8		; conc::CellPool<DCTClass *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_C@_0EI@BEMGDCCH@MAnalyse?3?5cannot?5use?5a?5fixed?5fra@ ; `string'
PUBLIC	??_C@_0DG@IDHPFBBC@MAnalyse?3?5Clip?5with?5float?5pixel?5@ ; `string'
PUBLIC	??_C@_0CD@JIMPFCGE@MAnalyse?3?5Clip?5must?5be?5YUV?5or?5YU@ ; `string'
PUBLIC	??_C@_0DE@FOMLGJBB@MAnalyse?3?5wrong?5super?5clip?5?$CIpseu@ ; `string'
PUBLIC	??_C@_0EO@GNFDPKLC@MAnalyse?3?5Block?8s?5size?5must?5be?54@ ; `string'
PUBLIC	??_C@_0CE@GIGNLFPB@MAnalyse?3?5pel?5has?5to?5be?51?5or?52?5o@ ; `string'
PUBLIC	??_C@_0DN@OOBBCPMB@MAnalyse?3?5overlap?5must?5be?5less?5o@ ; `string'
PUBLIC	??_C@_0DH@OLKLKFMA@MAnalyse?3?5wrong?5overlap?5for?5the?5@ ; `string'
PUBLIC	??_C@_0DI@GPLFOKOC@MAnalyse?3?5Block?5sizes?5must?5be?58?5@ ; `string'
PUBLIC	??_C@_0EH@PBOJLGAP@MAnalyse?3?5wrong?5overlap?5for?5the?5@ ; `string'
PUBLIC	??_C@_0EO@BOJACNKF@MAnalyse?3?5it?5is?5not?5enough?5level@ ; `string'
PUBLIC	??_C@_0CK@DEPAJCDH@MAnalyse?3?5non?9valid?5number?5of?5le@ ; `string'
PUBLIC	??_C@_0EH@HPJHCKDK@MAnalyse?3?5dct?5modes?5using?5SADT?5r@ ; `string'
PUBLIC	??_C@_0DI@ICFFNAOJ@MAnalyse?3?5super?5clip?5does?5not?5co@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0CH@MBLDLPPN@MAnalyse?3?5out?5file?5can?5not?5be?5cr@ ; `string'
PUBLIC	??_R4?$CellPool@PAVDCTClass@@@conc@@6B@		; conc::CellPool<DCTClass *>::`RTTI Complete Object Locator'
PUBLIC	??_R2?$ObjPool@VDCTClass@@@conc@@8		; conc::ObjPool<DCTClass>::`RTTI Base Class Array'
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
;	COMDAT ??_R2?$ObjPool@VDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R2?$ObjPool@VDCTClass@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$ObjPool@VDCTClass@@@conc@@8 ; conc::ObjPool<DCTClass>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4?$CellPool@PAVDCTClass@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$CellPool@PAVDCTClass@@@conc@@6B@ DD 00H		; conc::CellPool<DCTClass *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CellPool@PAVDCTClass@@@conc@@@8
	DD	FLAT:??_R3?$CellPool@PAVDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CH@MBLDLPPN@MAnalyse?3?5out?5file?5can?5not?5be?5cr@
CONST	SEGMENT
??_C@_0CH@MBLDLPPN@MAnalyse?3?5out?5file?5can?5not?5be?5cr@ DB 'MAnalyse:'
	DB	' out file can not be created!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@ICFFNAOJ@MAnalyse?3?5super?5clip?5does?5not?5co@
CONST	SEGMENT
??_C@_0DI@ICFFNAOJ@MAnalyse?3?5super?5clip?5does?5not?5co@ DB 'MAnalyse: '
	DB	'super clip does not contain needed color data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@HPJHCKDK@MAnalyse?3?5dct?5modes?5using?5SADT?5r@
CONST	SEGMENT
??_C@_0EH@HPJHCKDK@MAnalyse?3?5dct?5modes?5using?5SADT?5r@ DB 'MAnalyse: '
	DB	'dct modes using SADT require at least MMX2 CPU capabilities.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DEPAJCDH@MAnalyse?3?5non?9valid?5number?5of?5le@
CONST	SEGMENT
??_C@_0CK@DEPAJCDH@MAnalyse?3?5non?9valid?5number?5of?5le@ DB 'MAnalyse: '
	DB	'non-valid number of levels (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@BOJACNKF@MAnalyse?3?5it?5is?5not?5enough?5level@
CONST	SEGMENT
??_C@_0EO@BOJACNKF@MAnalyse?3?5it?5is?5not?5enough?5level@ DB 'MAnalyse: '
	DB	'it is not enough levels  in super clip (%d), while MAnalyse a'
	DB	'sks %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@PBOJLGAP@MAnalyse?3?5wrong?5overlap?5for?5the?5@
CONST	SEGMENT
??_C@_0EH@PBOJLGAP@MAnalyse?3?5wrong?5overlap?5for?5the?5@ DB 'MAnalyse: '
	DB	'wrong overlap for the colorspace subsampling for divide mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GPLFOKOC@MAnalyse?3?5Block?5sizes?5must?5be?58?5@
CONST	SEGMENT
??_C@_0DI@GPLFOKOC@MAnalyse?3?5Block?5sizes?5must?5be?58?5@ DB 'MAnalyse:'
	DB	' Block sizes must be 8 or more for divide mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OLKLKFMA@MAnalyse?3?5wrong?5overlap?5for?5the?5@
CONST	SEGMENT
??_C@_0DH@OLKLKFMA@MAnalyse?3?5wrong?5overlap?5for?5the?5@ DB 'MAnalyse: '
	DB	'wrong overlap for the colorspace subsampling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OOBBCPMB@MAnalyse?3?5overlap?5must?5be?5less?5o@
CONST	SEGMENT
??_C@_0DN@OOBBCPMB@MAnalyse?3?5overlap?5must?5be?5less?5o@ DB 'MAnalyse: '
	DB	'overlap must be less or equal than half block size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GIGNLFPB@MAnalyse?3?5pel?5has?5to?5be?51?5or?52?5o@
CONST	SEGMENT
??_C@_0CE@GIGNLFPB@MAnalyse?3?5pel?5has?5to?5be?51?5or?52?5o@ DB 'MAnalys'
	DB	'e: pel has to be 1 or 2 or 4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@GNFDPKLC@MAnalyse?3?5Block?8s?5size?5must?5be?54@
CONST	SEGMENT
??_C@_0EO@GNFDPKLC@MAnalyse?3?5Block?8s?5size?5must?5be?54@ DB 'MAnalyse:'
	DB	' Block''s size must be 4x4, 8x4, 8x8, 16x2, 16x8, 16x16, 32x1'
	DB	'6, 32x32', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FOMLGJBB@MAnalyse?3?5wrong?5super?5clip?5?$CIpseu@
CONST	SEGMENT
??_C@_0DE@FOMLGJBB@MAnalyse?3?5wrong?5super?5clip?5?$CIpseu@ DB 'MAnalyse'
	DB	': wrong super clip (pseudoaudio) parameters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JIMPFCGE@MAnalyse?3?5Clip?5must?5be?5YUV?5or?5YU@
CONST	SEGMENT
??_C@_0CD@JIMPFCGE@MAnalyse?3?5Clip?5must?5be?5YUV?5or?5YU@ DB 'MAnalyse:'
	DB	' Clip must be YUV or YUY2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@IDHPFBBC@MAnalyse?3?5Clip?5with?5float?5pixel?5@
CONST	SEGMENT
??_C@_0DG@IDHPFBBC@MAnalyse?3?5Clip?5with?5float?5pixel?5@ DB 'MAnalyse: '
	DB	'Clip with float pixel type is not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@BEMGDCCH@MAnalyse?3?5cannot?5use?5a?5fixed?5fra@
CONST	SEGMENT
??_C@_0EI@BEMGDCCH@MAnalyse?3?5cannot?5use?5a?5fixed?5fra@ DB 'MAnalyse: '
	DB	'cannot use a fixed frame reference (delta < 1) in multi mode.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_R3?$CellPool@PAVDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R3?$CellPool@PAVDCTClass@@@conc@@8 DD 00H		; conc::CellPool<DCTClass *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CellPool@PAVDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AioMax@H@conc@@8
rdata$r	SEGMENT
??_R3?$AioMax@H@conc@@8 DD 00H				; conc::AioMax<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AioMax@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_R4?$ObjPool@VDCTClass@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$ObjPool@VDCTClass@@@conc@@6B@ DD 00H		; conc::ObjPool<DCTClass>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ObjPool@VDCTClass@@@conc@@@8
	DD	FLAT:??_R3?$ObjPool@VDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$LockFreeStack@PAVDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$LockFreeStack@PAVDCTClass@@@conc@@8 DD FLAT:??_R0?AV?$LockFreeStack@PAVDCTClass@@@conc@@@8 ; conc::LockFreeStack<DCTClass *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$LockFreeStack@PAVDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2?$LockFreeStack@PAVDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R2?$LockFreeStack@PAVDCTClass@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$LockFreeStack@PAVDCTClass@@@conc@@8 ; conc::LockFreeStack<DCTClass *>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
CONST	SEGMENT
??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@ DD FLAT:??_R4?$LockFreeStack@PAVDCTClass@@@conc@@6B@ ; conc::LockFreeStack<DCTClass *>::`vftable'
	DD	FLAT:??_E?$LockFreeStack@PAVDCTClass@@@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4MVAnalyse@@6B@
rdata$r	SEGMENT
??_R4MVAnalyse@@6B@ DD 00H				; MVAnalyse::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVAnalyse@@@8
	DD	FLAT:??_R3MVAnalyse@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AioAdd@I@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AioAdd@I@conc@@8 DD FLAT:??_R0?AV?$AioAdd@I@conc@@@8 ; conc::AioAdd<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AioAdd@I@conc@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@con'
	DB	'c@@@conc@@', 00H
data$r	ENDS
;	COMDAT ??_7?$CellPool@PAVDCTClass@@@conc@@6B@
CONST	SEGMENT
??_7?$CellPool@PAVDCTClass@@@conc@@6B@ DD FLAT:??_R4?$CellPool@PAVDCTClass@@@conc@@6B@ ; conc::CellPool<DCTClass *>::`vftable'
	DD	FLAT:??_E?$CellPool@PAVDCTClass@@@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$LockFreeStack@PAVDCTClass@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$LockFreeStack@PAVDCTClass@@@conc@@6B@ DD 00H	; conc::LockFreeStack<DCTClass *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$LockFreeStack@PAVDCTClass@@@conc@@@8
	DD	FLAT:??_R3?$LockFreeStack@PAVDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3MVAnalyse@@8
rdata$r	SEGMENT
??_R3MVAnalyse@@8 DD 00H				; MVAnalyse::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2MVAnalyse@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CellPool@PAVDCTClass@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$CellPool@PAVDCTClass@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::CellPool<DCTClass *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CellPool@PAVDCTClass@@@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$ObjPool@VDCTClass@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$ObjPool@VDCTClass@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::ObjPool<DCTClass> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ObjPool@VDCTClass@@@conc@@', 00H
data$r	ENDS
;	COMDAT ??_7?$AioMax@H@conc@@6B@
CONST	SEGMENT
??_7?$AioMax@H@conc@@6B@ DD FLAT:??_R4?$AioMax@H@conc@@6B@ ; conc::AioMax<int>::`vftable'
	DD	FLAT:??_E?$AioMax@H@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$AioAdd@I@conc@@8
rdata$r	SEGMENT
??_R2?$AioAdd@I@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AioAdd@I@conc@@8 ; conc::AioAdd<unsigned int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVAnalyse@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVAnalyse@@8 DD FLAT:??_R0?AVMVAnalyse@@@8 ; MVAnalyse::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVAnalyse@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AioMax@H@conc@@@8
data$r	SEGMENT
??_R0?AV?$AioMax@H@conc@@@8 DD FLAT:??_7type_info@@6B@	; conc::AioMax<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AioMax@H@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AioMax@H@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AioMax@H@conc@@8 DD FLAT:??_R0?AV?$AioMax@H@conc@@@8 ; conc::AioMax<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AioMax@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_R4?$AioAdd@I@conc@@6B@
rdata$r	SEGMENT
??_R4?$AioAdd@I@conc@@6B@ DD 00H			; conc::AioAdd<unsigned int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AioAdd@I@conc@@@8
	DD	FLAT:??_R3?$AioAdd@I@conc@@8
rdata$r	ENDS
;	COMDAT ??_7?$AioAdd@I@conc@@6B@
CONST	SEGMENT
??_7?$AioAdd@I@conc@@6B@ DD FLAT:??_R4?$AioAdd@I@conc@@6B@ ; conc::AioAdd<unsigned int>::`vftable'
	DD	FLAT:??_E?$AioAdd@I@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CellPool@PAVDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CellPool@PAVDCTClass@@@conc@@8 DD FLAT:??_R0?AV?$CellPool@PAVDCTClass@@@conc@@@8 ; conc::CellPool<DCTClass *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CellPool@PAVDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_7MVAnalyse@@6B@
CONST	SEGMENT
??_7MVAnalyse@@6B@ DD FLAT:??_R4MVAnalyse@@6B@		; MVAnalyse::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVAnalyse@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVAnalyse@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8
rdata$r	SEGMENT
??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$AioAdd@I@conc@@8
rdata$r	SEGMENT
??_R3?$AioAdd@I@conc@@8 DD 00H				; conc::AioAdd<unsigned int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AioAdd@I@conc@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$LockFreeStack@PAVDCTClass@@@conc@@@8
data$r	SEGMENT
??_R0?AV?$LockFreeStack@PAVDCTClass@@@conc@@@8 DD FLAT:??_7type_info@@6B@ ; conc::LockFreeStack<DCTClass *> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$LockFreeStack@PAVDCTClass@@@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8
rdata$r	SEGMENT
??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8 DD 00H ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ObjPool@VDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ObjPool@VDCTClass@@@conc@@8 DD FLAT:??_R0?AV?$ObjPool@VDCTClass@@@conc@@@8 ; conc::ObjPool<DCTClass>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ObjPool@VDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVAnalyse@@@8
data$r	SEGMENT
??_R0?AVMVAnalyse@@@8 DD FLAT:??_7type_info@@6B@	; MVAnalyse `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVAnalyse@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$AioMax@H@conc@@6B@
rdata$r	SEGMENT
??_R4?$AioMax@H@conc@@6B@ DD 00H			; conc::AioMax<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AioMax@H@conc@@@8
	DD	FLAT:??_R3?$AioMax@H@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AioMax@H@conc@@8
rdata$r	SEGMENT
??_R2?$AioMax@H@conc@@8 DD FLAT:??_R1A@?0A@EA@?$AioMax@H@conc@@8 ; conc::AioMax<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
rdata$r	SEGMENT
??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@ DD 00H ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@@8
	DD	FLAT:??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8 DD FLAT:??_R0?AV?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@@8 ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ObjPool@VDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R3?$ObjPool@VDCTClass@@@conc@@8 DD 00H		; conc::ObjPool<DCTClass>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$ObjPool@VDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R3?$LockFreeStack@PAVDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R3?$LockFreeStack@PAVDCTClass@@@conc@@8 DD 00H	; conc::LockFreeStack<DCTClass *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$LockFreeStack@PAVDCTClass@@@conc@@8
rdata$r	ENDS
;	COMDAT ??_R2MVAnalyse@@8
rdata$r	SEGMENT
??_R2MVAnalyse@@8 DD FLAT:??_R1A@?0A@EA@MVAnalyse@@8	; MVAnalyse::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
rdata$r	ENDS
;	COMDAT ??_7?$ObjPool@VDCTClass@@@conc@@6B@
CONST	SEGMENT
??_7?$ObjPool@VDCTClass@@@conc@@6B@ DD FLAT:??_R4?$ObjPool@VDCTClass@@@conc@@6B@ ; conc::ObjPool<DCTClass>::`vftable'
	DD	FLAT:??_E?$ObjPool@VDCTClass@@@conc@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$AioAdd@I@conc@@@8
data$r	SEGMENT
??_R0?AV?$AioAdd@I@conc@@@8 DD FLAT:??_7type_info@@6B@	; conc::AioAdd<unsigned int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AioAdd@I@conc@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$CellPool@PAVDCTClass@@@conc@@8
rdata$r	SEGMENT
??_R2?$CellPool@PAVDCTClass@@@conc@@8 DD FLAT:??_R1A@?0A@EA@?$CellPool@PAVDCTClass@@@conc@@8 ; conc::CellPool<DCTClass *>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
CONST	SEGMENT
??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@ DD FLAT:??_R4?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`vftable'
	DD	FLAT:??_E?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAEPAXI@Z
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1><std::_Wrap_alloc<std::allocator<int> > >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<int> > >
PUBLIC	??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z ; std::forward<std::vector<int,std::allocator<int> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > ><std::_Wrap_alloc<std::allocator<int> >,void>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<int> > &>
PUBLIC	??R?$AioAdd@I@conc@@QBEII@Z			; conc::AioAdd<unsigned int>::operator()
PUBLIC	?cas@?$AtomicInt@I@conc@@QAEIII@Z		; conc::AtomicInt<unsigned int>::cas
PUBLIC	??B?$AtomicInt@I@conc@@QBEIXZ			; conc::AtomicInt<unsigned int>::operator unsigned int
PUBLIC	?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Swap_all
PUBLIC	?_Assign_rv@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<int,std::allocator<int> >::_Assign_rv
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z		; MVAnalyse::SrcRefData::SrcRefData
PUBLIC	??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z ; std::allocator<MVAnalyse::SrcRefData>::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
PUBLIC	??$exec_both@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@AAI2@Z ; conc::AtomicIntOp::exec_both<unsigned int,conc::AioAdd<unsigned int> >
PUBLIC	??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@$$QAV34@@Z ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
PUBLIC	??$forward@VSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z ; std::forward<MVAnalyse::SrcRefData>
PUBLIC	??$exec@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@@Z ; conc::AtomicIntOp::exec<unsigned int,conc::AioAdd<unsigned int> >
PUBLIC	??0?$AioAdd@I@conc@@QAE@I@Z			; conc::AioAdd<unsigned int>::AioAdd<unsigned int>
PUBLIC	??_G?$AioAdd@I@conc@@UAEPAXI@Z			; conc::AioAdd<unsigned int>::`scalar deleting destructor'
PUBLIC	??1?$AioAdd@I@conc@@UAE@XZ			; conc::AioAdd<unsigned int>::~AioAdd<unsigned int>
PUBLIC	??1SrcRefData@MVAnalyse@@QAE@XZ			; MVAnalyse::SrcRefData::~SrcRefData
PUBLIC	??_GSrcRefData@MVAnalyse@@QAEPAXI@Z		; MVAnalyse::SrcRefData::`scalar deleting destructor'
PUBLIC	??0SrcRefData@MVAnalyse@@QAE@XZ			; MVAnalyse::SrcRefData::SrcRefData
PUBLIC	??$destroy@VSrcRefData@MVAnalyse@@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ; std::allocator<MVAnalyse::SrcRefData>::destroy<MVAnalyse::SrcRefData>
PUBLIC	??$construct@VSrcRefData@MVAnalyse@@V12@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
PUBLIC	??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ; std::allocator<MVAnalyse::SrcRefData>::construct<MVAnalyse::SrcRefData>
PUBLIC	??$move@AAVSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z ; std::move<MVAnalyse::SrcRefData &>
PUBLIC	??R?$AioMax@H@conc@@QBEHH@Z			; conc::AioMax<int>::operator()
PUBLIC	?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::cas_combi
PUBLIC	??Y?$AtomicInt@I@conc@@QAEAAV01@ABI@Z		; conc::AtomicInt<unsigned int>::operator+=
PUBLIC	??$destroy@VSrcRefData@MVAnalyse@@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::destroy<MVAnalyse::SrcRefData>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	??$_Ptr_move_cat@VSrcRefData@MVAnalyse@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVSrcRefData@MVAnalyse@@0@Z ; std::_Ptr_move_cat<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
PUBLIC	??$_Uninitialized_copy_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked1<int,int,std::allocator<int> >
PUBLIC	??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData>
PUBLIC	??$exec_both@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@AAH2@Z ; conc::AtomicIntOp::exec_both<int,conc::AioMax<int> >
PUBLIC	?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVDCTClass@@@2@H0H@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::cas2
PUBLIC	?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEHXZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::get_val
PUBLIC	?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::get_ptr
PUBLIC	?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::read_ptr
PUBLIC	?cas@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@PAV32@0@Z ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::cas
PUBLIC	?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::LockFreeStack<DCTClass *>::push
PUBLIC	?return_cell@?$CellPool@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::CellPool<DCTClass *>::return_cell
PUBLIC	?swap@?$AtomicMem@$01@conc@@SAHACHH@Z		; conc::AtomicMem<2>::swap
PUBLIC	??E?$AtomicInt@I@conc@@QAEAAV01@XZ		; conc::AtomicInt<unsigned int>::operator++
PUBLIC	??0?$LockFreeCell@PAVDCTClass@@@conc@@QAE@XZ	; conc::LockFreeCell<DCTClass *>::LockFreeCell<DCTClass *>
PUBLIC	??$destroy@VSrcRefData@MVAnalyse@@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::destroy<MVAnalyse::SrcRefData>
PUBLIC	??$_Rechecked@PAVSrcRefData@MVAnalyse@@PAV12@@std@@YAAAPAVSrcRefData@MVAnalyse@@AAPAV12@PAV12@@Z ; std::_Rechecked<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	??$_Unchecked@PAVSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z ; std::_Unchecked<MVAnalyse::SrcRefData *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<int *,int *,std::allocator<int> >
PUBLIC	??$construct@VSrcRefData@MVAnalyse@@$$V@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData>
PUBLIC	??$exec@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@@Z ; conc::AtomicIntOp::exec<int,conc::AioMax<int> >
PUBLIC	??0?$AioMax@H@conc@@QAE@H@Z			; conc::AioMax<int>::AioMax<int>
PUBLIC	??$?8HH@std@@YA_NABV?$allocator@H@0@0@Z		; std::operator==<int,int>
PUBLIC	??$_Unfancy@VSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z ; std::_Unfancy<MVAnalyse::SrcRefData>
PUBLIC	?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVDCTClass@@@2@H@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::set
PUBLIC	??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >
PUBLIC	??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@1@J@Z ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>::operator[]
PUBLIC	??B?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@1@XZ ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::operator conc::LockFreeCell<DCTClass *> *
PUBLIC	??4?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVDCTClass@@@1@@Z ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::operator=
PUBLIC	??0?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::AtomicPtr<conc::LockFreeCell<DCTClass *> >
PUBLIC	?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ; conc::LockFreeStack<DCTClass *>::pop
PUBLIC	?compute_grown_size@?$CellPool@PAVDCTClass@@@conc@@CAII@Z ; conc::CellPool<DCTClass *>::compute_grown_size
PUBLIC	?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z ; conc::CellPool<DCTClass *>::allocate_zone
PUBLIC	?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z ; conc::ObjPool<DCTClass>::delete_obj_stack
PUBLIC	??4?$AtomicInt@H@conc@@QAEAAV01@H@Z		; conc::AtomicInt<int>::operator=
PUBLIC	??0?$AtomicInt@H@conc@@QAE@H@Z			; conc::AtomicInt<int>::AtomicInt<int>
PUBLIC	??4?$AtomicInt@I@conc@@QAEAAV01@I@Z		; conc::AtomicInt<unsigned int>::operator=
PUBLIC	??0?$AtomicInt@I@conc@@QAE@I@Z			; conc::AtomicInt<unsigned int>::AtomicInt<unsigned int>
PUBLIC	??_G?$AioMax@H@conc@@UAEPAXI@Z			; conc::AioMax<int>::`scalar deleting destructor'
PUBLIC	??1?$AioMax@H@conc@@UAE@XZ			; conc::AioMax<int>::~AioMax<int>
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAE@XZ ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>
PUBLIC	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
PUBLIC	??$_Uninitialized_move@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ; std::_Uninitialized_move<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<int> > >
PUBLIC	??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<int *,int *>
PUBLIC	??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ; std::_Ptr_copy_cat<int,int>
PUBLIC	??$?8V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z ; std::operator==<std::allocator<int>,std::allocator<int> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	??0?$LockFreeStack@PAVDCTClass@@@conc@@QAE@XZ	; conc::LockFreeStack<DCTClass *>::LockFreeStack<DCTClass *>
PUBLIC	?expand_to@?$CellPool@PAVDCTClass@@@conc@@QAEXI@Z ; conc::CellPool<DCTClass *>::expand_to
PUBLIC	?clear_all@?$CellPool@PAVDCTClass@@@conc@@QAEXXZ ; conc::CellPool<DCTClass *>::clear_all
PUBLIC	??0?$CellPool@PAVDCTClass@@@conc@@QAE@XZ	; conc::CellPool<DCTClass *>::CellPool<DCTClass *>
PUBLIC	?cleanup@?$ObjPool@VDCTClass@@@conc@@QAEXXZ	; conc::ObjPool<DCTClass>::cleanup
PUBLIC	??0?$allocator@VSrcRefData@MVAnalyse@@@std@@QAE@XZ ; std::allocator<MVAnalyse::SrcRefData>::allocator<MVAnalyse::SrcRefData>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >
PUBLIC	??0?$auto_ptr_ref@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z ; std::auto_ptr_ref<GroupOfPlanes>::auto_ptr_ref<GroupOfPlanes>
PUBLIC	??0?$auto_ptr_ref@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z ; std::auto_ptr_ref<DCTFactory>::auto_ptr_ref<DCTFactory>
PUBLIC	??_G?$CellPool@PAVDCTClass@@@conc@@UAEPAXI@Z	; conc::CellPool<DCTClass *>::`scalar deleting destructor'
PUBLIC	??_G?$ObjPool@VDCTClass@@@conc@@UAEPAXI@Z	; conc::ObjPool<DCTClass>::`scalar deleting destructor'
PUBLIC	??$_Destroy_range@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
PUBLIC	??$_Umove@PAVSrcRefData@MVAnalyse@@@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEPAVSrcRefData@MVAnalyse@@PAV23@00@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Umove<MVAnalyse::SrcRefData *>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<int> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1><>
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_unchecked<int *,int *>
PUBLIC	??$?9V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z ; std::operator!=<std::allocator<int>,std::allocator<int> >
PUBLIC	??$_Uninitialized_default_fill_n@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	??$?BVDCTFactory@@@?$auto_ptr@VDCTFactory@@@std@@QAE?AU?$auto_ptr_ref@VDCTFactory@@@1@XZ ; std::auto_ptr<DCTFactory>::operator<DCTFactory> std::auto_ptr_ref<DCTFactory>
PUBLIC	??$?BVGroupOfPlanes@@@?$auto_ptr@VGroupOfPlanes@@@std@@QAE?AU?$auto_ptr_ref@VGroupOfPlanes@@@1@XZ ; std::auto_ptr<GroupOfPlanes>::operator<GroupOfPlanes> std::auto_ptr_ref<GroupOfPlanes>
PUBLIC	??1?$CellPool@PAVDCTClass@@@conc@@UAE@XZ	; conc::CellPool<DCTClass *>::~CellPool<DCTClass *>
PUBLIC	?set_factory@?$ObjPool@VDCTClass@@@conc@@QAEXAAV?$ObjFactoryInterface@VDCTClass@@@2@@Z ; conc::ObjPool<DCTClass>::set_factory
PUBLIC	??1?$ObjPool@VDCTClass@@@conc@@UAE@XZ		; conc::ObjPool<DCTClass>::~ObjPool<DCTClass>
PUBLIC	??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ		; conc::ObjPool<DCTClass>::ObjPool<DCTClass>
PUBLIC	?max_size@?$allocator@VSrcRefData@MVAnalyse@@@std@@QBEIXZ ; std::allocator<MVAnalyse::SrcRefData>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAIABV?$allocator@VSrcRefData@MVAnalyse@@@2@@Z ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z ; std::allocator<MVAnalyse::SrcRefData>::deallocate
PUBLIC	?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ; std::allocator<MVAnalyse::SrcRefData>::allocate
PUBLIC	?capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myend
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_second
PUBLIC	?_Unused_capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Unused_capacity
PUBLIC	?max_size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::max_size
PUBLIC	?_Destroy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXPAVSrcRefData@MVAnalyse@@0@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Destroy
PUBLIC	?_Grow_to@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEII@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reallocate
PUBLIC	?_Xlen@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEXXZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_first
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@H@std@@@2@@Z ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Copy_alloc
PUBLIC	?size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::size
PUBLIC	?_Pop_back_n@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Pop_back_n
PUBLIC	?_Buy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAE_NI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Buy
PUBLIC	?_Reserve@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reserve
PUBLIC	?_Tidy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXXZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Mylast
PUBLIC	?get@?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ ; std::auto_ptr<GroupOfPlanes>::get
PUBLIC	?reset@?$auto_ptr@VGroupOfPlanes@@@std@@QAEXPAVGroupOfPlanes@@@Z ; std::auto_ptr<GroupOfPlanes>::reset
PUBLIC	?reset@?$auto_ptr@VDCTFactory@@@std@@QAEXPAVDCTFactory@@@Z ; std::auto_ptr<DCTFactory>::reset
PUBLIC	??_GGroupOfPlanes@@QAEPAXI@Z			; GroupOfPlanes::`scalar deleting destructor'
PUBLIC	??_G?$LockFreeStack@PAVDCTClass@@@conc@@UAEPAXI@Z ; conc::LockFreeStack<DCTClass *>::`scalar deleting destructor'
PUBLIC	??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAEPAXI@Z ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`scalar deleting destructor'
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
PUBLIC	??0?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@I@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	??1?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::~vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >
PUBLIC	?resize@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::resize
PUBLIC	??A?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEAAVSrcRefData@MVAnalyse@@I@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::operator[]
PUBLIC	??0?$auto_ptr@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z ; std::auto_ptr<GroupOfPlanes>::auto_ptr<GroupOfPlanes>
PUBLIC	??4?$auto_ptr@VGroupOfPlanes@@@std@@QAEAAV01@U?$auto_ptr_ref@VGroupOfPlanes@@@1@@Z ; std::auto_ptr<GroupOfPlanes>::operator=
PUBLIC	??1?$auto_ptr@VGroupOfPlanes@@@std@@QAE@XZ	; std::auto_ptr<GroupOfPlanes>::~auto_ptr<GroupOfPlanes>
PUBLIC	??C?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ ; std::auto_ptr<GroupOfPlanes>::operator->
PUBLIC	??0?$auto_ptr@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z ; std::auto_ptr<DCTFactory>::auto_ptr<DCTFactory>
PUBLIC	??4?$auto_ptr@VDCTFactory@@@std@@QAEAAV01@U?$auto_ptr_ref@VDCTFactory@@@1@@Z ; std::auto_ptr<DCTFactory>::operator=
PUBLIC	??1?$auto_ptr@VDCTFactory@@@std@@QAE@XZ		; std::auto_ptr<DCTFactory>::~auto_ptr<DCTFactory>
PUBLIC	??D?$auto_ptr@VDCTFactory@@@std@@QBEAAVDCTFactory@@XZ ; std::auto_ptr<DCTFactory>::operator*
PUBLIC	?get@?$auto_ptr@VDCTFactory@@@std@@QBEPAVDCTFactory@@XZ ; std::auto_ptr<DCTFactory>::get
PUBLIC	??1?$LockFreeStack@PAVDCTClass@@@conc@@UAE@XZ	; conc::LockFreeStack<DCTClass *>::~LockFreeStack<DCTClass *>
PUBLIC	??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAE@XZ ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::~AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >
PUBLIC	?load_src_frame@MVAnalyse@@AAEXAAVMVGroupOfFrames@@AAVPVideoFrame@@ABVMVAnalysisData@@@Z ; MVAnalyse::load_src_frame
PUBLIC	?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVAnalyse::GetFrame
PUBLIC	??1MVAnalyse@@UAE@XZ				; MVAnalyse::~MVAnalyse
PUBLIC	??4SrcRefData@MVAnalyse@@QAEAAV01@ABV01@@Z	; MVAnalyse::SrcRefData::operator=
PUBLIC	??_GMVAnalyse@@UAEPAXI@Z			; MVAnalyse::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVAnalyse@@UAGHHH@Z		; MVAnalyse::SetCacheHints
PUBLIC	?MulDivFPS@VideoInfo@@QAEXII@Z			; VideoInfo::MulDivFPS
PUBLIC	?IsFieldBased@VideoInfo@@QBE_NXZ		; VideoInfo::IsFieldBased
PUBLIC	?IsYUV@VideoInfo@@QBE_NXZ			; VideoInfo::IsYUV
PUBLIC	?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z	; std::_Container_base0::_Swap_all
PUBLIC	??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z ; MVAnalyse::MVAnalyse
EXTRN	??_E?$LockFreeStack@PAVDCTClass@@@conc@@UAEPAXI@Z:PROC ; conc::LockFreeStack<DCTClass *>::`vector deleting destructor'
EXTRN	??_E?$ObjPool@VDCTClass@@@conc@@UAEPAXI@Z:PROC	; conc::ObjPool<DCTClass>::`vector deleting destructor'
EXTRN	??_E?$CellPool@PAVDCTClass@@@conc@@UAEPAXI@Z:PROC ; conc::CellPool<DCTClass *>::`vector deleting destructor'
EXTRN	??_E?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAEPAXI@Z:PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`vector deleting destructor'
EXTRN	??_E?$AioAdd@I@conc@@UAEPAXI@Z:PROC		; conc::AioAdd<unsigned int>::`vector deleting destructor'
EXTRN	??_E?$AioMax@H@conc@@UAEPAXI@Z:PROC		; conc::AioMax<int>::`vector deleting destructor'
EXTRN	??_EMVAnalyse@@UAEPAXI@Z:PROC			; MVAnalyse::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$9
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$57
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVAnalyse@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MVAnalyse@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVAnalyse@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVAnalyse@@UAE@XZ$38
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$18
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
;	COMDAT ??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_this$1$ = -60						; size = 4
_analysisDataDivided$1$ = -56				; size = 4
_nHeight_B$1$ = -52					; size = 4
$T2 = -52						; size = 4
$T3 = -52						; size = 4
_nBlkY$1$ = -48						; size = 4
_nHeight$1$ = -48					; size = 4
_nLevelsMax$1$ = -44					; size = 4
_nWidth_B$1$ = -40					; size = 4
$T4 = -36						; size = 4
_analysisData$1$ = -32					; size = 4
_nSuperModeYUV$1$ = -28					; size = 4
_nSuperLevels$1$ = -24					; size = 4
_this$ = -20						; size = 4
_nSuperHPad$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
__blksizex$ = 12					; size = 4
__blksizey$ = 16					; size = 4
_lv$ = 20						; size = 4
_st$ = 24						; size = 4
_stp$ = 28						; size = 4
__pelSearch$ = 32					; size = 4
_isb$ = 36						; size = 1
_lambda$ = 40						; size = 4
$T5 = 44						; size = 4
tv2209 = 44						; size = 4
$T6 = 44						; size = 4
_chroma$ = 44						; size = 1
_df$ = 48						; size = 4
__lsad$ = 52						; size = 4
__plevel$ = 56						; size = 4
__global$ = 60						; size = 1
__pnew$ = 64						; size = 4
__pzero$ = 68						; size = 4
__pglobal$ = 72						; size = 4
__overlapx$ = 76					; size = 4
__overlapy$ = 80					; size = 4
__outfilename$ = 84					; size = 4
__dctmode$ = 88						; size = 4
tv2208 = 92						; size = 4
__divide$ = 92						; size = 4
__sadx264$dead$ = 96					; size = 4
__badSAD$ = 100						; size = 4
__badrange$ = 104					; size = 4
__isse$ = 108						; size = 1
__meander$ = 112					; size = 1
_nSuperVPad$1$ = 116					; size = 4
_temporal_flag$ = 116					; size = 1
__tryMany$ = 120					; size = 1
$T7 = 124						; size = 4
_nSuperPel$1$ = 124					; size = 4
tv2204 = 124						; size = 4
$T8 = 124						; size = 4
_multi_flag$ = 124					; size = 1
_chroma$1$ = 127					; size = 1
_nBlkX$1$ = 128						; size = 4
_mt_flag$ = 128						; size = 1
_env$ = 132						; size = 4
??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z PROC ; MVAnalyse::MVAnalyse, COMDAT
; _this$ = ecx

; 57   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvanalyse.cpp

; 48   :   : ::GenericVideoFilter(_child)

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN99@MVAnalyse
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN99@MVAnalyse
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN99@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 48   :   : ::GenericVideoFilter(_child)

	mov	ecx, esi
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 49   :   , _srd_arr(1)

	lea	edi, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	ecx
	mov	ecx, edi

; 57   : {

	mov	DWORD PTR [esi], OFFSET ??_7MVAnalyse@@6B@
	mov	DWORD PTR $T4[ebp], edi
	call	??0?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@I@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 697  : 		: _Myptr(_Ptr)

	mov	DWORD PTR [esi+76], 0
; File c:\github\mvtools\sources\mvanalyse.cpp

; 52   :   , _temporal_flag(temporal_flag)

	mov	al, BYTE PTR _temporal_flag$[ebp]
	mov	bl, BYTE PTR _multi_flag$[ebp]
	mov	BYTE PTR [esi+147], al

; 53   :   , _mt_flag(mt_flag)

	mov	eax, DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR [esi+146], bl
	mov	BYTE PTR [esi+148], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 697  : 		: _Myptr(_Ptr)

	mov	DWORD PTR [esi+168], 0
; File c:\github\mvtools\sources\mvanalyse.cpp

; 55   :   , _dct_pool()

	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ	; conc::ObjPool<DCTClass>::ObjPool<DCTClass>
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 56   :   , _delta_max(0)

	mov	DWORD PTR [esi+576], 0

; 58   :   if (multi_flag && df < 1)

	test	bl, bl
	je	SHORT $LN12@MVAnalyse
	cmp	DWORD PTR _df$[ebp], 1
	jge	SHORT $LN12@MVAnalyse

; 59   :   {
; 60   :     env->ThrowError(

	mov	ecx, DWORD PTR _env$[ebp]
	push	OFFSET ??_C@_0EI@BEMGDCCH@MAnalyse?3?5cannot?5use?5a?5fixed?5fra@
	push	ecx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN12@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 692  :   int ComponentSize() const AVS_BakedCode(return AVS_LinkCallOptDefault(ComponentSize, 1))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN109@MVAnalyse
	cmp	DWORD PTR [eax], 532			; 00000214H
	jbe	SHORT $LN109@MVAnalyse
; File c:\github\mvtools\sources\mvanalyse.cpp

; 66   :   pixelsize = vi.ComponentSize();

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 692  :   int ComponentSize() const AVS_BakedCode(return AVS_LinkCallOptDefault(ComponentSize, 1))

	mov	eax, DWORD PTR [eax+532]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 66   :   pixelsize = vi.ComponentSize();

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 692  :   int ComponentSize() const AVS_BakedCode(return AVS_LinkCallOptDefault(ComponentSize, 1))

	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN110@MVAnalyse
$LN109@MVAnalyse:
	mov	ebx, DWORD PTR _this$[ebp]
	mov	ecx, 1
$LN110@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 66   :   pixelsize = vi.ComponentSize();

	mov	DWORD PTR [ebx+152], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	test	eax, eax
	je	SHORT $LN113@MVAnalyse
	cmp	DWORD PTR [eax], 536			; 00000218H
	jbe	SHORT $LN113@MVAnalyse
	mov	eax, DWORD PTR [eax+536]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 67   :   bits_per_pixel = vi.BitsPerComponent();

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN114@MVAnalyse
$LN113@MVAnalyse:
	mov	ecx, 8
$LN114@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 72   :   if (pixelsize == 4)

	cmp	DWORD PTR [ebx+152], 4
	mov	DWORD PTR [ebx+156], ecx
	mov	esi, DWORD PTR [edi]

; 73   :   {
; 74   :     env->ThrowError("MAnalyse: Clip with float pixel type is not supported");

	mov	edi, DWORD PTR _env$[ebp]
	mov	DWORD PTR _analysisData$1$[ebp], esi
	lea	ecx, DWORD PTR [esi+88]
	mov	DWORD PTR _analysisDataDivided$1$[ebp], ecx
	jne	SHORT $LN13@MVAnalyse
	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DG@IDHPFBBC@MAnalyse?3?5Clip?5with?5float?5pixel?5@
	push	edi
	call	DWORD PTR [eax+20]
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	add	esp, 8
$LN13@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	test	eax, eax
	je	SHORT $LN345@MVAnalyse
	cmp	DWORD PTR [eax], 24			; 00000018H
	jbe	SHORT $LN344@MVAnalyse
	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 77   :   if (!vi.IsYUV() && !vi.IsYUY2()) // YUY2 is also YUV but let's see what is supported

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvanalyse.cpp

; 77   :   if (!vi.IsYUV() && !vi.IsYUY2()) // YUY2 is also YUV but let's see what is supported

	test	al, al
	jne	SHORT $LN14@MVAnalyse
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN344@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	test	eax, eax
	je	SHORT $LN345@MVAnalyse
	cmp	DWORD PTR [eax], 28			; 0000001cH
	jbe	SHORT $LN345@MVAnalyse
	mov	eax, DWORD PTR [eax+28]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 77   :   if (!vi.IsYUV() && !vi.IsYUY2()) // YUY2 is also YUV but let's see what is supported

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvanalyse.cpp

; 77   :   if (!vi.IsYUV() && !vi.IsYUY2()) // YUY2 is also YUV but let's see what is supported

	test	al, al
	jne	SHORT $LN14@MVAnalyse
$LN345@MVAnalyse:

; 78   : //if (! vi.IsYV12 () && ! vi.IsYUY2 ())
; 79   :   {
; 80   :     env->ThrowError("MAnalyse: Clip must be YUV or YUY2");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CD@JIMPFCGE@MAnalyse?3?5Clip?5must?5be?5YUV?5or?5YU@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN14@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN83@MVAnalyse

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN82@MVAnalyse
$LN83@MVAnalyse:
	push	ecx
; File c:\github\mvtools\sources\mvanalyse.cpp

; 85   :   memcpy(&params, &child->GetVideoInfo().num_audio_samples, 8);

	call	eax
$LN82@MVAnalyse:
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _nSuperVPad$1$[ebp], edx

; 86   :   const int		nHeight = params.nHeight;
; 87   :   const int		nSuperHPad = params.nHPad;

	mov	eax, DWORD PTR _nSuperVPad$1$[ebp]

; 88   :   const int		nSuperVPad = params.nVPad;

	shr	DWORD PTR _nSuperVPad$1$[ebp], 24	; 00000018H
	shr	eax, 16					; 00000010H
	movzx	eax, al
	mov	DWORD PTR _nSuperHPad$1$[ebp], eax

; 89   :   const int		nSuperPel = params.nPel;

	movzx	eax, cl
	mov	DWORD PTR _nSuperPel$1$[ebp], eax

; 90   :   const int		nSuperModeYUV = params.nModeYUV;

	mov	eax, ecx
	shr	eax, 8

; 91   :   const int		nSuperLevels = params.nLevels;

	shr	ecx, 16					; 00000010H
	movzx	edx, dx
	movzx	eax, al
	movzx	ecx, cl
	mov	DWORD PTR _nHeight$1$[ebp], edx
	mov	DWORD PTR _nSuperModeYUV$1$[ebp], eax
	mov	DWORD PTR _nSuperLevels$1$[ebp], ecx
	test	edx, edx

; 92   : 
; 93   :   if (nHeight <= 0
; 94   :     || nSuperHPad < 0
; 95   :     || nSuperHPad >= vi.width / 2 // PF: intentional /2
; 96   :     || nSuperVPad < 0
; 97   :     || nSuperPel < 1
; 98   :     || nSuperPel     >  4
; 99   :     || nSuperModeYUV <  0
; 100  :     || nSuperModeYUV >  YUVPLANES
; 101  :     || nSuperLevels < 1)

	je	SHORT $LN16@MVAnalyse
	mov	eax, DWORD PTR [ebx+16]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _nSuperHPad$1$[ebp], eax
	jge	SHORT $LN16@MVAnalyse
	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	dec	eax
	cmp	eax, 3
	ja	SHORT $LN16@MVAnalyse
	cmp	DWORD PTR _nSuperModeYUV$1$[ebp], 7
	ja	SHORT $LN16@MVAnalyse
	cmp	ecx, 1
	jae	SHORT $LN15@MVAnalyse
$LN16@MVAnalyse:

; 102  :   {
; 103  :     env->ThrowError("MAnalyse: wrong super clip (pseudoaudio) parameters");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DE@FOMLGJBB@MAnalyse?3?5wrong?5super?5clip?5?$CIpseu@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN15@MVAnalyse:

; 104  :   }
; 105  : 
; 106  :   analysisData.nWidth = vi.width - nSuperHPad * 2;

	mov	ecx, DWORD PTR [ebx+16]
	lea	edx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR _nSuperHPad$1$[ebp]
	add	eax, eax
	mov	DWORD PTR _this$1$[ebp], edx
	sub	ecx, eax

; 107  :   analysisData.nHeight = nHeight;

	mov	eax, DWORD PTR _nHeight$1$[ebp]
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+36], ecx

; 108  :   analysisData.pixelType = vi.pixel_type;

	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [esi+60], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 707  :   bool IsY()   const AVS_BakedCode( return AVS_LinkCallOpt(IsY, IsY8) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	$LN163@MVAnalyse
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 552				; 00000228H
	ja	SHORT $LN153@MVAnalyse
	cmp	ecx, 48					; 00000030H
	jbe	SHORT $LN346@MVAnalyse
	mov	eax, DWORD PTR [eax+48]
	jmp	SHORT $LN363@MVAnalyse
$LN153@MVAnalyse:
	mov	eax, DWORD PTR [eax+552]
$LN363@MVAnalyse:
	mov	ecx, edx
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvanalyse.cpp

; 109  :   if (!vi.IsY()) {

	test	al, al
	jne	SHORT $LN17@MVAnalyse
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	lea	edx, DWORD PTR [ebx+16]
$LN346@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	test	eax, eax
	je	SHORT $LN163@MVAnalyse
	cmp	DWORD PTR [eax], 28			; 0000001cH
	jbe	SHORT $LN64@MVAnalyse
	mov	eax, DWORD PTR [eax+28]
	mov	ecx, edx
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvanalyse.cpp

; 110  :     analysisData.yRatioUV = vi.IsYUY2() ? 1 : (1 << vi.GetPlaneHeightSubsampling(PLANAR_U));

	test	al, al
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	je	SHORT $LN64@MVAnalyse
	mov	edx, 1
	jmp	SHORT $LN65@MVAnalyse
$LN64@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 662  :   int GetPlaneHeightSubsampling(int plane) const AVS_BakedCode(return AVS_LinkCall(GetPlaneHeightSubsampling)(plane))

	test	eax, eax
	je	SHORT $LN163@MVAnalyse
	cmp	DWORD PTR [eax], 148			; 00000094H
	jbe	SHORT $LN163@MVAnalyse
	mov	eax, DWORD PTR [eax+148]
	lea	ecx, DWORD PTR [ebx+16]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN164@MVAnalyse
$LN17@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 114  :     analysisData.yRatioUV = 1; // n/a

	mov	DWORD PTR [esi+64], 1

; 115  :     analysisData.xRatioUV = 1; // n/a

	mov	DWORD PTR [esi+68], 1
	jmp	SHORT $LN18@MVAnalyse
$LN163@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 662  :   int GetPlaneHeightSubsampling(int plane) const AVS_BakedCode(return AVS_LinkCall(GetPlaneHeightSubsampling)(plane))

	xor	ecx, ecx
$LN164@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 110  :     analysisData.yRatioUV = vi.IsYUY2() ? 1 : (1 << vi.GetPlaneHeightSubsampling(PLANAR_U));

	mov	edx, 1
	shl	edx, cl
$LN65@MVAnalyse:
	mov	DWORD PTR [esi+64], edx
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	test	eax, eax
	je	SHORT $LN171@MVAnalyse
	cmp	DWORD PTR [eax], 28			; 0000001cH
	jbe	SHORT $LN66@MVAnalyse
	mov	eax, DWORD PTR [eax+28]
	lea	ecx, DWORD PTR [ebx+16]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvanalyse.cpp

; 111  :     analysisData.xRatioUV = vi.IsYUY2() ? 2 : (1 << vi.GetPlaneWidthSubsampling(PLANAR_U));

	test	al, al
	je	SHORT $LN354@MVAnalyse
	mov	eax, 2
	jmp	SHORT $LN67@MVAnalyse
$LN354@MVAnalyse:
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN66@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 661  :   int GetPlaneWidthSubsampling(int plane) const AVS_BakedCode(return AVS_LinkCall(GetPlaneWidthSubsampling)(plane))

	test	eax, eax
	je	SHORT $LN171@MVAnalyse
	cmp	DWORD PTR [eax], 144			; 00000090H
	jbe	SHORT $LN171@MVAnalyse
	mov	eax, DWORD PTR [eax+144]
	lea	ecx, DWORD PTR [ebx+16]
	push	2
	call	eax
	mov	ecx, eax
	jmp	SHORT $LN172@MVAnalyse
$LN171@MVAnalyse:
	xor	ecx, ecx
$LN172@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 111  :     analysisData.xRatioUV = vi.IsYUY2() ? 2 : (1 << vi.GetPlaneWidthSubsampling(PLANAR_U));

	mov	eax, 1
	shl	eax, cl
$LN67@MVAnalyse:
	mov	DWORD PTR [esi+68], eax
$LN18@MVAnalyse:

; 116  :   }
; 117  :   analysisData.pixelsize = pixelsize;

	mov	eax, DWORD PTR [ebx+152]
	mov	DWORD PTR [esi+72], eax

; 118  :   analysisData.bits_per_pixel = bits_per_pixel;

	mov	eax, DWORD PTR [ebx+156]

; 119  : 
; 120  : //	env->ThrowError ("MVAnalyse: %d, %d, %d, %d, %d", nPrepHPad, nPrepVPad, nPrepPel, nPrepModeYUV, nPrepLevels);
; 121  :   pSrcGOF = new MVGroupOfFrames(

	push	44					; 0000002cH
	mov	DWORD PTR [esi+76], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	push	DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, eax
	push	DWORD PTR [ebx+156]
	push	DWORD PTR [ebx+152]
	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+68]
	push	DWORD PTR __isse$[ebp]
	push	DWORD PTR _nSuperModeYUV$1$[ebp]
	push	DWORD PTR _nSuperVPad$1$[ebp]
	push	DWORD PTR _nSuperHPad$1$[ebp]
	push	DWORD PTR _nSuperPel$1$[ebp]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	push	DWORD PTR _nSuperLevels$1$[ebp]
	call	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ; MVGroupOfFrames::MVGroupOfFrames
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 122  :     nSuperLevels, analysisData.nWidth, analysisData.nHeight,
; 123  :     nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV,
; 124  :     _isse, analysisData.xRatioUV, analysisData.yRatioUV, pixelsize, bits_per_pixel, mt_flag
; 125  :   );
; 126  :   pRefGOF = new MVGroupOfFrames(

	push	44					; 0000002cH
	mov	DWORD PTR [ebx+564], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	push	DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, eax
	push	DWORD PTR [ebx+156]
	push	DWORD PTR [ebx+152]
	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+68]
	push	DWORD PTR __isse$[ebp]
	push	DWORD PTR _nSuperModeYUV$1$[ebp]
	push	DWORD PTR _nSuperVPad$1$[ebp]
	push	DWORD PTR _nSuperHPad$1$[ebp]
	push	DWORD PTR _nSuperPel$1$[ebp]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	push	DWORD PTR _nSuperLevels$1$[ebp]
	call	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ; MVGroupOfFrames::MVGroupOfFrames
	mov	ecx, DWORD PTR __blksizex$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	DWORD PTR [ebx+568], eax
	mov	eax, DWORD PTR __blksizey$[ebp]
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], eax

; 127  :     nSuperLevels, analysisData.nWidth, analysisData.nHeight,
; 128  :     nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV,
; 129  :     _isse, analysisData.xRatioUV, analysisData.yRatioUV, pixelsize, bits_per_pixel, mt_flag
; 130  :   );
; 131  : 
; 132  :   analysisData.nBlkSizeX = _blksizex;
; 133  :   analysisData.nBlkSizeY = _blksizey;
; 134  :   if ((analysisData.nBlkSizeX != 4 || analysisData.nBlkSizeY != 4)
; 135  :     && (analysisData.nBlkSizeX != 8 || analysisData.nBlkSizeY != 4)
; 136  :     && (analysisData.nBlkSizeX != 8 || analysisData.nBlkSizeY != 8)
; 137  :     && (analysisData.nBlkSizeX != 16 || analysisData.nBlkSizeY != 2)
; 138  :     && (analysisData.nBlkSizeX != 16 || analysisData.nBlkSizeY != 8)
; 139  :     && (analysisData.nBlkSizeX != 16 || analysisData.nBlkSizeY != 16)
; 140  :     && (analysisData.nBlkSizeX != 32 || analysisData.nBlkSizeY != 32)
; 141  :     && (analysisData.nBlkSizeX != 32 || analysisData.nBlkSizeY != 16))

	cmp	ecx, 4
	jne	SHORT $LN20@MVAnalyse
	cmp	eax, ecx
	jmp	SHORT $LN364@MVAnalyse
$LN20@MVAnalyse:
	cmp	ecx, 8
	jne	SHORT $LN22@MVAnalyse
	cmp	eax, 4
	je	SHORT $LN19@MVAnalyse
	cmp	eax, ecx
	jmp	SHORT $LN364@MVAnalyse
$LN22@MVAnalyse:
	cmp	ecx, 16					; 00000010H
	jne	SHORT $LN25@MVAnalyse
	cmp	eax, 2
	je	SHORT $LN19@MVAnalyse
	cmp	eax, 8
	jmp	SHORT $LN365@MVAnalyse
$LN25@MVAnalyse:
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN27@MVAnalyse
	cmp	eax, ecx
$LN365@MVAnalyse:
	je	SHORT $LN19@MVAnalyse
	cmp	eax, 16					; 00000010H
$LN364@MVAnalyse:
	je	SHORT $LN19@MVAnalyse
$LN27@MVAnalyse:

; 142  :   {
; 143  :     env->ThrowError(

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0EO@GNFDPKLC@MAnalyse?3?5Block?8s?5size?5must?5be?54@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN19@MVAnalyse:

; 144  :       "MAnalyse: Block's size must be "
; 145  :       "4x4, 8x4, 8x8, 16x2, 16x8, 16x16, 32x16, 32x32"
; 146  :     );
; 147  :   }
; 148  : 
; 149  : 
; 150  :   analysisData.nPel = nSuperPel;
; 151  :   if (analysisData.nPel != 1
; 152  :     && analysisData.nPel != 2
; 153  :     && analysisData.nPel != 4)

	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	mov	DWORD PTR [esi+16], eax
	cmp	eax, 1
	je	SHORT $LN28@MVAnalyse
	cmp	eax, 2
	je	SHORT $LN28@MVAnalyse
	cmp	eax, 4
	je	SHORT $LN28@MVAnalyse

; 154  :   {
; 155  :     env->ThrowError("MAnalyse: pel has to be 1 or 2 or 4");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CE@GIGNLFPB@MAnalyse?3?5pel?5has?5to?5be?51?5or?52?5o@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN28@MVAnalyse:

; 156  :   }
; 157  : 
; 158  :   analysisData.nDeltaFrame = df;
; 159  : //	if (analysisData.nDeltaFrame < 1)
; 160  : //	{
; 161  : //		analysisData.nDeltaFrame = 1;
; 162  : //	}
; 163  : 
; 164  :   if (_overlapx < 0 || _overlapx > _blksizex/2
; 165  :     || _overlapy < 0 || _overlapy > _blksizey/2)

	mov	ecx, DWORD PTR __overlapx$[ebp]
	mov	eax, DWORD PTR _df$[ebp]
	mov	DWORD PTR [esi+24], eax
	test	ecx, ecx
	js	SHORT $LN30@MVAnalyse
	mov	eax, DWORD PTR __blksizex$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jg	SHORT $LN30@MVAnalyse
	cmp	DWORD PTR __overlapy$[ebp], 0
	jl	SHORT $LN30@MVAnalyse
	mov	eax, DWORD PTR __blksizey$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR __overlapy$[ebp], eax
	jle	SHORT $LN29@MVAnalyse
$LN30@MVAnalyse:

; 166  :   {
; 167  :     env->ThrowError("MAnalyse: overlap must be less or equal than half block size");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DN@OOBBCPMB@MAnalyse?3?5overlap?5must?5be?5less?5o@
	push	edi
	call	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR __overlapx$[ebp]
	add	esp, 8
$LN29@MVAnalyse:

; 168  :   }
; 169  : 
; 170  :    //if (_overlapx % 2 || (_overlapy % 2 > 0 && vi.IsYV12 ())) // was: _overlapx % 2
; 171  :   if (_overlapx % analysisData.xRatioUV || _overlapy % analysisData.yRatioUV) // PF subsampling-aware

	mov	eax, ecx
	cdq
	idiv	DWORD PTR [esi+68]
	test	edx, edx
	jne	SHORT $LN32@MVAnalyse
	mov	eax, DWORD PTR __overlapy$[ebp]
	cdq
	idiv	DWORD PTR [esi+64]
	test	edx, edx
	je	SHORT $LN31@MVAnalyse
$LN32@MVAnalyse:

; 172  :   {
; 173  :     env->ThrowError("MAnalyse: wrong overlap for the colorspace subsampling");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DH@OLKLKFMA@MAnalyse?3?5wrong?5overlap?5for?5the?5@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN31@MVAnalyse:

; 174  :   }
; 175  : 
; 176  :   if (_divide != 0 && (_blksizex < 8 || _blksizey < 8)) // || instead of && 2.5.11.22 green garbage issue

	cmp	DWORD PTR __divide$[ebp], 0
	je	SHORT $LN33@MVAnalyse
	cmp	DWORD PTR __blksizex$[ebp], 8
	jl	SHORT $LN34@MVAnalyse
	cmp	DWORD PTR __blksizey$[ebp], 8
	jge	SHORT $LN33@MVAnalyse
$LN34@MVAnalyse:

; 177  :   {
; 178  :     env->ThrowError(

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DI@GPLFOKOC@MAnalyse?3?5Block?5sizes?5must?5be?58?5@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN33@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 707  :   bool IsY()   const AVS_BakedCode( return AVS_LinkCallOpt(IsY, IsY8) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN355@MVAnalyse
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 552				; 00000228H
	ja	SHORT $LN177@MVAnalyse
	cmp	ecx, 48					; 00000030H
	jbe	SHORT $LN355@MVAnalyse
	mov	eax, DWORD PTR [eax+48]
	jmp	SHORT $LN366@MVAnalyse
$LN177@MVAnalyse:
	mov	eax, DWORD PTR [eax+552]
$LN366@MVAnalyse:
	lea	ecx, DWORD PTR [ebx+16]
	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvanalyse.cpp

; 183  :   if (vi.IsY() && chroma)

	test	al, al
	je	SHORT $LN355@MVAnalyse
	mov	BYTE PTR _chroma$1$[ebp], 0
	jmp	SHORT $LN35@MVAnalyse
$LN355@MVAnalyse:
	mov	al, BYTE PTR _chroma$[ebp]
	mov	BYTE PTR _chroma$1$[ebp], al
$LN35@MVAnalyse:

; 184  :   {
; 185  :     chroma = false; // PF 22d silent fallback
; 186  :     //env->ThrowError ("MAnalyse: chroma is not allowed for greyscale mode");
; 187  :   }
; 188  :   /*
; 189  :  if (   _divide != 0
; 190  :     && (   (_overlapx % 4                    )
; 191  :         || (_overlapy % 4 > 0 && vi.IsYV12 ())
; 192  :         || (_overlapy % 2 > 0 && vi.IsYUY2 ()))) // todo check
; 193  : */
; 194  :   if (_divide != 0
; 195  :     && ((_overlapx % (2 * analysisData.xRatioUV)) || (_overlapy % (2 * analysisData.yRatioUV))) // PF subsampling-aware

	mov	eax, DWORD PTR __divide$[ebp]
	test	eax, eax
	je	SHORT $LN36@MVAnalyse
	mov	ecx, DWORD PTR [esi+68]
	mov	eax, DWORD PTR __overlapx$[ebp]
	add	ecx, ecx
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN37@MVAnalyse
	mov	ecx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR __overlapy$[ebp]
	add	ecx, ecx
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN361@MVAnalyse
$LN37@MVAnalyse:

; 196  :     )
; 197  :   {
; 198  :     env->ThrowError("MAnalyse: wrong overlap for the colorspace subsampling for divide mode");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0EH@PBOJLGAP@MAnalyse?3?5wrong?5overlap?5for?5the?5@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN361@MVAnalyse:
	mov	eax, DWORD PTR __divide$[ebp]
$LN36@MVAnalyse:
	mov	ecx, DWORD PTR __overlapx$[ebp]

; 199  :   }
; 200  : 
; 201  :   divideExtra = _divide;

	mov	DWORD PTR [ebx+132], eax
	mov	eax, DWORD PTR __overlapy$[ebp]

; 202  : 
; 203  :   // include itself, but usually equal to 256 :-)
; 204  :   headerSize = std::max(int(4 + sizeof(analysisData)), 256);

	mov	DWORD PTR [ebx+560], 256		; 00000100H
	mov	DWORD PTR [esi+48], eax

; 205  : 
; 206  :   analysisData.nOverlapX = _overlapx;
; 207  :   analysisData.nOverlapY = _overlapy;
; 208  : 
; 209  :   const int		nBlkX = (analysisData.nWidth - analysisData.nOverlapX)
; 210  :     / (analysisData.nBlkSizeX - analysisData.nOverlapX);

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
	mov	DWORD PTR [esi+44], ecx
	mov	DWORD PTR tv2209[ebp], eax
	mov	eax, DWORD PTR [esi+36]
	sub	eax, ecx
	cdq
	idiv	DWORD PTR tv2209[ebp]
	mov	DWORD PTR _nBlkX$1$[ebp], eax

; 211  :   const int		nBlkY = (analysisData.nHeight - analysisData.nOverlapY)
; 212  :     / (analysisData.nBlkSizeY - analysisData.nOverlapY);

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR __overlapy$[ebp]
	mov	DWORD PTR tv2208[ebp], eax
	mov	eax, DWORD PTR [esi+40]
	sub	eax, DWORD PTR __overlapy$[ebp]
	cdq
	idiv	DWORD PTR tv2208[ebp]

; 213  : 
; 214  :   analysisData.nBlkX = nBlkX;

	mov	edx, DWORD PTR _nBlkX$1$[ebp]
	mov	DWORD PTR _nBlkY$1$[ebp], eax

; 215  :   analysisData.nBlkY = nBlkY;

	mov	DWORD PTR [esi+56], eax

; 216  : 
; 217  :   const int		nWidth_B =
; 218  :     (analysisData.nBlkSizeX - analysisData.nOverlapX) * nBlkX
; 219  :     + analysisData.nOverlapX; // covered by blocks

	mov	eax, DWORD PTR tv2209[ebp]
	imul	eax, edx
	mov	DWORD PTR [esi+52], edx
	add	eax, ecx

; 220  :   const int		nHeight_B =
; 221  :     (analysisData.nBlkSizeY - analysisData.nOverlapY) * nBlkY
; 222  :     + analysisData.nOverlapY;
; 223  : 
; 224  :   // calculate valid levels
; 225  :   int				nLevelsMax = 0;

	xor	ecx, ecx
	mov	DWORD PTR _nWidth_B$1$[ebp], eax
	mov	eax, DWORD PTR tv2208[ebp]
	imul	eax, DWORD PTR _nBlkY$1$[ebp]
	mov	DWORD PTR _nLevelsMax$1$[ebp], ecx
	add	eax, DWORD PTR __overlapy$[ebp]
	mov	DWORD PTR _nHeight_B$1$[ebp], eax

; 226  :   // at last one block
; 227  :   while (((nWidth_B >> nLevelsMax) - analysisData.nOverlapX)
; 228  :     / (analysisData.nBlkSizeX - analysisData.nOverlapX) > 0
; 229  :     && ((nHeight_B >> nLevelsMax) - analysisData.nOverlapY)

	mov	eax, DWORD PTR _nWidth_B$1$[ebp]
	sub	eax, DWORD PTR __overlapx$[ebp]
	cdq
	idiv	DWORD PTR tv2209[ebp]
	test	eax, eax
	jle	SHORT $LN3@MVAnalyse
	mov	ebx, DWORD PTR __overlapx$[ebp]
	mov	edi, DWORD PTR __overlapy$[ebp]
	mov	esi, DWORD PTR _nHeight_B$1$[ebp]
	npad	1
$LL2@MVAnalyse:
	mov	eax, esi
	sar	eax, cl
	sub	eax, edi
	cdq
	idiv	DWORD PTR tv2208[ebp]
	test	eax, eax
	jle	SHORT $LN357@MVAnalyse
	mov	eax, DWORD PTR _nWidth_B$1$[ebp]

; 230  :     / (analysisData.nBlkSizeY - analysisData.nOverlapY) > 0)
; 231  :   {
; 232  :     ++nLevelsMax;

	inc	ecx
	sar	eax, cl
	sub	eax, ebx
	cdq
	idiv	DWORD PTR tv2209[ebp]
	test	eax, eax
	jg	SHORT $LL2@MVAnalyse
$LN357@MVAnalyse:
	mov	ebx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _analysisData$1$[ebp]
	mov	edi, DWORD PTR _env$[ebp]
	mov	DWORD PTR _nLevelsMax$1$[ebp], ecx
$LN3@MVAnalyse:
	mov	edx, DWORD PTR _lv$[ebp]
	test	edx, edx
	lea	eax, DWORD PTR [ecx+edx]
	cmovle	edx, eax
	mov	DWORD PTR [esi+20], edx

; 233  :   }
; 234  : 
; 235  :   analysisData.nLvCount = (lv > 0) ? lv : nLevelsMax + lv;
; 236  :   if (analysisData.nLvCount > nSuperLevels)

	cmp	edx, DWORD PTR _nSuperLevels$1$[ebp]
	jle	SHORT $LN38@MVAnalyse

; 237  :   {
; 238  :     env->ThrowError(

	mov	eax, DWORD PTR [edi]
	push	edx
	push	DWORD PTR _nSuperLevels$1$[ebp]
	push	OFFSET ??_C@_0EO@BOJACNKF@MAnalyse?3?5it?5is?5not?5enough?5level@
	push	edi
	call	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _nLevelsMax$1$[ebp]
	add	esp, 16					; 00000010H
$LN38@MVAnalyse:

; 239  :       "MAnalyse: it is not enough levels  in super clip (%d), "
; 240  :       "while MAnalyse asks %d", nSuperLevels, analysisData.nLvCount
; 241  :     );
; 242  :   }
; 243  :   if (analysisData.nLvCount < 1
; 244  :     || analysisData.nLvCount > nLevelsMax)

	mov	edx, DWORD PTR [esi+20]
	cmp	edx, 1
	jl	SHORT $LN40@MVAnalyse
	cmp	edx, ecx
	jle	SHORT $LN39@MVAnalyse
$LN40@MVAnalyse:

; 245  :   {
; 246  :     env->ThrowError(

	mov	eax, DWORD PTR [edi]
	push	edx
	push	OFFSET ??_C@_0CK@DEPAJCDH@MAnalyse?3?5non?9valid?5number?5of?5le@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 12					; 0000000cH
$LN39@MVAnalyse:

; 247  :       "MAnalyse: non-valid number of levels (%d)", analysisData.nLvCount
; 248  :     );
; 249  :   }
; 250  : 
; 251  :   analysisData.isBackward = isb;

	mov	al, BYTE PTR _isb$[ebp]
	mov	BYTE PTR [esi+28], al

; 252  : 
; 253  :   nLambda = lambda;
; 254  :   lsad = _lsad   * (_blksizex * _blksizey) / 64 * (1 << (bits_per_pixel - 8)); // normalized to 8x8 blocksize todo: float

	mov	esi, DWORD PTR __blksizex$[ebp]
	imul	esi, DWORD PTR __blksizey$[ebp]
	mov	eax, DWORD PTR _lambda$[ebp]
	mov	edi, DWORD PTR [ebx+156]
	mov	DWORD PTR [ebx+84], eax
	mov	eax, esi

; 255  :   pnew = _pnew;
; 256  :   plevel = _plevel;
; 257  :   global = _global;
; 258  :   pglobal = _pglobal;
; 259  :   pzero = _pzero;
; 260  :   badSAD = _badSAD * (_blksizex * _blksizey) / 64 * (1 << (bits_per_pixel - 8));

	imul	esi, DWORD PTR __badSAD$[ebp]
	imul	eax, DWORD PTR __lsad$[ebp]
	lea	ecx, DWORD PTR [edi-8]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	mov	edx, DWORD PTR __pzero$[ebp]
	sar	eax, 6
	shl	eax, cl
	mov	ecx, DWORD PTR __plevel$[ebp]
	mov	DWORD PTR [ebx+100], eax
	mov	eax, DWORD PTR __pnew$[ebp]
	mov	DWORD PTR [ebx+104], eax
	mov	eax, esi

; 261  :   badrange = _badrange;
; 262  :   meander = _meander;
; 263  :   tryMany = _tryMany;
; 264  : 
; 265  :   if (_dctmode != 0)

	mov	esi, DWORD PTR __dctmode$[ebp]
	mov	DWORD PTR [ebx+112], ecx
	mov	cl, BYTE PTR __global$[ebp]
	mov	DWORD PTR [ebx+124], edx
	cdq
	and	edx, 63					; 0000003fH
	mov	BYTE PTR [ebx+116], cl
	mov	ecx, DWORD PTR __pglobal$[ebp]
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR [ebx+120], ecx
	lea	ecx, DWORD PTR [edi-8]
	shl	eax, cl
	mov	DWORD PTR [ebx+136], eax
	mov	eax, DWORD PTR __badrange$[ebp]
	mov	DWORD PTR [ebx+140], eax
	mov	al, BYTE PTR __meander$[ebp]
	mov	BYTE PTR [ebx+144], al
	mov	al, BYTE PTR __tryMany$[ebp]
	mov	BYTE PTR [ebx+145], al
	test	esi, esi
	je	SHORT $LN359@MVAnalyse

; 266  :   {
; 267  :     _dct_factory_ptr = std::auto_ptr <DCTFactory>(

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	edi, DWORD PTR _env$[ebp]
	mov	ecx, eax
	push	edi
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	DWORD PTR [ebx+156]
	push	DWORD PTR [ebx+152]
	push	DWORD PTR __blksizey$[ebp]
	push	DWORD PTR __blksizex$[ebp]
	push	DWORD PTR __isse$[ebp]
	push	esi
	call	??0DCTFactory@@QAE@H_NHHHHAAVIScriptEnvironment@@@Z ; DCTFactory::DCTFactory
	mov	esi, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	ecx, DWORD PTR [ebx+168]
	cmp	esi, ecx
	je	SHORT $LN198@MVAnalyse

; 795  : 			delete _Myptr;

	test	ecx, ecx
	je	SHORT $LN198@MVAnalyse
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN198@MVAnalyse:

; 767  : 		return (*get());

	mov	eax, esi

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [ebx+168], esi
; File c:\github\mvtools\sources\conc\objpool.hpp

; 93   : 	_factory_ptr = &fact;

	mov	DWORD PTR [ebx+184], eax
	jmp	SHORT $LN41@MVAnalyse
$LN359@MVAnalyse:
	mov	edi, DWORD PTR _env$[ebp]
$LN41@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 273  :   switch (st)

	mov	eax, DWORD PTR _st$[ebp]
	cmp	eax, 7
	ja	SHORT $LN49@MVAnalyse
	jmp	DWORD PTR $LN369@MVAnalyse[eax*4]
$LN42@MVAnalyse:

; 274  :   {
; 275  :   case 0:
; 276  :     searchType = ONETIME;

	mov	DWORD PTR [ebx+88], 1

; 277  :     nSearchParam = (stp < 1) ? 1 : stp;
; 278  :     break;

	jmp	SHORT $LN367@MVAnalyse
$LN43@MVAnalyse:

; 279  :   case 1:
; 280  :     searchType = NSTEP;
; 281  :     nSearchParam = (stp < 0) ? 0 : stp;

	mov	eax, DWORD PTR _stp$[ebp]
	xor	ecx, ecx
	test	eax, eax
	mov	DWORD PTR [ebx+88], 2
	cmovs	eax, ecx

; 282  :     break;

	jmp	SHORT $LN368@MVAnalyse
$LN44@MVAnalyse:

; 283  :   case 3:
; 284  :     searchType = EXHAUSTIVE;

	mov	DWORD PTR [ebx+88], 8

; 285  :     nSearchParam = (stp < 1) ? 1 : stp;
; 286  :     break;

	jmp	SHORT $LN367@MVAnalyse
$LN45@MVAnalyse:

; 287  :   case 4:
; 288  :     searchType = HEX2SEARCH;

	mov	DWORD PTR [ebx+88], 16			; 00000010H

; 289  :     nSearchParam = (stp < 1) ? 1 : stp;
; 290  :     break;

	jmp	SHORT $LN367@MVAnalyse
$LN46@MVAnalyse:

; 291  :   case 5:
; 292  :     searchType = UMHSEARCH;

	mov	DWORD PTR [ebx+88], 32			; 00000020H

; 293  :     nSearchParam = (stp < 1) ? 1 : stp; // really min is 4
; 294  :     break;

	jmp	SHORT $LN367@MVAnalyse
$LN47@MVAnalyse:

; 295  :   case 6:
; 296  :     searchType = HSEARCH;

	mov	DWORD PTR [ebx+88], 64			; 00000040H

; 297  :     nSearchParam = (stp < 1) ? 1 : stp;
; 298  :     break;

	jmp	SHORT $LN367@MVAnalyse
$LN48@MVAnalyse:

; 299  :   case 7:
; 300  :     searchType = VSEARCH;

	mov	DWORD PTR [ebx+88], 128			; 00000080H

; 301  :     nSearchParam = (stp < 1) ? 1 : stp;
; 302  :     break;

	jmp	SHORT $LN367@MVAnalyse
$LN49@MVAnalyse:

; 303  :   case 2:
; 304  :   default:
; 305  :     searchType = LOGARITHMIC;

	mov	DWORD PTR [ebx+88], 4
$LN367@MVAnalyse:

; 306  :     nSearchParam = (stp < 1) ? 1 : stp;

	mov	eax, DWORD PTR _stp$[ebp]
	mov	ecx, 1
	cmp	eax, 1
	cmovl	eax, ecx
$LN368@MVAnalyse:

; 307  :   }
; 308  : 
; 309  :   // not below value of 0 at finest level
; 310  :   nPelSearch = (_pelSearch <= 0) ? analysisData.nPel : _pelSearch;

	mov	esi, DWORD PTR _analysisData$1$[ebp]
	mov	DWORD PTR [ebx+92], eax
	mov	eax, DWORD PTR __pelSearch$[ebp]
	test	eax, eax
	jg	SHORT $LN77@MVAnalyse
	mov	eax, DWORD PTR [esi+16]
$LN77@MVAnalyse:
	mov	DWORD PTR [ebx+96], eax

; 311  : 
; 312  : 
; 313  :   analysisData.nFlags = 0;
; 314  :   analysisData.nFlags |= (_isse) ? MOTION_USE_ISSE : 0;

	xor	ecx, ecx
	cmp	BYTE PTR __isse$[ebp], cl
	mov	eax, 32					; 00000020H

; 315  :   analysisData.nFlags |= (analysisData.isBackward) ? MOTION_IS_BACKWARD : 0;

	mov	edx, 64					; 00000040H
	cmovne	ecx, eax
	xor	eax, eax
	cmp	BYTE PTR [esi+28], al
	cmovne	eax, edx

; 316  :   analysisData.nFlags |= (chroma) ? MOTION_USE_CHROMA_MOTION : 0;

	mov	edx, 2048				; 00000800H
	or	ecx, eax
	xor	eax, eax
	cmp	BYTE PTR _chroma$1$[ebp], al
	cmovne	eax, edx
	or	eax, ecx
	mov	DWORD PTR [esi+32], eax

; 317  :   analysisData.nFlags |= cpu_detect(); // 161002 get rid of sadx264, no effect

	call	?cpu_detect@@YAIXZ			; cpu_detect
	or	eax, DWORD PTR [esi+32]

; 318  : #if 0
; 319  :   if (_sadx264 == 0)
; 320  :   {
; 321  :     analysisData.nFlags |= cpu_detect();
; 322  :   }
; 323  :   else
; 324  :   {
; 325  :     if (_sadx264 > 0 && _sadx264 <= 12)
; 326  :     {
; 327  :       //force specific function
; 328  :       analysisData.nFlags |= CPU_MMXEXT;
; 329  :       analysisData.nFlags |= (_sadx264 == 2) ? CPU_CACHELINE_32 : 0;
; 330  :       analysisData.nFlags |= (_sadx264 == 3 || _sadx264 == 5 || _sadx264 == 7) ? CPU_CACHELINE_64 : 0;
; 331  :       analysisData.nFlags |= (_sadx264 == 4 || _sadx264 == 5 || _sadx264 == 10) ? CPU_SSE2_IS_FAST : 0;
; 332  :       analysisData.nFlags |= (_sadx264 == 6) ? CPU_SSE3 : 0;
; 333  :       analysisData.nFlags |= (_sadx264 == 7 || _sadx264 >= 11) ? CPU_SSSE3 : 0;
; 334  :       //beta (debug)
; 335  :       analysisData.nFlags |= (_sadx264 == 8) ? MOTION_USE_SSD : 0;
; 336  :       analysisData.nFlags |= (_sadx264 >= 9 && _sadx264 <= 12) ? MOTION_USE_SATD : 0;
; 337  : //			analysisData.nFlags |= (_sadx264 == 12) ? CPU_PHADD_IS_FAST : 0;
; 338  :     }
; 339  :   }
; 340  : #endif
; 341  : 
; 342  :   if (_dctmode >= 5 && (analysisData.nFlags & CPU_MMXEXT) == 0)

	cmp	DWORD PTR __dctmode$[ebp], 5
	mov	DWORD PTR [esi+32], eax
	jl	SHORT $LN50@MVAnalyse
	test	eax, 32768				; 00008000H
	jne	SHORT $LN50@MVAnalyse

; 343  :   {
; 344  :     env->ThrowError(

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0EH@HPJHCKDK@MAnalyse?3?5dct?5modes?5using?5SADT?5r@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN50@MVAnalyse:

; 345  :       "MAnalyse: dct modes using SADT "
; 346  :       "require at least MMX2 CPU capabilities."
; 347  :     );
; 348  :   }
; 349  : 
; 350  :   nModeYUV = (chroma) ? YUVPLANES : YPLANE;

	cmp	BYTE PTR _chroma$1$[ebp], 0
	mov	eax, 7
	mov	ecx, 1
	cmovne	ecx, eax

; 351  :   if ((nModeYUV & nSuperModeYUV) != nModeYUV)

	mov	eax, ecx
	mov	DWORD PTR [ebx+572], ecx
	and	eax, DWORD PTR _nSuperModeYUV$1$[ebp]
	cmp	eax, ecx
	je	SHORT $LN51@MVAnalyse

; 352  :   {
; 353  :     env->ThrowError(

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0DI@ICFFNAOJ@MAnalyse?3?5super?5clip?5does?5not?5co@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN51@MVAnalyse:

; 358  :   _vectorfields_aptr = std::auto_ptr <GroupOfPlanes>(new GroupOfPlanes(

	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	xor	edx, edx
	movzx	ecx, BYTE PTR [ebx+148]
	cmp	DWORD PTR [ebx+168], edx
	push	ecx
	lea	ecx, DWORD PTR [ebx+176]
	cmove	ecx, edx
	push	ecx
	push	DWORD PTR [esi+76]
	mov	ecx, eax
	push	DWORD PTR [esi+72]
	push	DWORD PTR [ebx+132]
	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+68]
	push	DWORD PTR [esi+56]
	push	DWORD PTR [esi+52]
	push	DWORD PTR [esi+48]
	push	DWORD PTR [esi+44]
	push	DWORD PTR [esi+32]
	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	call	??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z ; GroupOfPlanes::GroupOfPlanes
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	eax, DWORD PTR [ebx+76]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 358  :   _vectorfields_aptr = std::auto_ptr <GroupOfPlanes>(new GroupOfPlanes(

	mov	DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 794  : 		if (_Ptr != _Myptr)

	mov	DWORD PTR $T7[ebp], eax
	cmp	ecx, eax
	je	SHORT $LN233@MVAnalyse

; 795  : 			delete _Myptr;

	test	eax, eax
	je	SHORT $LN233@MVAnalyse
	mov	ecx, eax
	call	??1GroupOfPlanes@@QAE@XZ		; GroupOfPlanes::~GroupOfPlanes
	push	60					; 0000003cH
	push	DWORD PTR $T7[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR $T5[ebp]
	add	esp, 8
$LN233@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 378  :   analysisData.nHPadding = nSuperHPad; // v2.0

	mov	eax, DWORD PTR _nSuperHPad$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [ebx+76], ecx
; File c:\github\mvtools\sources\mvanalyse.cpp

; 378  :   analysisData.nHPadding = nSuperHPad; // v2.0

	mov	DWORD PTR [esi+80], eax

; 379  :   analysisData.nVPadding = nSuperVPad;

	mov	eax, DWORD PTR _nSuperVPad$1$[ebp]
	mov	DWORD PTR [esi+84], eax
	mov	eax, DWORD PTR __outfilename$[ebp]
	mov	DWORD PTR [esi], 22093			; 0000564dH

; 380  : 
; 381  :   // MVAnalysisData and outfile format version: last update v1.8.1
; 382  :   analysisData.nVersion = MVAnalysisData::VERSION;

	mov	DWORD PTR [esi+4], 5

; 383  : //	DebugPrintf(" MVAnalyseData size= %d",sizeof(analysisData));
; 384  : 
; 385  :   outfilename = _outfilename;
; 386  :   if (lstrlen(outfilename) > 0)

	push	eax
	mov	DWORD PTR [ebx+128], eax
	call	DWORD PTR __imp__lstrlenA@4
	test	eax, eax
	jle	SHORT $LN52@MVAnalyse

; 387  :   {
; 388  :     outfile = fopen(outfilename, "wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	DWORD PTR [ebx+128]
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	DWORD PTR [ebx+160], eax

; 389  :     if (outfile == NULL)

	test	eax, eax
	jne	SHORT $LN54@MVAnalyse

; 390  :     {
; 391  :       env->ThrowError("MAnalyse: out file can not be created!");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CH@MBLDLPPN@MAnalyse?3?5out?5file?5can?5not?5be?5cr@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8

; 392  :     }
; 393  :     else

	jmp	SHORT $LN53@MVAnalyse
$LN54@MVAnalyse:

; 394  :     {
; 395  :       fwrite(&analysisData, sizeof(analysisData), 1, outfile);

	push	eax
	push	1
	push	88					; 00000058H
	push	esi
	call	DWORD PTR __imp__fwrite

; 396  :       // short vx, short vy, int SAD = 4 words = 8 bytes per block
; 397  :       outfilebuf = new short[nBlkX * nBlkY * 4];

	mov	eax, DWORD PTR _nBlkY$1$[ebp]
	xor	ecx, ecx
	imul	eax, DWORD PTR _nBlkX$1$[ebp]
	mov	edx, 2
	shl	eax, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ebx+164], eax

; 398  :     }
; 399  :   }
; 400  :   else

	jmp	SHORT $LN53@MVAnalyse
$LN52@MVAnalyse:

; 401  :   {
; 402  :     outfile = NULL;

	mov	DWORD PTR [ebx+160], 0

; 403  :     outfilebuf = NULL;

	mov	DWORD PTR [ebx+164], 0
$LN53@MVAnalyse:

; 404  :   }
; 405  : 
; 406  :   // Defines the format of the output vector clip
; 407  :   const int		width_bytes = headerSize + _vectorfields_aptr->GetArraySize() * 4;

	mov	ecx, DWORD PTR [ebx+76]
	call	?GetArraySize@GroupOfPlanes@@QAEHXZ	; GroupOfPlanes::GetArraySize
	mov	ecx, DWORD PTR [ebx+560]

; 408  :   ClipFnc::format_vector_clip(

	mov	dl, 1
	push	edi
	push	OFFSET ??_C@_08MPPFBKIE@MAnalyse?$AA@
	lea	edi, DWORD PTR [ebx+16]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, edi
	push	eax
	push	OFFSET ??_C@_05HJLHGJPL@rgb32?$AA@
	push	DWORD PTR _nBlkX$1$[ebp]
	call	?format_vector_clip@ClipFnc@@SAXAAUVideoInfo@@_NHPBDH2AAVIScriptEnvironment@@@Z ; ClipFnc::format_vector_clip
	add	esp, 20					; 00000014H

; 409  :     vi, true, nBlkX, "rgb32", width_bytes, "MAnalyse", *env
; 410  :   );
; 411  : 
; 412  :   if (divideExtra)	//v1.8.1

	cmp	DWORD PTR [ebx+132], 0
	je	SHORT $LN56@MVAnalyse

; 413  :   {
; 414  :     memcpy(&analysisDataDivided, &analysisData, sizeof(analysisData));

	movups	xmm0, XMMWORD PTR [esi]
	mov	ecx, DWORD PTR _analysisDataDivided$1$[ebp]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	xmm0, XMMWORD PTR [esi+48]
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	xmm0, XMMWORD PTR [esi+64]
	movups	XMMWORD PTR [ecx+64], xmm0
	movq	xmm0, QWORD PTR [esi+80]
	movq	QWORD PTR [ecx+80], xmm0

; 415  :     analysisDataDivided.nBlkX = analysisData.nBlkX * 2;

	mov	eax, DWORD PTR [esi+52]
	add	eax, eax
	mov	DWORD PTR [ecx+52], eax

; 416  :     analysisDataDivided.nBlkY = analysisData.nBlkY * 2;

	mov	eax, DWORD PTR [esi+56]
	add	eax, eax
	mov	DWORD PTR [ecx+56], eax

; 417  :     analysisDataDivided.nBlkSizeX = analysisData.nBlkSizeX / 2;

	mov	eax, DWORD PTR [esi+8]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [ecx+8], eax

; 418  :     analysisDataDivided.nBlkSizeY = analysisData.nBlkSizeY / 2;

	mov	eax, DWORD PTR [esi+12]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [ecx+12], eax

; 419  :     analysisDataDivided.nOverlapX = analysisData.nOverlapX / 2;

	mov	eax, DWORD PTR [esi+44]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [ecx+44], eax

; 420  :     analysisDataDivided.nOverlapY = analysisData.nOverlapY / 2;

	mov	eax, DWORD PTR [esi+48]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [ecx+48], eax

; 421  :     analysisDataDivided.nLvCount = analysisData.nLvCount + 1;

	mov	eax, DWORD PTR [esi+20]
	inc	eax
	mov	DWORD PTR [ecx+20], eax
$LN56@MVAnalyse:

; 422  :   }
; 423  : 
; 424  :   if (_temporal_flag)

	cmp	BYTE PTR [ebx+147], 0
	je	SHORT $LN358@MVAnalyse

; 425  :   {
; 426  :     _srd_arr[0]._vec_prev.resize(_vectorfields_aptr->GetArraySize()); // array for prev vectors

	mov	ecx, DWORD PTR [ebx+76]
	call	?GetArraySize@GroupOfPlanes@@QAEHXZ	; GroupOfPlanes::GetArraySize
	mov	ecx, DWORD PTR [ebx+64]
	lea	esi, DWORD PTR [ebx+64]
	push	eax
	add	ecx, 176				; 000000b0H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize
	jmp	SHORT $LN57@MVAnalyse
$LN358@MVAnalyse:
	lea	esi, DWORD PTR [ebx+64]
$LN57@MVAnalyse:

; 427  :   }
; 428  :   _srd_arr[0]._vec_prev_frame = -2;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+188], -2			; fffffffeH

; 429  : 
; 430  :   // From this point, analysisData and analysisDataDivided references will
; 431  :   // become invalid, because of the _srd_arr.resize(). Don't use them any more.
; 432  : 
; 433  :   if (_multi_flag)

	cmp	BYTE PTR [ebx+146], 0
	je	$LN356@MVAnalyse

; 436  : 
; 437  :     _srd_arr.resize(_delta_max * 2);

	mov	eax, DWORD PTR _df$[ebp]
	mov	ecx, esi
	mov	DWORD PTR [ebx+576], eax
	add	eax, eax
	push	eax
	call	?resize@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::resize

; 438  :     for (int delta_index = 0; delta_index < _delta_max; ++delta_index)

	cmp	DWORD PTR [ebx+576], 0
	jle	SHORT $LN7@MVAnalyse

; 434  :   {
; 435  :     _delta_max = df;

	xor	ebx, ebx
	mov	DWORD PTR tv2204[ebp], 1
$LL8@MVAnalyse:

; 439  :     {
; 440  :       for (int dir_index = 0; dir_index < 2; ++dir_index)

	xor	edi, edi
$LL11@MVAnalyse:

; 444  :         srd = _srd_arr[0];

	mov	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	esi, DWORD PTR [esi]
	add	esi, ebx
; File c:\github\mvtools\sources\mvanalyse.cpp

; 444  :         srd = _srd_arr[0];

	mov	ecx, esi
	push	DWORD PTR [eax]
	call	??4SrcRefData@MVAnalyse@@QAEAAV01@ABV01@@Z

; 445  : 
; 446  :         srd._analysis_data.nDeltaFrame = delta_index + 1;

	mov	edx, DWORD PTR tv2204[ebp]

; 447  :         srd._analysis_data.isBackward = (dir_index == 0);

	test	edi, edi
	mov	DWORD PTR [esi+24], edx
	sete	al
	mov	BYTE PTR [esi+28], al

; 448  :         if (srd._analysis_data.isBackward)

	test	al, al
	je	SHORT $LN59@MVAnalyse

; 449  :         {
; 450  :           srd._analysis_data.nFlags |= MOTION_IS_BACKWARD;

	or	DWORD PTR [esi+32], 64			; 00000040H

; 451  :         }
; 452  :         else

	jmp	SHORT $LN60@MVAnalyse
$LN59@MVAnalyse:

; 453  :         {
; 454  :           srd._analysis_data.nFlags &= ~MOTION_IS_BACKWARD;

	and	DWORD PTR [esi+32], -65			; ffffffbfH
$LN60@MVAnalyse:

; 455  :         }
; 456  : 
; 457  :         srd._analysis_data_divided.nDeltaFrame = srd._analysis_data.nDeltaFrame;
; 458  :         srd._analysis_data_divided.isBackward = srd._analysis_data.isBackward;

	mov	BYTE PTR [esi+116], al
	inc	edi

; 459  :         srd._analysis_data_divided.nFlags = srd._analysis_data.nFlags;

	mov	eax, DWORD PTR [esi+32]
	add	ebx, 192				; 000000c0H
	mov	DWORD PTR [esi+112], edx
	mov	DWORD PTR [esi+120], eax
	mov	esi, DWORD PTR $T4[ebp]
	cmp	edi, 2
	jl	SHORT $LL11@MVAnalyse

; 438  :     for (int delta_index = 0; delta_index < _delta_max; ++delta_index)

	mov	ecx, DWORD PTR _this$[ebp]
	inc	edx
	mov	DWORD PTR tv2204[ebp], edx
	lea	eax, DWORD PTR [edx-1]
	lea	esi, DWORD PTR [ecx+64]
	cmp	eax, DWORD PTR [ecx+576]
	jl	SHORT $LL8@MVAnalyse
	mov	esi, DWORD PTR $T4[ebp]
	mov	ebx, ecx
	mov	edi, DWORD PTR _this$1$[ebp]
$LN7@MVAnalyse:

; 463  :     vi.num_frames *= _delta_max * 2;

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, DWORD PTR [ebx+576]
; File c:\github\mvtools\sources\include\avisynth.h

; 671  :   void MulDivFPS(unsigned multiplier, unsigned divisor) AVS_BakedCode(AVS_LinkCall(MulDivFPS)(multiplier, divisor))

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvanalyse.cpp

; 463  :     vi.num_frames *= _delta_max * 2;

	imul	eax, ecx

; 464  :     vi.MulDivFPS(_delta_max * 2, 1);

	add	ecx, ecx
	add	eax, eax
	mov	DWORD PTR [ebx+32], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 671  :   void MulDivFPS(unsigned multiplier, unsigned divisor) AVS_BakedCode(AVS_LinkCall(MulDivFPS)(multiplier, divisor))

	test	edx, edx
	je	SHORT $LN303@MVAnalyse
	cmp	DWORD PTR [edx], 164			; 000000a4H
	jbe	SHORT $LN303@MVAnalyse
	mov	eax, DWORD PTR [edx+164]
	push	1
	push	ecx
	mov	ecx, edi
	call	eax
$LN356@MVAnalyse:
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN303@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 470  :   if (divideExtra)	//v1.8.1

	cmp	DWORD PTR [ebx+132], 0

; 471  :   {
; 472  : #if !defined(_WIN64)
; 473  :     vi.nchannels = reinterpret_cast <uintptr_t> (&_srd_arr[0]._analysis_data_divided);

	mov	eax, DWORD PTR [esi]
	je	SHORT $LN61@MVAnalyse
	add	eax, 88					; 00000058H
$LN61@MVAnalyse:

; 474  : #else
; 475  :     uintptr_t p = reinterpret_cast <uintptr_t> (&_srd_arr[0]._analysis_data_divided);
; 476  :     vi.nchannels = 0x80000000L | (int)(p >> 32);
; 477  :     vi.sample_type = (int)(p & 0xffffffffUL);
; 478  : #endif
; 479  :   }
; 480  :   else
; 481  :   {
; 482  : #if !defined(_WIN64)
; 483  :     vi.nchannels = reinterpret_cast <uintptr_t> (&_srd_arr[0]._analysis_data);

	mov	DWORD PTR [ebx+56], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN351@MVAnalyse
	cmp	DWORD PTR [edx], 248			; 000000f8H
	jbe	SHORT $LN351@MVAnalyse
	mov	eax, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
$LN351@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 490  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	128					; 00000080H
	npad	1
$LN369@MVAnalyse:
	DD	$LN42@MVAnalyse
	DD	$LN43@MVAnalyse
	DD	$LN49@MVAnalyse
	DD	$LN44@MVAnalyse
	DD	$LN45@MVAnalyse
	DD	$LN46@MVAnalyse
	DD	$LN47@MVAnalyse
	DD	$LN48@MVAnalyse
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::~vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$auto_ptr@VGroupOfPlanes@@@std@@QAE@XZ ; std::auto_ptr<GroupOfPlanes>::~auto_ptr<GroupOfPlanes>
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$auto_ptr@VDCTFactory@@@std@@QAE@XZ	; std::auto_ptr<DCTFactory>::~auto_ptr<DCTFactory>
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1?$ObjPool@VDCTClass@@@conc@@UAE@XZ	; conc::ObjPool<DCTClass>::~ObjPool<DCTClass>
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$7:
	push	44					; 0000002cH
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$8:
	push	44					; 0000002cH
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$9:
	push	36					; 00000024H
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$11:
	push	60					; 0000003cH
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z$57:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVAnalyse@@QAE@VPClip@@HHHHHH_NH1HHH1HHHHHPBDHHHHH111111PAVIScriptEnvironment@@@Z ENDP ; MVAnalyse::MVAnalyse
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$dead$ = ecx

; 48   : 		}

	ret	4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?IsYUV@VideoInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsYUV@VideoInfo@@QBE_NXZ PROC				; VideoInfo::IsYUV, COMDAT
; _this$ = ecx

; 623  :   bool IsYUV() const AVS_BakedCode(return AVS_LinkCall(IsYUV)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@IsYUV
	cmp	DWORD PTR [eax], 24			; 00000018H
	jbe	SHORT $LN3@IsYUV
	mov	eax, DWORD PTR [eax+24]
	call	eax
	movzx	eax, al
	ret	0
$LN3@IsYUV:
	xor	al, al
	ret	0
?IsYUV@VideoInfo@@QBE_NXZ ENDP				; VideoInfo::IsYUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?IsFieldBased@VideoInfo@@QBE_NXZ
_TEXT	SEGMENT
?IsFieldBased@VideoInfo@@QBE_NXZ PROC			; VideoInfo::IsFieldBased, COMDAT
; _this$ = ecx

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@IsFieldBas
	cmp	DWORD PTR [eax], 64			; 00000040H
	jbe	SHORT $LN3@IsFieldBas
	mov	eax, DWORD PTR [eax+64]
	call	eax
	movzx	eax, al
	ret	0
$LN3@IsFieldBas:
	xor	al, al
	ret	0
?IsFieldBased@VideoInfo@@QBE_NXZ ENDP			; VideoInfo::IsFieldBased
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?MulDivFPS@VideoInfo@@QAEXII@Z
_TEXT	SEGMENT
_multiplier$ = 8					; size = 4
_divisor$ = 12						; size = 4
?MulDivFPS@VideoInfo@@QAEXII@Z PROC			; VideoInfo::MulDivFPS, COMDAT
; _this$ = ecx

; 671  :   void MulDivFPS(unsigned multiplier, unsigned divisor) AVS_BakedCode(AVS_LinkCall(MulDivFPS)(multiplier, divisor))

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@MulDivFPS
	cmp	DWORD PTR [eax], 164			; 000000a4H
	jbe	SHORT $LN3@MulDivFPS
	mov	eax, DWORD PTR [eax+164]
	jmp	eax
$LN3@MulDivFPS:
	ret	8
?MulDivFPS@VideoInfo@@QAEXII@Z ENDP			; VideoInfo::MulDivFPS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalyse.h
;	COMDAT ?SetCacheHints@MVAnalyse@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVAnalyse@@UAGHHH@Z PROC			; MVAnalyse::SetCacheHints, COMDAT

; 136  :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 137  :   }

	ret	12					; 0000000cH
?SetCacheHints@MVAnalyse@@UAGHHH@Z ENDP			; MVAnalyse::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVAnalyse@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVAnalyse@@UAEPAXI@Z PROC				; MVAnalyse::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVAnalyse@@UAE@XZ			; MVAnalyse::~MVAnalyse
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	584					; 00000248H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVAnalyse@@UAEPAXI@Z ENDP				; MVAnalyse::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4SrcRefData@MVAnalyse@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4SrcRefData@MVAnalyse@@QAEAAV01@ABV01@@Z PROC		; MVAnalyse::SrcRefData::operator=, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	push	edi
	mov	edi, ecx
	movups	xmm0, XMMWORD PTR [esi]
	lea	eax, DWORD PTR [esi+176]
	push	eax
	movups	XMMWORD PTR [edi], xmm0
	lea	ecx, DWORD PTR [edi+176]
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR [edi+16], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	movups	XMMWORD PTR [edi+32], xmm0
	movups	xmm0, XMMWORD PTR [esi+48]
	movups	XMMWORD PTR [edi+48], xmm0
	movups	xmm0, XMMWORD PTR [esi+64]
	movups	XMMWORD PTR [edi+64], xmm0
	movq	xmm0, QWORD PTR [esi+80]
	movq	QWORD PTR [edi+80], xmm0
	movups	xmm0, XMMWORD PTR [esi+88]
	movups	XMMWORD PTR [edi+88], xmm0
	movups	xmm0, XMMWORD PTR [esi+104]
	movups	XMMWORD PTR [edi+104], xmm0
	movups	xmm0, XMMWORD PTR [esi+120]
	movups	XMMWORD PTR [edi+120], xmm0
	movups	xmm0, XMMWORD PTR [esi+136]
	movups	XMMWORD PTR [edi+136], xmm0
	movups	xmm0, XMMWORD PTR [esi+152]
	movups	XMMWORD PTR [edi+152], xmm0
	movq	xmm0, QWORD PTR [esi+168]
	movq	QWORD PTR [edi+168], xmm0
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	mov	eax, DWORD PTR [esi+188]
	mov	DWORD PTR [edi+188], eax
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??4SrcRefData@MVAnalyse@@QAEAAV01@ABV01@@Z ENDP		; MVAnalyse::SrcRefData::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
;	COMDAT ??1MVAnalyse@@UAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 1
__$EHRec$ = -12						; size = 12
??1MVAnalyse@@UAE@XZ PROC				; MVAnalyse::~MVAnalyse, COMDAT
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1MVAnalyse@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	edi
	mov	edi, ecx

; 496  :   if (outfile != NULL)

	mov	eax, DWORD PTR [edi+160]
	mov	DWORD PTR [edi], OFFSET ??_7MVAnalyse@@6B@
	test	eax, eax
	je	SHORT $LN2@MVAnalyse

; 497  :   {
; 498  :     fclose(outfile);

	push	eax
	call	DWORD PTR __imp__fclose

; 499  :     outfile = 0;
; 500  :     delete[] outfilebuf;

	push	DWORD PTR [edi+164]
	mov	DWORD PTR [edi+160], 0
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8

; 501  :     outfilebuf = 0;

	mov	DWORD PTR [edi+164], 0
$LN2@MVAnalyse:

; 502  :   }
; 503  : 
; 504  :   delete pSrcGOF;

	push	esi
	mov	esi, DWORD PTR [edi+564]
	test	esi, esi
	je	SHORT $LN9@MVAnalyse
	mov	ecx, esi
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@MVAnalyse:

; 505  :   pSrcGOF = 0;
; 506  :   delete pRefGOF;

	mov	esi, DWORD PTR [edi+568]
	mov	DWORD PTR [edi+564], 0
	test	esi, esi
	je	SHORT $LN13@MVAnalyse
	mov	ecx, esi
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@MVAnalyse:

; 508  : }

	lea	ecx, DWORD PTR [edi+176]
	mov	DWORD PTR [edi+568], 0
	call	??1?$ObjPool@VDCTClass@@@conc@@UAE@XZ	; conc::ObjPool<DCTClass>::~ObjPool<DCTClass>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 757  : 		delete _Myptr;

	mov	ecx, DWORD PTR [edi+168]
	test	ecx, ecx
	je	SHORT $LN18@MVAnalyse
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@MVAnalyse:
	mov	esi, DWORD PTR [edi+76]
	test	esi, esi
	je	SHORT $LN27@MVAnalyse
	mov	ecx, esi
	call	??1GroupOfPlanes@@QAE@XZ		; GroupOfPlanes::~GroupOfPlanes
	push	60					; 0000003cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN27@MVAnalyse:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi+64]
	test	ecx, ecx
	je	SHORT $LN34@MVAnalyse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [edi+68]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR [edi+72]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [edi+64]
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [edi+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	192					; 000000c0H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi+64], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+68], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+72], 0
$LN34@MVAnalyse:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	pop	esi
	test	eax, eax
	je	SHORT $LN148@MVAnalyse
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN148@MVAnalyse
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [edi+8]
	call	eax
$LN148@MVAnalyse:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 508  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [edi], OFFSET ??_7IClip@@6B@
	pop	edi
; File c:\github\mvtools\sources\mvanalyse.cpp

; 508  : }

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVAnalyse@@UAE@XZ$38:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVAnalyse@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVAnalyse@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVAnalyse@@UAE@XZ ENDP				; MVAnalyse::~MVAnalyse
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mvanalyse.cpp
;	COMDAT ?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
_nbr_src_frames$1$ = -36				; size = 4
_srd$1$ = -32						; size = 4
_maxframe$1$ = -28					; size = 4
_src$3 = -28						; size = 4
$T4 = -28						; size = 4
$T5 = -28						; size = 4
_minframe$1$ = -24					; size = 4
$T6 = -24						; size = 4
_nref$1$ = -20						; size = 4
$T7 = -20						; size = 4
_nsrc$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ref$8 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_n$ = 16						; size = 4
$T9 = 20						; size = 4
_fieldShift$1$ = 20					; size = 4
_env$ = 20						; size = 4
?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVAnalyse::GetFrame, COMDAT

; 513  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esi
	mov	DWORD PTR $T2[ebp], 0

; 514  :   const int		ndiv = (_multi_flag) ? _delta_max * 2 : 1;

	mov	esi, DWORD PTR _this$[ebp]
	push	edi
	cmp	BYTE PTR [esi+146], 0
	je	SHORT $LN15@GetFrame
	mov	ecx, DWORD PTR [esi+576]
	add	ecx, ecx
	jmp	SHORT $LN16@GetFrame
$LN15@GetFrame:
	mov	ecx, 1
$LN16@GetFrame:

; 515  :   const int		nsrc = n / ndiv;

	mov	eax, DWORD PTR _n$[ebp]
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 515  :   const int		nsrc = n / ndiv;

	mov	ebx, eax
	mov	DWORD PTR _nsrc$1$[ebp], ebx
	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	edi, DWORD PTR [edx+edx*2]
	shl	edi, 6
	add	edi, DWORD PTR [esi+64]
	mov	DWORD PTR _srd$1$[ebp], edi
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN20@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN19@GetFrame
$LN20@GetFrame:
	push	ecx
; File c:\github\mvtools\sources\mvanalyse.cpp

; 520  :   const int		nbr_src_frames = child->GetVideoInfo().num_frames;

	call	eax
$LN19@GetFrame:

; 521  :   int				minframe;
; 522  :   int				maxframe;
; 523  :   int				nref;
; 524  :   if (srd._analysis_data.nDeltaFrame > 0)

	mov	edx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _nbr_src_frames$1$[ebp], eax
	test	edx, edx
	jle	SHORT $LN2@GetFrame

; 525  :   {
; 526  :     const int		offset =
; 527  :       (srd._analysis_data.isBackward)

	cmp	BYTE PTR [edi+28], 0
	jne	SHORT $LN18@GetFrame
	neg	edx
$LN18@GetFrame:

; 530  :     minframe = std::max(-offset, 0);

	mov	ecx, edx
	mov	DWORD PTR $T5[ebp], 0
	neg	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edi, DWORD PTR $T6[ebp]
	lea	eax, DWORD PTR $T5[ebp]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 530  :     minframe = std::max(-offset, 0);

	mov	DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovns	eax, edi
; File c:\github\mvtools\sources\mvanalyse.cpp

; 531  :     maxframe = nbr_src_frames + std::min(-offset, 0);

	mov	DWORD PTR $T7[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	test	ecx, ecx
	lea	edi, DWORD PTR $T7[ebp]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 530  :     minframe = std::max(-offset, 0);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _minframe$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T4[ebp]
	cmovle	eax, edi
; File c:\github\mvtools\sources\mvanalyse.cpp

; 531  :     maxframe = nbr_src_frames + std::min(-offset, 0);

	mov	DWORD PTR $T4[ebp], 0

; 532  :     nref = nsrc + offset;
; 533  :   }
; 534  :   else // special static mode

	mov	edi, DWORD PTR _srd$1$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR _nbr_src_frames$1$[ebp]
	add	edx, ebx
	jmp	SHORT $LN136@GetFrame
$LN2@GetFrame:

; 535  :   {
; 536  :     nref = -srd._analysis_data.nDeltaFrame;	// positive fixed frame number

	neg	edx

; 537  :     minframe = 0;

	mov	DWORD PTR _minframe$1$[ebp], 0
$LN136@GetFrame:

; 538  :     maxframe = nbr_src_frames;
; 539  :   }
; 540  : 
; 541  :   PVideoFrame			dst = env->NewVideoFrame(vi);

	mov	ecx, DWORD PTR _env$[ebp]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	32					; 00000020H
	mov	DWORD PTR _nref$1$[ebp], edx
	lea	edx, DWORD PTR [esi+16]
	push	edx
	mov	DWORD PTR _maxframe$1$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	push	ebx
	push	ecx
	call	DWORD PTR [eax+56]

; 640  :   }
; 641  : 
; 642  :   return dst;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR $T2[ebp], 1
	test	eax, eax
	je	SHORT $LN50@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN50@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+220]
	push	0
	call	eax
	mov	ebx, eax
	jmp	SHORT $LN51@GetFrame
$LN50@GetFrame:
	xor	ebx, ebx
$LN51@GetFrame:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 545  :   memcpy(pDst, &headerSize, sizeof(int));

	mov	eax, DWORD PTR [esi+560]
	mov	DWORD PTR [ebx], eax

; 546  :   if (divideExtra)

	cmp	DWORD PTR [esi+132], 0
	je	SHORT $LN4@GetFrame

; 547  :   {
; 548  :     memcpy(

	movups	xmm0, XMMWORD PTR [edi+88]
	movups	XMMWORD PTR [ebx+4], xmm0
	movups	xmm0, XMMWORD PTR [edi+104]
	movups	XMMWORD PTR [ebx+20], xmm0
	movups	xmm0, XMMWORD PTR [edi+120]
	movups	XMMWORD PTR [ebx+36], xmm0
	movups	xmm0, XMMWORD PTR [edi+136]
	movups	XMMWORD PTR [ebx+52], xmm0
	movups	xmm0, XMMWORD PTR [edi+152]
	movups	XMMWORD PTR [ebx+68], xmm0
	movq	xmm0, QWORD PTR [edi+168]

; 549  :       pDst + sizeof(int),
; 550  :       &srd._analysis_data_divided,
; 551  :       sizeof(srd._analysis_data_divided)
; 552  :     );
; 553  :   }
; 554  :   else

	jmp	SHORT $LN137@GetFrame
$LN4@GetFrame:

; 555  :   {
; 556  :     memcpy(

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [ebx+4], xmm0
	movups	xmm0, XMMWORD PTR [edi+16]
	movups	XMMWORD PTR [ebx+20], xmm0
	movups	xmm0, XMMWORD PTR [edi+32]
	movups	XMMWORD PTR [ebx+36], xmm0
	movups	xmm0, XMMWORD PTR [edi+48]
	movups	XMMWORD PTR [ebx+52], xmm0
	movups	xmm0, XMMWORD PTR [edi+64]
	movups	XMMWORD PTR [ebx+68], xmm0
	movq	xmm0, QWORD PTR [edi+80]
$LN137@GetFrame:

; 557  :       pDst + sizeof(int),
; 558  :       &srd._analysis_data,
; 559  :       sizeof(srd._analysis_data)
; 560  :     );
; 561  :   }
; 562  :   pDst += headerSize;
; 563  : 
; 564  :   if (nsrc < minframe || nsrc >= maxframe)

	mov	edx, DWORD PTR _nsrc$1$[ebp]
	movq	QWORD PTR [ebx+84], xmm0
	add	ebx, DWORD PTR [esi+560]
	cmp	edx, DWORD PTR _minframe$1$[ebp]
	jl	$LN8@GetFrame
	cmp	edx, DWORD PTR _maxframe$1$[ebp]
	jge	$LN8@GetFrame

; 572  :     ::PVideoFrame	src = child->GetFrame(nsrc, env); // v2.0

	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 572  :     ::PVideoFrame	src = child->GetFrame(nsrc, env); // v2.0

	push	edx
	lea	edx, DWORD PTR _src$3[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]

; 573  :     load_src_frame(*pSrcGOF, src, srd._analysis_data);

	push	edi
	lea	eax, DWORD PTR _src$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	push	DWORD PTR [esi+564]
	mov	ecx, esi
	call	?load_src_frame@MVAnalyse@@AAEXAAVMVGroupOfFrames@@AAVPVideoFrame@@ABVMVAnalysisData@@@Z ; MVAnalyse::load_src_frame

; 577  :     ::PVideoFrame	ref = child->GetFrame(nref, env); // v2.0

	push	DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\mvanalyse.cpp

; 577  :     ::PVideoFrame	ref = child->GetFrame(nref, env); // v2.0

	lea	edx, DWORD PTR _ref$8[ebp]
	push	DWORD PTR _nref$1$[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]

; 578  :     load_src_frame(*pRefGOF, ref, srd._analysis_data);

	push	edi
	lea	eax, DWORD PTR _ref$8[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	eax
	push	DWORD PTR [esi+568]
	mov	ecx, esi
	call	?load_src_frame@MVAnalyse@@AAEXAAVMVGroupOfFrames@@AAVPVideoFrame@@ABVMVAnalysisData@@@Z ; MVAnalyse::load_src_frame
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN69@GetFrame
	cmp	DWORD PTR [eax], 64			; 00000040H
	jbe	SHORT $LN69@GetFrame
	mov	eax, DWORD PTR [eax+64]
	lea	ecx, DWORD PTR [esi+16]
	call	eax
	movzx	eax, al
	jmp	SHORT $LN70@GetFrame
$LN69@GetFrame:
	xor	eax, eax
$LN70@GetFrame:
; File c:\github\mvtools\sources\clipfnc.cpp

; 55   : 	if (field_flag && npel > 1 && ((nsrc - nref) & 1) != 0)

	test	al, al
	je	SHORT $LN72@GetFrame
	push	DWORD PTR _nref$1$[ebp]
	mov	edx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [esi+8]
	push	DWORD PTR _nsrc$1$[ebp]
	call	?compute_fieldshift@ClipFnc@@SAHAAVPClip@@_NHHH@Z ; ClipFnc::compute_fieldshift
	add	esp, 8
	mov	DWORD PTR _fieldShift$1$[ebp], eax
	jmp	SHORT $LN78@GetFrame
$LN72@GetFrame:

; 56   : 	{
; 57   : 		const bool		parity_src = clp->GetParity (nsrc);
; 58   : 		const bool		parity_ref = clp->GetParity (nref);
; 59   : 
; 60   : 		if (parity_src && ! parity_ref)
; 61   : 		{
; 62   : 			fieldshift = npel / 2;
; 63   : 		}
; 64   : 		else if (parity_ref && ! parity_src)
; 65   : 		{
; 66   : 			fieldshift = -(npel / 2);
; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	return (fieldshift);

	mov	DWORD PTR _fieldShift$1$[ebp], 0
$LN78@GetFrame:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 588  :     if (outfile != NULL)

	mov	eax, DWORD PTR [esi+160]
	test	eax, eax
	je	SHORT $LN9@GetFrame

; 589  :     {
; 590  :       fwrite(&n, sizeof(int), 1, outfile);	// write frame number

	push	eax
	push	1
	lea	eax, DWORD PTR _n$[ebp]
	push	4
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
$LN9@GetFrame:

; 591  :     }
; 592  : 
; 593  :     // temporal predictor dst if prev frame was really prev
; 594  :     int *			pVecPrevOrNull = 0;

	xor	ecx, ecx

; 595  :     if (_temporal_flag && srd._vec_prev_frame == nsrc - 1)

	cmp	BYTE PTR [esi+147], cl
	je	SHORT $LN10@GetFrame
	mov	eax, DWORD PTR _nsrc$1$[ebp]
	dec	eax
	cmp	DWORD PTR [edi+188], eax
	jne	SHORT $LN10@GetFrame

; 596  :     {
; 597  :       pVecPrevOrNull = &srd._vec_prev[0];

	mov	ecx, DWORD PTR [edi+176]
$LN10@GetFrame:

; 598  :     }
; 599  : 
; 600  :     _vectorfields_aptr->SearchMVs(

	movzx	eax, BYTE PTR [esi+145]
	push	eax
	movzx	eax, BYTE PTR [esi+144]
	push	ecx
	push	eax
	push	DWORD PTR [esi+140]
	movzx	eax, BYTE PTR [esi+116]
	push	DWORD PTR [esi+136]
	mov	ecx, DWORD PTR [esi+76]
	push	DWORD PTR [esi+120]
	push	DWORD PTR [esi+124]
	push	DWORD PTR _fieldShift$1$[ebp]
	push	DWORD PTR [esi+164]
	push	ebx
	push	DWORD PTR [edi+32]
	push	eax
	push	DWORD PTR [esi+112]
	push	DWORD PTR [esi+104]
	push	DWORD PTR [esi+100]
	push	DWORD PTR [esi+84]
	push	DWORD PTR [esi+96]
	push	DWORD PTR [esi+92]
	push	DWORD PTR [esi+88]
	push	DWORD PTR [esi+568]
	push	DWORD PTR [esi+564]
	call	?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z ; GroupOfPlanes::SearchMVs

; 601  :       pSrcGOF, pRefGOF,
; 602  :       searchType, nSearchParam, nPelSearch, nLambda, lsad, pnew, plevel,
; 603  :       global, srd._analysis_data.nFlags, reinterpret_cast<int*>(pDst),
; 604  :       outfilebuf, fieldShift, pzero, pglobal, badSAD, badrange,
; 605  :       meander, pVecPrevOrNull, tryMany
; 606  :     );
; 607  : 
; 608  :     if (divideExtra)

	cmp	DWORD PTR [esi+132], 0
	je	SHORT $LN11@GetFrame

; 609  :     {
; 610  :       // make extra level with divided sublocks with median (not estimated)
; 611  :       // motion
; 612  :       _vectorfields_aptr->ExtraDivide(

	push	ecx
	mov	ecx, DWORD PTR [esi+76]
	push	ebx
	call	?ExtraDivide@GroupOfPlanes@@QAEXPAHH@Z	; GroupOfPlanes::ExtraDivide
$LN11@GetFrame:

; 613  :         reinterpret_cast <int *> (pDst),
; 614  :         srd._analysis_data.nFlags
; 615  :       );
; 616  :     }
; 617  : 
; 618  : //		PROFILE_CUMULATE ();
; 619  :     if (outfile != NULL)

	mov	eax, DWORD PTR [esi+160]
	test	eax, eax
	je	SHORT $LN12@GetFrame

; 620  :     {
; 621  :       fwrite(

	push	eax
	mov	eax, DWORD PTR [edi+56]
	imul	eax, DWORD PTR [edi+52]
	push	1
	shl	eax, 3
	push	eax
	push	DWORD PTR [esi+164]
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
$LN12@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN105@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN105@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _ref$8[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN105@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN60@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN60@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _src$3[ebp]
	call	eax
	jmp	SHORT $LN60@GetFrame
$LN8@GetFrame:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 777  : 		return (get());

	mov	ecx, DWORD PTR [esi+76]
	mov	DWORD PTR $T9[ebp], ecx
; File c:\github\mvtools\sources\groupofplanes.cpp

; 305  :   array[0] = GetArraySize();

	call	?GetArraySize@GroupOfPlanes@@QAEHXZ	; GroupOfPlanes::GetArraySize

; 306  : 
; 307  :   // write validity : unvalid in that case
; 308  :   array[1] = 0;
; 309  : 
; 310  :   array += 2;
; 311  : 
; 312  :   // write planes
; 313  :   for (int i = nLevelCount - 1; i >= 0; i--)

	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], 0
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, 1
	js	SHORT $LN60@GetFrame
	mov	esi, eax
	lea	edi, DWORD PTR [ebx+8]
	npad	4
$LL61@GetFrame:

; 314  :   {
; 315  :     array += planes[i]->WriteDefaultToArray(array, divideExtra);

	push	DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR [ecx+56]
	push	edi
	mov	ecx, DWORD PTR [ecx+esi*4]
	call	?WriteDefaultToArray@PlaneOfBlocks@@QAEHPAHH@Z ; PlaneOfBlocks::WriteDefaultToArray
	sub	esi, 1
	mov	ecx, DWORD PTR $T9[ebp]
	lea	edi, DWORD PTR [edi+eax*4]
	jns	SHORT $LL61@GetFrame
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR _srd$1$[ebp]
$LN60@GetFrame:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 631  :   if (_temporal_flag)

	cmp	BYTE PTR [esi+147], 0
	je	SHORT $LN134@GetFrame

; 632  :   {
; 633  :     // store previous vectors for use as predictor in next frame
; 634  :     memcpy(

	mov	ecx, DWORD PTR [esi+76]
	call	?GetArraySize@GroupOfPlanes@@QAEHXZ	; GroupOfPlanes::GetArraySize
	push	eax
	push	ebx
	push	DWORD PTR [edi+176]
	call	_memcpy

; 635  :       &srd._vec_prev[0],
; 636  :       reinterpret_cast <int *> (pDst),
; 637  :       _vectorfields_aptr->GetArraySize()
; 638  :     );
; 639  :     srd._vec_prev_frame = nsrc;

	mov	eax, DWORD PTR _nsrc$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+188], eax
$LN134@GetFrame:

; 640  :   }
; 641  : 
; 642  :   return dst;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN22@GetFrame
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN22@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _src$3[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _ref$8[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$17:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$18:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVAnalyse@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVAnalyse::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalyse.cpp
;	COMDAT ?load_src_frame@MVAnalyse@@AAEXAAVMVGroupOfFrames@@AAVPVideoFrame@@ABVMVAnalysisData@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_gof$ = 8						; size = 4
_pSrcY$1$ = 12						; size = 4
_src$ = 12						; size = 4
_ana_data$ = 16						; size = 4
?load_src_frame@MVAnalyse@@AAEXAAVMVGroupOfFrames@@AAVPVideoFrame@@ABVMVAnalysisData@@@Z PROC ; MVAnalyse::load_src_frame, COMDAT
; _this$ = ecx

; 648  : {

	push	ecx

; 649  :   PROFILE_START(MOTION_PROFILE_YUY2CONVERT);
; 650  :   const unsigned char *	pSrcY;
; 651  :   const unsigned char *	pSrcU;
; 652  :   const unsigned char *	pSrcV;
; 653  :   int				nSrcPitchY;
; 654  :   int				nSrcPitchUV;
; 655  :   if ((ana_data.pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR _ana_data$[esp]
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR [eax+60]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR _this$1$[esp+16], ecx
	push	edi
	cmp	eax, 1610612740				; 60000004H
	jne	$LN2@load_src_f
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage

; 976  :   VideoFrame* operator->() const { return p; }

	mov	edi, DWORD PTR _src$[esp+16]

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN9@load_src_f
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN9@load_src_f
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ebp, eax
	mov	DWORD PTR _pSrcY$1$[esp+16], eax
	jmp	SHORT $LN10@load_src_f
$LN9@load_src_f:
	xor	ebp, ebp
	mov	DWORD PTR _pSrcY$1$[esp+16], ebp
$LN10@load_src_f:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN15@load_src_f
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN15@load_src_f
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN16@load_src_f
$LN15@load_src_f:
	xor	eax, eax
$LN16@load_src_f:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 660  :     pSrcU = pSrcY + src->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1
	add	ebx, ebp
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN21@load_src_f
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN21@load_src_f
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN22@load_src_f
$LN21@load_src_f:
	xor	eax, eax
$LN22@load_src_f:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 661  :     pSrcV = pSrcU + src->GetRowSize() / 4;

	cdq
	and	edx, 3
	lea	ebp, DWORD PTR [edx+eax]
	sar	ebp, 2
	add	ebp, ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN27@load_src_f
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN27@load_src_f
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	edi, eax
; File c:\github\mvtools\sources\mvanalyse.cpp

; 665  :   else

	jmp	$LN58@load_src_f
$LN27@load_src_f:
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	xor	edi, edi
; File c:\github\mvtools\sources\mvanalyse.cpp

; 663  :     nSrcPitchUV = nSrcPitchY;

	mov	eax, edi

; 665  :   else

	jmp	$LN58@load_src_f
$LN2@load_src_f:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage

; 976  :   VideoFrame* operator->() const { return p; }

	mov	esi, DWORD PTR _src$[esp+16]

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN33@load_src_f
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN33@load_src_f
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+212]
	push	1
	call	eax
	mov	DWORD PTR _pSrcY$1$[esp+16], eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN34@load_src_f
$LN33@load_src_f:
	mov	DWORD PTR _pSrcY$1$[esp+16], 0
$LN34@load_src_f:
	test	eax, eax
	je	SHORT $LN39@load_src_f
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN39@load_src_f
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+212]
	push	2
	call	eax
	mov	ebx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN40@load_src_f
$LN39@load_src_f:
	xor	ebx, ebx
$LN40@load_src_f:
	test	eax, eax
	je	SHORT $LN45@load_src_f
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN45@load_src_f
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+212]
	push	4
	call	eax
	mov	ebp, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN46@load_src_f
$LN45@load_src_f:
	xor	ebp, ebp
$LN46@load_src_f:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN51@load_src_f
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN51@load_src_f
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN52@load_src_f
$LN51@load_src_f:
	xor	edi, edi
$LN52@load_src_f:
	test	eax, eax
	je	SHORT $LN57@load_src_f
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN57@load_src_f
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	jmp	SHORT $LN58@load_src_f
$LN57@load_src_f:
	xor	eax, eax
$LN58@load_src_f:
; File c:\github\mvtools\sources\mvanalyse.cpp

; 675  :   gof.Update(

	mov	ecx, DWORD PTR _gof$[esp+16]
	push	eax
	push	ebp
	push	eax
	mov	eax, DWORD PTR _this$1$[esp+32]
	push	ebx
	push	edi
	push	DWORD PTR _pSrcY$1$[esp+36]
	push	DWORD PTR [eax+572]
	call	?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z ; MVGroupOfFrames::Update
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 676  :     nModeYUV,
; 677  :     (BYTE*)pSrcY, nSrcPitchY,
; 678  :     (BYTE*)pSrcU, nSrcPitchUV,
; 679  :     (BYTE*)pSrcV, nSrcPitchUV
; 680  :   ); // v2.0
; 681  : }

	pop	ecx
	ret	12					; 0000000cH
?load_src_frame@MVAnalyse@@AAEXAAVMVGroupOfFrames@@AAVPVideoFrame@@ABVMVAnalysisData@@@Z ENDP ; MVAnalyse::load_src_frame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAE@XZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::~AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >, COMDAT
; _this$ = ecx

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	ret	0
??1?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAE@XZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::~AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\lockfreestack.h
;	COMDAT ??1?$LockFreeStack@PAVDCTClass@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$LockFreeStack@PAVDCTClass@@@conc@@UAE@XZ PROC	; conc::LockFreeStack<DCTClass *>::~LockFreeStack<DCTClass *>, COMDAT
; _this$ = ecx

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [ecx+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	ret	0
??1?$LockFreeStack@PAVDCTClass@@@conc@@UAE@XZ ENDP	; conc::LockFreeStack<DCTClass *>::~LockFreeStack<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?get@?$auto_ptr@VDCTFactory@@@std@@QBEPAVDCTFactory@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VDCTFactory@@@std@@QBEPAVDCTFactory@@XZ PROC ; std::auto_ptr<DCTFactory>::get, COMDAT
; _this$ = ecx

; 782  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 783  : 		}

	ret	0
?get@?$auto_ptr@VDCTFactory@@@std@@QBEPAVDCTFactory@@XZ ENDP ; std::auto_ptr<DCTFactory>::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??D?$auto_ptr@VDCTFactory@@@std@@QBEAAVDCTFactory@@XZ
_TEXT	SEGMENT
??D?$auto_ptr@VDCTFactory@@@std@@QBEAAVDCTFactory@@XZ PROC ; std::auto_ptr<DCTFactory>::operator*, COMDAT
; _this$ = ecx

; 762  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 763  : 		if (_Myptr == 0)
; 764  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 765  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 766  : 
; 767  : 		return (*get());

	mov	eax, DWORD PTR [ecx]

; 768  : 		}

	ret	0
??D?$auto_ptr@VDCTFactory@@@std@@QBEAAVDCTFactory@@XZ ENDP ; std::auto_ptr<DCTFactory>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??1?$auto_ptr@VDCTFactory@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VDCTFactory@@@std@@QAE@XZ PROC		; std::auto_ptr<DCTFactory>::~auto_ptr<DCTFactory>, COMDAT
; _this$ = ecx

; 757  : 		delete _Myptr;

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN3@auto_ptr
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN3@auto_ptr:

; 758  : 		}

	ret	0
??1?$auto_ptr@VDCTFactory@@@std@@QAE@XZ ENDP		; std::auto_ptr<DCTFactory>::~auto_ptr<DCTFactory>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??4?$auto_ptr@VDCTFactory@@@std@@QAEAAV01@U?$auto_ptr_ref@VDCTFactory@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$auto_ptr@VDCTFactory@@@std@@QAEAAV01@U?$auto_ptr_ref@VDCTFactory@@@1@@Z PROC ; std::auto_ptr<DCTFactory>::operator=, COMDAT
; _this$ = ecx

; 748  : 		{	// assign compatible _Right._Ref (assume pointer)

	push	esi
	mov	esi, ecx
	push	edi

; 749  : 		_Ty *_Ptr = _Right._Ref;

	mov	edi, DWORD PTR __Right$[esp+4]

; 750  : 		_Right._Ref = 0;	// release old

	mov	DWORD PTR __Right$[esp+4], 0

; 794  : 		if (_Ptr != _Myptr)

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	je	SHORT $LN9@operator

; 795  : 			delete _Myptr;

	test	ecx, ecx
	je	SHORT $LN9@operator
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN9@operator:

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [esi], edi

; 751  : 		reset(_Ptr);	// set new
; 752  : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 753  : 		}

	ret	4
??4?$auto_ptr@VDCTFactory@@@std@@QAEAAV01@U?$auto_ptr_ref@VDCTFactory@@@1@@Z ENDP ; std::auto_ptr<DCTFactory>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z PROC ; std::auto_ptr<DCTFactory>::auto_ptr<DCTFactory>, COMDAT
; _this$ = ecx

; 697  : 		: _Myptr(_Ptr)

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax

; 699  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z ENDP ; std::auto_ptr<DCTFactory>::auto_ptr<DCTFactory>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??C?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ
_TEXT	SEGMENT
??C?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ PROC ; std::auto_ptr<GroupOfPlanes>::operator->, COMDAT
; _this$ = ecx

; 772  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 773  : 		if (_Myptr == 0)
; 774  : 			_DEBUG_ERROR("auto_ptr not dereferencable");
; 775  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 776  : 
; 777  : 		return (get());

	mov	eax, DWORD PTR [ecx]

; 778  : 		}

	ret	0
??C?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ ENDP ; std::auto_ptr<GroupOfPlanes>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??1?$auto_ptr@VGroupOfPlanes@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$auto_ptr@VGroupOfPlanes@@@std@@QAE@XZ PROC		; std::auto_ptr<GroupOfPlanes>::~auto_ptr<GroupOfPlanes>, COMDAT
; _this$ = ecx

; 756  : 		{	// destroy the object

	push	esi

; 757  : 		delete _Myptr;

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN6@auto_ptr
	mov	ecx, esi
	call	??1GroupOfPlanes@@QAE@XZ		; GroupOfPlanes::~GroupOfPlanes
	push	60					; 0000003cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@auto_ptr:
	pop	esi

; 758  : 		}

	ret	0
??1?$auto_ptr@VGroupOfPlanes@@@std@@QAE@XZ ENDP		; std::auto_ptr<GroupOfPlanes>::~auto_ptr<GroupOfPlanes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??4?$auto_ptr@VGroupOfPlanes@@@std@@QAEAAV01@U?$auto_ptr_ref@VGroupOfPlanes@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$auto_ptr@VGroupOfPlanes@@@std@@QAEAAV01@U?$auto_ptr_ref@VGroupOfPlanes@@@1@@Z PROC ; std::auto_ptr<GroupOfPlanes>::operator=, COMDAT
; _this$ = ecx

; 748  : 		{	// assign compatible _Right._Ref (assume pointer)

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 749  : 		_Ty *_Ptr = _Right._Ref;

	mov	edi, DWORD PTR __Right$[esp+8]

; 750  : 		_Right._Ref = 0;	// release old

	mov	DWORD PTR __Right$[esp+8], 0

; 794  : 		if (_Ptr != _Myptr)

	mov	ebx, DWORD PTR [esi]
	cmp	edi, ebx
	je	SHORT $LN13@operator

; 795  : 			delete _Myptr;

	test	ebx, ebx
	je	SHORT $LN13@operator
	mov	ecx, ebx
	call	??1GroupOfPlanes@@QAE@XZ		; GroupOfPlanes::~GroupOfPlanes
	push	60					; 0000003cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@operator:

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [esi], edi

; 751  : 		reset(_Ptr);	// set new
; 752  : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 753  : 		}

	ret	4
??4?$auto_ptr@VGroupOfPlanes@@@std@@QAEAAV01@U?$auto_ptr_ref@VGroupOfPlanes@@@1@@Z ENDP ; std::auto_ptr<GroupOfPlanes>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$auto_ptr@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z PROC ; std::auto_ptr<GroupOfPlanes>::auto_ptr<GroupOfPlanes>, COMDAT
; _this$ = ecx

; 697  : 		: _Myptr(_Ptr)

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax

; 699  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z ENDP ; std::auto_ptr<GroupOfPlanes>::auto_ptr<GroupOfPlanes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEAAVSrcRefData@MVAnalyse@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEAAVSrcRefData@MVAnalyse@@I@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 6
	add	eax, DWORD PTR [ecx]

; 1243 : 		}

	ret	4
??A?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEAAVSrcRefData@MVAnalyse@@I@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
$T2 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	ebx

; 1134 : 		if (_Newsize < size())

	mov	ebx, DWORD PTR __Newsize$[esp]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	push	ebp

; 1133 : 		{	// determine new length, padding as needed

	mov	ebp, ecx
	push	esi
	push	edi

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR [ebp+4]
	mov	edx, edi
	sub	edx, DWORD PTR [ebp]
	imul	edx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1134 : 		if (_Newsize < size())

	cmp	ecx, ebx
	jbe	SHORT $LN202@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	sub	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	edx, edi
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	lea	esi, DWORD PTR [ebx+ebx*2]
	shl	esi, 6
	add	esi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	ecx, esi
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [ebp+4], esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1147 : 			}
; 1148 : 		}

	ret	4
$LN202@resize:

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	mov	eax, ebx
	sub	eax, ecx
	mov	ecx, ebp
	push	eax
	call	?_Reserve@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reserve
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebp+4]
	sub	ecx, DWORD PTR [ebp]
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	ecx, DWORD PTR [ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1139 : 			_TRY_BEGIN
; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),

	mov	edx, ebx
	sub	edx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	call	??$_Uninitialized_default_fill_n1@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1141 : 				this->_Getal());
; 1142 : 			_CATCH_ALL
; 1143 : 			_Tidy();
; 1144 : 			_RERAISE;
; 1145 : 			_CATCH_END
; 1146 : 			this->_Mylast() += _Newsize - size();

	sub	ebx, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 6
	add	DWORD PTR [ebp+4], eax
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
?resize@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
??1?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::~vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	192					; 000000c0H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 5
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	pop	ecx
	ret	0
??1?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::~vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Count$dead$ = 8					; size = 4
??0?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@I@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; _this$ = ecx

; 717  : 		{	// construct from _Count * value_type()

	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1562 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1563 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1564 : 		this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ; std::allocator<MVAnalyse::SrcRefData>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	edx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
	add	eax, 192				; 000000c0H
	mov	DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$_Uninitialized_default_fill_n1@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 729  : 		}

	mov	eax, esi
	add	DWORD PTR [esi+4], 192			; 000000c0H
	pop	esi
	pop	ecx
	ret	4
??0?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@I@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT
; _this$ = ecx

; 980  : 		{	// assign _Right

	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi

; 981  : 		if (this != &_Right)

	mov	esi, DWORD PTR __Right$[esp+8]
	mov	DWORD PTR _this$1$[esp+12], ebx
	cmp	ebx, esi
	je	$LN529@operator

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi]
	cmp	edi, edx

; 982  : 			{	// different, assign it
; 983  : 			if (this->_Getal() != _Right._Getal()
; 984  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 985  : 				{	// change allocator before copying
; 986  : 				_Tidy();
; 987  : 				this->_Copy_alloc(_Right._Getal());
; 988  : 				}
; 989  : 
; 990  : 			this->_Orphan_all();
; 991  : 
; 992  : 			if (_Right.empty())

	jne	SHORT $LN4@operator

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [ebx]
	pop	edi
	mov	DWORD PTR [ebx+4], eax

; 1018 : 					_TRY_BEGIN
; 1019 : 					this->_Mylast() =
; 1020 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1021 : 						this->_Myfirst());
; 1022 : 					_CATCH_ALL
; 1023 : 					_Tidy();
; 1024 : 					_RERAISE;
; 1025 : 					_CATCH_END
; 1026 : 				}
; 1027 : 			}
; 1028 : 		return (*this);

	mov	eax, ebx
	pop	esi
	pop	ebx

; 1029 : 		}

	pop	ecx
	ret	4
$LN4@operator:

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebx]
	mov	eax, edx
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	sub	eax, edi
	sub	ebp, ecx
	sar	eax, 2
	sar	ebp, 2

; 993  : 				clear();	// new sequence empty, erase existing sequence
; 994  : 			else if (_Right.size() <= size())

	cmp	eax, ebp
	ja	SHORT $LN6@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edx, edi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	edi
	push	ecx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	ecx, DWORD PTR [esi]

; 999  : 				this->_Mylast() = this->_Myfirst() + _Right.size();

	mov	eax, DWORD PTR [ebx]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	ecx, 2

; 999  : 				this->_Mylast() = this->_Myfirst() + _Right.size();

	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+4], eax
$LN528@operator:

; 1018 : 					_TRY_BEGIN
; 1019 : 					this->_Mylast() =
; 1020 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1021 : 						this->_Myfirst());
; 1022 : 					_CATCH_ALL
; 1023 : 					_Tidy();
; 1024 : 					_RERAISE;
; 1025 : 					_CATCH_END
; 1026 : 				}
; 1027 : 			}
; 1028 : 		return (*this);

	pop	ebp
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 1029 : 		}

	pop	ecx
	ret	4
$LN6@operator:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ebx+8]
	sub	edx, ecx
	sar	edx, 2

; 1000 : 				}
; 1001 : 			else if (_Right.size() <= capacity())

	cmp	eax, edx
	ja	SHORT $LN8@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	ebx, DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1003 : 				pointer _Ptr = _Right._Myfirst() + size();

	lea	ebp, DWORD PTR [edi+ebp*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, ebp
	sub	eax, edi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	edi
	push	ecx
	call	ebx

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _this$1$[esp+32]
	sub	esi, ebp

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	ebp
	mov	edi, DWORD PTR [edi+4]
	push	edi
	call	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1006 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),

	mov	ecx, DWORD PTR _this$1$[esp+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1006 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),

	mov	DWORD PTR [ecx+4], eax

; 1018 : 					_TRY_BEGIN
; 1019 : 					this->_Mylast() =
; 1020 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1021 : 						this->_Myfirst());
; 1022 : 					_CATCH_ALL
; 1023 : 					_Tidy();
; 1024 : 					_RERAISE;
; 1025 : 					_CATCH_END
; 1026 : 				}
; 1027 : 			}
; 1028 : 		return (*this);

	mov	eax, ecx
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 1029 : 		}

	pop	ecx
	ret	4
$LN8@operator:

; 1007 : 					this->_Mylast());
; 1008 : 				}
; 1009 : 			else
; 1010 : 				{	// not enough room, allocate new array and construct new
; 1011 : 				if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN10@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 4
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+4]

; 1012 : 					{	// discard old array
; 1013 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1014 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1015 : 						this->_Myend() - this->_Myfirst());
; 1016 : 					}
; 1017 : 				if (_Buy(_Right.size()))

	mov	ecx, ebx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, DWORD PTR [esi]
	sar	eax, 2

; 1012 : 					{	// discard old array
; 1013 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1014 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1015 : 						this->_Myend() - this->_Myfirst());
; 1016 : 					}
; 1017 : 				if (_Buy(_Right.size()))

	push	eax
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	test	al, al
	je	SHORT $LN528@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	eax, DWORD PTR [esi]

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [ebx]
	sub	esi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	esi
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [esi+edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 999  : 				this->_Mylast() = this->_Myfirst() + _Right.size();

	mov	DWORD PTR [ebx+4], eax

; 1018 : 					_TRY_BEGIN
; 1019 : 					this->_Mylast() =
; 1020 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1021 : 						this->_Myfirst());
; 1022 : 					_CATCH_ALL
; 1023 : 					_Tidy();
; 1024 : 					_RERAISE;
; 1025 : 					_CATCH_END
; 1026 : 				}
; 1027 : 			}
; 1028 : 		return (*this);

	mov	eax, ebx
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 1029 : 		}

	pop	ecx
	ret	4
$LN529@operator:
	pop	esi

; 1018 : 					_TRY_BEGIN
; 1019 : 					this->_Mylast() =
; 1020 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1021 : 						this->_Myfirst());
; 1022 : 					_CATCH_ALL
; 1023 : 					_Tidy();
; 1024 : 					_RERAISE;
; 1025 : 					_CATCH_END
; 1026 : 				}
; 1027 : 			}
; 1028 : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 1029 : 		}

	pop	ecx
	ret	4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAEPAXI@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	je	SHORT $LN7@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@UAEPAXI@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??_G?$LockFreeStack@PAVDCTClass@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$LockFreeStack@PAVDCTClass@@@conc@@UAEPAXI@Z PROC	; conc::LockFreeStack<DCTClass *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	je	SHORT $LN10@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$LockFreeStack@PAVDCTClass@@@conc@@UAEPAXI@Z ENDP	; conc::LockFreeStack<DCTClass *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GGroupOfPlanes@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GGroupOfPlanes@@QAEPAXI@Z PROC			; GroupOfPlanes::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1GroupOfPlanes@@QAE@XZ		; GroupOfPlanes::~GroupOfPlanes
	push	60					; 0000003cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	pop	esi
	ret	4
??_GGroupOfPlanes@@QAEPAXI@Z ENDP			; GroupOfPlanes::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?reset@?$auto_ptr@VDCTFactory@@@std@@QAEXPAVDCTFactory@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?reset@?$auto_ptr@VDCTFactory@@@std@@QAEXPAVDCTFactory@@@Z PROC ; std::auto_ptr<DCTFactory>::reset, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy designated object and store new pointer

	push	esi
	mov	esi, ecx
	push	edi

; 794  : 		if (_Ptr != _Myptr)

	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	je	SHORT $LN7@reset

; 795  : 			delete _Myptr;

	test	ecx, ecx
	je	SHORT $LN7@reset
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN7@reset:

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi

; 797  : 		}

	ret	4
?reset@?$auto_ptr@VDCTFactory@@@std@@QAEXPAVDCTFactory@@@Z ENDP ; std::auto_ptr<DCTFactory>::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?reset@?$auto_ptr@VGroupOfPlanes@@@std@@QAEXPAVGroupOfPlanes@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?reset@?$auto_ptr@VGroupOfPlanes@@@std@@QAEXPAVGroupOfPlanes@@@Z PROC ; std::auto_ptr<GroupOfPlanes>::reset, COMDAT
; _this$ = ecx

; 793  : 		{	// destroy designated object and store new pointer

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 794  : 		if (_Ptr != _Myptr)

	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, ebx
	je	SHORT $LN11@reset

; 795  : 			delete _Myptr;

	test	ebx, ebx
	je	SHORT $LN11@reset
	mov	ecx, ebx
	call	??1GroupOfPlanes@@QAE@XZ		; GroupOfPlanes::~GroupOfPlanes
	push	60					; 0000003cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN11@reset:

; 796  : 		_Myptr = _Ptr;

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebx

; 797  : 		}

	ret	4
?reset@?$auto_ptr@VGroupOfPlanes@@@std@@QAEXPAVGroupOfPlanes@@@Z ENDP ; std::auto_ptr<GroupOfPlanes>::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ?get@?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ
_TEXT	SEGMENT
?get@?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ PROC ; std::auto_ptr<GroupOfPlanes>::get, COMDAT
; _this$ = ecx

; 782  : 		return (_Myptr);

	mov	eax, DWORD PTR [ecx]

; 783  : 		}

	ret	0
?get@?$auto_ptr@VGroupOfPlanes@@@std@@QBEPAVGroupOfPlanes@@XZ ENDP ; std::auto_ptr<GroupOfPlanes>::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
?_Tidy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXXZ PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	192					; 000000c0H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 5
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXXZ ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebx
	mov	ebx, ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, 715827883				; 2aaaaaabH
	push	ebp
	push	esi
	push	edi
	mov	ebp, DWORD PTR [ebx+8]
	mov	edx, ebp
	mov	esi, DWORD PTR [ebx+4]
	sub	edx, esi

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	edi, DWORD PTR __Count$[esp+12]

; 1048 : 		return (this->_Myend() - this->_Mylast());

	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, edi
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	esi, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	esi

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, 22369621				; 01555555H

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN135@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	ebp, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebp

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edi, ecx
	xor	ecx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 22369621				; 01555555H
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	add	eax, esi
	cmp	edx, esi
	cmovae	ecx, eax
	cmp	ecx, edi
	cmovae	edi, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, ebx
	push	edi
	call	?_Reallocate@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN134@Reserve:
?_Reserve@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$dead$ = 8					; size = 4
?_Buy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAE_NI@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1562 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1563 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1564 : 		this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ; std::allocator<MVAnalyse::SrcRefData>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
	add	eax, 192				; 000000c0H
	mov	DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
	pop	esi

; 1577 : 		}

	ret	4
?_Buy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	eax, DWORD PTR __Count$[esp-4]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1527 : 		{	// erase _Count elements at end

	mov	edi, ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	edx, DWORD PTR [edi+4]
	mov	esi, edx
	sub	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	ecx, esi
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1181 : 		}

	ret	0
?size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@H@std@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Copy_alloc, COMDAT
; _this$dead$ = ecx

; 533  : 		_Pocca(_Getal(), _Al);
; 534  : 		}

	ret	4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@H@std@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, ecx
	push	edi

; 1562 : 		this->_Myfirst() = pointer();
; 1563 : 		this->_Mylast() = pointer();
; 1564 : 		this->_Myend() = pointer();
; 1565 : 
; 1566 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1567 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1577 : 		}

	ret	4
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@Buy

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN110@Buy:
$LN4@Buy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1577 : 		}

	ret	4
$LN109@Buy:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1543 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	192					; 000000c0H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ; std::allocator<MVAnalyse::SrcRefData>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAPAVSrcRefData@MVAnalyse@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEXXZ PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEXXZ ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
$T2 = 8							; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ecx
	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	ebp, DWORD PTR __Count$[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ; std::allocator<MVAnalyse::SrcRefData>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T2[esp+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T2[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 5
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+16]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	192					; 000000c0H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 5
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	eax, DWORD PTR [ebp*2]
	add	eax, ebp
	shl	eax, 6
	add	eax, edi
	mov	DWORD PTR [esi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 6
	add	eax, edi
	mov	DWORD PTR [esi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [esi], edi

; 1623 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
?_Reallocate@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEII@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Grow_to, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	push	esi
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 22369621				; 01555555H
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IBEII@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXPAVSrcRefData@MVAnalyse@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXPAVSrcRefData@MVAnalyse@@0@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Destroy, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp-4]
	mov	edx, DWORD PTR __Last$[esp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1582 : 		}

	ret	8
?_Destroy@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEXPAVSrcRefData@MVAnalyse@@0@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 22369621				; 01555555H

; 1186 : 		}

	ret	0
?max_size@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx+4]
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 22369621				; 01555555H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABQAVSrcRefData@MVAnalyse@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1044 : 		}

	ret	0
?capacity@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z PROC ; std::allocator<MVAnalyse::SrcRefData>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 22369621				; 01555555H
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 6

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEPAVSrcRefData@MVAnalyse@@I@Z ENDP ; std::allocator<MVAnalyse::SrcRefData>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z PROC ; std::allocator<MVAnalyse::SrcRefData>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	192					; 000000c0H
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@I@Z ENDP ; std::allocator<MVAnalyse::SrcRefData>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAIABV?$allocator@VSrcRefData@MVAnalyse@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAIABV?$allocator@VSrcRefData@MVAnalyse@@@2@@Z PROC ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 22369621				; 01555555H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAIABV?$allocator@VSrcRefData@MVAnalyse@@@2@@Z ENDP ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VSrcRefData@MVAnalyse@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VSrcRefData@MVAnalyse@@@std@@QBEIXZ PROC ; std::allocator<MVAnalyse::SrcRefData>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 22369621				; 01555555H

; 750  : 		}

	ret	0
?max_size@?$allocator@VSrcRefData@MVAnalyse@@@std@@QBEIXZ ENDP ; std::allocator<MVAnalyse::SrcRefData>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ PROC		; conc::ObjPool<DCTClass>::ObjPool<DCTClass>, COMDAT
; _this$ = ecx

; 55   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR [edi], OFFSET ??_7?$ObjPool@VDCTClass@@@conc@@6B@

; 51   : :	_factory_ptr (0)

	mov	DWORD PTR [edi+8], 0
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 41   : {

	mov	DWORD PTR [edi+16], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [edi+24], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	movq	QWORD PTR [edi+32], xmm0
	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [edi+36]

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+32], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+36], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+32], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+36], 0
; File c:\github\mvtools\sources\conc\objpool.hpp

; 52   : ,	_stack_free ()

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 41   : {

	mov	DWORD PTR [edi+40], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [edi+48], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	movq	QWORD PTR [edi+56], xmm0
	mov	eax, DWORD PTR [edi+56]
	mov	ecx, DWORD PTR [edi+60]

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+56], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+60], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+56], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+60], 0
; File c:\github\mvtools\sources\conc\objpool.hpp

; 54   : ,	_obj_cell_pool ()

	lea	ecx, DWORD PTR [edi+64]
	call	??0?$CellPool@PAVDCTClass@@@conc@@QAE@XZ ; conc::CellPool<DCTClass *>::CellPool<DCTClass *>

; 56   : 	_obj_cell_pool.expand_to (1024);

	push	1024					; 00000400H
	lea	ecx, DWORD PTR [edi+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?expand_to@?$CellPool@PAVDCTClass@@@conc@@QAEXI@Z ; conc::CellPool<DCTClass *>::expand_to

; 57   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$LockFreeStack@PAVDCTClass@@@conc@@UAE@XZ ; conc::LockFreeStack<DCTClass *>::~LockFreeStack<DCTClass *>
__unwindfunclet$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$LockFreeStack@PAVDCTClass@@@conc@@UAE@XZ ; conc::LockFreeStack<DCTClass *>::~LockFreeStack<DCTClass *>
__unwindfunclet$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$CellPool@PAVDCTClass@@@conc@@UAE@XZ ; conc::CellPool<DCTClass *>::~CellPool<DCTClass *>
__ehhandler$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$ObjPool@VDCTClass@@@conc@@QAE@XZ ENDP		; conc::ObjPool<DCTClass>::ObjPool<DCTClass>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ??1?$ObjPool@VDCTClass@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$ObjPool@VDCTClass@@@conc@@UAE@XZ PROC		; conc::ObjPool<DCTClass>::~ObjPool<DCTClass>, COMDAT
; _this$ = ecx

; 70   : {

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 227  : 	const int		count_free = delete_obj_stack  (_stack_free, false);

	push	0
	lea	ebx, DWORD PTR [esi+16]

; 70   : {

	mov	DWORD PTR [esi], OFFSET ??_7?$ObjPool@VDCTClass@@@conc@@6B@

; 227  : 	const int		count_free = delete_obj_stack  (_stack_free, false);

	push	ebx
	call	?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z ; conc::ObjPool<DCTClass>::delete_obj_stack

; 228  : 	const int		count_all  = delete_obj_stack  (_stack_all,  true);

	push	1
	lea	edi, DWORD PTR [esi+40]
	mov	ecx, esi
	push	edi
	call	?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z ; conc::ObjPool<DCTClass>::delete_obj_stack
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 63   : 	clear_all ();

	lea	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [esi+64], OFFSET ??_7?$CellPool@PAVDCTClass@@@conc@@6B@
	call	?clear_all@?$CellPool@PAVDCTClass@@@conc@@QAEXXZ ; conc::CellPool<DCTClass *>::clear_all
; File c:\github\mvtools\sources\conc\mutex.hpp

; 46   : 	::DeleteCriticalSection (&_crit_sec);

	lea	eax, DWORD PTR [esi+360]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi+72], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+80], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [edi], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [edi+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	pop	edi
	pop	esi
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [ebx], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [ebx+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	pop	ebx
; File c:\github\mvtools\sources\conc\objpool.hpp

; 72   : }

	ret	0
??1?$ObjPool@VDCTClass@@@conc@@UAE@XZ ENDP		; conc::ObjPool<DCTClass>::~ObjPool<DCTClass>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?set_factory@?$ObjPool@VDCTClass@@@conc@@QAEXAAV?$ObjFactoryInterface@VDCTClass@@@2@@Z
_TEXT	SEGMENT
_fact$ = 8						; size = 4
?set_factory@?$ObjPool@VDCTClass@@@conc@@QAEXAAV?$ObjFactoryInterface@VDCTClass@@@2@@Z PROC ; conc::ObjPool<DCTClass>::set_factory, COMDAT
; _this$ = ecx

; 91   : 	assert (&fact != 0);
; 92   : 
; 93   : 	_factory_ptr = &fact;

	mov	eax, DWORD PTR _fact$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 94   : }

	ret	4
?set_factory@?$ObjPool@VDCTClass@@@conc@@QAEXAAV?$ObjFactoryInterface@VDCTClass@@@2@@Z ENDP ; conc::ObjPool<DCTClass>::set_factory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ??1?$CellPool@PAVDCTClass@@@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$CellPool@PAVDCTClass@@@conc@@UAE@XZ PROC		; conc::CellPool<DCTClass *>::~CellPool<DCTClass *>, COMDAT
; _this$ = ecx

; 62   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$CellPool@PAVDCTClass@@@conc@@6B@

; 63   : 	clear_all ();

	call	?clear_all@?$CellPool@PAVDCTClass@@@conc@@QAEXXZ ; conc::CellPool<DCTClass *>::clear_all
; File c:\github\mvtools\sources\conc\mutex.hpp

; 46   : 	::DeleteCriticalSection (&_crit_sec);

	lea	eax, DWORD PTR [esi+296]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi+8], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+16], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	pop	esi
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 64   : }

	ret	0
??1?$CellPool@PAVDCTClass@@@conc@@UAE@XZ ENDP		; conc::CellPool<DCTClass *>::~CellPool<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$?BVGroupOfPlanes@@@?$auto_ptr@VGroupOfPlanes@@@std@@QAE?AU?$auto_ptr_ref@VGroupOfPlanes@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVGroupOfPlanes@@@?$auto_ptr@VGroupOfPlanes@@@std@@QAE?AU?$auto_ptr_ref@VGroupOfPlanes@@@1@XZ PROC ; std::auto_ptr<GroupOfPlanes>::operator<GroupOfPlanes> std::auto_ptr_ref<GroupOfPlanes>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]

; 722  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 723  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);
; 724  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 682  : 		: _Ref(_Right)

	mov	DWORD PTR [eax], edx

; 725  : 		return (_Ans);
; 726  : 		}

	ret	4
??$?BVGroupOfPlanes@@@?$auto_ptr@VGroupOfPlanes@@@std@@QAE?AU?$auto_ptr_ref@VGroupOfPlanes@@@1@XZ ENDP ; std::auto_ptr<GroupOfPlanes>::operator<GroupOfPlanes> std::auto_ptr_ref<GroupOfPlanes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$?BVDCTFactory@@@?$auto_ptr@VDCTFactory@@@std@@QAE?AU?$auto_ptr_ref@VDCTFactory@@@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$?BVDCTFactory@@@?$auto_ptr@VDCTFactory@@@std@@QAE?AU?$auto_ptr_ref@VDCTFactory@@@1@XZ PROC ; std::auto_ptr<DCTFactory>::operator<DCTFactory> std::auto_ptr_ref<DCTFactory>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]

; 722  : 		_Other *_Cvtptr = _Myptr;	// test implicit conversion
; 723  : 		auto_ptr_ref<_Other> _Ans(_Cvtptr);
; 724  : 		_Myptr = 0;	// pass ownership to auto_ptr_ref

	mov	DWORD PTR [ecx], 0

; 682  : 		: _Ref(_Right)

	mov	DWORD PTR [eax], edx

; 725  : 		return (_Ans);
; 726  : 		}

	ret	4
??$?BVDCTFactory@@@?$auto_ptr@VDCTFactory@@@std@@QAE?AU?$auto_ptr_ref@VDCTFactory@@@1@XZ ENDP ; std::auto_ptr<DCTFactory>::operator<DCTFactory> std::auto_ptr_ref<DCTFactory>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ecx

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Uninitialized_default_fill_n@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
??$?9V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z PROC ; std::operator!=<std::allocator<int>,std::allocator<int> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1026 : 	return (!(_Left == _Right));

	xor	al, al

; 1027 : 	}

	ret	0
??$?9V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_unchecked<int *,int *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2332 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi

; 2332 : 	{	// copy [_First, _Last) to [_Dest, ...)

	mov	edi, edx

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2333 : 		// note: _Copy_unchecked is called directly elsewhere in the STL
; 2334 : 	return (_Copy_unchecked1(_First, _Last,
; 2335 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2336 : 	}

	ret	0
??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_unchecked<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[esp-4]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Ptr$[esp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1654 : 		}

	ret	12					; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >,std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<int> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAVSrcRefData@MVAnalyse@@@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEPAVSrcRefData@MVAnalyse@@PAV23@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVSrcRefData@MVAnalyse@@@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEPAVSrcRefData@MVAnalyse@@PAV23@00@Z PROC ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Umove<MVAnalyse::SrcRefData *>, COMDAT
; _this$dead$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Ptr$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
??$_Umove@PAVSrcRefData@MVAnalyse@@@?$vector@VSrcRefData@MVAnalyse@@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@IAEPAVSrcRefData@MVAnalyse@@PAV23@00@Z ENDP ; std::vector<MVAnalyse::SrcRefData,std::allocator<MVAnalyse::SrcRefData> >::_Umove<MVAnalyse::SrcRefData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	ecx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Destroy_range@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$ObjPool@VDCTClass@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ObjPool@VDCTClass@@@conc@@UAEPAXI@Z PROC		; conc::ObjPool<DCTClass>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$ObjPool@VDCTClass@@@conc@@UAE@XZ	; conc::ObjPool<DCTClass>::~ObjPool<DCTClass>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	384					; 00000180H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$ObjPool@VDCTClass@@@conc@@UAEPAXI@Z ENDP		; conc::ObjPool<DCTClass>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.h
; File c:\github\mvtools\sources\conc\atomicptrintpair.h
;	COMDAT ??_G?$CellPool@PAVDCTClass@@@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CellPool@PAVDCTClass@@@conc@@UAEPAXI@Z PROC	; conc::CellPool<DCTClass *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 62   : {

	mov	DWORD PTR [esi], OFFSET ??_7?$CellPool@PAVDCTClass@@@conc@@6B@

; 63   : 	clear_all ();

	call	?clear_all@?$CellPool@PAVDCTClass@@@conc@@QAEXXZ ; conc::CellPool<DCTClass *>::clear_all
; File c:\github\mvtools\sources\conc\mutex.hpp

; 46   : 	::DeleteCriticalSection (&_crit_sec);

	lea	eax, DWORD PTR [esi+296]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
	test	BYTE PTR ___flags$[esp], 1
; File c:\github\mvtools\sources\conc\lockfreestack.h

; 67   : 	virtual			~LockFreeStack () {}

	mov	DWORD PTR [esi+8], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.h

; 55   : 	virtual			~AtomicPtrIntPair () {}

	mov	DWORD PTR [esi+16], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	je	SHORT $LN16@scalar
	push	320					; 00000140H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN16@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$CellPool@PAVDCTClass@@@conc@@UAEPAXI@Z ENDP	; conc::CellPool<DCTClass *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr_ref@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z PROC ; std::auto_ptr_ref<DCTFactory>::auto_ptr_ref<DCTFactory>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [ecx], eax

; 684  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr_ref@VDCTFactory@@@std@@QAE@PAVDCTFactory@@@Z ENDP ; std::auto_ptr_ref<DCTFactory>::auto_ptr_ref<DCTFactory>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??0?$auto_ptr_ref@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$auto_ptr_ref@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z PROC ; std::auto_ptr_ref<GroupOfPlanes>::auto_ptr_ref<GroupOfPlanes>, COMDAT
; _this$ = ecx

; 682  : 		: _Ref(_Right)

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	DWORD PTR [ecx], eax

; 684  : 		}

	mov	eax, ecx
	ret	4
??0?$auto_ptr_ref@VGroupOfPlanes@@@std@@QAE@PAVGroupOfPlanes@@@Z ENDP ; std::auto_ptr_ref<GroupOfPlanes>::auto_ptr_ref<GroupOfPlanes>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >::_Vector_val<std::_Simple_types<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VSrcRefData@MVAnalyse@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VSrcRefData@MVAnalyse@@@std@@QAE@XZ PROC	; std::allocator<MVAnalyse::SrcRefData>::allocator<MVAnalyse::SrcRefData>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@VSrcRefData@MVAnalyse@@@std@@QAE@XZ ENDP	; std::allocator<MVAnalyse::SrcRefData>::allocator<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?cleanup@?$ObjPool@VDCTClass@@@conc@@QAEXXZ
_TEXT	SEGMENT
?cleanup@?$ObjPool@VDCTClass@@@conc@@QAEXXZ PROC	; conc::ObjPool<DCTClass>::cleanup, COMDAT
; _this$ = ecx

; 226  : {

	push	esi
	mov	esi, ecx

; 227  : 	const int		count_free = delete_obj_stack  (_stack_free, false);

	push	0
	lea	eax, DWORD PTR [esi+16]
	push	eax
	call	?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z ; conc::ObjPool<DCTClass>::delete_obj_stack

; 228  : 	const int		count_all  = delete_obj_stack  (_stack_all,  true);

	push	1
	lea	eax, DWORD PTR [esi+40]
	mov	ecx, esi
	push	eax
	call	?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z ; conc::ObjPool<DCTClass>::delete_obj_stack
	pop	esi

; 229  : 
; 230  : 	// False would mean that some cells are still out, in use.
; 231  : 	assert (count_free == count_all);
; 232  : }

	ret	0
?cleanup@?$ObjPool@VDCTClass@@@conc@@QAEXXZ ENDP	; conc::ObjPool<DCTClass>::cleanup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ??0?$CellPool@PAVDCTClass@@@conc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CellPool@PAVDCTClass@@@conc@@QAE@XZ PROC		; conc::CellPool<DCTClass *>::CellPool<DCTClass *>, COMDAT
; _this$ = ecx

; 49   : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	xorps	xmm0, xmm0
	push	256					; 00000100H
	push	0
	mov	DWORD PTR _this$[esp+20], edi
	mov	DWORD PTR [edi], OFFSET ??_7?$CellPool@PAVDCTClass@@@conc@@6B@
	lea	esi, DWORD PTR [edi+32]
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 41   : {

	mov	DWORD PTR [edi+8], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [edi+16], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	movq	QWORD PTR [edi+24], xmm0
	mov	eax, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+28]

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+24], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+28], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [edi+24], 0
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 45   : ,	_zone_list ()

	push	esi
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [edi+28], 0
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 45   : ,	_zone_list ()

	call	_memset
	add	esp, 12					; 0000000cH
	mov	ecx, 64					; 00000040H
	mov	eax, esi
$LL19@CellPool:
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 43   : :	_ptr ()

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+4]
	sub	ecx, 1
	jne	SHORT $LL19@CellPool
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 63   : :	_val (val)

	mov	DWORD PTR [edi+288], ecx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 48   : ,	_alloc_mutex ()

	lea	eax, DWORD PTR [edi+296]
	xorps	xmm0, xmm0
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 63   : :	_val (val)

	mov	DWORD PTR [edi+292], ecx
; File c:\github\mvtools\sources\conc\mutex.hpp

; 37   : :	_crit_sec ()

	movups	XMMWORD PTR [eax], xmm0

; 38   : {
; 39   : 	::InitializeCriticalSection (&_crit_sec);

	push	eax
	movq	QWORD PTR [eax+16], xmm0
	call	DWORD PTR __imp__InitializeCriticalSection@4
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 63   : :	_val (val)

	mov	ecx, 64					; 00000040H
$LL4@CellPool:
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 52   : 	for (int zone_index = 0; zone_index < MAX_NBR_ZONES; ++zone_index)

	add	esi, 4
	sub	ecx, 1
	jne	SHORT $LL4@CellPool

; 53   : 	{
; 54   : 		_zone_list [zone_index] = 0;
; 55   : 	}
; 56   : }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ecx
	ret	0
??0?$CellPool@PAVDCTClass@@@conc@@QAE@XZ ENDP		; conc::CellPool<DCTClass *>::CellPool<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?clear_all@?$CellPool@PAVDCTClass@@@conc@@QAEXXZ
_TEXT	SEGMENT
?clear_all@?$CellPool@PAVDCTClass@@@conc@@QAEXXZ PROC	; conc::CellPool<DCTClass *>::clear_all, COMDAT
; _this$ = ecx

; 72   : {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
$LL2@clear_all:

; 73   : #if !defined (NDEBUG)
; 74   : 	size_t nbr_total_cells = compute_total_size_for_zones (_nbr_zones);
; 75   : 	
; 76   : 	assert (_nbr_avail_cells == nbr_total_cells);
; 77   : #endif
; 78   : 	
; 79   : 	while (_cell_stack.pop () != 0)

	lea	ecx, DWORD PTR [ebp+8]
	call	?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ; conc::LockFreeStack<DCTClass *>::pop
	test	eax, eax
	jne	SHORT $LL2@clear_all

; 84   : 	for (int zone_index = 0; zone_index < _nbr_zones; ++zone_index)

	xor	edi, edi
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 93   : 	return (T (_val));

	lea	ebx, DWORD PTR [ebp+292]
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 84   : 	for (int zone_index = 0; zone_index < _nbr_zones; ++zone_index)

	cmp	DWORD PTR [ebx], edi
	jle	SHORT $LN5@clear_all
	lea	esi, DWORD PTR [ebp+32]
$LL6@clear_all:

; 85   : 	{
; 86   : 		AtomicPtr <CellType> &	zone_ptr_ref = _zone_list [zone_index];
; 87   : 		CellType *		zone_ptr = zone_ptr_ref;

	mov	eax, DWORD PTR [esi]

; 88   : 		if (zone_ptr != 0)

	test	eax, eax
	je	SHORT $LN4@clear_all

; 89   : 		{
; 90   : 			delete [] zone_ptr;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
$LN4@clear_all:
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 84   : 	for (int zone_index = 0; zone_index < _nbr_zones; ++zone_index)

	inc	edi
	add	esi, 4
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LL6@clear_all
$LN5@clear_all:
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [ebx], eax
	xor	ecx, ecx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 95   : 	_nbr_avail_cells = 0;

	lea	eax, DWORD PTR [ebp+288]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xchg	DWORD PTR [eax], ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 96   : }

	ret	0
?clear_all@?$CellPool@PAVDCTClass@@@conc@@QAEXXZ ENDP	; conc::CellPool<DCTClass *>::clear_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?expand_to@?$CellPool@PAVDCTClass@@@conc@@QAEXI@Z
_TEXT	SEGMENT
_total_size$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
_nbr_cells$ = 8						; size = 4
?expand_to@?$CellPool@PAVDCTClass@@@conc@@QAEXI@Z PROC	; conc::CellPool<DCTClass *>::expand_to, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 107  : 	size_t			total_size = 0;
; 108  : 	int				zone_index = 0;

	xor	ebx, ebx
	mov	DWORD PTR _this$1$[esp+20], ecx
	mov	esi, 64					; 00000040H
	mov	DWORD PTR _total_size$1$[esp+20], 0
	push	edi

; 109  : 	while (total_size < nbr_cells && zone_index < MAX_NBR_ZONES)

	cmp	DWORD PTR _nbr_cells$[ebp], ebx
	jbe	SHORT $LN3@expand_to

; 104  : 	assert (nbr_cells > 0);
; 105  : 
; 106  : 	size_t			cur_size = BASE_SIZE;

	lea	edi, DWORD PTR [ecx+32]
$LL2@expand_to:

; 109  : 	while (total_size < nbr_cells && zone_index < MAX_NBR_ZONES)

	cmp	ebx, 64					; 00000040H
	jge	SHORT $LN3@expand_to

; 110  : 	{
; 111  : 		AtomicPtr <CellType> &	zone_ptr_ref = _zone_list [zone_index];
; 112  : 		CellType *		zone_ptr = zone_ptr_ref;

	mov	eax, DWORD PTR [edi]

; 113  : 		if (zone_ptr == 0)

	test	eax, eax
	jne	SHORT $LN4@expand_to

; 114  : 		{
; 115  : 			allocate_zone (zone_index, cur_size, zone_ptr_ref);

	push	edi
	push	esi
	push	ecx
	call	?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z ; conc::CellPool<DCTClass *>::allocate_zone
	mov	ecx, DWORD PTR _this$1$[esp+24]
$LN4@expand_to:

; 116  : 		}
; 117  : 
; 118  : 		total_size += cur_size;

	mov	eax, DWORD PTR _total_size$1$[esp+24]

; 119  : 		cur_size = compute_grown_size (cur_size);
; 120  : 		++ zone_index;

	inc	ebx
	add	eax, esi
	add	edi, 4

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	esi, DWORD PTR [esi+esi*2]

; 116  : 		}
; 117  : 
; 118  : 		total_size += cur_size;

	mov	DWORD PTR _total_size$1$[esp+24], eax

; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	shr	esi, 1

; 109  : 	while (total_size < nbr_cells && zone_index < MAX_NBR_ZONES)

	cmp	eax, DWORD PTR _nbr_cells$[ebp]
	jb	SHORT $LL2@expand_to
$LN3@expand_to:

; 121  : 	}
; 122  : 
; 123  : 	AioMax <int>	ftor (zone_index);
; 124  : 	AtomicIntOp::exec (_nbr_zones, ftor);

	lea	esi, DWORD PTR [ecx+292]
	npad	4
$LL22@expand_to:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	edx, ebx
	mov	ecx, edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ecx, ebx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL22@expand_to
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 125  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?expand_to@?$CellPool@PAVDCTClass@@@conc@@QAEXI@Z ENDP	; conc::CellPool<DCTClass *>::expand_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
;	COMDAT ??0?$LockFreeStack@PAVDCTClass@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$LockFreeStack@PAVDCTClass@@@conc@@QAE@XZ PROC	; conc::LockFreeStack<DCTClass *>::LockFreeStack<DCTClass *>, COMDAT
; _this$ = ecx

; 41   : {

	mov	DWORD PTR [ecx], OFFSET ??_7?$LockFreeStack@PAVDCTClass@@@conc@@6B@
	xorps	xmm0, xmm0
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 41   : {

	mov	DWORD PTR [ecx+8], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	movq	QWORD PTR [ecx+16], xmm0
	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ecx+20]
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 43   : }

	mov	eax, ecx
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+16], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+20], 0

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+16], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+20], 0
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 43   : }

	ret	0
??0?$LockFreeStack@PAVDCTClass@@@conc@@QAE@XZ ENDP	; conc::LockFreeStack<DCTClass *>::LockFreeStack<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 453  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	push	edi
	mov	edi, edx

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	test	edi, edi
	je	SHORT $LN3@Uninitiali
	push	esi
	lea	esi, DWORD PTR [ecx+184]
	npad	2
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	lea	eax, DWORD PTR [esi-184]
	test	eax, eax
	je	SHORT $LN2@Uninitiali
	push	192					; 000000c0H
	lea	eax, DWORD PTR [esi-184]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi-8], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi-4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi], 0
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	esi, 192				; 000000c0H
	sub	edi, 1
	jne	SHORT $LL4@Uninitiali
	pop	esi
$LN3@Uninitiali:
	pop	edi

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAVSrcRefData@MVAnalyse@@IV?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAXPAVSrcRefData@MVAnalyse@@IAAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<MVAnalyse::SrcRefData *,unsigned int,std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
??$?8V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z PROC ; std::operator==<std::allocator<int>,std::allocator<int> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1017 : 	return (static_cast<const _Ty&>(_Left)

	mov	al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

	ret	0
??$?8V?$allocator@H@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@H@std@@@0@0@Z ENDP ; std::operator==<std::allocator<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z PROC ; std::_Ptr_copy_cat<int,int>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 793  : 	return {};

	mov	eax, ecx

; 794  : 	}

	ret	0
??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ENDP ; std::_Ptr_copy_cat<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<int *,int *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2324 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable

	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi

; 2324 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable

	mov	edi, edx

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2325 : 	return (_Copy_memmove(_First, _Last, _Dest));
; 2326 : 	}

	ret	0
??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z PROC ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 265  : 	}

	ret	0
??$_Uninitialized_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ENDP ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<int> > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1039 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@H@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z PROC ; std::_Uninitialized_move<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	push	edi
	mov	edi, edx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	ecx, edi
	je	SHORT $LN145@Destroy_ra
	push	esi
	lea	esi, DWORD PTR [ecx+176]
	npad	2
$LL4@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN25@Destroy_ra

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN141@Destroy_ra

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	ecx, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN93@Destroy_ra

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN141@Destroy_ra

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN141@Destroy_ra

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN141@Destroy_ra

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN141@Destroy_ra

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN93@Destroy_ra:

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN25@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	add	esi, 192				; 000000c0H
	lea	eax, DWORD PTR [esi-176]
	cmp	eax, edi
	jne	SHORT $LL4@Destroy_ra
	pop	esi
$LN145@Destroy_ra:
	pop	edi

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	ret	0
$LN141@Destroy_ra:

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN149@Destroy_ra:
$LN148@Destroy_ra:
	int	3
??$_Destroy_range1@V?$allocator@VSrcRefData@MVAnalyse@@@std@@PAVSrcRefData@MVAnalyse@@@std@@YAXPAVSrcRefData@MVAnalyse@@0AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<MVAnalyse::SrcRefData>,MVAnalyse::SrcRefData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAE@XZ PROC ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>, COMDAT
; _this$ = ecx
	mov	edx, 64					; 00000040H
	mov	eax, ecx
	npad	9
$LL4@Array:

; 43   : :	_ptr ()

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+4]
	sub	edx, 1
	jne	SHORT $LL4@Array
	mov	eax, ecx
	ret	0
??0?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAE@XZ ENDP ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___n$ = 8						; size = 4
___f$ = 12						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
; ___t$ = ecx
; ___s$ = edx
	push	ebp
	push	esi
	mov	esi, DWORD PTR ___n$[esp+4]
	mov	ebp, edx
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+12]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, ebp
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	ebx
$LN6@vector:
	pop	edi
	pop	esi
	pop	ebp
	ret	8
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiomax.h
;	COMDAT ??1?$AioMax@H@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AioMax@H@conc@@UAE@XZ PROC				; conc::AioMax<int>::~AioMax<int>, COMDAT
; _this$ = ecx

; 47   : 	virtual			~AioMax () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AioMax@H@conc@@6B@
	ret	0
??1?$AioMax@H@conc@@UAE@XZ ENDP				; conc::AioMax<int>::~AioMax<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiomax.h
;	COMDAT ??_G?$AioMax@H@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AioMax@H@conc@@UAEPAXI@Z PROC			; conc::AioMax<int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 47   : 	virtual			~AioMax () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AioMax@H@conc@@6B@
	je	SHORT $LN7@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AioMax@H@conc@@UAEPAXI@Z ENDP			; conc::AioMax<int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??0?$AtomicInt@I@conc@@QAE@I@Z
_TEXT	SEGMENT
_val$dead$ = 8						; size = 4
??0?$AtomicInt@I@conc@@QAE@I@Z PROC			; conc::AtomicInt<unsigned int>::AtomicInt<unsigned int>, COMDAT
; _this$ = ecx

; 63   : :	_val (val)

	mov	DWORD PTR [ecx], 0

; 65   : 	assert (is_ptr_aligned_nz ((const void *) (&_val), sizeof (_val)));
; 66   : }

	mov	eax, ecx
	ret	4
??0?$AtomicInt@I@conc@@QAE@I@Z ENDP			; conc::AtomicInt<unsigned int>::AtomicInt<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??4?$AtomicInt@I@conc@@QAEAAV01@I@Z
_TEXT	SEGMENT
_other$dead$ = 8					; size = 4
??4?$AtomicInt@I@conc@@QAEAAV01@I@Z PROC		; conc::AtomicInt<unsigned int>::operator=, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 85   : 	return (*this);

	mov	eax, ecx

; 86   : }

	ret	4
??4?$AtomicInt@I@conc@@QAEAAV01@I@Z ENDP		; conc::AtomicInt<unsigned int>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??0?$AtomicInt@H@conc@@QAE@H@Z
_TEXT	SEGMENT
_val$dead$ = 8						; size = 4
??0?$AtomicInt@H@conc@@QAE@H@Z PROC			; conc::AtomicInt<int>::AtomicInt<int>, COMDAT
; _this$ = ecx

; 63   : :	_val (val)

	mov	DWORD PTR [ecx], 0

; 65   : 	assert (is_ptr_aligned_nz ((const void *) (&_val), sizeof (_val)));
; 66   : }

	mov	eax, ecx
	ret	4
??0?$AtomicInt@H@conc@@QAE@H@Z ENDP			; conc::AtomicInt<int>::AtomicInt<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??4?$AtomicInt@H@conc@@QAEAAV01@H@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??4?$AtomicInt@H@conc@@QAEAAV01@H@Z PROC		; conc::AtomicInt<int>::operator=, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	mov	eax, DWORD PTR _other$[esp-4]
	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 85   : 	return (*this);

	mov	eax, ecx

; 86   : }

	ret	4
??4?$AtomicInt@H@conc@@QAEAAV01@H@Z ENDP		; conc::AtomicInt<int>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\objpool.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\objpool.hpp
;	COMDAT ?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z
_TEXT	SEGMENT
_ptr_stack$ = 8						; size = 4
_destroy_flag$ = 12					; size = 1
?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z PROC ; conc::ObjPool<DCTClass>::delete_obj_stack, COMDAT
; _this$ = ecx

; 246  : {

	push	ebx
	push	ebp

; 247  : 	assert (&ptr_stack != 0);
; 248  : 
; 249  : 	PtrStack::CellType *		cell_ptr = 0;
; 250  : 	int				count = 0;

	mov	ebp, DWORD PTR _ptr_stack$[esp+4]
	mov	ebx, ecx
	push	esi
	push	edi
	xor	edi, edi
	npad	4
$LL4@delete_obj:

; 251  : 	do
; 252  : 	{
; 253  : 		cell_ptr = ptr_stack.pop ();

	mov	ecx, ebp
	call	?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ; conc::LockFreeStack<DCTClass *>::pop
	mov	esi, eax

; 254  : 		if (cell_ptr != 0)

	test	esi, esi
	je	SHORT $LN43@delete_obj

; 255  : 		{
; 256  : 			if (destroy_flag)

	cmp	BYTE PTR _destroy_flag$[esp+12], 0
	je	SHORT $LN6@delete_obj

; 257  : 			{
; 258  : 				ObjType * &		obj_ptr = cell_ptr->_val;
; 259  : 				delete obj_ptr;

	push	24					; 00000018H
	push	DWORD PTR [esi+4]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 260  : 				obj_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN6@delete_obj:
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 165  : 	_cell_stack.push (cell);

	push	esi
	lea	ecx, DWORD PTR [ebx+72]
	call	?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::LockFreeStack<DCTClass *>::push

; 166  : 
; 167  : 	++ _nbr_avail_cells;

	lea	esi, DWORD PTR [ebx+352]
$LL21@delete_obj:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL21@delete_obj
; File c:\github\mvtools\sources\conc\objpool.hpp

; 264  : 			++ count;

	inc	edi

; 265  : 		}
; 266  : 	}
; 267  : 	while (cell_ptr != 0);

	jmp	SHORT $LL4@delete_obj
$LN43@delete_obj:

; 268  : 
; 269  : 	return (count);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 270  : }

	ret	8
?delete_obj_stack@?$ObjPool@VDCTClass@@@conc@@AAEHAAV?$LockFreeStack@PAVDCTClass@@@2@_N@Z ENDP ; conc::ObjPool<DCTClass>::delete_obj_stack
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\critsec.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\mutex.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z
_TEXT	SEGMENT
_lock$ = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_zone_index$dead$ = 8					; size = 4
tv278 = 12						; size = 4
$T2 = 12						; size = 4
_cur_size$ = 12						; size = 4
_zone_ptr_ref$ = 16					; size = 4
?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z PROC ; conc::CellPool<DCTClass *>::allocate_zone, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	eax, ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], eax

; 183  : 	assert (zone_index >= 0);
; 184  : 	assert (zone_index < MAX_NBR_ZONES);
; 185  : 
; 186  : 	CritSec			lock (_alloc_mutex);

	lea	esi, DWORD PTR [eax+296]
; File c:\github\mvtools\sources\conc\mutex.hpp

; 53   : 	::EnterCriticalSection (&_crit_sec);

	push	esi
; File c:\github\mvtools\sources\conc\critsec.hpp

; 41   : :	_mutex (mutex)

	mov	DWORD PTR _lock$[ebp], esi
; File c:\github\mvtools\sources\conc\mutex.hpp

; 53   : 	::EnterCriticalSection (&_crit_sec);

	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 188  : 	CellType *		zone_ptr = new CellType [cur_size];

	mov	ebx, DWORD PTR _cur_size$[ebp]
	xor	ecx, ecx
	mov	eax, ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
	test	edi, edi
	je	SHORT $LN8@allocate_z
	mov	eax, ebx
	mov	ecx, edi
	test	ebx, ebx
	je	SHORT $LN9@allocate_z
	npad	7
$LL17@allocate_z:
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 43   : :	_ptr ()

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+8]
	sub	eax, 1
	jne	SHORT $LL17@allocate_z
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 188  : 	CellType *		zone_ptr = new CellType [cur_size];

	jmp	SHORT $LN9@allocate_z
$LN8@allocate_z:
	xor	edi, edi
$LN9@allocate_z:
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, DWORD PTR _zone_ptr_ref$[ebp]
	mov	edx, edi
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 190  : 	if (zone_ptr_ref.cas (zone_ptr, 0) != (CellType *)0)

	test	eax, eax
	je	SHORT $LN5@allocate_z

; 191  : 	{
; 192  : 		// CAS has failed, meaning that another thread is allocating this zone.
; 193  : 		delete [] zone_ptr;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 194  : 
; 195  : 		// Note: because of the mutex, this part shouldn't be accessed.
; 196  : 	}
; 197  : 
; 198  : 	else

	jmp	SHORT $LN3@allocate_z
$LN5@allocate_z:

; 201  : 		for (size_t pos = 0; pos < cur_size; ++pos)

	test	ebx, ebx
	je	SHORT $LN3@allocate_z
	mov	esi, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR [esi+8]
	add	esi, 288				; 00000120H
	mov	DWORD PTR tv278[ebp], eax
	npad	1
$LL4@allocate_z:

; 202  : 		{
; 203  : 			CellType &		cell = zone_ptr [pos];
; 204  : 			_cell_stack.push (cell);

	push	edi
	mov	ecx, eax
	call	?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::LockFreeStack<DCTClass *>::push
$LL41@allocate_z:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL41@allocate_z
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 201  : 		for (size_t pos = 0; pos < cur_size; ++pos)

	mov	eax, DWORD PTR tv278[ebp]
	add	edi, 8
	sub	ebx, 1
	jne	SHORT $LL4@allocate_z
	mov	esi, DWORD PTR _lock$[ebp]
$LN3@allocate_z:
; File c:\github\mvtools\sources\conc\mutex.hpp

; 60   : 	::LeaveCriticalSection (&_crit_sec);

	push	esi
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 209  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z$0:
	lea	ecx, DWORD PTR _lock$[ebp]
	jmp	??1CritSec@conc@@QAE@XZ			; conc::CritSec::~CritSec
__ehhandler$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?allocate_zone@?$CellPool@PAVDCTClass@@@conc@@AAEXHIAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@2@@Z ENDP ; conc::CellPool<DCTClass *>::allocate_zone
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?compute_grown_size@?$CellPool@PAVDCTClass@@@conc@@CAII@Z
_TEXT	SEGMENT
?compute_grown_size@?$CellPool@PAVDCTClass@@@conc@@CAII@Z PROC ; conc::CellPool<DCTClass *>::compute_grown_size, COMDAT
; _prev_size$ = ecx

; 216  : 	assert (prev_size >= BASE_SIZE);
; 217  : 
; 218  : 	return (prev_size * GROW_RATE_NUM / GROW_RATE_DEN);

	lea	eax, DWORD PTR [ecx+ecx*2]
	shr	eax, 1

; 219  : }

	ret	0
?compute_grown_size@?$CellPool@PAVDCTClass@@@conc@@CAII@Z ENDP ; conc::CellPool<DCTClass *>::compute_grown_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
;	COMDAT ?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ
_TEXT	SEGMENT
tv164 = -24						; size = 4
_this$1$ = -20						; size = 4
_comp$1 = -16						; size = 8
_newx$2 = -8						; size = 8
?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ PROC ; conc::LockFreeStack<DCTClass *>::pop, COMDAT
; _this$ = ecx

; 68   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	lea	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _this$1$[esp+36], ecx
	push	edi
	mov	DWORD PTR tv164[esp+40], eax
$LL4@pop:

; 69   : 	CellType *		cell_ptr;
; 70   : 	bool				cont_flag = true;
; 71   : 	do
; 72   : 	{
; 73   : 		cell_ptr = _head_ptr.get_ptr ();

	mov	esi, DWORD PTR [eax]

; 74   : 
; 75   : 		if (cell_ptr == 0)

	test	esi, esi
	je	SHORT $LN39@pop

; 76   : 		{
; 77   : 			cont_flag = false;	// Empty stack.
; 78   : 		}
; 79   : 
; 80   : 		else
; 81   : 		{
; 82   : 			const ptrdiff_t	count = _head_ptr.get_val ();

	mov	ecx, DWORD PTR [ecx+20]

; 83   : 			if (cell_ptr != 0)
; 84   : 			{
; 85   : 				CellType *		next_ptr = cell_ptr->_next_ptr;

	mov	eax, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 112  : 	newx._content._ptr = new_ptr;

	mov	DWORD PTR _newx$2[esp+40], eax
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 86   : 				if (_head_ptr.cas2 (next_ptr, count + 1, cell_ptr, count))

	lea	eax, DWORD PTR [ecx+1]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 113  : 	newx._content._val = new_val;

	mov	DWORD PTR _newx$2[esp+44], eax

; 114  : 
; 115  : 	Combi				comp;
; 116  : 	comp._content._ptr = comp_ptr;

	mov	DWORD PTR _comp$1[esp+40], esi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$1[esp+40]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 117  : 	comp._content._val = comp_val;

	mov	DWORD PTR _comp$1[esp+44], ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	edx, DWORD PTR _comp$1[esp+44]
	mov	ebx, DWORD PTR _newx$2[esp+40]
	mov	ecx, DWORD PTR _newx$2[esp+44]
	mov	edi, DWORD PTR tv164[esp+40]
	lock	 cmpxchg8b QWORD PTR [edi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 122  : 	return (old._storage == comp._storage);

	cmp	eax, DWORD PTR _comp$1[esp+40]
	mov	eax, edi
	mov	ecx, DWORD PTR _this$1$[esp+40]
	jne	SHORT $LL4@pop
	cmp	edx, DWORD PTR _comp$1[esp+44]
	jne	SHORT $LL4@pop
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
$LN39@pop:
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 97   : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$LockFreeStack@PAVDCTClass@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ENDP ; conc::LockFreeStack<DCTClass *>::pop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??0?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ PROC ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::AtomicPtr<conc::LockFreeCell<DCTClass *> >, COMDAT
; _this$ = ecx

; 43   : :	_ptr ()

	mov	DWORD PTR [ecx], 0

; 45   : 	assert (is_ptr_aligned_nz ((const void *) (&_ptr), sizeof (_ptr)));
; 46   : }

	mov	eax, ecx
	ret	0
??0?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ ENDP ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::AtomicPtr<conc::LockFreeCell<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??4?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVDCTClass@@@1@@Z
_TEXT	SEGMENT
_other_ptr$ = 8						; size = 4
??4?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVDCTClass@@@1@@Z PROC ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::operator=, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	mov	eax, DWORD PTR _other_ptr$[esp-4]
	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 64   : 	return (*this);

	mov	eax, ecx

; 65   : }

	ret	4
??4?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEAAV01@PAV?$LockFreeCell@PAVDCTClass@@@1@@Z ENDP ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??B?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@1@XZ
_TEXT	SEGMENT
??B?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@1@XZ PROC ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::operator conc::LockFreeCell<DCTClass *> *, COMDAT
; _this$ = ecx

; 72   : 	return (read_ptr ());

	mov	eax, DWORD PTR [ecx]

; 73   : }

	ret	0
??B?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@1@XZ ENDP ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::operator conc::LockFreeCell<DCTClass *> *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@1@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@1@J@Z PROC ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 56   : }

	ret	4
??A?$Array@V?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@$0EA@@conc@@QAEAAV?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@1@J@Z ENDP ; conc::Array<conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >,64>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >, COMDAT
; _this$ = ecx

; 41   : {

	mov	DWORD PTR [ecx], OFFSET ??_7?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@6B@
	xorps	xmm0, xmm0
	movq	QWORD PTR [ecx+8], xmm0
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]

; 42   : 	conc_CHECK_CT (DataSize, sizeof (RealContent) == sizeof (DataType));
; 43   : 
; 44   : 	set (0, 0);
; 45   : }

	mov	eax, ecx

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+8], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+12], 0

; 42   : 	conc_CHECK_CT (DataSize, sizeof (RealContent) == sizeof (DataType));
; 43   : 
; 44   : 	set (0, 0);
; 45   : }

	ret	0
??0?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE@XZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVDCTClass@@@2@H@Z
_TEXT	SEGMENT
_ptr$dead$ = 8						; size = 4
_val$dead$ = 12						; size = 4
?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVDCTClass@@@2@H@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::set, COMDAT
; _this$ = ecx

; 51   : 	_data._content._ptr = ptr;

	mov	DWORD PTR [ecx+8], 0

; 52   : 	_data._content._val = val;

	mov	DWORD PTR [ecx+12], 0

; 53   : }

	ret	8
?set@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEXPAV?$LockFreeCell@PAVDCTClass@@@2@H@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@VSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z PROC ; std::_Unfancy<MVAnalyse::SrcRefData>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@VSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z ENDP ; std::_Unfancy<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8HH@std@@YA_NABV?$allocator@H@0@0@Z
_TEXT	SEGMENT
??$?8HH@std@@YA_NABV?$allocator@H@0@0@Z PROC		; std::operator==<int,int>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 796  : 	return (true);

	mov	al, 1

; 797  : 	}

	ret	0
??$?8HH@std@@YA_NABV?$allocator@H@0@0@Z ENDP		; std::operator==<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiomax.hpp
;	COMDAT ??0?$AioMax@H@conc@@QAE@H@Z
_TEXT	SEGMENT
_operand$ = 8						; size = 4
??0?$AioMax@H@conc@@QAE@H@Z PROC			; conc::AioMax<int>::AioMax<int>, COMDAT
; _this$ = ecx

; 40   : :	_operand (operand)

	mov	eax, DWORD PTR _operand$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 42   : 	// Nothing
; 43   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$AioMax@H@conc@@6B@
	ret	4
??0?$AioMax@H@conc@@QAE@H@Z ENDP			; conc::AioMax<int>::AioMax<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@@Z
_TEXT	SEGMENT
??$exec@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@@Z PROC ; conc::AtomicIntOp::exec<int,conc::AioMax<int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 40   : {

	push	esi
	push	edi
	mov	edi, edx
$LL6@exec:

; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, esi
	cmp	esi, DWORD PTR [edi+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	edx, DWORD PTR [edi+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL6@exec

; 41   : 	assert (&atom != 0);
; 42   : 	assert (&ftor != 0);
; 43   : 
; 44   : 	T					val_new;
; 45   : 	T					val_old;
; 46   : 	exec_both (atom, ftor, val_old, val_new);
; 47   : }

	pop	edi
	pop	esi
	ret	0
??$exec@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@@Z ENDP ; conc::AtomicIntOp::exec<int,conc::AioMax<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VSrcRefData@MVAnalyse@@$$V@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VSrcRefData@MVAnalyse@@$$V@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z PROC ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	esi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	esi, DWORD PTR __Ptr$[esp]
	test	esi, esi
	je	SHORT $LN7@construct
	push	192					; 000000c0H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi+176], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+180], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+184], 0
$LN7@construct:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	4
??$construct@VSrcRefData@MVAnalyse@@$$V@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<int *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 252  : 	}

	ret	0
??$_Uninitialized_copy_al_unchecked@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAVSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAVSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z PROC ; std::_Unchecked<MVAnalyse::SrcRefData *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAVSrcRefData@MVAnalyse@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@@Z ENDP ; std::_Unchecked<MVAnalyse::SrcRefData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move_al_unchecked@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAVSrcRefData@MVAnalyse@@PAV12@@std@@YAAAPAVSrcRefData@MVAnalyse@@AAPAV12@PAV12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAVSrcRefData@MVAnalyse@@PAV12@@std@@YAAAPAVSrcRefData@MVAnalyse@@AAPAV12@PAV12@@Z PROC ; std::_Rechecked<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAVSrcRefData@MVAnalyse@@PAV12@@std@@YAAAPAVSrcRefData@MVAnalyse@@AAPAV12@PAV12@@Z ENDP ; std::_Rechecked<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VSrcRefData@MVAnalyse@@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VSrcRefData@MVAnalyse@@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z PROC ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::destroy<MVAnalyse::SrcRefData>, COMDAT
; _this$dead$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	esi
	mov	esi, DWORD PTR __Ptr$[esp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+176]
	test	ecx, ecx
	je	SHORT $LN18@destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+184]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+176], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+180], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+184], 0
$LN18@destroy:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	ret	4
??$destroy@VSrcRefData@MVAnalyse@@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::destroy<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ??0?$LockFreeCell@PAVDCTClass@@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$LockFreeCell@PAVDCTClass@@@conc@@QAE@XZ PROC	; conc::LockFreeCell<DCTClass *>::LockFreeCell<DCTClass *>, COMDAT
; _this$ = ecx

; 43   : :	_ptr ()

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0?$LockFreeCell@PAVDCTClass@@@conc@@QAE@XZ ENDP	; conc::LockFreeCell<DCTClass *>::LockFreeCell<DCTClass *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??E?$AtomicInt@I@conc@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$AtomicInt@I@conc@@QAEAAV01@XZ PROC			; conc::AtomicInt<unsigned int>::operator++, COMDAT
; _this$ = ecx

; 142  : {

	push	esi
$LL12@operator:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	edx, DWORD PTR [esi+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL12@operator
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 144  : }

	mov	eax, ecx
	pop	esi
	ret	0
??E?$AtomicInt@I@conc@@QAEAAV01@XZ ENDP			; conc::AtomicInt<unsigned int>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicmem.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicmem.hpp
;	COMDAT ?swap@?$AtomicMem@$01@conc@@SAHACHH@Z
_TEXT	SEGMENT
?swap@?$AtomicMem@$01@conc@@SAHACHH@Z PROC		; conc::AtomicMem<2>::swap, COMDAT
; _dest$ = ecx
; _excg$ = edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xchg	DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicmem.hpp

; 44   : 	return (Interlocked::swap (dest, excg));

	mov	eax, edx

; 45   : }

	ret	0
?swap@?$AtomicMem@$01@conc@@SAHACHH@Z ENDP		; conc::AtomicMem<2>::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\cellpool.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\cellpool.hpp
;	COMDAT ?return_cell@?$CellPool@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z
_TEXT	SEGMENT
_cell$ = 8						; size = 4
?return_cell@?$CellPool@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z PROC ; conc::CellPool<DCTClass *>::return_cell, COMDAT
; _this$ = ecx

; 162  : {

	push	ecx
	push	esi

; 163  : 	assert (&cell != 0);
; 164  : 
; 165  : 	_cell_stack.push (cell);

	push	DWORD PTR _cell$[esp+4]
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+8]
	call	?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ; conc::LockFreeStack<DCTClass *>::push

; 166  : 
; 167  : 	++ _nbr_avail_cells;

	add	esi, 288				; 00000120H
$LL14@return_cel:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL14@return_cel
; File c:\github\mvtools\sources\conc\cellpool.hpp

; 168  : }

	pop	esi
	pop	ecx
	ret	4
?return_cell@?$CellPool@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ENDP ; conc::CellPool<DCTClass *>::return_cell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\lockfreestack.hpp
;	COMDAT ?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z
_TEXT	SEGMENT
tv88 = -24						; size = 4
_this$1$ = -20						; size = 4
_comp$1 = -16						; size = 8
_newx$2 = -8						; size = 8
_cell$ = 8						; size = 4
?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z PROC ; conc::LockFreeStack<DCTClass *>::push, COMDAT
; _this$ = ecx

; 49   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	mov	eax, ecx
	push	ebx
	push	esi
	push	edi
	lea	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _this$1$[esp+40], eax
	mov	DWORD PTR tv88[esp+40], ecx
	npad	7
$LL4@push:

; 50   : 	assert (&cell != 0);
; 51   : 
; 52   : 	CellType *		head_ptr;
; 53   : 	ptrdiff_t		count;
; 54   : 	do
; 55   : 	{
; 56   : 		head_ptr = _head_ptr.get_ptr ();

	mov	edx, DWORD PTR [ecx]

; 57   : 		count    = _head_ptr.get_val ();

	mov	esi, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	mov	eax, edx
	mov	ecx, DWORD PTR _cell$[ebp]
	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 112  : 	newx._content._ptr = new_ptr;

	mov	DWORD PTR _newx$2[esp+40], ecx
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 60   : 	while (! _head_ptr.cas2 (&cell, count + 1, head_ptr, count));

	lea	eax, DWORD PTR [esi+1]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 113  : 	newx._content._val = new_val;

	mov	DWORD PTR _newx$2[esp+44], eax

; 114  : 
; 115  : 	Combi				comp;
; 116  : 	comp._content._ptr = comp_ptr;

	mov	DWORD PTR _comp$1[esp+40], edx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$1[esp+40]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 117  : 	comp._content._val = comp_val;

	mov	DWORD PTR _comp$1[esp+44], esi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	edx, DWORD PTR _comp$1[esp+44]
	mov	ebx, DWORD PTR _newx$2[esp+40]
	mov	ecx, DWORD PTR _newx$2[esp+44]
	mov	esi, DWORD PTR tv88[esp+40]
	lock	 cmpxchg8b QWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 122  : 	return (old._storage == comp._storage);

	cmp	eax, DWORD PTR _comp$1[esp+40]
	mov	esi, DWORD PTR _comp$1[esp+44]
	mov	eax, DWORD PTR _this$1$[esp+40]
	mov	ecx, DWORD PTR tv88[esp+40]
	jne	SHORT $LL4@push
	cmp	edx, esi
	jne	SHORT $LL4@push
; File c:\github\mvtools\sources\conc\lockfreestack.hpp

; 61   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$LockFreeStack@PAVDCTClass@@@conc@@QAEXAAV?$LockFreeCell@PAVDCTClass@@@2@@Z ENDP ; conc::LockFreeStack<DCTClass *>::push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ?cas@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@PAV32@0@Z
_TEXT	SEGMENT
_other_ptr$ = 8						; size = 4
_comp_ptr$dead$ = 12					; size = 4
?cas@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@PAV32@0@Z PROC ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::cas, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	edx, DWORD PTR _other_ptr$[esp-4]
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicptr.hpp

; 114  : }

	ret	8
?cas@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAEPAV?$LockFreeCell@PAVDCTClass@@@2@PAV32@0@Z ENDP ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::cas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptr.hpp
;	COMDAT ?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ
_TEXT	SEGMENT
?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ PROC ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::read_ptr, COMDAT
; _this$ = ecx

; 129  : 	return (static_cast <T *> (_ptr));

	mov	eax, DWORD PTR [ecx]

; 130  : }

	ret	0
?read_ptr@?$AtomicPtr@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@ABEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ENDP ; conc::AtomicPtr<conc::LockFreeCell<DCTClass *> >::read_ptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ
_TEXT	SEGMENT
?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::get_ptr, COMDAT
; _this$ = ecx

; 81   : 	return (_data._content._ptr);

	mov	eax, DWORD PTR [ecx+8]

; 82   : }

	ret	0
?get_ptr@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEPAV?$LockFreeCell@PAVDCTClass@@@2@XZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::get_ptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEHXZ
_TEXT	SEGMENT
?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEHXZ PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::get_val, COMDAT
; _this$ = ecx

; 89   : 	return (_data._content._val);

	mov	eax, DWORD PTR [ecx+12]

; 90   : }

	ret	0
?get_val@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QBEHXZ ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::get_val
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVDCTClass@@@2@H0H@Z
_TEXT	SEGMENT
_comp$ = -16						; size = 8
_newx$ = -8						; size = 8
_new_ptr$ = 8						; size = 4
_new_val$ = 12						; size = 4
_comp_ptr$ = 16						; size = 4
_comp_val$ = 20						; size = 4
?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVDCTClass@@@2@H0H@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::cas2, COMDAT
; _this$ = ecx

; 110  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H

; 111  : 	Combi				newx;
; 112  : 	newx._content._ptr = new_ptr;

	mov	eax, DWORD PTR _new_ptr$[ebp]
	mov	DWORD PTR _newx$[esp+16], eax

; 113  : 	newx._content._val = new_val;

	mov	eax, DWORD PTR _new_val$[ebp]
	mov	DWORD PTR _newx$[esp+20], eax

; 114  : 
; 115  : 	Combi				comp;
; 116  : 	comp._content._ptr = comp_ptr;

	mov	eax, DWORD PTR _comp_ptr$[ebp]
	mov	DWORD PTR _comp$[esp+16], eax

; 117  : 	comp._content._val = comp_val;

	mov	eax, DWORD PTR _comp_val$[ebp]
	push	ebx
	mov	DWORD PTR _comp$[esp+24], eax
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	eax, DWORD PTR _comp$[esp+20]
	mov	edx, DWORD PTR _comp$[esp+24]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 110  : {

	push	esi

; 149  : 	old._storage = Interlocked::cas (

	lea	esi, DWORD PTR [ecx+8]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	ebx, DWORD PTR _newx$[esp+24]
	mov	ecx, DWORD PTR _newx$[esp+28]
	lock	 cmpxchg8b QWORD PTR [esi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 122  : 	return (old._storage == comp._storage);

	cmp	eax, DWORD PTR _comp$[esp+24]
	jne	SHORT $LN3@cas2
	cmp	edx, DWORD PTR _comp$[esp+28]
	jne	SHORT $LN3@cas2
	mov	al, 1

; 123  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@cas2:
	pop	esi
	xor	al, al
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?cas2@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@QAE_NPAV?$LockFreeCell@PAVDCTClass@@@2@H0H@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::cas2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\aiomax.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_both@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@AAH2@Z
_TEXT	SEGMENT
_val_old$ = 8						; size = 4
_val_new$ = 12						; size = 4
??$exec_both@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@AAH2@Z PROC ; conc::AtomicIntOp::exec_both<int,conc::AioMax<int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 83   : {

	push	ebx
; File c:\github\mvtools\sources\conc\aiomax.hpp

; 50   : 	return (std::max (old_val, _operand));

	mov	ebx, DWORD PTR _val_new$[esp]
	push	ebp
	mov	ebp, DWORD PTR _val_old$[esp+4]
	push	esi
	push	edi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 83   : {

	mov	edi, edx
	mov	esi, ecx
$LL4@exec_both:

; 84   : 	assert (&atom != 0);
; 85   : 	assert (&ftor != 0);
; 86   : 
; 87   : 	T					val_cur;
; 88   : 	do
; 89   : 	{
; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, edx
	cmp	edx, DWORD PTR [edi+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	ecx, DWORD PTR [edi+4]
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [ebx], ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 92   : 		val_old = atom.cas (val_new, val_cur);

	mov	DWORD PTR [ebp], eax

; 93   : 	}
; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL4@exec_both

; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$exec_both@HV?$AioMax@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioMax@H@1@AAH2@Z ENDP ; conc::AtomicIntOp::exec_both<int,conc::AioMax<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z
_TEXT	SEGMENT
??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z PROC ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	esi
	mov	esi, edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN5@construct
	push	192					; 000000c0H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi+176], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+180], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+184], 0
$LN5@construct:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z ENDP ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<int,int,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 241  : 	}

	ret	0
??$_Uninitialized_copy_al_unchecked1@HHV?$allocator@H@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<int,int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@VSrcRefData@MVAnalyse@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVSrcRefData@MVAnalyse@@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@VSrcRefData@MVAnalyse@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVSrcRefData@MVAnalyse@@0@Z PROC ; std::_Ptr_move_cat<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	xor	al, al

; 811  : 	}

	ret	0
??$_Ptr_move_cat@VSrcRefData@MVAnalyse@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVSrcRefData@MVAnalyse@@0@Z ENDP ; std::_Ptr_move_cat<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	esi, edi
	je	SHORT $LN41@Uninitiali
	mov	ecx, DWORD PTR __Dest$[esp+4]
	npad	2
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN2@Uninitiali
	push	esi
	call	??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 192				; 000000c0H
	add	ecx, 192				; 000000c0H
	cmp	esi, edi
	jne	SHORT $LL4@Uninitiali

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

	pop	edi
	mov	eax, ecx
	pop	esi

; 285  : 	}

	ret	0
$LN41@Uninitiali:

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	edi
	pop	esi

; 285  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@PAVSrcRefData@MVAnalyse@@PAV12@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@YAPAVSrcRefData@MVAnalyse@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<MVAnalyse::SrcRefData *,MVAnalyse::SrcRefData *,std::allocator<MVAnalyse::SrcRefData> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VSrcRefData@MVAnalyse@@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z
_TEXT	SEGMENT
??$destroy@VSrcRefData@MVAnalyse@@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z PROC ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::destroy<MVAnalyse::SrcRefData>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 863  : 		{	// destroy object at _Ptr

	push	esi
	mov	esi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+176]
	test	ecx, ecx
	je	SHORT $LN16@destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+184]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+176], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+180], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+184], 0
$LN16@destroy:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	ret	0
??$destroy@VSrcRefData@MVAnalyse@@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@@Z ENDP ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::destroy<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??Y?$AtomicInt@I@conc@@QAEAAV01@ABI@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??Y?$AtomicInt@I@conc@@QAEAAV01@ABI@Z PROC		; conc::AtomicInt<unsigned int>::operator+=, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR _other$[esp-4]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 116  : {

	push	esi
	push	edi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	edi, DWORD PTR [eax]
$LL10@operator:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	edx, DWORD PTR [esi+edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL10@operator
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 122  : 	return (*this);

	pop	edi
	mov	eax, ecx

; 123  : }

	pop	esi
	ret	4
??Y?$AtomicInt@I@conc@@QAEAAV01@ABI@Z ENDP		; conc::AtomicInt<unsigned int>::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp
;	COMDAT ?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z
_TEXT	SEGMENT
_excg$ = 8						; size = 4
_comp$ = 12						; size = 4
?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z PROC ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::cas_combi, COMDAT
; _old$ = ecx
; _dest$ = edx

; 137  : {

	push	ebx
	push	ebp
	push	esi

; 138  : #if (conc_WORD_SIZE == 64)
; 139  : 
; 140  : 	Interlocked::cas (
; 141  : 		old._storage,
; 142  : 		dest._storage,
; 143  : 		excg._storage,
; 144  : 		comp._storage
; 145  : 	);
; 146  : 
; 147  : #else		// conc_WORD_SIZE
; 148  : 
; 149  : 	old._storage = Interlocked::cas (

	mov	esi, DWORD PTR _comp$[esp+8]
	mov	ebp, ecx
	push	edi
	mov	edi, edx
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	esi, DWORD PTR _excg$[esp+12]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 110  : 	return (_InterlockedCompareExchange64 (&dest, excg, comp));

	mov	ebx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	lock	 cmpxchg8b QWORD PTR [edi]
; File c:\github\mvtools\sources\conc\atomicptrintpair.hpp

; 156  : }

	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], edx
	pop	ebp
	pop	ebx
	ret	0
?cas_combi@?$AtomicPtrIntPair@V?$LockFreeCell@PAVDCTClass@@@conc@@@conc@@CAXAATCombi@12@0ABT312@1@Z ENDP ; conc::AtomicPtrIntPair<conc::LockFreeCell<DCTClass *> >::cas_combi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aiomax.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\conc\aiomax.hpp
;	COMDAT ??R?$AioMax@H@conc@@QBEHH@Z
_TEXT	SEGMENT
_old_val$ = 8						; size = 4
??R?$AioMax@H@conc@@QBEHH@Z PROC			; conc::AioMax<int>::operator(), COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR _old_val$[esp-4]
	cmp	eax, DWORD PTR [ecx+4]
	cmovl	eax, DWORD PTR [ecx+4]
; File c:\github\mvtools\sources\conc\aiomax.hpp

; 51   : }

	ret	4
??R?$AioMax@H@conc@@QBEHH@Z ENDP			; conc::AioMax<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAVSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z
_TEXT	SEGMENT
??$move@AAVSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z PROC ; std::move<MVAnalyse::SrcRefData &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAVSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z ENDP ; std::move<MVAnalyse::SrcRefData &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z PROC ; std::allocator<MVAnalyse::SrcRefData>::construct<MVAnalyse::SrcRefData>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	esi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	esi, DWORD PTR __Ptr$[esp]
	test	esi, esi
	je	SHORT $LN3@construct
	push	192					; 000000c0H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi+176], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+180], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+184], 0
$LN3@construct:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	4
??$construct@VSrcRefData@MVAnalyse@@$$V@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ENDP ; std::allocator<MVAnalyse::SrcRefData>::construct<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VSrcRefData@MVAnalyse@@V12@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VSrcRefData@MVAnalyse@@V12@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
	push	DWORD PTR _<_Args_0>$[esp-4]
	call	??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	8
??$construct@VSrcRefData@MVAnalyse@@V12@@?$_Wrap_alloc@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VSrcRefData@MVAnalyse@@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VSrcRefData@MVAnalyse@@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z PROC ; std::allocator<MVAnalyse::SrcRefData>::destroy<MVAnalyse::SrcRefData>, COMDAT
; _this$dead$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	esi
	mov	esi, DWORD PTR __Ptr$[esp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+176]
	test	ecx, ecx
	je	SHORT $LN14@destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+184]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+176], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+180], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+184], 0
$LN14@destroy:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	ret	4
??$destroy@VSrcRefData@MVAnalyse@@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@@Z ENDP ; std::allocator<MVAnalyse::SrcRefData>::destroy<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0SrcRefData@MVAnalyse@@QAE@XZ
_TEXT	SEGMENT
??0SrcRefData@MVAnalyse@@QAE@XZ PROC			; MVAnalyse::SrcRefData::SrcRefData, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx+176], 0
	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+180], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+184], 0
	ret	0
??0SrcRefData@MVAnalyse@@QAE@XZ ENDP			; MVAnalyse::SrcRefData::SrcRefData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??_GSrcRefData@MVAnalyse@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GSrcRefData@MVAnalyse@@QAEPAXI@Z PROC		; MVAnalyse::SrcRefData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+176]
	test	ecx, ecx
	je	SHORT $LN104@scalar

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+184]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+176], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+180], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+184], 0
$LN104@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GSrcRefData@MVAnalyse@@QAEPAXI@Z ENDP		; MVAnalyse::SrcRefData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1SrcRefData@MVAnalyse@@QAE@XZ
_TEXT	SEGMENT
??1SrcRefData@MVAnalyse@@QAE@XZ PROC			; MVAnalyse::SrcRefData::~SrcRefData, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+176]
	test	ecx, ecx
	je	SHORT $LN7@SrcRefData

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+184]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+176], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+180], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+184], 0
$LN7@SrcRefData:
	pop	esi
	ret	0
??1SrcRefData@MVAnalyse@@QAE@XZ ENDP			; MVAnalyse::SrcRefData::~SrcRefData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.h
;	COMDAT ??1?$AioAdd@I@conc@@UAE@XZ
_TEXT	SEGMENT
??1?$AioAdd@I@conc@@UAE@XZ PROC				; conc::AioAdd<unsigned int>::~AioAdd<unsigned int>, COMDAT
; _this$ = ecx

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$AioAdd@I@conc@@6B@
	ret	0
??1?$AioAdd@I@conc@@UAE@XZ ENDP				; conc::AioAdd<unsigned int>::~AioAdd<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.h
;	COMDAT ??_G?$AioAdd@I@conc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$AioAdd@I@conc@@UAEPAXI@Z PROC			; conc::AioAdd<unsigned int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 47   : 	virtual			~AioAdd () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$AioAdd@I@conc@@6B@
	je	SHORT $LN7@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$AioAdd@I@conc@@UAEPAXI@Z ENDP			; conc::AioAdd<unsigned int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.hpp
;	COMDAT ??0?$AioAdd@I@conc@@QAE@I@Z
_TEXT	SEGMENT
_operand$ = 8						; size = 4
??0?$AioAdd@I@conc@@QAE@I@Z PROC			; conc::AioAdd<unsigned int>::AioAdd<unsigned int>, COMDAT
; _this$ = ecx

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR _operand$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 40   : 	// Nothing
; 41   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$AioAdd@I@conc@@6B@
	ret	4
??0?$AioAdd@I@conc@@QAE@I@Z ENDP			; conc::AioAdd<unsigned int>::AioAdd<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@@Z
_TEXT	SEGMENT
??$exec@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@@Z PROC ; conc::AtomicIntOp::exec<unsigned int,conc::AioAdd<unsigned int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 40   : {

	push	esi
	push	edi
$LL6@exec:

; 90   : 		val_cur = atom;

	mov	edi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	mov	esi, DWORD PTR [edx+4]
	add	esi, edi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edi
	jne	SHORT $LL6@exec

; 41   : 	assert (&atom != 0);
; 42   : 	assert (&ftor != 0);
; 43   : 
; 44   : 	T					val_new;
; 45   : 	T					val_old;
; 46   : 	exec_both (atom, ftor, val_old, val_new);
; 47   : }

	pop	edi
	pop	esi
	ret	0
??$exec@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@@Z ENDP ; conc::AtomicIntOp::exec<unsigned int,conc::AioAdd<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@VSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z
_TEXT	SEGMENT
??$forward@VSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z PROC ; std::forward<MVAnalyse::SrcRefData>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@VSrcRefData@MVAnalyse@@@std@@YA$$QAVSrcRefData@MVAnalyse@@AAV12@@Z ENDP ; std::forward<MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@$$QAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@$$QAV34@@Z PROC ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	push	DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, edx
	call	??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator_traits@V?$allocator@VSrcRefData@MVAnalyse@@@std@@@std@@SAXAAV?$allocator@VSrcRefData@MVAnalyse@@@1@PAVSrcRefData@MVAnalyse@@$$QAV34@@Z ENDP ; std::allocator_traits<std::allocator<MVAnalyse::SrcRefData> >::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_both@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@AAI2@Z
_TEXT	SEGMENT
_val_old$ = 8						; size = 4
_val_new$ = 12						; size = 4
??$exec_both@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@AAI2@Z PROC ; conc::AtomicIntOp::exec_both<unsigned int,conc::AioAdd<unsigned int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 83   : {

	push	ebx
	mov	ebx, DWORD PTR _val_new$[esp]
	push	ebp
	mov	ebp, DWORD PTR _val_old$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	npad	2
$LL4@exec_both:

; 84   : 	assert (&atom != 0);
; 85   : 	assert (&ftor != 0);
; 86   : 
; 87   : 	T					val_cur;
; 88   : 	do
; 89   : 	{
; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	mov	ecx, DWORD PTR [edx+4]
	add	ecx, esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [ebx], ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [edi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 92   : 		val_old = atom.cas (val_new, val_cur);

	mov	DWORD PTR [ebp], eax

; 93   : 	}
; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL4@exec_both

; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$exec_both@IV?$AioAdd@I@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@I@1@AAV?$AioAdd@I@1@AAI2@Z ENDP ; conc::AtomicIntOp::exec_both<unsigned int,conc::AioAdd<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z PROC ; std::allocator<MVAnalyse::SrcRefData>::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
	push	DWORD PTR _<_Args_0>$[esp-4]
	call	??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z
$LN3@construct:

; 738  : 		}

	ret	8
??$construct@VSrcRefData@MVAnalyse@@V12@@?$allocator@VSrcRefData@MVAnalyse@@@std@@QAEXPAVSrcRefData@MVAnalyse@@$$QAV23@@Z ENDP ; std::allocator<MVAnalyse::SrcRefData>::construct<MVAnalyse::SrcRefData,MVAnalyse::SrcRefData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z PROC		; MVAnalyse::SrcRefData::SrcRefData, COMDAT
; _this$ = ecx
	mov	edx, DWORD PTR ___that$[esp-4]
	movups	xmm0, XMMWORD PTR [edx]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [edx+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	xmm0, XMMWORD PTR [edx+32]
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	xmm0, XMMWORD PTR [edx+48]
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	xmm0, XMMWORD PTR [edx+64]
	movups	XMMWORD PTR [ecx+64], xmm0
	movq	xmm0, QWORD PTR [edx+80]
	movq	QWORD PTR [ecx+80], xmm0
	movups	xmm0, XMMWORD PTR [edx+88]
	movups	XMMWORD PTR [ecx+88], xmm0
	movups	xmm0, XMMWORD PTR [edx+104]
	movups	XMMWORD PTR [ecx+104], xmm0
	movups	xmm0, XMMWORD PTR [edx+120]
	movups	XMMWORD PTR [ecx+120], xmm0
	movups	xmm0, XMMWORD PTR [edx+136]
	movups	XMMWORD PTR [ecx+136], xmm0
	movups	xmm0, XMMWORD PTR [edx+152]
	movups	XMMWORD PTR [ecx+152], xmm0
	movq	xmm0, QWORD PTR [edx+168]
	movq	QWORD PTR [ecx+168], xmm0

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx+176], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+180], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+184], 0

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	eax, DWORD PTR [edx+176]
	mov	DWORD PTR [ecx+176], eax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	eax, DWORD PTR [edx+180]
	mov	DWORD PTR [ecx+180], eax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+184], eax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	mov	DWORD PTR [edx+176], 0

; 875  : 		_Right._Mylast() = pointer();

	mov	DWORD PTR [edx+180], 0

; 876  : 		_Right._Myend() = pointer();

	mov	DWORD PTR [edx+184], 0
	mov	eax, DWORD PTR [edx+188]
	mov	DWORD PTR [ecx+188], eax
	mov	eax, ecx
	ret	4
??0SrcRefData@MVAnalyse@@QAE@$$QAV01@@Z ENDP		; MVAnalyse::SrcRefData::SrcRefData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	edx, DWORD PTR __Right$[esp-4]

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 842  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 843  : 		}

	mov	eax, ecx

; 874  : 		_Right._Myfirst() = pointer();

	mov	DWORD PTR [edx], 0

; 875  : 		_Right._Mylast() = pointer();

	mov	DWORD PTR [edx+4], 0

; 876  : 		_Right._Myend() = pointer();

	mov	DWORD PTR [edx+8], 0

; 842  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 843  : 		}

	ret	4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Assign_rv, COMDAT
; _this$ = ecx

; 869  : 		this->_Swap_all((_Myt&)_Right);
; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	mov	DWORD PTR [edx], 0

; 875  : 		_Right._Mylast() = pointer();

	mov	DWORD PTR [edx+4], 0

; 876  : 		_Right._Myend() = pointer();

	mov	DWORD PTR [edx+8], 0

; 877  : 		}

	ret	8
?_Assign_rv@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Swap_all, COMDAT
; _this$dead$ = ecx

; 618  : 		_Get_data()._Swap_all(_Right._Get_data());
; 619  : 		}

	ret	4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??B?$AtomicInt@I@conc@@QBEIXZ
_TEXT	SEGMENT
??B?$AtomicInt@I@conc@@QBEIXZ PROC			; conc::AtomicInt<unsigned int>::operator unsigned int, COMDAT
; _this$ = ecx

; 93   : 	return (T (_val));

	mov	eax, DWORD PTR [ecx]

; 94   : }

	ret	0
??B?$AtomicInt@I@conc@@QBEIXZ ENDP			; conc::AtomicInt<unsigned int>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ?cas@?$AtomicInt@I@conc@@QAEIII@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
_comp$ = 12						; size = 4
?cas@?$AtomicInt@I@conc@@QAEIII@Z PROC			; conc::AtomicInt<unsigned int>::cas, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	edx, DWORD PTR _other$[esp-4]
	mov	eax, DWORD PTR _comp$[esp-4]
	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 110  : }

	ret	8
?cas@?$AtomicInt@I@conc@@QAEIII@Z ENDP			; conc::AtomicInt<unsigned int>::cas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\aioadd.hpp
;	COMDAT ??R?$AioAdd@I@conc@@QBEII@Z
_TEXT	SEGMENT
_old_val$ = 8						; size = 4
??R?$AioAdd@I@conc@@QBEII@Z PROC			; conc::AioAdd<unsigned int>::operator(), COMDAT
; _this$ = ecx

; 48   : 	return (old_val + _operand);

	mov	eax, DWORD PTR [ecx+4]
	add	eax, DWORD PTR _old_val$[esp-4]

; 49   : }

	ret	4
??R?$AioAdd@I@conc@@QBEII@Z ENDP			; conc::AioAdd<unsigned int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$move@AAU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<int> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > ><std::_Wrap_alloc<std::allocator<int> >,void>, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 529  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 529  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > ><std::_Wrap_alloc<std::allocator<int> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<int> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1><std::_Wrap_alloc<std::allocator<int> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@H@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@H@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1><std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::_Wrap_alloc<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
END
