; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvflowinter.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EG@EACJFEMN@MFlowInter?3?5cannot?5use?5motion?5ve@ ; `string'
PUBLIC	??_C@_0CE@CKCCGPHL@MFlowInter?5?3?5wrong?5super?5frame?5c@ ; `string'
PUBLIC	??_C@_0CD@HFPFFHOA@MFlowInter?3?5wrong?5backward?5vecto@ ; `string'
PUBLIC	??_C@_0CC@IMFOIGJO@MFlowInter?3?5wrong?5forward?5vector@ ; `string'
PUBLIC	??_R3MVFlowInter@@8				; MVFlowInter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@MVFlowInter@@8			; MVFlowInter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4MVFlowInter@@6B@				; MVFlowInter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMVFlowInter@@@8				; MVFlowInter `RTTI Type Descriptor'
PUBLIC	??_R2MVFlowInter@@8				; MVFlowInter::`RTTI Base Class Array'
PUBLIC	??_7MVFlowInter@@6B@				; MVFlowInter::`vftable'
;	COMDAT ??_7MVFlowInter@@6B@
CONST	SEGMENT
??_7MVFlowInter@@6B@ DD FLAT:??_R4MVFlowInter@@6B@	; MVFlowInter::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVFlowInter@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVFlowInter@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2MVFlowInter@@8
rdata$r	SEGMENT
??_R2MVFlowInter@@8 DD FLAT:??_R1A@?0A@EA@MVFlowInter@@8 ; MVFlowInter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVFlowInter@@@8
data$r	SEGMENT
??_R0?AVMVFlowInter@@@8 DD FLAT:??_7type_info@@6B@	; MVFlowInter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVFlowInter@@', 00H
data$r	ENDS
;	COMDAT ??_R4MVFlowInter@@6B@
rdata$r	SEGMENT
??_R4MVFlowInter@@6B@ DD 00H				; MVFlowInter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVFlowInter@@@8
	DD	FLAT:??_R3MVFlowInter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVFlowInter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVFlowInter@@8 DD FLAT:??_R0?AVMVFlowInter@@@8 ; MVFlowInter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVFlowInter@@8
rdata$r	ENDS
;	COMDAT ??_R3MVFlowInter@@8
rdata$r	SEGMENT
??_R3MVFlowInter@@8 DD 00H				; MVFlowInter::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVFlowInter@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CC@IMFOIGJO@MFlowInter?3?5wrong?5forward?5vector@
CONST	SEGMENT
??_C@_0CC@IMFOIGJO@MFlowInter?3?5wrong?5forward?5vector@ DB 'MFlowInter: '
	DB	'wrong forward vectors', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HFPFFHOA@MFlowInter?3?5wrong?5backward?5vecto@
CONST	SEGMENT
??_C@_0CD@HFPFFHOA@MFlowInter?3?5wrong?5backward?5vecto@ DB 'MFlowInter: '
	DB	'wrong backward vectors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CKCCGPHL@MFlowInter?5?3?5wrong?5super?5frame?5c@
CONST	SEGMENT
??_C@_0CE@CKCCGPHL@MFlowInter?5?3?5wrong?5super?5frame?5c@ DB 'MFlowInter'
	DB	' : wrong super frame clip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@EACJFEMN@MFlowInter?3?5cannot?5use?5motion?5ve@
CONST	SEGMENT
??_C@_0EG@EACJFEMN@MFlowInter?3?5cannot?5use?5motion?5ve@ DB 'MFlowInter:'
	DB	' cannot use motion vectors with absolute frame references.', 00H ; `string'
PUBLIC	?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVFlowInter::GetFrame
PUBLIC	??1MVFlowInter@@UAE@XZ				; MVFlowInter::~MVFlowInter
PUBLIC	??_GMVFlowInter@@UAEPAXI@Z			; MVFlowInter::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVFlowInter@@UAGHHH@Z		; MVFlowInter::SetCacheHints
PUBLIC	??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z ; MVFlowInter::MVFlowInter
EXTRN	??_EMVFlowInter@@UAEPAXI@Z:PROC			; MVFlowInter::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z DD 019930522H
	DD	014H
	DD	FLAT:__unwindtable$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$10
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$13
	DD	0aH
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$15
	DD	0bH
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$16
	DD	0bH
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$20
	DD	0aH
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$21
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$22
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$23
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$26
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVFlowInter@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1MVFlowInter@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVFlowInter@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowInter@@UAE@XZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowInter@@UAE@XZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowInter@@UAE@XZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVFlowInter@@UAE@XZ$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	01fH
	DD	FLAT:__unwindtable$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$20
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$21
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9
	DD	010H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10
	DD	010H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$27
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$28
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$29
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$30
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$31
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$32
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$33
	DD	04H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$34
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$35
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$36
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$37
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$38
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$39
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
;	COMDAT ??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
_super$ = 12						; size = 4
__mvbw$ = 16						; size = 4
__mvfw$ = 20						; size = 4
__time256$ = 24						; size = 4
_cache_args$3 = 28					; size = 8
__ml$ = 28						; size = 8
tv1932 = 36						; size = 4
_nSuperHPad$1$ = 36					; size = 4
__blend$ = 36						; size = 1
_nSCD1$ = 40						; size = 4
_nSuperPel$1$ = 44					; size = 4
_nSCD2$ = 44						; size = 4
tv1938 = 48						; size = 4
_nSuperWidth$1$ = 48					; size = 4
$T4 = 48						; size = 4
$T5 = 48						; size = 4
$T6 = 48						; size = 4
$T7 = 48						; size = 4
$T8 = 48						; size = 4
__isse$ = 48						; size = 1
tv1828 = 52						; size = 4
_nHeightS$1$ = 52					; size = 4
__planar$ = 52						; size = 1
__timeclip$ = 56					; size = 4
_env$ = 60						; size = 4
??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z PROC ; MVFlowInter::MVFlowInter, COMDAT
; _this$ = ecx

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowinter.cpp

; 32   :   GenericVideoFilter(_child),

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN51@MVFlowInte
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN51@MVFlowInte
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN51@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 32   :   GenericVideoFilter(_child),

	mov	ecx, ebx
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 33   :   MVFilter(_mvfw, "MFlowInter", env, 1, 0),

	mov	esi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	push	0
	push	1
	push	esi
	push	OFFSET ??_C@_0L@DJEOPEOC@MFlowInter?$AA@
	push	ecx
	lea	ecx, DWORD PTR [ebx+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter

; 34   :   mvClipB(_mvbw, nSCD1, nSCD2, env, 1, 0),

	mov	edi, DWORD PTR _nSCD2$[ebp]
	lea	ecx, DWORD PTR __mvbw$[ebp]
	push	0
	push	1
	push	esi
	mov	esi, DWORD PTR _nSCD1$[ebp]
	push	edi
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [ebx+152]

; 37   : {

	mov	DWORD PTR [ebx], OFFSET ??_7MVFlowInter@@6B@
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	push	0
	push	1
	push	DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	edi
	push	esi
	push	ecx
	lea	ecx, DWORD PTR [ebx+392]
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\github\mvtools\sources\include\avisynth.h

; 936  :   PClip() AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN55@MVFlowInte
	cmp	DWORD PTR [eax], 228			; 000000e4H
	jbe	SHORT $LN55@MVFlowInte
	mov	eax, DWORD PTR [eax+228]
	lea	ecx, DWORD PTR [ebx+648]
	call	eax
$LN55@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 53   :   time256 = _time256;

	mov	eax, DWORD PTR __time256$[ebp]

; 54   :   ml = _ml;
; 55   :   isse = _isse;
; 56   :   planar = _planar;
; 57   :   blend = _blend;
; 58   : 
; 59   :   CheckSimilarity(mvClipB, "mvbw", env);

	lea	ecx, DWORD PTR [ebx+64]
	mov	esi, DWORD PTR _env$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	movsd	xmm0, QWORD PTR __ml$[ebp]
	mov	DWORD PTR [ebx+632], eax
	mov	al, BYTE PTR __isse$[ebp]
	mov	BYTE PTR [ebx+652], al
	mov	al, BYTE PTR __planar$[ebp]
	mov	BYTE PTR [ebx+653], al
	mov	al, BYTE PTR __blend$[ebp]
	push	esi
	mov	BYTE PTR [ebx+654], al
	lea	eax, DWORD PTR [ebx+152]
	push	OFFSET ??_C@_04DNAGLECB@mvbw?$AA@
	push	eax
	movsd	QWORD PTR [ebx+640], xmm0
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity

; 60   :   CheckSimilarity(mvClipF, "mvfw", env);

	push	esi
	push	OFFSET ??_C@_04DKAPBMPN@mvfw?$AA@
	lea	eax, DWORD PTR [ebx+392]
	push	eax
	lea	ecx, DWORD PTR [ebx+64]
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	eax, DWORD PTR [ebx+292]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 62   :   if (mvClipB.GetDeltaFrame() <= 0 || mvClipB.GetDeltaFrame() <= 0)

	test	eax, eax
	jg	SHORT $LN2@MVFlowInte

; 63   :     env->ThrowError("MFlowInter: cannot use motion vectors with absolute frame references.");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0EG@EACJFEMN@MFlowInter?3?5cannot?5use?5motion?5ve@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN2@MVFlowInte:
	mov	eax, DWORD PTR _super$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN24@MVFlowInte
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN23@MVFlowInte
$LN24@MVFlowInte:
	push	eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 66   :   memcpy(&params, &super->GetVideoInfo().num_audio_samples, 8);

	call	ecx
	mov	edx, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN23@MVFlowInte:
	mov	ecx, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [edx+36]

; 67   :   int nHeightS = params.nHeight;

	movzx	edi, cx

; 68   :   int nSuperHPad = params.nHPad;

	shr	ecx, 16					; 00000010H
	movzx	ecx, cl
	mov	DWORD PTR _nSuperHPad$1$[ebp], ecx

; 69   :   int nSuperVPad = params.nVPad;
; 70   :   int nSuperPel = params.nPel;

	movzx	ecx, dl
	mov	DWORD PTR _nSuperPel$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nHeightS$1$[ebp], edi
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN26@MVFlowInte
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	edx, DWORD PTR [eax+16]
	jmp	SHORT $LN25@MVFlowInte
$LN26@MVFlowInte:
	push	eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 73   :   int nSuperWidth = super->GetVideoInfo().width; // really super

	call	ecx
	mov	edx, eax
	mov	eax, DWORD PTR _super$[ebp]
$LN25@MVFlowInte:
	mov	ecx, DWORD PTR [eax]
	lea	edi, DWORD PTR [ebx+648]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _nSuperWidth$1$[ebp], edx
	mov	ecx, DWORD PTR [ecx+20]
	cmp	ecx, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	je	SHORT $LN27@MVFlowInte

; 74   :   int nSuperHeight = super->GetVideoInfo().height;

	push	eax
	call	ecx
	mov	edx, DWORD PTR _nSuperWidth$1$[ebp]
$LN27@MVFlowInte:

; 75   : 
; 76   :   if (nHeight != nHeightS
; 77   :     || nWidth != nSuperWidth - nSuperHPad * 2
; 78   :     || nPel != nSuperPel)

	mov	eax, DWORD PTR _nHeightS$1$[ebp]
	cmp	DWORD PTR [ebx+96], eax
	jne	SHORT $LN5@MVFlowInte
	mov	eax, DWORD PTR _nSuperHPad$1$[ebp]
	add	eax, eax
	sub	edx, eax
	cmp	DWORD PTR [ebx+92], edx
	jne	SHORT $LN5@MVFlowInte
	mov	eax, DWORD PTR _nSuperPel$1$[ebp]
	cmp	DWORD PTR [ebx+104], eax
	je	SHORT $LN4@MVFlowInte
$LN5@MVFlowInte:

; 79   :   {
; 80   :     env->ThrowError("MFlowInter : wrong super frame clip");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CE@CKCCGPHL@MFlowInter?5?3?5wrong?5super?5frame?5c@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN4@MVFlowInte:

; 81   :   }
; 82   : 
; 83   :   if (nPel == 1)

	cmp	DWORD PTR [ebx+104], 1
	jne	SHORT $LN6@MVFlowInte
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	$LN7@MVFlowInte
	cmp	DWORD PTR [eax], 244			; 000000f4H
	jbe	$LN7@MVFlowInte
	mov	eax, DWORD PTR [eax+244]
	lea	ecx, DWORD PTR _super$[ebp]
	push	ecx
	mov	ecx, edi
	call	eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 85   :   else

	jmp	$LN7@MVFlowInte
$LN6@MVFlowInte:

; 87   :     finest = new MVFinest(super, isse, env);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR $T8[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	movzx	ecx, BYTE PTR [ebx+652]
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowinter.cpp

; 87   :     finest = new MVFinest(super, isse, env);

	push	ecx
	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN79@MVFlowInte
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN79@MVFlowInte
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR _super$[ebp]
	push	edx
	call	eax
$LN79@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 87   :     finest = new MVFinest(super, isse, env);

	mov	ecx, DWORD PTR $T8[ebp]
	call	??0MVFinest@@QAE@VPClip@@_NPAVIScriptEnvironment@@@Z ; MVFinest::MVFinest
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\github\mvtools\sources\include\avisynth.h

; 939  :   void operator=(IClip* x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN87@MVFlowInte
	cmp	DWORD PTR [eax], 240			; 000000f0H
	jbe	SHORT $LN83@MVFlowInte
	mov	eax, DWORD PTR [eax+240]
	push	ecx
	mov	ecx, edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN83@MVFlowInte:

; 1000 :   AVSValue(const PClip& c) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR2)(c) )

	test	eax, eax
	je	SHORT $LN87@MVFlowInte
	cmp	DWORD PTR [eax], 284			; 0000011cH
	jbe	SHORT $LN87@MVFlowInte
	mov	eax, DWORD PTR [eax+284]
	lea	ecx, DWORD PTR _cache_args$3[ebp]
	push	edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN87@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 89   :     finest = env->Invoke("InternalCache", AVSValue(cache_args, 1)).AsClip(); // add cache for speed

	lea	ecx, DWORD PTR $T7[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	push	ecx
	push	0
	sub	esp, 8
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 1007 :   AVSValue(const AVSValue* a, int size) AVS_BakedCode( AVS_LinkCall(AVSValue_CONSTRUCTOR8)(a, size) )

	test	eax, eax
	je	SHORT $LN91@MVFlowInte
	cmp	DWORD PTR [eax], 308			; 00000134H
	jbe	SHORT $LN91@MVFlowInte
	mov	eax, DWORD PTR [eax+308]
	lea	edx, DWORD PTR _cache_args$3[ebp]
	push	1
	push	edx
	call	eax
$LN91@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 89   :     finest = env->Invoke("InternalCache", AVSValue(cache_args, 1)).AsClip(); // add cache for speed

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T2[ebp]
	push	OFFSET ??_C@_0O@FPHICKBJ@InternalCache?$AA@
	push	ecx
	push	esi
	call	DWORD PTR [eax+32]
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	call	?AsClip@AVSValue@@QBE?AVPClip@@XZ	; AVSValue::AsClip
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File c:\github\mvtools\sources\include\avisynth.h

; 940  :   void operator=(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_OPERATOR_ASSIGN1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN95@MVFlowInte
	cmp	DWORD PTR [eax], 244			; 000000f4H
	jbe	SHORT $LN95@MVFlowInte
	mov	eax, DWORD PTR [eax+244]
	push	ecx
	mov	ecx, edi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN95@MVFlowInte:

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	eax, eax
	je	SHORT $LN99@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN99@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR $T7[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN99@MVFlowInte:

; 1011 :   ~AVSValue() AVS_BakedCode( AVS_LinkCall(AVSValue_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	test	eax, eax
	je	SHORT $LN104@MVFlowInte
	cmp	DWORD PTR [eax], 316			; 0000013cH
	jbe	SHORT $LN104@MVFlowInte
	mov	eax, DWORD PTR [eax+316]
	lea	ecx, DWORD PTR $T2[ebp]
	call	eax
$LN104@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 90   :   }

	push	OFFSET ??1AVSValue@@QAE@XZ		; AVSValue::~AVSValue
	push	1
	push	8
	lea	eax, DWORD PTR _cache_args$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
$LN7@MVFlowInte:

; 91   : 
; 92   : //	if (nWidth  != vi.width || (nWidth + nHPadding*2)*nPel != finest->GetVideoInfo().width ||
; 93   : //	    nHeight  != vi.height || (nHeight + nVPadding*2)*nPel != finest->GetVideoInfo().height )
; 94   : //		env->ThrowError("MVFlowInter: wrong source or finest frame size");
; 95   : 
; 96   :   // may be padded for full frame cover
; 97   :   nBlkXP = (nBlkX*(nBlkSizeX - nOverlapX) + nOverlapX < nWidth) ? nBlkX + 1 : nBlkX;

	mov	edx, DWORD PTR [ebx+76]
	sub	edx, DWORD PTR [ebx+108]
	mov	ecx, DWORD PTR [ebx+64]
	mov	eax, ecx
	imul	eax, edx
	add	eax, DWORD PTR [ebx+108]
	cmp	eax, DWORD PTR [ebx+92]
	jge	SHORT $LN13@MVFlowInte
	inc	ecx
$LN13@MVFlowInte:

; 98   :   nBlkYP = (nBlkY*(nBlkSizeY - nOverlapY) + nOverlapY < nHeight) ? nBlkY + 1 : nBlkY;

	mov	eax, DWORD PTR [ebx+112]
	mov	esi, DWORD PTR [ebx+80]
	mov	edi, DWORD PTR [ebx+68]
	sub	esi, eax
	mov	DWORD PTR tv1938[ebp], eax
	mov	eax, edi
	imul	eax, esi
	mov	DWORD PTR [ebx+832], ecx
	add	eax, DWORD PTR [ebx+112]
	cmp	eax, DWORD PTR [ebx+96]
	jge	SHORT $LN15@MVFlowInte
	inc	edi
$LN15@MVFlowInte:

; 99   :   nWidthP = nBlkXP*(nBlkSizeX - nOverlapX) + nOverlapX;
; 100  :   nHeightP = nBlkYP*(nBlkSizeY - nOverlapY) + nOverlapY;

	mov	eax, DWORD PTR tv1938[ebp]
	imul	edx, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	imul	esi, edi
	mov	DWORD PTR [ebx+836], edi
	mov	ebx, DWORD PTR [ebx+108]
	add	ebx, edx
	mov	DWORD PTR [ecx+840], ebx
	add	eax, esi
	mov	DWORD PTR tv1828[ebp], esi

; 101  :   // for YV12
; 102  :   nWidthPUV = nWidthP / xRatioUV;

	mov	esi, DWORD PTR [ecx+120]
	mov	DWORD PTR [ecx+844], eax
	mov	eax, ebx
	cdq
	idiv	esi
	mov	DWORD PTR tv1932[ebp], esi

; 103  :   nHeightPUV = nHeightP / yRatioUV;

	mov	esi, DWORD PTR tv1938[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR tv1828[ebp]
	mov	DWORD PTR [ecx+848], edi
	mov	ecx, DWORD PTR [ecx+124]

; 113  :   VXFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	push	128					; 00000080H
	lea	eax, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR _this$[ebp]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+852], eax
	mov	eax, DWORD PTR [edx+96]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+820], eax
	mov	eax, DWORD PTR [edx+92]
	cdq
	idiv	DWORD PTR tv1932[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+816], eax
	mov	eax, DWORD PTR [edx+84]
	cdq
	idiv	DWORD PTR tv1932[ebp]
	mov	DWORD PTR [esi+856], eax
	mov	eax, DWORD PTR [esi+88]
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	ecx, DWORD PTR [ebx+15]
	mov	ebx, esi
; File c:\github\mvtools\sources\mvflowinter.cpp

; 108  :   nVPaddingUV = nVPadding / yRatioUV;

	mov	DWORD PTR [esi+860], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	and	ecx, -16				; fffffff0H
; File c:\github\mvtools\sources\mvflowinter.cpp

; 113  :   VXFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	esi, DWORD PTR __imp___aligned_malloc
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [edi+15]
	and	eax, -16				; fffffff0H
; File c:\github\mvtools\sources\mvflowinter.cpp

; 111  :   VPitchUV = AlignNumber(nWidthPUV, 16);

	mov	DWORD PTR [ebx+828], eax

; 113  :   VXFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR tv1828[ebp]
	add	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR [ebx+824], ecx
	imul	ecx, eax
	lea	eax, DWORD PTR [ecx*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+656], eax

; 114  :   VXFullUVB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+660], eax

; 115  :   VYFullYB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+664], eax

; 116  :   VYFullUVB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+668], eax

; 117  : 
; 118  :   VXFullYF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+672], eax

; 119  :   VXFullUVF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+676], eax

; 120  :   VYFullYF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+680], eax

; 121  :   VYFullUVF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+684], eax
	add	esp, 64					; 00000040H

; 122  : 
; 123  :   VXSmallYB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+720], eax

; 124  :   VYSmallYB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+728], eax

; 125  :   VXSmallUVB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+724], eax

; 126  :   VYSmallUVB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+732], eax

; 127  : 
; 128  :   VXSmallYF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+736], eax

; 129  :   VYSmallYF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+744], eax

; 130  :   VXSmallUVF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+740], eax

; 131  :   VYSmallUVF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	push	128					; 00000080H
	imul	eax, DWORD PTR [ebx+832]
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+748], eax
	add	esp, 64					; 00000040H

; 132  : 
; 133  :   VXFullYBB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+688], eax

; 134  :   VXFullUVBB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+692], eax

; 135  :   VYFullYBB = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+696], eax

; 136  :   VYFullUVBB = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+700], eax

; 137  : 
; 138  :   VXFullYFF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+704], eax

; 139  :   VXFullUVFF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+708], eax

; 140  :   VYFullYFF = (short*)_aligned_malloc(2 * nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+712], eax

; 141  :   VYFullUVFF = (short*)_aligned_malloc(2 * nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+716], eax
	add	esp, 64					; 00000040H

; 142  : 
; 143  :   VXSmallYBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+752], eax

; 144  :   VYSmallYBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+760], eax

; 145  :   VXSmallUVBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+756], eax

; 146  :   VYSmallUVBB = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+764], eax

; 147  : 
; 148  :   VXSmallYFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+768], eax

; 149  :   VYSmallYFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+776], eax

; 150  :   VXSmallUVFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+772], eax

; 151  :   VYSmallUVFF = (short*)_aligned_malloc(2 * nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	lea	eax, DWORD PTR [eax*2+128]
	push	eax
	call	esi
	mov	DWORD PTR [ebx+780], eax
	add	esp, 64					; 00000040H

; 152  : 
; 153  :   MaskSmallB = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+784], eax

; 154  :   MaskFullYB = (unsigned char*)_aligned_malloc(nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+788], eax

; 155  :   MaskFullUVB = (unsigned char*)_aligned_malloc(nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+792], eax

; 156  : 
; 157  :   MaskSmallF = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+796], eax

; 158  :   MaskFullYF = (unsigned char*)_aligned_malloc(nHeightP*VPitchY + 128, 128);

	mov	eax, DWORD PTR [ebx+824]
	imul	eax, DWORD PTR [ebx+844]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+800], eax

; 159  :   MaskFullUVF = (unsigned char*)_aligned_malloc(nHeightPUV*VPitchUV + 128, 128);

	mov	eax, DWORD PTR [ebx+828]
	imul	eax, DWORD PTR [ebx+852]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+804], eax

; 160  : 
; 161  :   SADMaskSmallB = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi
	mov	DWORD PTR [ebx+808], eax

; 162  :   SADMaskSmallF = (unsigned char*)_aligned_malloc(nBlkXP*nBlkYP + 128, 128);

	mov	eax, DWORD PTR [ebx+836]
	imul	eax, DWORD PTR [ebx+832]
	push	128					; 00000080H
	sub	eax, -128				; ffffff80H
	push	eax
	call	esi

; 163  : 
; 164  :   int CPUF_Resize = env->GetCPUFlags();

	mov	ecx, DWORD PTR _env$[ebp]
	add	esp, 64					; 00000040H
	mov	DWORD PTR [ebx+812], eax
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+4]
	mov	esi, eax

; 165  :   if (!isse) CPUF_Resize = (CPUF_Resize & !CPUF_INTEGER_SSE) & !CPUF_SSE2;

	xor	eax, eax
	cmp	BYTE PTR [ebx+652], al

; 166  : 
; 167  :   upsizer = new SimpleResize(nWidthP, nHeightP, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	cmove	esi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize

; 168  :   upsizerUV = new SimpleResize(nWidthPUV, nHeightPUV, nBlkXP, nBlkYP, CPUF_Resize);

	push	40					; 00000028H
	mov	DWORD PTR [ebx+864], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, eax
	push	esi
	push	DWORD PTR [ebx+836]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	call	??0SimpleResize@@QAE@HHHHJ@Z		; SimpleResize::SimpleResize
	mov	DWORD PTR [ebx+868], eax

; 169  :   /* no in 2.5.11.22
; 170  :   if (timeclip == 0)
; 171  :   {
; 172  :     LUTVB = new VectLut [1];
; 173  :     LUTVF = new VectLut [1];
; 174  :     Create_LUTV(time256, LUTVB [0], LUTVF [0]);
; 175  :   }
; 176  :   else
; 177  :   {
; 178  :     LUTVB = new VectLut [256];
; 179  :     LUTVF = new VectLut [256];
; 180  :     for (int t256 = 0; t256 < 256; ++t256)
; 181  :     {
; 182  :       Create_LUTV(t256, LUTVB [t256], LUTVF [t256]);
; 183  :     }
; 184  :   }
; 185  :   */
; 186  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN9@MVFlowInte
	cmp	BYTE PTR [ebx+653], 0
	jne	SHORT $LN9@MVFlowInte

; 187  :   {
; 188  :     DstPlanes = new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, eax
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	??0YUY2Planes@@QAE@HH@Z			; YUY2Planes::YUY2Planes
	mov	DWORD PTR [ebx+872], eax
$LN9@MVFlowInte:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN113@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN113@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN113@MVFlowInte:
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	eax, eax
	je	SHORT $LN118@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN118@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN118@MVFlowInte:
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN123@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN123@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mvbw$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN123@MVFlowInte:
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	test	eax, eax
	je	SHORT $LN128@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN128@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __mvfw$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN128@MVFlowInte:
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	test	eax, eax
	je	SHORT $LN136@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN136@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __timeclip$[ebp]
	call	eax
$LN136@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 191  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR __timeclip$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR __mvfw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR __mvbw$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR _super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1MVClip@@UAE@XZ			; MVClip::~MVClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$10:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$13:
	push	OFFSET ??1AVSValue@@QAE@XZ		; AVSValue::~AVSValue
	push	1
	push	8
	lea	eax, DWORD PTR _cache_args$3[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$15:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1AVSValue@@QAE@XZ			; AVSValue::~AVSValue
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$16:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$20:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$21:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$22:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$25:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z$26:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVFlowInter@@QAE@VPClip@@000HN_NHH110PAVIScriptEnvironment@@@Z ENDP ; MVFlowInter::MVFlowInter
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowinter.h
;	COMDAT ?SetCacheHints@MVFlowInter@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVFlowInter@@UAGHHH@Z PROC		; MVFlowInter::SetCacheHints, COMDAT

; 105  :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 106  :   }

	ret	12					; 0000000cH
?SetCacheHints@MVFlowInter@@UAGHHH@Z ENDP		; MVFlowInter::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVFlowInter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVFlowInter@@UAEPAXI@Z PROC				; MVFlowInter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVFlowInter@@UAE@XZ			; MVFlowInter::~MVFlowInter
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	880					; 00000370H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVFlowInter@@UAEPAXI@Z ENDP				; MVFlowInter::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\simpleresize.cpp
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
;	COMDAT ??1MVFlowInter@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVFlowInter@@UAE@XZ PROC				; MVFlowInter::~MVFlowInter, COMDAT
; _this$ = ecx

; 194  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVFlowInter@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 195  :   if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	edi, DWORD PTR __imp___aligned_free
	mov	eax, DWORD PTR [esi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [esi], OFFSET ??_7MVFlowInter@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN11@MVFlowInte
	cmp	BYTE PTR [esi+653], 0
	jne	SHORT $LN11@MVFlowInte

; 196  :   {
; 197  :     delete DstPlanes;

	mov	ebx, DWORD PTR [esi+872]
	test	ebx, ebx
	je	SHORT $LN11@MVFlowInte
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN11@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 200  :   delete upsizer;

	mov	ebx, DWORD PTR [esi+864]
	test	ebx, ebx
	je	SHORT $LN18@MVFlowInte
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN18@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 201  :   delete upsizerUV;

	mov	ebx, DWORD PTR [esi+868]
	test	ebx, ebx
	je	SHORT $LN25@MVFlowInte
; File c:\github\mvtools\sources\simpleresize.cpp

; 103  :   _aligned_free(hControl);

	push	DWORD PTR [ebx+16]
	call	edi

; 104  :   _aligned_free(vWorkY);

	push	DWORD PTR [ebx+28]
	call	edi

; 105  :   _aligned_free(vWorkY2);

	push	DWORD PTR [ebx+32]
	call	edi

; 106  :   _aligned_free(vOffsets);

	push	DWORD PTR [ebx+20]
	call	edi

; 107  :   _aligned_free(vWeights);

	push	DWORD PTR [ebx+24]
	call	edi
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 28					; 0000001cH
$LN25@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 203  :   _aligned_free(VXFullYB);

	push	DWORD PTR [esi+656]
	call	edi

; 204  :   _aligned_free(VXFullUVB);

	push	DWORD PTR [esi+660]
	call	edi

; 205  :   _aligned_free(VYFullYB);

	push	DWORD PTR [esi+664]
	call	edi

; 206  :   _aligned_free(VYFullUVB);

	push	DWORD PTR [esi+668]
	call	edi

; 207  :   _aligned_free(VXSmallYB);

	push	DWORD PTR [esi+720]
	call	edi

; 208  :   _aligned_free(VYSmallYB);

	push	DWORD PTR [esi+728]
	call	edi

; 209  :   _aligned_free(VXSmallUVB);

	push	DWORD PTR [esi+724]
	call	edi

; 210  :   _aligned_free(VYSmallUVB);

	push	DWORD PTR [esi+732]
	call	edi

; 211  :   _aligned_free(VXFullYF);

	push	DWORD PTR [esi+672]
	call	edi

; 212  :   _aligned_free(VXFullUVF);

	push	DWORD PTR [esi+676]
	call	edi

; 213  :   _aligned_free(VYFullYF);

	push	DWORD PTR [esi+680]
	call	edi

; 214  :   _aligned_free(VYFullUVF);

	push	DWORD PTR [esi+684]
	call	edi

; 215  :   _aligned_free(VXSmallYF);

	push	DWORD PTR [esi+736]
	call	edi

; 216  :   _aligned_free(VYSmallYF);

	push	DWORD PTR [esi+744]
	call	edi

; 217  :   _aligned_free(VXSmallUVF);

	push	DWORD PTR [esi+740]
	call	edi

; 218  :   _aligned_free(VYSmallUVF);

	push	DWORD PTR [esi+748]
	call	edi
	add	esp, 64					; 00000040H

; 219  : 
; 220  :   _aligned_free(MaskSmallB);

	push	DWORD PTR [esi+784]
	call	edi

; 221  :   _aligned_free(MaskFullYB);

	push	DWORD PTR [esi+788]
	call	edi

; 222  :   _aligned_free(MaskFullUVB);

	push	DWORD PTR [esi+792]
	call	edi

; 223  :   _aligned_free(MaskSmallF);

	push	DWORD PTR [esi+796]
	call	edi

; 224  :   _aligned_free(MaskFullYF);

	push	DWORD PTR [esi+800]
	call	edi

; 225  :   _aligned_free(MaskFullUVF);

	push	DWORD PTR [esi+804]
	call	edi

; 226  : 
; 227  :   _aligned_free(VXFullYBB);

	push	DWORD PTR [esi+688]
	call	edi

; 228  :   _aligned_free(VXFullUVBB);

	push	DWORD PTR [esi+692]
	call	edi

; 229  :   _aligned_free(VYFullYBB);

	push	DWORD PTR [esi+696]
	call	edi

; 230  :   _aligned_free(VYFullUVBB);

	push	DWORD PTR [esi+700]
	call	edi

; 231  :   _aligned_free(VXSmallYBB);

	push	DWORD PTR [esi+752]
	call	edi

; 232  :   _aligned_free(VYSmallYBB);

	push	DWORD PTR [esi+760]
	call	edi

; 233  :   _aligned_free(VXSmallUVBB);

	push	DWORD PTR [esi+756]
	call	edi

; 234  :   _aligned_free(VYSmallUVBB);

	push	DWORD PTR [esi+764]
	call	edi

; 235  :   _aligned_free(VXFullYFF);

	push	DWORD PTR [esi+704]
	call	edi

; 236  :   _aligned_free(VXFullUVFF);

	push	DWORD PTR [esi+708]
	call	edi
	add	esp, 64					; 00000040H

; 237  :   _aligned_free(VYFullYFF);

	push	DWORD PTR [esi+712]
	call	edi

; 238  :   _aligned_free(VYFullUVFF);

	push	DWORD PTR [esi+716]
	call	edi

; 239  :   _aligned_free(VXSmallYFF);

	push	DWORD PTR [esi+768]
	call	edi

; 240  :   _aligned_free(VYSmallYFF);

	push	DWORD PTR [esi+776]
	call	edi

; 241  :   _aligned_free(VXSmallUVFF);

	push	DWORD PTR [esi+772]
	call	edi

; 242  :   _aligned_free(VYSmallUVFF);

	push	DWORD PTR [esi+780]
	call	edi

; 243  : 
; 244  :   _aligned_free(SADMaskSmallB);

	push	DWORD PTR [esi+808]
	call	edi

; 245  :   _aligned_free(SADMaskSmallF);

	push	DWORD PTR [esi+812]
	call	edi
	add	esp, 32					; 00000020H
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN33@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN33@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 251  : }

	lea	ecx, DWORD PTR [esi+648]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
$LN33@MVFlowInte:
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+456]
	mov	DWORD PTR [esi+392], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN44@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN44@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+400]
	call	eax
$LN44@MVFlowInte:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+392], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvclip.cpp

; 79   : }

	lea	ecx, DWORD PTR [esi+216]
	mov	DWORD PTR [esi+152], OFFSET ??_7MVClip@@6B@
	call	??1FakeGroupOfPlanes@@QAE@XZ		; FakeGroupOfPlanes::~FakeGroupOfPlanes
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN58@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN58@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+160]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN58@MVFlowInte:

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi+152], OFFSET ??_7IClip@@6B@

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN75@MVFlowInte
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN75@MVFlowInte
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN75@MVFlowInte:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 251  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\mvflowinter.cpp

; 251  : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVFlowInter@@UAE@XZ$6:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowInter@@UAE@XZ$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowInter@@UAE@XZ$13:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVFlowInter@@UAE@XZ$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVFlowInter@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVFlowInter@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVFlowInter@@UAE@XZ ENDP				; MVFlowInter::~MVFlowInter
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvflowinter.cpp
;	COMDAT ?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -136						; size = 4
$T3 = -132						; size = 2
$T4 = -132						; size = 2
$T5 = -128						; size = 2
$T6 = -128						; size = 2
_nSrcPitches$2$ = -124					; size = 4
_nSrcPitches$1$ = -124					; size = 4
_nref$1$ = -124						; size = 4
_nDstPitches$2$ = -120					; size = 4
_pRef$2$ = -120						; size = 4
_mvFF$7 = -120						; size = 4
$T8 = -120						; size = 4
_pRef$3$ = -116						; size = 4
_pSrc$2$ = -116						; size = 4
_mvBB$9 = -116						; size = 4
_pSrc$3$ = -112						; size = 4
_nOffsetUV$1$ = -112					; size = 4
_pDst$2$ = -108						; size = 4
_nOffsetY$1$ = -108					; size = 4
_mvF$ = -104						; size = 4
_mvB$ = -100						; size = 4
_nRefPitches$5$ = -96					; size = 4
_pDstYUY2$1$ = -96					; size = 4
_nSrcPitches$3$ = -92					; size = 4
_nDstPitchYUY2$1$ = -92					; size = 4
_nDstPitches$4$ = -88					; size = 4
_pRef$6$ = -88						; size = 4
_pRef$5$ = -84						; size = 4
_pSrc$6$ = -84						; size = 4
_nRefPitches$6$ = -80					; size = 4
_pSrc$5$ = -80						; size = 4
_pDst$4$ = -76						; size = 4
_pRef$4$ = -76						; size = 4
_nRefPitches$7$ = -72					; size = 4
_pSrc$4$ = -72						; size = 4
_nDstPitches$6$ = -68					; size = 4
_pDst$5$ = -68						; size = 4
_nDstPitches$5$ = -64					; size = 4
_pRef$7$ = -64						; size = 4
_pDst$3$ = -60						; size = 4
_pSrc$7$ = -60						; size = 4
_pDst$6$ = -56						; size = 4
_nRefPitches$4$ = -56					; size = 4
_i$1$ = -52						; size = 4
$T10 = -52						; size = 2
_pRef$1$ = -48						; size = 4
_pSrc$1$ = -44						; size = 4
_nRefPitches$1$ = -40					; size = 4
_nDstPitches$3$ = -36					; size = 4
_nDstPitches$1$ = -32					; size = 4
_pDst$1$ = -28						; size = 4
_src$ = -24						; size = 4
_ref$ = -20						; size = 4
_dst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_src$11 = 8						; size = 4
_nDstPitchYUY2$ = 8					; size = 4
_pDstYUY2$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_i$1$ = 16						; size = 4
$T12 = 16						; size = 2
_ref$13 = 16						; size = 4
_n$ = 16						; size = 4
_nRefPitches$3$ = 20					; size = 4
_nRefPitches$2$ = 20					; size = 4
$T14 = 20						; size = 2
$T15 = 20						; size = 2
_env$ = 20						; size = 4
?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVFlowInter::GetFrame, COMDAT

; 255  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 124				; 0000007cH
; File c:\github\mvtools\sources\include\avisynth.h

; 970  :   PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR0)() )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR $T2[ebp], 0
	test	eax, eax
	je	SHORT $LN63@GetFrame
	cmp	DWORD PTR [eax], 252			; 000000fcH
	jbe	SHORT $LN63@GetFrame
	mov	eax, DWORD PTR [eax+252]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
$LN63@GetFrame:
	push	ebx
	push	esi
	push	edi
; File c:\github\mvtools\sources\mvflowinter.cpp

; 256  :   PVideoFrame dst;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 269  :     env->ThrowError("MFlowInter: cannot use motion vectors with absolute frame references.");

	mov	edi, DWORD PTR _env$[ebp]
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	esi, DWORD PTR [ebx+292]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 267  :   if (off <= 0)

	test	esi, esi
	jg	SHORT $LN20@GetFrame

; 269  :     env->ThrowError("MFlowInter: cannot use motion vectors with absolute frame references.");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0EG@EACJFEMN@MFlowInter?3?5cannot?5use?5motion?5ve@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN20@GetFrame:

; 270  :   }
; 271  :   const int		nref = n + off;

	mov	ecx, DWORD PTR _n$[ebp]

; 272  : 
; 273  :   PVideoFrame mvF = mvClipF.GetFrame(nref, env);

	mov	eax, DWORD PTR [ebx+392]
	add	ecx, esi
	push	edi
	push	ecx
	mov	DWORD PTR _nref$1$[ebp], ecx
	lea	esi, DWORD PTR [ebx+392]
	lea	ecx, DWORD PTR _mvF$[ebp]
	push	ecx
	push	esi
	call	DWORD PTR [eax+4]

; 274  :   mvClipF.Update(mvF, env);// forward from current to next

	push	edi
	lea	eax, DWORD PTR _mvF$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	eax
	mov	ecx, esi
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN69@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN69@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvF$[ebp]
	push	0
	call	eax
$LN69@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 276  :   PVideoFrame mvB = mvClipB.GetFrame(n, env);

	mov	eax, DWORD PTR [ebx+152]
	lea	esi, DWORD PTR [ebx+152]
	push	edi
	push	DWORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _mvB$[ebp]
	push	ecx
	push	esi
	call	DWORD PTR [eax+4]

; 277  :   mvClipB.Update(mvB, env);// backward from next to current

	push	edi
	lea	eax, DWORD PTR _mvB$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	eax
	mov	ecx, esi
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN73@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN73@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvB$[ebp]
	push	0
	call	eax
$LN73@GetFrame:
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [ebx+296]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 283  :   if (!mvClipB.IsBackward())

	test	al, al
	jne	SHORT $LN21@GetFrame

; 284  :     env->ThrowError("MFlowInter: wrong backward vectors");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CD@HFPFFHOA@MFlowInter?3?5wrong?5backward?5vecto@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN21@GetFrame:
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [ebx+536]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 285  :   if (mvClipF.IsBackward())

	test	al, al
	je	SHORT $LN22@GetFrame

; 286  :     env->ThrowError("MFlowInter: wrong forward vectors");

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0CC@IMFOIGJO@MFlowInter?3?5wrong?5forward?5vector@
	push	edi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN22@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+648]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 289  :   PVideoFrame	src = finest->GetFrame(n, env);

	lea	edx, DWORD PTR _src$[ebp]
	push	edi
	push	DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 290  :   PVideoFrame ref = finest->GetFrame(nref, env);//  ref for  compensation

	lea	edx, DWORD PTR _ref$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+648]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 290  :   PVideoFrame ref = finest->GetFrame(nref, env);//  ref for  compensation

	push	edi
	push	DWORD PTR _nref$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]

; 291  :   dst = env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [ebx+16]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR [edi]
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	push	edi
	call	DWORD PTR [ecx+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN85@GetFrame
	cmp	DWORD PTR [esi], 268			; 0000010cH
	jbe	SHORT $LN85@GetFrame
	push	eax
	mov	eax, DWORD PTR [esi+268]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN85@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	esi, esi
	je	SHORT $LN89@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN89@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR $T8[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN89@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [ebx+372]
	mov	ecx, DWORD PTR [ebx+240]
	push	DWORD PTR [ebx+368]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN23@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ebx+220]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN23@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [ebx+612]
	mov	ecx, DWORD PTR [ebx+480]
	push	DWORD PTR [ebx+608]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN23@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ebx+460]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN23@GetFrame
; File c:\github\mvtools\sources\mvflowinter.cpp

; 303  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN25@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN116@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN116@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$1$[ebp], eax
	jmp	SHORT $LN117@GetFrame
$LN116@GetFrame:
	mov	DWORD PTR _pSrc$1$[ebp], 0
$LN117@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN122@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN122@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN123@GetFrame
$LN122@GetFrame:
	xor	eax, eax
$LN123@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 307  :       pSrc[1] = pSrc[0] + src->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	add	edi, DWORD PTR _pSrc$1$[ebp]
	mov	DWORD PTR _pSrc$4$[ebp], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN128@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN128@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN129@GetFrame
$LN128@GetFrame:
	xor	eax, eax
$LN129@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 308  :       pSrc[2] = pSrc[1] + src->GetRowSize() / 4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, edi
	mov	DWORD PTR _pSrc$6$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN140@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN134@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN134@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN140@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN140@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$1$[ebp], eax
	jmp	SHORT $LN141@GetFrame
$LN140@GetFrame:
	mov	DWORD PTR _pRef$1$[ebp], 0
$LN141@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN146@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN146@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN147@GetFrame
$LN146@GetFrame:
	xor	eax, eax
$LN147@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 314  :       pRef[1] = pRef[0] + ref->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	add	edi, DWORD PTR _pRef$1$[ebp]
	mov	DWORD PTR _pRef$4$[ebp], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN152@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN152@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN153@GetFrame
$LN152@GetFrame:
	xor	eax, eax
$LN153@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 315  :       pRef[2] = pRef[1] + ref->GetRowSize() / 4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, edi
	mov	DWORD PTR _pRef$6$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN158@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN158@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN667@GetFrame
$LN158@GetFrame:
	xor	eax, eax
$LN667@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 320  :       if (!planar)

	cmp	BYTE PTR [ebx+653], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	mov	DWORD PTR _nRefPitches$1$[ebp], eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 317  :       nRefPitches[1] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$4$[ebp], eax

; 318  :       nRefPitches[2] = nRefPitches[0];

	mov	DWORD PTR _nRefPitches$6$[ebp], eax

; 320  :       if (!planar)

	jne	SHORT $LN27@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN164@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN164@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	jmp	SHORT $LN165@GetFrame
$LN164@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN165@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN170@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN170@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
	jmp	SHORT $LN171@GetFrame
$LN170@GetFrame:
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], 0
$LN171@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [ebx+872]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 325  :         pDst[1] = DstPlanes->GetPtrU();

	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDst$3$[ebp], edi

; 326  :         pDst[2] = DstPlanes->GetPtrV();

	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR _pDst$5$[ebp], edi

; 327  :         nDstPitches[0] = DstPlanes->GetPitch();

	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR _nDstPitches$1$[ebp], edi
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	edi, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 324  :         pDst[0] = DstPlanes->GetPtr();

	mov	DWORD PTR _pDst$1$[ebp], ecx
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	DWORD PTR _nDstPitches$3$[ebp], edi
; File c:\github\mvtools\sources\mvflowinter.cpp

; 329  :         nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$5$[ebp], edi

; 330  :       }
; 331  :       else

	jmp	$LN314@GetFrame
$LN27@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN188@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN188@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN189@GetFrame
$LN188@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN189@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN194@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN194@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN195@GetFrame
$LN194@GetFrame:
	xor	eax, eax
$LN195@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 334  :         pDst[1] = pDst[0] + dst->GetRowSize() / 2;

	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	add	edi, DWORD PTR _pDst$1$[ebp]
	mov	DWORD PTR _pDst$3$[ebp], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN200@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN200@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN201@GetFrame
$LN200@GetFrame:
	xor	eax, eax
$LN201@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 335  :         pDst[2] = pDst[1] + dst->GetRowSize() / 4;;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, edi
	mov	DWORD PTR _pDst$5$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN206@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN206@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	edi, eax
	jmp	SHORT $LN668@GetFrame
$LN206@GetFrame:
	xor	edi, edi
$LN668@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 354  :     else

	mov	eax, DWORD PTR _pDstYUY2$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	mov	DWORD PTR _nDstPitches$1$[ebp], edi
; File c:\github\mvtools\sources\mvflowinter.cpp

; 337  :         nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$3$[ebp], edi

; 338  :         nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR _nDstPitches$5$[ebp], edi

; 354  :     else

	mov	edi, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], edi
	jmp	$LN314@GetFrame
$LN25@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN212@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN212@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN213@GetFrame
$LN212@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN213@GetFrame:
	test	esi, esi
	je	SHORT $LN218@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN218@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$3$[ebp], eax
	jmp	SHORT $LN219@GetFrame
$LN218@GetFrame:
	mov	DWORD PTR _pDst$3$[ebp], 0
$LN219@GetFrame:
	test	esi, esi
	je	SHORT $LN224@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN224@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$5$[ebp], eax
	jmp	SHORT $LN225@GetFrame
$LN224@GetFrame:
	mov	DWORD PTR _pDst$5$[ebp], 0
$LN225@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN230@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN230@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$1$[ebp], eax
	jmp	SHORT $LN231@GetFrame
$LN230@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], 0
$LN231@GetFrame:
	test	esi, esi
	je	SHORT $LN236@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN236@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	jmp	SHORT $LN237@GetFrame
$LN236@GetFrame:
	mov	DWORD PTR _nDstPitches$3$[ebp], 0
$LN237@GetFrame:
	test	esi, esi
	je	SHORT $LN242@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN242@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$5$[ebp], eax
	jmp	SHORT $LN243@GetFrame
$LN242@GetFrame:
	mov	DWORD PTR _nDstPitches$5$[ebp], 0
$LN243@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN248@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN248@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$1$[ebp], eax
	jmp	SHORT $LN249@GetFrame
$LN248@GetFrame:
	mov	DWORD PTR _pRef$1$[ebp], 0
$LN249@GetFrame:
	test	esi, esi
	je	SHORT $LN254@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN254@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$4$[ebp], eax
	jmp	SHORT $LN255@GetFrame
$LN254@GetFrame:
	mov	DWORD PTR _pRef$4$[ebp], 0
$LN255@GetFrame:
	test	esi, esi
	je	SHORT $LN260@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN260@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$6$[ebp], eax
	jmp	SHORT $LN261@GetFrame
$LN260@GetFrame:
	mov	DWORD PTR _pRef$6$[ebp], 0
$LN261@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN266@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN266@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$1$[ebp], eax
	jmp	SHORT $LN267@GetFrame
$LN266@GetFrame:
	mov	DWORD PTR _nRefPitches$1$[ebp], 0
$LN267@GetFrame:
	test	esi, esi
	je	SHORT $LN272@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN272@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$4$[ebp], eax
	jmp	SHORT $LN273@GetFrame
$LN272@GetFrame:
	mov	DWORD PTR _nRefPitches$4$[ebp], 0
$LN273@GetFrame:
	test	esi, esi
	je	SHORT $LN278@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN278@GetFrame
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$6$[ebp], eax
	jmp	SHORT $LN279@GetFrame
$LN278@GetFrame:
	mov	DWORD PTR _nRefPitches$6$[ebp], 0
$LN279@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN284@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN284@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$1$[ebp], eax
	jmp	SHORT $LN285@GetFrame
$LN284@GetFrame:
	mov	DWORD PTR _pSrc$1$[ebp], 0
$LN285@GetFrame:
	test	esi, esi
	je	SHORT $LN290@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN290@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$4$[ebp], eax
	jmp	SHORT $LN291@GetFrame
$LN290@GetFrame:
	mov	DWORD PTR _pSrc$4$[ebp], 0
$LN291@GetFrame:
	test	esi, esi
	je	SHORT $LN296@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN296@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$6$[ebp], eax
	jmp	SHORT $LN297@GetFrame
$LN296@GetFrame:
	mov	DWORD PTR _pSrc$6$[ebp], 0
$LN297@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN662@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN302@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN302@GetFrame:
	test	esi, esi
	je	SHORT $LN662@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN308@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN308@GetFrame:
	test	esi, esi
	je	SHORT $LN662@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN662@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	edi, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], edi
	jmp	SHORT $LN314@GetFrame
$LN662@GetFrame:
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN314@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 390  :     int nOffsetY = nRefPitches[0] * nVPadding*nPel + nHPadding*nPel*pixelsize;

	mov	ecx, DWORD PTR [ebx+136]
	mov	esi, DWORD PTR [ebx+88]
	imul	esi, DWORD PTR _nRefPitches$1$[ebp]
	mov	eax, DWORD PTR [ebx+84]
	imul	eax, ecx

; 391  :     int nOffsetUV = nRefPitches[1] * nVPaddingUV*nPel + nHPaddingUV*nPel*pixelsize;
; 392  : 
; 393  : 
; 394  :     // make  vector vx and vy small masks
; 395  :     MakeVectorSmallMasks(mvClipB, nBlkX, nBlkY, VXSmallYB, nBlkXP, VYSmallYB, nBlkXP);

	mov	edx, DWORD PTR [ebx+64]
	add	esi, eax
	mov	eax, DWORD PTR [ebx+856]
	imul	esi, DWORD PTR [ebx+104]
	imul	eax, ecx
	lea	ecx, DWORD PTR [ebx+152]
	mov	DWORD PTR _nOffsetY$1$[ebp], esi
	mov	esi, DWORD PTR [ebx+860]
	imul	esi, DWORD PTR _nRefPitches$4$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ebx+832]
	imul	esi, DWORD PTR [ebx+104]
	push	eax
	push	DWORD PTR [ebx+728]
	push	eax
	push	DWORD PTR [ebx+720]
	mov	DWORD PTR _nOffsetUV$1$[ebp], esi
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 396  :     MakeVectorSmallMasks(mvClipF, nBlkX, nBlkY, VXSmallYF, nBlkXP, VYSmallYF, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	lea	ecx, DWORD PTR [ebx+392]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	DWORD PTR [ebx+744]
	push	eax
	push	DWORD PTR [ebx+736]
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 397  :     if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+832]
	add	esp, 40					; 00000028H
	cmp	eax, DWORD PTR [ebx+64]
	jle	$LN3@GetFrame

; 398  :     {
; 399  :       for (int j = 0; j < nBlkY; j++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+68], edi
	jle	$LN3@GetFrame

; 401  :         VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	DWORD PTR $T10[ebp], edi

; 403  :         VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	DWORD PTR $T6[ebp], edi
$LL4@GetFrame:

; 401  :         VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	esi, DWORD PTR [ebx+832]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T10[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 401  :         VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	edx, DWORD PTR [ebx+720]
	imul	esi, edi
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 401  :         VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [edx+ecx*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 401  :         VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [edx+ecx*2]

; 402  :         VYSmallYB[j*nBlkXP + nBlkX] = VYSmallYB[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 401  :         VXSmallYB[j*nBlkXP + nBlkX] = std::min(VXSmallYB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 402  :         VYSmallYB[j*nBlkXP + nBlkX] = VYSmallYB[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+728]
	imul	edx, edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T6[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 403  :         VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	esi, DWORD PTR [ebx+832]
	mov	edx, DWORD PTR [ebx+736]
	imul	esi, edi
	lea	ecx, DWORD PTR [edx-2]
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
	cmp	bx, WORD PTR [ecx+esi*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 404  :         VYSmallYF[j*nBlkXP + nBlkX] = VYSmallYF[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+esi*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 403  :         VXSmallYF[j*nBlkXP + nBlkX] = std::min(VXSmallYF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 404  :         VYSmallYF[j*nBlkXP + nBlkX] = VYSmallYF[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+744]
	imul	edx, edi
	inc	edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
	cmp	edi, DWORD PTR [ebx+68]
	jl	$LL4@GetFrame
$LN3@GetFrame:

; 405  :       }
; 406  :     }
; 407  :     if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+836]
	cmp	eax, DWORD PTR [ebx+68]
	jle	$LN6@GetFrame

; 409  :       for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [ebx+832], edi
	jle	$LN6@GetFrame

; 412  :         VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	DWORD PTR $T5[ebp], edi

; 414  :         VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	DWORD PTR $T4[ebp], edi
	npad	11
$LL7@GetFrame:

; 411  :         VXSmallYB[nBlkXP*nBlkY + i] = VXSmallYB[nBlkXP*(nBlkY - 1) + i];

	mov	ecx, DWORD PTR [ebx+68]
	mov	esi, DWORD PTR [ebx+832]
	mov	edx, DWORD PTR [ebx+720]
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, esi
	imul	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T5[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 411  :         VXSmallYB[nBlkXP*nBlkY + i] = VXSmallYB[nBlkXP*(nBlkY - 1) + i];

	add	eax, edi
	add	esi, edi
	movzx	eax, WORD PTR [edx+eax*2]
	mov	WORD PTR [edx+esi*2], ax

; 412  :         VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	edx, DWORD PTR [ebx+68]
	mov	edi, DWORD PTR [ebx+832]
	mov	esi, DWORD PTR [ebx+728]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 412  :         VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	lea	eax, DWORD PTR [edx-1]
	imul	eax, edi
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 413  :         VXSmallYF[nBlkXP*nBlkY + i] = VXSmallYF[nBlkXP*(nBlkY - 1) + i];

	mov	ebx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 412  :         VYSmallYB[nBlkXP*nBlkY + i] = std::min(VYSmallYB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax

; 413  :         VXSmallYF[nBlkXP*nBlkY + i] = VXSmallYF[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+832]
	mov	edx, DWORD PTR [ebx+736]
	lea	ecx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	ecx, eax
	add	esi, DWORD PTR _i$1$[ebp]
	add	ecx, DWORD PTR _i$1$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T4[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 413  :         VXSmallYF[nBlkXP*nBlkY + i] = VXSmallYF[nBlkXP*(nBlkY - 1) + i];

	mov	WORD PTR [edx+esi*2], ax

; 414  :         VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	edi, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+832]
	mov	esi, DWORD PTR [ebx+744]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 414  :         VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	lea	eax, DWORD PTR [edi-1]
	imul	eax, edx
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 409  :       for (int i = 0; i < nBlkXP; i++)

	mov	ebx, DWORD PTR _this$[ebp]

; 414  :         VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 414  :         VYSmallYF[nBlkXP*nBlkY + i] = std::min(VYSmallYF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax
	mov	edi, DWORD PTR _i$1$[ebp]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [ebx+832]
	jl	$LL7@GetFrame
$LN6@GetFrame:

; 415  :       }
; 416  :     }
; 417  :     VectorSmallMaskYToHalfUV(VXSmallYB, nBlkXP, nBlkYP, VXSmallUVB, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+724]
	mov	ecx, DWORD PTR [ebx+720]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 418  :     VectorSmallMaskYToHalfUV(VYSmallYB, nBlkXP, nBlkYP, VYSmallUVB, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+732]
	mov	ecx, DWORD PTR [ebx+728]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 419  :     VectorSmallMaskYToHalfUV(VXSmallYF, nBlkXP, nBlkYP, VXSmallUVF, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+740]
	mov	ecx, DWORD PTR [ebx+736]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 420  :     VectorSmallMaskYToHalfUV(VYSmallYF, nBlkXP, nBlkYP, VYSmallUVF, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+748]
	mov	ecx, DWORD PTR [ebx+744]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 421  : 
; 422  :     // analyse vectors field to detect occlusion
; 423  : 
; 424  :     // 2.6.0.5? removed at 2.5.11.22 merge
; 425  :     //if (timeclip == 0) // 2.6.0.5? feature 
; 426  :     {
; 427  :       //	  double occNormB = (256-time256)/(256*ml);
; 428  :       MakeVectorOcclusionMaskTime(mvClipB, nBlkX, nBlkY, ml, 1.0,

	mov	eax, DWORD PTR [ebx+80]
	lea	edi, DWORD PTR [ebx+152]
	sub	eax, DWORD PTR [ebx+112]
	add	esp, 48					; 00000030H
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	ecx, edi
	movsd	xmm3, QWORD PTR [ebx+640]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	mov	eax, DWORD PTR [ebx+76]
	sub	eax, DWORD PTR [ebx+108]
	push	eax
	mov	eax, 256				; 00000100H
	sub	eax, DWORD PTR [ebx+632]
	push	eax
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+784]
	push	DWORD PTR [ebx+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [ebx+68]
	call	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime

; 429  :         nPel, MaskSmallB, nBlkXP, (256 - time256),
; 430  :         nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);
; 431  :       //	  double occNormF = time256/(256*ml);
; 432  :       MakeVectorOcclusionMaskTime(mvClipF, nBlkX, nBlkY, ml, 1.0,

	mov	eax, DWORD PTR [ebx+80]
	lea	ecx, DWORD PTR [ebx+392]
	sub	eax, DWORD PTR [ebx+112]
	add	esp, 36					; 00000024H
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	xmm3, QWORD PTR [ebx+640]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	mov	eax, DWORD PTR [ebx+76]
	sub	eax, DWORD PTR [ebx+108]
	push	eax
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+796]
	push	DWORD PTR [ebx+104]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [ebx+68]
	call	?MakeVectorOcclusionMaskTime@@YAXAAVMVClip@@HHNNHPAEHHHH@Z ; MakeVectorOcclusionMaskTime

; 433  :         nPel, MaskSmallF, nBlkXP, time256,
; 434  :         nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);
; 435  :     }
; 436  :     /* 2.6.0.5? removed at 2.5.11.22 merge
; 437  :     else
; 438  :     {
; 439  :       class OpFwd
; 440  :       {
; 441  :       public:
; 442  :         static inline int compute (int t) { return (      t); }
; 443  :       };
; 444  : 
; 445  :       class OpBkw
; 446  :       {
; 447  :       public:
; 448  :         static inline int compute (int t) { return (256 - t); }
; 449  :       };
; 450  : 
; 451  :       MakeVectorOcclusionMaskTimePlane <OpBkw> (
; 452  :         mvClipB, nBlkX, nBlkY, ml,
; 453  :         nPel, MaskSmallB, nBlkXP, pt256[0], nt256Pitches[0],
; 454  :         nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);
; 455  :       MakeVectorOcclusionMaskTimePlane <OpFwd> (
; 456  :         mvClipF, nBlkX, nBlkY, ml,
; 457  :         nPel, MaskSmallF, nBlkXP, pt256[0], nt256Pitches[0],
; 458  :         nBlkSizeX - nOverlapX, nBlkSizeY - nOverlapY);
; 459  :     }
; 460  :     */
; 461  :     if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+832]
	add	esp, 36					; 00000024H
	cmp	eax, DWORD PTR [ebx+64]
	jle	SHORT $LN9@GetFrame

; 462  :     {
; 463  :       for (int j = 0; j < nBlkY; j++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+68], esi
	jle	SHORT $LN9@GetFrame
	npad	7
$LL10@GetFrame:

; 464  :       {
; 465  :         MaskSmallB[j*nBlkXP + nBlkX] = MaskSmallB[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+64]
	imul	edx, esi
	add	edx, DWORD PTR [ebx+784]
	mov	al, BYTE PTR [edx+ecx-1]
	mov	BYTE PTR [edx+ecx], al

; 466  :         MaskSmallF[j*nBlkXP + nBlkX] = MaskSmallF[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+64]
	imul	edx, esi
	inc	esi
	add	edx, DWORD PTR [ebx+796]
	mov	al, BYTE PTR [edx+ecx-1]
	mov	BYTE PTR [edx+ecx], al
	cmp	esi, DWORD PTR [ebx+68]
	jl	SHORT $LL10@GetFrame
$LN9@GetFrame:

; 467  :       }
; 468  :     }
; 469  :     if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+836]
	cmp	eax, DWORD PTR [ebx+68]
	jle	SHORT $LN12@GetFrame

; 470  :     {
; 471  :       for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+832], edi
	jle	SHORT $LN664@GetFrame
	npad	3
$LL13@GetFrame:

; 472  :       {
; 473  :         MaskSmallB[nBlkXP*nBlkY + i] = MaskSmallB[nBlkXP*(nBlkY - 1) + i];

	mov	edx, DWORD PTR [ebx+68]
	mov	esi, DWORD PTR [ebx+832]
	mov	eax, DWORD PTR [ebx+784]
	lea	ecx, DWORD PTR [edx-1]
	imul	ecx, esi
	imul	esi, edx
	add	ecx, eax
	add	esi, eax
	mov	al, BYTE PTR [ecx+edi]
	mov	BYTE PTR [esi+edi], al

; 474  :         MaskSmallF[nBlkXP*nBlkY + i] = MaskSmallF[nBlkXP*(nBlkY - 1) + i];

	mov	edx, DWORD PTR [ebx+68]
	mov	esi, DWORD PTR [ebx+832]
	mov	eax, DWORD PTR [ebx+796]
	lea	ecx, DWORD PTR [edx-1]
	imul	ecx, esi
	imul	esi, edx
	add	ecx, eax
	add	esi, eax
	mov	al, BYTE PTR [ecx+edi]
	mov	BYTE PTR [esi+edi], al
	inc	edi
	cmp	edi, DWORD PTR [ebx+832]
	jl	SHORT $LL13@GetFrame
$LN664@GetFrame:
	lea	edi, DWORD PTR [ebx+152]
$LN12@GetFrame:

; 475  :       }
; 476  :     }
; 477  :     // upsize (bilinear interpolate) vector masks to fullframe size
; 478  : 
; 479  : 
; 480  :     int dummyplane = PLANAR_Y; // use luma plane resizer code for all planes if we resize from luma small mask
; 481  :     upsizer->SimpleResizeDo_uint16(VXFullYB, nWidthP, nHeightP, VPitchY, VXSmallYB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+720]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+656]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 482  :     upsizer->SimpleResizeDo_uint16(VYFullYB, nWidthP, nHeightP, VPitchY, VYSmallYB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+728]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+664]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 483  :     upsizerUV->SimpleResizeDo_uint16(VXFullUVB, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+724]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+660]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 484  :     upsizerUV->SimpleResizeDo_uint16(VYFullUVB, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+732]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+668]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 485  : 
; 486  :     upsizer->SimpleResizeDo_uint16(VXFullYF, nWidthP, nHeightP, VPitchY, VXSmallYF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+736]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+672]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 487  :     upsizer->SimpleResizeDo_uint16(VYFullYF, nWidthP, nHeightP, VPitchY, VYSmallYF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+744]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+680]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 488  :     upsizerUV->SimpleResizeDo_uint16(VXFullUVF, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+740]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+676]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 489  :     upsizerUV->SimpleResizeDo_uint16(VYFullUVF, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+748]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+684]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 490  : 
; 491  :     upsizer->SimpleResizeDo_uint8(MaskFullYB, nWidthP, nHeightP, VPitchY, MaskSmallB, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+832]
	push	ecx
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+784]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+788]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 492  :     upsizerUV->SimpleResizeDo_uint8(MaskFullUVB, nWidthPUV, nHeightPUV, VPitchUV, MaskSmallB, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+832]
	push	ecx
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+784]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+792]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 493  : 
; 494  :     upsizer->SimpleResizeDo_uint8(MaskFullYF, nWidthP, nHeightP, VPitchY, MaskSmallF, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+832]
	push	ecx
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+796]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+800]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 495  :     upsizerUV->SimpleResizeDo_uint8(MaskFullUVF, nWidthPUV, nHeightPUV, VPitchUV, MaskSmallF, nBlkXP, nBlkXP, dummyplane);

	mov	eax, DWORD PTR [ebx+832]
	push	ecx
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+796]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+804]
	call	?SimpleResizeDo_uint8@SimpleResize@@QAEXPAEHHHPBEHHH@Z ; SimpleResize::SimpleResizeDo_uint8

; 496  : 
; 497  : 
; 498  :     // Get motion info from more frames for occlusion areas
; 499  :     PVideoFrame mvFF = mvClipF.GetFrame(n, env);

	mov	esi, DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR [ebx+392]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _mvFF$7[ebp]
	push	esi
	push	DWORD PTR _n$[ebp]
	push	edx
	push	ecx
	call	DWORD PTR [eax+4]

; 500  :     mvClipF.Update(mvFF, env);// forward from prev to cur

	push	esi
	lea	eax, DWORD PTR _mvFF$7[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	lea	ecx, DWORD PTR [ebx+392]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN330@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN330@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvFF$7[ebp]
	push	0
	call	eax
$LN330@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 502  :     PVideoFrame mvBB = mvClipB.GetFrame(nref, env);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _mvBB$9[ebp]
	push	esi
	push	DWORD PTR _nref$1$[ebp]
	push	ecx
	push	edi
	call	DWORD PTR [eax+4]

; 503  :     mvClipB.Update(mvBB, env);// backward from next next to next

	push	esi
	lea	eax, DWORD PTR _mvBB$9[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	eax
	mov	ecx, edi
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN334@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN334@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvBB$9[ebp]
	push	0
	call	eax
$LN334@GetFrame:
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [edi+220]
	mov	ecx, DWORD PTR [edi+88]
	push	DWORD PTR [edi+216]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN33@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [edi+68]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN33@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [ebx+612]
	mov	ecx, DWORD PTR [ebx+480]
	push	DWORD PTR [ebx+608]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	$LN33@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [ebx+460]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	$LN33@GetFrame
; File c:\github\mvtools\sources\mvflowinter.cpp

; 509  :       MakeVectorSmallMasks(mvClipB, nBlkX, nBlkY, VXSmallYBB, nBlkXP, VYSmallYBB, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, edi
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	DWORD PTR [ebx+760]
	push	eax
	push	DWORD PTR [ebx+752]
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 510  :       MakeVectorSmallMasks(mvClipF, nBlkX, nBlkY, VXSmallYFF, nBlkXP, VYSmallYFF, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	lea	ecx, DWORD PTR [ebx+392]
	mov	edx, DWORD PTR [ebx+64]
	push	eax
	push	DWORD PTR [ebx+776]
	push	eax
	push	DWORD PTR [ebx+768]
	push	DWORD PTR [ebx+68]
	call	?MakeVectorSmallMasks@@YAXAAVMVClip@@HHPAFH1H@Z ; MakeVectorSmallMasks

; 511  :       if (nBlkXP > nBlkX) // fill right

	mov	eax, DWORD PTR [ebx+832]
	add	esp, 40					; 00000028H
	cmp	eax, DWORD PTR [ebx+64]
	jle	$LN15@GetFrame

; 512  :       {
; 513  :         for (int j = 0; j < nBlkY; j++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+68], edi
	jle	$LN15@GetFrame

; 515  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	DWORD PTR $T12[ebp], edi

; 517  :           VXSmallYFF[j*nBlkXP + nBlkX] = std::min(VXSmallYFF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	DWORD PTR $T15[ebp], edi
	npad	7
$LL16@GetFrame:

; 515  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	esi, DWORD PTR [ebx+832]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T12[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 515  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	edx, DWORD PTR [ebx+752]
	imul	esi, edi
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 515  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [edx+ecx*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 515  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	lea	ecx, DWORD PTR [edx+ecx*2]

; 516  :           VYSmallYBB[j*nBlkXP + nBlkX] = VYSmallYBB[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 515  :           VXSmallYBB[j*nBlkXP + nBlkX] = std::min(VXSmallYBB[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 516  :           VYSmallYBB[j*nBlkXP + nBlkX] = VYSmallYBB[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+760]
	imul	edx, edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T15[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 517  :           VXSmallYFF[j*nBlkXP + nBlkX] = std::min(VXSmallYFF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	mov	esi, DWORD PTR [ebx+832]
	mov	edx, DWORD PTR [ebx+768]
	imul	esi, edi
	lea	ecx, DWORD PTR [edx-2]
	add	esi, DWORD PTR [ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
	cmp	bx, WORD PTR [ecx+esi*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 518  :           VYSmallYFF[j*nBlkXP + nBlkX] = VYSmallYFF[j*nBlkXP + nBlkX - 1];

	mov	ebx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+esi*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	eax, ecx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 517  :           VXSmallYFF[j*nBlkXP + nBlkX] = std::min(VXSmallYFF[j*nBlkXP + nBlkX - 1], short(0)); // 2.5.11.22

	movzx	eax, WORD PTR [eax]
	mov	WORD PTR [edx+esi*2], ax

; 518  :           VYSmallYFF[j*nBlkXP + nBlkX] = VYSmallYFF[j*nBlkXP + nBlkX - 1];

	mov	edx, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+776]
	imul	edx, edi
	inc	edi
	add	edx, DWORD PTR [ebx+64]
	movzx	eax, WORD PTR [ecx+edx*2-2]
	mov	WORD PTR [ecx+edx*2], ax
	cmp	edi, DWORD PTR [ebx+68]
	jl	$LL16@GetFrame
$LN15@GetFrame:

; 519  :         }
; 520  :       }
; 521  :       if (nBlkYP > nBlkY) // fill bottom

	mov	eax, DWORD PTR [ebx+836]
	cmp	eax, DWORD PTR [ebx+68]
	jle	$LN18@GetFrame

; 523  :         for (int i = 0; i < nBlkXP; i++)

	xor	edi, edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [ebx+832], edi
	jle	$LN18@GetFrame

; 526  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	DWORD PTR $T14[ebp], edi

; 528  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	DWORD PTR $T3[ebp], edi
	npad	11
$LL19@GetFrame:

; 525  :           VXSmallYBB[nBlkXP*nBlkY + i] = VXSmallYBB[nBlkXP*(nBlkY - 1) + i];

	mov	ecx, DWORD PTR [ebx+68]
	mov	esi, DWORD PTR [ebx+832]
	mov	edx, DWORD PTR [ebx+752]
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, esi
	imul	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T14[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 525  :           VXSmallYBB[nBlkXP*nBlkY + i] = VXSmallYBB[nBlkXP*(nBlkY - 1) + i];

	add	eax, edi
	add	esi, edi
	movzx	eax, WORD PTR [edx+eax*2]
	mov	WORD PTR [edx+esi*2], ax

; 526  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	edx, DWORD PTR [ebx+68]
	mov	edi, DWORD PTR [ebx+832]
	mov	esi, DWORD PTR [ebx+760]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 526  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	lea	eax, DWORD PTR [edx-1]
	imul	eax, edi
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 527  :           VXSmallYFF[nBlkXP*nBlkY + i] = VXSmallYFF[nBlkXP*(nBlkY - 1) + i];

	mov	ebx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 526  :           VYSmallYBB[nBlkXP*nBlkY + i] = std::min(VYSmallYBB[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax

; 527  :           VXSmallYFF[nBlkXP*nBlkY + i] = VXSmallYFF[nBlkXP*(nBlkY - 1) + i];

	mov	esi, DWORD PTR [ebx+68]
	mov	eax, DWORD PTR [ebx+832]
	mov	edx, DWORD PTR [ebx+768]
	lea	ecx, DWORD PTR [esi-1]
	imul	esi, eax
	imul	ecx, eax
	add	esi, DWORD PTR _i$1$[ebp]
	add	ecx, DWORD PTR _i$1$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T3[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 527  :           VXSmallYFF[nBlkXP*nBlkY + i] = VXSmallYFF[nBlkXP*(nBlkY - 1) + i];

	mov	WORD PTR [edx+esi*2], ax

; 528  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	mov	edi, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR [ebx+832]
	mov	esi, DWORD PTR [ebx+776]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	xor	ebx, ebx
; File c:\github\mvtools\sources\mvflowinter.cpp

; 528  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	lea	eax, DWORD PTR [edi-1]
	imul	eax, edx
	add	eax, DWORD PTR _i$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	bx, WORD PTR [esi+eax*2]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 523  :         for (int i = 0; i < nBlkXP; i++)

	mov	ebx, DWORD PTR _this$[ebp]

; 528  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	lea	eax, DWORD PTR [esi+eax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, eax
; File c:\github\mvtools\sources\mvflowinter.cpp

; 528  :           VYSmallYFF[nBlkXP*nBlkY + i] = std::min(VYSmallYFF[nBlkXP*(nBlkY - 1) + i], short(0)); // 2.5.11.22

	imul	edi, edx
	movzx	eax, WORD PTR [ecx]
	add	edi, DWORD PTR _i$1$[ebp]
	mov	WORD PTR [esi+edi*2], ax
	mov	edi, DWORD PTR _i$1$[ebp]
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [ebx+832]
	jl	$LL19@GetFrame
$LN18@GetFrame:

; 529  :         }
; 530  :       }
; 531  :       VectorSmallMaskYToHalfUV(VXSmallYBB, nBlkXP, nBlkYP, VXSmallUVBB, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+756]
	mov	ecx, DWORD PTR [ebx+752]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 532  :       VectorSmallMaskYToHalfUV(VYSmallYBB, nBlkXP, nBlkYP, VYSmallUVBB, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+764]
	mov	ecx, DWORD PTR [ebx+760]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 533  :       VectorSmallMaskYToHalfUV(VXSmallYFF, nBlkXP, nBlkYP, VXSmallUVFF, xRatioUV);

	push	DWORD PTR [ebx+120]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+772]
	mov	ecx, DWORD PTR [ebx+768]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 534  :       VectorSmallMaskYToHalfUV(VYSmallYFF, nBlkXP, nBlkYP, VYSmallUVFF, yRatioUV);

	push	DWORD PTR [ebx+124]
	mov	edx, DWORD PTR [ebx+832]
	push	DWORD PTR [ebx+780]
	mov	ecx, DWORD PTR [ebx+776]
	push	DWORD PTR [ebx+836]
	call	?VectorSmallMaskYToHalfUV@@YAXPAFHH0H@Z	; VectorSmallMaskYToHalfUV

; 535  : 
; 536  :       // upsize vectors to full frame
; 537  :       upsizer->SimpleResizeDo_uint16(VXFullYBB, nWidthP, nHeightP, VPitchY, VXSmallYBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	add	esp, 48					; 00000030H
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+752]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+688]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 538  :       upsizer->SimpleResizeDo_uint16(VYFullYBB, nWidthP, nHeightP, VPitchY, VYSmallYBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+760]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+696]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 539  :       upsizerUV->SimpleResizeDo_uint16(VXFullUVBB, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+756]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+692]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 540  :       upsizerUV->SimpleResizeDo_uint16(VYFullUVBB, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVBB, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+764]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+700]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 541  : 
; 542  :       upsizer->SimpleResizeDo_uint16(VXFullYFF, nWidthP, nHeightP, VPitchY, VXSmallYFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+864]
	push	eax
	push	eax
	push	DWORD PTR [ebx+768]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	push	DWORD PTR [ebx+704]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 543  :       upsizer->SimpleResizeDo_uint16(VYFullYFF, nWidthP, nHeightP, VPitchY, VYSmallYFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	push	eax
	push	eax
	push	DWORD PTR [ebx+776]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+844]
	push	DWORD PTR [ebx+840]
	mov	ecx, DWORD PTR [ebx+864]
	push	DWORD PTR [ebx+712]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 544  :       upsizerUV->SimpleResizeDo_uint16(VXFullUVFF, nWidthPUV, nHeightPUV, VPitchUV, VXSmallUVFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+772]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+708]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 545  :       upsizerUV->SimpleResizeDo_uint16(VYFullUVFF, nWidthPUV, nHeightPUV, VPitchUV, VYSmallUVFF, nBlkXP, nBlkXP);

	mov	eax, DWORD PTR [ebx+832]
	mov	ecx, DWORD PTR [ebx+868]
	push	eax
	push	eax
	push	DWORD PTR [ebx+780]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+852]
	push	DWORD PTR [ebx+848]
	push	DWORD PTR [ebx+716]
	call	?SimpleResizeDo_uint16@SimpleResize@@QAEXPAFHHHPBFHH@Z ; SimpleResize::SimpleResizeDo_uint16

; 546  :       // back to 2.5.11.22 what is timeclip??? in 2.6.0.5
; 547  :       if (pixelsize == 1) {
; 548  :         FlowInterExtra<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	push	DWORD PTR [ebx+712]
	mov	eax, DWORD PTR _pSrc$1$[ebp]
	push	DWORD PTR [ebx+696]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	DWORD PTR [ebx+704]
	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR [ebx+688]
	mov	ecx, DWORD PTR _pDst$1$[ebp]
	push	DWORD PTR [ebx+104]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+800]
	push	DWORD PTR [ebx+788]
	push	DWORD PTR [ebx+680]
	push	DWORD PTR [ebx+664]
	push	DWORD PTR [ebx+672]
	push	DWORD PTR [ebx+656]
	push	DWORD PTR _nRefPitches$1$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	cmp	DWORD PTR [ebx+136], 1
	push	eax
	jne	$LN37@GetFrame
	call	??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned char>

; 549  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 550  :           nWidth, nHeight, time256, nPel, VXFullYBB, VXFullYFF, VYFullYBB, VYFullYFF);
; 551  :         FlowInterExtra<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+716]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [ebx+700]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+708]
	mov	edi, DWORD PTR _pDst$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+692]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	mov	ecx, edi
	push	DWORD PTR [ebx+104]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned char>
	add	esp, 144				; 00000090H

; 552  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 553  :           nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 554  :         FlowInterExtra<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+692]
	push	DWORD PTR [ebx+104]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInterExtra@E@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned char>
	add	esp, 72					; 00000048H

; 555  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 556  :           nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 557  :       }
; 558  :       else {

	jmp	$LN40@GetFrame
$LN37@GetFrame:

; 559  :         FlowInterExtra<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	call	??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned short>

; 560  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 561  :           nWidth, nHeight, time256, nPel, VXFullYBB, VXFullYFF, VYFullYBB, VYFullYFF);
; 562  :         FlowInterExtra<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+716]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [ebx+700]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+708]
	mov	edi, DWORD PTR _pDst$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+692]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	mov	ecx, edi
	push	DWORD PTR [ebx+104]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned short>
	add	esp, 144				; 00000090H

; 563  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 564  :           nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 565  :         FlowInterExtra<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+716]
	push	DWORD PTR [ebx+700]
	push	DWORD PTR [ebx+708]
	push	DWORD PTR [ebx+692]
	push	DWORD PTR [ebx+104]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInterExtra@G@@YAXPAEHPBE1HPAF22200HHHHH2222@Z ; FlowInterExtra<unsigned short>
	add	esp, 72					; 00000048H

; 566  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 567  :           nWidthUV, nHeightUV, time256, nPel, VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 568  :       }
; 569  :     /* 2.6.0.5? removed at 2.5.11.22 merge
; 570  :       if (timeclip == 0)
; 571  :       {
; 572  :         FlowInterExtra(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],
; 573  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 574  :           nWidth, nHeight, nPel, t256_prov_cst,
; 575  :           VXFullYBB, VXFullYFF, VYFullYBB, VYFullYFF);
; 576  :         FlowInterExtra(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],
; 577  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 578  :           nWidthUV, nHeightUV, nPel, t256_prov_cst,
; 579  :           VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 580  :         FlowInterExtra(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],
; 581  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 582  :           nWidthUV, nHeightUV, nPel, t256_prov_cst,
; 583  :           VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 584  :       }
; 585  :       else
; 586  :       {
; 587  :         FlowInterExtra(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],
; 588  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 589  :           nWidth, nHeight, nPel,
; 590  :           Time256ProviderPlane (pt256 [0], nt256Pitches [0], LUTVB, LUTVF),
; 591  :           VXFullYBB, VXFullYFF, VYFullYBB, VYFullYFF);
; 592  :         FlowInterExtra(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],
; 593  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 594  :           nWidthUV, nHeightUV, nPel,
; 595  :           Time256ProviderPlane (pt256 [1], nt256Pitches [1], LUTVB, LUTVF),
; 596  :           VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 597  :         FlowInterExtra(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],
; 598  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 599  :           nWidthUV, nHeightUV, nPel,
; 600  :           Time256ProviderPlane (pt256 [2], nt256Pitches [2], LUTVB, LUTVF),
; 601  :           VXFullUVBB, VXFullUVFF, VYFullUVBB, VYFullUVFF);
; 602  :       }
; 603  :       */
; 604  :     }
; 605  :     else // bad extra frames, use old method without extra frames

	jmp	$LN40@GetFrame
$LN33@GetFrame:

; 606  :     {
; 607  :       // back to 2.5.11.22 what is timeclip??? in 2.6.0.5
; 608  :       if (pixelsize == 1) {
; 609  :         FlowInter<uint8_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	push	DWORD PTR [ebx+104]
	mov	eax, DWORD PTR _pSrc$1$[ebp]
	push	DWORD PTR [ebx+632]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	push	DWORD PTR [ebx+96]
	mov	edx, DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR [ebx+92]
	mov	ecx, DWORD PTR _pDst$1$[ebp]
	push	DWORD PTR [ebx+824]
	push	DWORD PTR [ebx+800]
	push	DWORD PTR [ebx+788]
	push	DWORD PTR [ebx+680]
	push	DWORD PTR [ebx+664]
	push	DWORD PTR [ebx+672]
	push	DWORD PTR [ebx+656]
	push	DWORD PTR _nRefPitches$1$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$1$[ebp]
	add	eax, DWORD PTR _nOffsetY$1$[ebp]
	cmp	DWORD PTR [ebx+136], 1
	push	eax
	jne	$LN39@GetFrame
	call	??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned char>

; 610  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 611  :           nWidth, nHeight, time256, nPel);
; 612  :         FlowInter<uint8_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+104]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [ebx+632]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+820]
	mov	edi, DWORD PTR _pDst$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+816]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	mov	ecx, edi
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned char>
	add	esp, 112				; 00000070H

; 613  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 614  :           nWidthUV, nHeightUV, time256, nPel);
; 615  :         FlowInter<uint8_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+104]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInter@E@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned char>

; 616  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 617  :           nWidthUV, nHeightUV, time256, nPel);
; 618  :       }
; 619  :       else { // pixelsize == 2

	jmp	$LN669@GetFrame
$LN39@GetFrame:

; 620  :         FlowInter<uint16_t>(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],

	call	??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned short>

; 621  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 622  :           nWidth, nHeight, time256, nPel);
; 623  :         FlowInter<uint16_t>(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],

	push	DWORD PTR [ebx+104]
	mov	esi, DWORD PTR _nOffsetUV$1$[ebp]
	push	DWORD PTR [ebx+632]
	mov	eax, DWORD PTR _pSrc$4$[ebp]
	push	DWORD PTR [ebx+820]
	mov	edi, DWORD PTR _pDst$3$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+816]
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	mov	ecx, edi
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$4$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$4$[ebp]
	add	eax, esi
	push	eax
	call	??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned short>
	add	esp, 112				; 00000070H

; 624  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 625  :           nWidthUV, nHeightUV, time256, nPel);
; 626  :         FlowInter<uint16_t>(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],

	mov	eax, DWORD PTR _pSrc$6$[ebp]
	mov	edx, DWORD PTR _nDstPitches$5$[ebp]
	add	eax, esi
	push	DWORD PTR [ebx+104]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+828]
	push	DWORD PTR [ebx+804]
	push	DWORD PTR [ebx+792]
	push	DWORD PTR [ebx+684]
	push	DWORD PTR [ebx+668]
	push	DWORD PTR [ebx+676]
	push	DWORD PTR [ebx+660]
	push	DWORD PTR _nRefPitches$6$[ebp]
	push	eax
	mov	eax, DWORD PTR _pRef$6$[ebp]
	add	eax, esi
	mov	esi, DWORD PTR _pDst$5$[ebp]
	push	eax
	mov	ecx, esi
	call	??$FlowInter@G@@YAXPAEHPBE1HPAF22200HHHHH@Z ; FlowInter<unsigned short>
$LN669@GetFrame:
	add	esp, 56					; 00000038H
$LN40@GetFrame:

; 627  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 628  :           nWidthUV, nHeightUV, time256, nPel);
; 629  :       }
; 630  : 
; 631  :     /* 2.6.0.5? removed at 2.5.11.22 merge
; 632  :     if (timeclip == 0)
; 633  :       {
; 634  :         FlowInter(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],
; 635  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 636  :           nWidth, nHeight, nPel, t256_prov_cst);
; 637  :         FlowInter(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],
; 638  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 639  :           nWidthUV, nHeightUV, nPel, t256_prov_cst);
; 640  :         FlowInter(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],
; 641  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 642  :           nWidthUV, nHeightUV, nPel, t256_prov_cst);
; 643  :       }
; 644  :       else
; 645  :       {
; 646  :         FlowInter(pDst[0], nDstPitches[0], pRef[0] + nOffsetY, pSrc[0] + nOffsetY, nRefPitches[0],
; 647  :           VXFullYB, VXFullYF, VYFullYB, VYFullYF, MaskFullYB, MaskFullYF, VPitchY,
; 648  :           nWidth, nHeight, nPel,
; 649  :           Time256ProviderPlane (pt256 [0], nt256Pitches [0], LUTVB, LUTVF));
; 650  :         FlowInter(pDst[1], nDstPitches[1], pRef[1] + nOffsetUV, pSrc[1] + nOffsetUV, nRefPitches[1],
; 651  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 652  :           nWidthUV, nHeightUV, nPel,
; 653  :           Time256ProviderPlane (pt256 [1], nt256Pitches [1], LUTVB, LUTVF));
; 654  :         FlowInter(pDst[2], nDstPitches[2], pRef[2] + nOffsetUV, pSrc[2] + nOffsetUV, nRefPitches[2],
; 655  :           VXFullUVB, VXFullUVF, VYFullUVB, VYFullUVF, MaskFullUVB, MaskFullUVF, VPitchUV,
; 656  :           nWidthUV, nHeightUV, nPel,
; 657  :           Time256ProviderPlane (pt256 [2], nt256Pitches [2], LUTVB, LUTVF));
; 658  :       }
; 659  :       */
; 660  :     }
; 661  : 
; 662  :     if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN370@GetFrame
	cmp	BYTE PTR [ebx+653], 0
	jne	SHORT $LN370@GetFrame

; 664  :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	al, BYTE PTR [ebx+652]
	mov	ecx, DWORD PTR [ebx+96]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	test	al, al
; File c:\github\mvtools\sources\mvflowinter.cpp

; 664  :       YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	mov	edx, DWORD PTR [ebx+92]
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	mov	eax, DWORD PTR _pDst$1$[ebp]
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	je	SHORT $LN369@GetFrame
; File c:\github\mvtools\sources\commonfunctions.h

; 131  :   return (bool)IS_PTR_ALIGNED(ptr, align);

	test	al, 15					; 0000000fH
; File c:\github\mvtools\sources\yuy2planes.cpp

; 154  :   if (sse2 && IsPtrAligned(srcY, 16)) {

	jne	SHORT $LN369@GetFrame

; 155  :     //U and V don't have to be aligned since we user movq to read from those
; 156  :     convert_yv16_to_yuy2_sse2(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	ecx
	push	edx
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	edx, edi
	mov	ecx, eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	esi
	call	?convert_yv16_to_yuy2_sse2@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_sse2

; 157  :   }
; 158  :   else

	jmp	SHORT $LN670@GetFrame
$LN369@GetFrame:

; 159  :   {
; 160  :     convert_yv16_to_yuy2_c(srcY, srcU, srcV, pDstYUY2, srcPitch, srcPitchUV, nDstPitchYUY2, nWidth, nHeight);

	push	ecx
	push	edx
	push	DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	edx, edi
	mov	ecx, eax
	push	DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$1$[ebp]
	push	DWORD PTR _pDstYUY2$1$[ebp]
	push	esi
	call	?convert_yv16_to_yuy2_c@@YAXPBE00PAEIIIII@Z ; convert_yv16_to_yuy2_c
$LN670@GetFrame:
	add	esp, 28					; 0000001cH
$LN370@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	eax, eax
	je	SHORT $LN376@GetFrame
	cmp	DWORD PTR [eax], 256			; 00000100H
	jbe	SHORT $LN376@GetFrame
	mov	eax, DWORD PTR [eax+256]
	lea	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	ecx, esi
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN376@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 9
	test	eax, eax
	je	SHORT $LN380@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN380@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvBB$9[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN380@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	eax, eax
	je	SHORT $LN385@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN385@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvFF$7[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN385@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	eax, eax
	je	SHORT $LN390@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN390@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN390@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	eax, eax
	je	SHORT $LN395@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN395@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN395@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	eax, eax
	je	SHORT $LN400@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN400@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN400@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	test	eax, eax
	je	SHORT $LN405@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	SHORT $LN405@GetFrame
	mov	eax, DWORD PTR [eax+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN405@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	eax, eax
	je	$LN631@GetFrame
	cmp	DWORD PTR [eax], 272			; 00000110H
	jbe	$LN631@GetFrame
	mov	edx, DWORD PTR [eax+272]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 667  :     return dst;

	jmp	$LN671@GetFrame
$LN23@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 675  :     PVideoFrame src = child->GetFrame(n, env); // it is easy to use child here - v2.0

	lea	edx, DWORD PTR _src$11[ebp]
	push	edi
	push	DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H

; 676  : 
; 677  :     if (blend) //let's blend src with ref frames like ConvertFPS

	cmp	BYTE PTR [ebx+654], 0
	je	$LN42@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 679  :       PVideoFrame ref = child->GetFrame(nref, env);

	lea	edx, DWORD PTR _ref$13[ebp]
	push	edi
	push	DWORD PTR _nref$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H

; 686  :       if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [ebx+116]
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvflowinter.cpp

; 686  :       if ((pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2)

	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN44@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN421@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN421@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$2$[ebp], eax
	jmp	SHORT $LN422@GetFrame
$LN421@GetFrame:
	mov	DWORD PTR _pSrc$2$[ebp], 0
$LN422@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN427@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN427@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$1$[ebp], eax
	jmp	SHORT $LN428@GetFrame
$LN427@GetFrame:
	mov	DWORD PTR _nSrcPitches$1$[ebp], 0
$LN428@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN433@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN433@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$2$[ebp], eax
	jmp	SHORT $LN434@GetFrame
$LN433@GetFrame:
	mov	DWORD PTR _pRef$2$[ebp], 0
$LN434@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN439@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN439@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$2$[ebp], eax
	jmp	SHORT $LN440@GetFrame
$LN439@GetFrame:
	mov	DWORD PTR _nRefPitches$2$[ebp], 0
$LN440@GetFrame:

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN445@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN445@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN446@GetFrame
$LN445@GetFrame:
	xor	edi, edi
$LN446@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN451@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN451@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN452@GetFrame
$LN451@GetFrame:
	xor	eax, eax
$LN452@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 695  :         Blend<uint8_t>(pDstYUY2, pSrc[0], pRef[0], nHeight, nWidth * 2, nDstPitchYUY2, nSrcPitches[0], nRefPitches[0], time256, isse);

	mov	edx, DWORD PTR _pSrc$2$[ebp]
	push	ecx
	push	DWORD PTR [ebx+632]
	mov	ecx, edi
	push	DWORD PTR _nRefPitches$2$[ebp]
	push	DWORD PTR _nSrcPitches$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	add	eax, eax
	push	eax
	push	DWORD PTR [ebx+96]
	push	DWORD PTR _pRef$2$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 696  : 
; 697  :     /* 2.6.0.5? removed at 2.5.11.22 merge
; 698  :     if (timeclip == 0)
; 699  :         {
; 700  :           const Time256ProviderCst	t256_provider (time256, 0, 0);
; 701  :           Blend(pDstYUY2, pSrc[0], pRef[0], nHeight, nWidth*2,
; 702  :             nDstPitchYUY2, nSrcPitches[0], nRefPitches[0],
; 703  :             t256_provider, isse);
; 704  :         }
; 705  :         else
; 706  :         {
; 707  :           pt256[0] = t256->GetReadPtr();
; 708  :           nt256Pitches[0] = t256->GetPitch();
; 709  : 
; 710  :           Blend(pDstYUY2, pSrc[0], pRef[0], nHeight, nWidth*2,
; 711  :             nDstPitchYUY2, nSrcPitches[0], nRefPitches[0],
; 712  :             Time256ProviderPlane (pt256[0], nt256Pitches[0], 0, 0), isse);
; 713  :         }
; 714  :         */
; 715  :       }
; 716  : 
; 717  :       else

	jmp	$LN672@GetFrame
$LN44@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN457@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN457@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$2$[ebp], eax
	jmp	SHORT $LN458@GetFrame
$LN457@GetFrame:
	mov	DWORD PTR _pDst$2$[ebp], 0
$LN458@GetFrame:
	test	esi, esi
	je	SHORT $LN463@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN463@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$4$[ebp], eax
	jmp	SHORT $LN464@GetFrame
$LN463@GetFrame:
	mov	DWORD PTR _pDst$4$[ebp], 0
$LN464@GetFrame:
	test	esi, esi
	je	SHORT $LN469@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN469@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$6$[ebp], eax
	jmp	SHORT $LN470@GetFrame
$LN469@GetFrame:
	mov	DWORD PTR _pDst$6$[ebp], 0
$LN470@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN475@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN475@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	jmp	SHORT $LN476@GetFrame
$LN475@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN476@GetFrame:
	test	esi, esi
	je	SHORT $LN481@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN481@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$4$[ebp], eax
	jmp	SHORT $LN482@GetFrame
$LN481@GetFrame:
	mov	DWORD PTR _nDstPitches$4$[ebp], 0
$LN482@GetFrame:
	test	esi, esi
	je	SHORT $LN487@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN487@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$6$[ebp], eax
	jmp	SHORT $LN488@GetFrame
$LN487@GetFrame:
	mov	DWORD PTR _nDstPitches$6$[ebp], 0
$LN488@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN493@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN493@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$3$[ebp], eax
	jmp	SHORT $LN494@GetFrame
$LN493@GetFrame:
	mov	DWORD PTR _pRef$3$[ebp], 0
$LN494@GetFrame:
	test	esi, esi
	je	SHORT $LN499@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN499@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$5$[ebp], eax
	jmp	SHORT $LN500@GetFrame
$LN499@GetFrame:
	mov	DWORD PTR _pRef$5$[ebp], 0
$LN500@GetFrame:
	test	esi, esi
	je	SHORT $LN505@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN505@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pRef$7$[ebp], eax
	jmp	SHORT $LN506@GetFrame
$LN505@GetFrame:
	mov	DWORD PTR _pRef$7$[ebp], 0
$LN506@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN511@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN511@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$3$[ebp], eax
	jmp	SHORT $LN512@GetFrame
$LN511@GetFrame:
	mov	DWORD PTR _nRefPitches$3$[ebp], 0
$LN512@GetFrame:
	test	esi, esi
	je	SHORT $LN517@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN517@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$5$[ebp], eax
	jmp	SHORT $LN518@GetFrame
$LN517@GetFrame:
	mov	DWORD PTR _nRefPitches$5$[ebp], 0
$LN518@GetFrame:
	test	esi, esi
	je	SHORT $LN523@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN523@GetFrame
	mov	ecx, DWORD PTR _ref$13[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nRefPitches$7$[ebp], eax
	jmp	SHORT $LN524@GetFrame
$LN523@GetFrame:
	mov	DWORD PTR _nRefPitches$7$[ebp], 0
$LN524@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN529@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN529@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$3$[ebp], eax
	jmp	SHORT $LN530@GetFrame
$LN529@GetFrame:
	mov	DWORD PTR _pSrc$3$[ebp], 0
$LN530@GetFrame:
	test	esi, esi
	je	SHORT $LN535@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN535@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$5$[ebp], eax
	jmp	SHORT $LN536@GetFrame
$LN535@GetFrame:
	mov	DWORD PTR _pSrc$5$[ebp], 0
$LN536@GetFrame:
	test	esi, esi
	je	SHORT $LN541@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN541@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$7$[ebp], eax
	jmp	SHORT $LN542@GetFrame
$LN541@GetFrame:
	mov	DWORD PTR _pSrc$7$[ebp], 0
$LN542@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN547@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN547@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$2$[ebp], eax
	jmp	SHORT $LN548@GetFrame
$LN547@GetFrame:
	mov	DWORD PTR _nSrcPitches$2$[ebp], 0
$LN548@GetFrame:
	test	esi, esi
	je	SHORT $LN553@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN553@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$3$[ebp], eax
	jmp	SHORT $LN554@GetFrame
$LN553@GetFrame:
	mov	DWORD PTR _nSrcPitches$3$[ebp], 0
$LN554@GetFrame:
	test	esi, esi
	je	SHORT $LN559@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN559@GetFrame
	mov	ecx, DWORD PTR _src$11[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	edi, eax
	jmp	SHORT $LN560@GetFrame
$LN559@GetFrame:
	xor	edi, edi
$LN560@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 741  :         if (pixelsize == 1) {

	cmp	DWORD PTR [ebx+136], 1

; 742  :           Blend<uint8_t>(pDst[0], pSrc[0], pRef[0], nHeight, nWidth, nDstPitches[0], nSrcPitches[0], nRefPitches[0], time256, isse);

	mov	edx, DWORD PTR _pSrc$3$[ebp]
	push	ecx
	push	DWORD PTR [ebx+632]
	mov	ecx, DWORD PTR _pDst$2$[ebp]
	push	DWORD PTR _nRefPitches$3$[ebp]
	push	DWORD PTR _nSrcPitches$2$[ebp]
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR [ebx+92]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR _pRef$3$[ebp]
	jne	SHORT $LN46@GetFrame
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 743  :           Blend<uint8_t>(pDst[1], pSrc[1], pRef[1], nHeightUV, nWidthUV, nDstPitches[1], nSrcPitches[1], nRefPitches[1], time256, isse);

	mov	edx, DWORD PTR _pSrc$5$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$4$[ebp]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR _nRefPitches$5$[ebp]
	push	DWORD PTR _nSrcPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$4$[ebp]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR _pRef$5$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 744  :           Blend<uint8_t>(pDst[2], pSrc[2], pRef[2], nHeightUV, nWidthUV, nDstPitches[2], nSrcPitches[2], nRefPitches[2], time256, isse);

	mov	edx, DWORD PTR _pSrc$7$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$6$[ebp]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR _nRefPitches$7$[ebp]
	push	edi
	push	DWORD PTR _nDstPitches$6$[ebp]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR _pRef$7$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 745  :         }
; 746  :         else { // pixelsize == 2

	jmp	SHORT $LN672@GetFrame
$LN46@GetFrame:

; 747  :           Blend<uint16_t>(pDst[0], pSrc[0], pRef[0], nHeight, nWidth, nDstPitches[0], nSrcPitches[0], nRefPitches[0], time256, isse);

	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>

; 748  :           Blend<uint16_t>(pDst[1], pSrc[1], pRef[1], nHeightUV, nWidthUV, nDstPitches[1], nSrcPitches[1], nRefPitches[1], time256, isse);

	mov	edx, DWORD PTR _pSrc$5$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$4$[ebp]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR _nRefPitches$5$[ebp]
	push	DWORD PTR _nSrcPitches$3$[ebp]
	push	DWORD PTR _nDstPitches$4$[ebp]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR _pRef$5$[ebp]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>

; 749  :           Blend<uint16_t>(pDst[2], pSrc[2], pRef[2], nHeightUV, nWidthUV, nDstPitches[2], nSrcPitches[2], nRefPitches[2], time256, isse);

	mov	edx, DWORD PTR _pSrc$7$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _pDst$6$[ebp]
	push	DWORD PTR [ebx+632]
	push	DWORD PTR _nRefPitches$7$[ebp]
	push	edi
	push	DWORD PTR _nDstPitches$6$[ebp]
	push	DWORD PTR [ebx+816]
	push	DWORD PTR [ebx+820]
	push	DWORD PTR _pRef$7$[ebp]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
$LN672@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\mvflowinter.cpp

; 749  :           Blend<uint16_t>(pDst[2], pSrc[2], pRef[2], nHeightUV, nWidthUV, nDstPitches[2], nSrcPitches[2], nRefPitches[2], time256, isse);

	add	esp, 32					; 00000020H
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	esi, esi
	je	SHORT $LN563@GetFrame
	cmp	DWORD PTR [esi], 256			; 00000100H
	jbe	SHORT $LN563@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [esi+256]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN563@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	test	esi, esi
	je	SHORT $LN567@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN567@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _ref$13[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN567@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	test	esi, esi
	je	SHORT $LN572@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN572@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$11[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN572@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	test	esi, esi
	je	SHORT $LN577@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN577@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN577@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	test	esi, esi
	je	SHORT $LN582@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN582@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN582@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	test	esi, esi
	je	SHORT $LN587@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN587@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN587@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	test	esi, esi
	je	SHORT $LN592@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN592@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN592@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 24		; 00000018H
	test	esi, esi
	je	SHORT $LN597@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN597@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN597@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 785  :       return dst;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 793  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN42@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	test	edx, edx
	je	SHORT $LN602@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN602@GetFrame
	lea	eax, DWORD PTR _src$11[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN602@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	test	edx, edx
	je	SHORT $LN606@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN606@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$11[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN606@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	test	edx, edx
	je	SHORT $LN611@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN611@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _ref$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN611@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	test	edx, edx
	je	SHORT $LN616@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN616@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN616@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	test	edx, edx
	je	SHORT $LN621@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN621@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvB$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN621@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	test	edx, edx
	je	SHORT $LN626@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN626@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvF$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN626@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 30		; 0000001eH
	test	edx, edx
	je	SHORT $LN631@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN631@GetFrame
	mov	edx, DWORD PTR [edx+272]
$LN671@GetFrame:
	lea	ecx, DWORD PTR _dst$[ebp]
	call	edx
$LN631@GetFrame:
; File c:\github\mvtools\sources\mvflowinter.cpp

; 793  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _dst$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _mvF$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _mvB$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR _ref$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6:
	lea	ecx, DWORD PTR _mvFF$7[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7:
	lea	ecx, DWORD PTR _mvBB$9[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$20:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$21:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$25:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$9:
	lea	ecx, DWORD PTR _src$11[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$10:
	lea	ecx, DWORD PTR _ref$13[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$27:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$28:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$29:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$30:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$31:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$32:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$33:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$34:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$35:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$36:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$37:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$38:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$39:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVFlowInter@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVFlowInter::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ??$AlignNumber@H@@YAHHH@Z
_TEXT	SEGMENT
??$AlignNumber@H@@YAHHH@Z PROC				; AlignNumber<int>, COMDAT
; _n$ = ecx
; _align$dead$ = edx

; 137  :   assert(IS_POWER2(align));
; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [ecx+15]
	and	eax, -16				; fffffff0H

; 139  : }

	ret	0
??$AlignNumber@H@@YAHHH@Z ENDP				; AlignNumber<int>
_TEXT	ENDS
END
