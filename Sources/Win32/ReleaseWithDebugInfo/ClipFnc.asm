; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\clipfnc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DA@HILKLKFM@?$CFs?3?5unsupported?5colorspace?5for?5t@ ; `string'
PUBLIC	??_C@_05HJLHGJPL@rgb32?$AA@			; `string'
PUBLIC	??_C@_05COCPKEEK@rgb24?$AA@			; `string'
PUBLIC	??_C@_04CHKONNFM@yuy2?$AA@			; `string'
EXTRN	__imp___stricmp:PROC
;	COMDAT ??_C@_04CHKONNFM@yuy2?$AA@
CONST	SEGMENT
??_C@_04CHKONNFM@yuy2?$AA@ DB 'yuy2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05COCPKEEK@rgb24?$AA@
CONST	SEGMENT
??_C@_05COCPKEEK@rgb24?$AA@ DB 'rgb24', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HJLHGJPL@rgb32?$AA@
CONST	SEGMENT
??_C@_05HJLHGJPL@rgb32?$AA@ DB 'rgb32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HILKLKFM@?$CFs?3?5unsupported?5colorspace?5for?5t@
CONST	SEGMENT
??_C@_0DA@HILKLKFM@?$CFs?3?5unsupported?5colorspace?5for?5t@ DB '%s: unsu'
	DB	'pported colorspace for the vector clip.', 00H ; `string'
PUBLIC	?interpolate_thsad@ClipFnc@@SAHHHHH@Z		; ClipFnc::interpolate_thsad
PUBLIC	?compute_mvclip_best_width@ClipFnc@@SAHHHH@Z	; ClipFnc::compute_mvclip_best_width
PUBLIC	?format_vector_clip@ClipFnc@@SAXAAUVideoInfo@@_NHPBDH2AAVIScriptEnvironment@@@Z ; ClipFnc::format_vector_clip
PUBLIC	?compute_fieldshift@ClipFnc@@SAHAAVPClip@@_NHHH@Z ; ClipFnc::compute_fieldshift
PUBLIC	??CPClip@@QBEPAVIClip@@XZ			; PClip::operator->
PUBLIC	?BitsPerPixel@VideoInfo@@QBEHXZ			; VideoInfo::BitsPerPixel
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?gcd@@YA_J_J0@Z
_TEXT	SEGMENT
_shift$1$ = 8						; size = 4
_u$ = 8							; size = 8
_v$ = 16						; size = 8
?gcd@@YA_J_J0@Z PROC					; gcd, COMDAT

; 41   :  {

	push	ebx

; 42   :      int shift;
; 43   : 
; 44   :      /* GCD(0,x) := x */
; 45   :      if (u == 0 || v == 0)

	mov	ebx, DWORD PTR _u$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _u$[esp+4]
	mov	eax, ebp
	push	esi
	or	eax, ebx
	mov	eax, DWORD PTR _v$[esp+12]
	push	edi
	mov	edi, DWORD PTR _v$[esp+12]
	je	$LN13@gcd
	mov	ecx, edi
	or	ecx, eax
	je	$LN13@gcd

; 47   : 
; 48   :      /* Let shift := lg K, where K is the greatest power of 2
; 49   :         dividing both u and v. */
; 50   :      for (shift = 0; ((u | v) & 1) == 0; ++shift) {

	mov	ecx, ebp
	xor	edx, edx
	or	ecx, edi
	mov	DWORD PTR _shift$1$[esp+12], edx
	and	ecx, 1
	or	ecx, edx
	jne	SHORT $LN18@gcd
	npad	7
$LL4@gcd:

; 51   :          u >>= 1;

	shrd	ebp, ebx, 1

; 52   :          v >>= 1;

	shrd	edi, eax, 1
	mov	ecx, ebp
	sar	ebx, 1
	or	ecx, edi
	sar	eax, 1
	and	ecx, 1
	inc	edx
	or	ecx, 0
	je	SHORT $LL4@gcd
	mov	DWORD PTR _shift$1$[esp+12], edx
$LN18@gcd:

; 53   :      }
; 54   : 
; 55   :      while ((u & 1) == 0)

	mov	ecx, ebp
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LL9@gcd
$LL5@gcd:

; 56   :        u >>= 1;

	shrd	ebp, ebx, 1
	mov	ecx, ebp
	sar	ebx, 1
	and	ecx, 1
	or	ecx, 0
	je	SHORT $LL5@gcd
$LL9@gcd:

; 57   : 
; 58   :      /* From here on, u is always odd. */
; 59   :      do {
; 60   :          while ((v & 1) == 0)  /* Loop X */

	mov	ecx, edi
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN11@gcd
$LL10@gcd:

; 61   :            v >>= 1;

	shrd	edi, eax, 1
	mov	ecx, edi
	sar	eax, 1
	and	ecx, 1
	or	ecx, 0
	je	SHORT $LL10@gcd
$LN11@gcd:

; 62   : 
; 63   :          /* Now u and v are both odd, so diff(u, v) is even.
; 64   :             Let u = min(u, v), v = diff(u, v)/2. */
; 65   :          if (u < v) {

	cmp	ebx, eax
	jg	SHORT $LN14@gcd
	jl	SHORT $LN40@gcd
	cmp	ebp, edi
	jae	SHORT $LN14@gcd
$LN40@gcd:

; 66   :              v -= u;

	sub	edi, ebp
	sbb	eax, ebx

; 67   :          } else {

	jmp	SHORT $LN15@gcd
$LN14@gcd:

; 68   :              __int64 diff = u - v;

	sub	ebp, edi
	mov	ecx, ebp

; 69   :              u = v;

	mov	ebp, edi
	sbb	ebx, eax

; 70   :              v = diff;

	mov	edi, ecx
	mov	edx, ebx
	mov	ebx, eax
	mov	eax, edx
$LN15@gcd:

; 71   :          }
; 72   :          v >>= 1;

	shrd	edi, eax, 1
	sar	eax, 1

; 73   :      } while (v != 0);

	mov	esi, edi
	or	esi, eax
	jne	SHORT $LL9@gcd

; 74   : 
; 75   :      return u << shift;

	mov	ecx, DWORD PTR _shift$1$[esp+12]
	mov	eax, ebp
	mov	edx, ebx

; 76   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 74   : 
; 75   :      return u << shift;

	jmp	__allshl
$LN13@gcd:

; 46   :        return u | v;

	or	ebp, edi
	or	ebx, eax

; 76   : }

	pop	edi
	pop	esi
	mov	eax, ebp
	mov	edx, ebx
	pop	ebp
	pop	ebx
	ret	0
?gcd@@YA_J_J0@Z ENDP					; gcd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?lcm@@YA_J_J0@Z
_TEXT	SEGMENT
_u$ = 8							; size = 8
_v$ = 16						; size = 8
?lcm@@YA_J_J0@Z PROC					; lcm, COMDAT

; 80   : {

	push	ecx
	push	esi
	push	edi

; 81   : 	const __int64		prod = u * v;
; 82   : 	const __int64		gcd_uv = gcd (u, v);

	push	DWORD PTR _v$[esp+12]
	push	DWORD PTR _v$[esp+12]
	push	DWORD PTR _u$[esp+20]
	push	DWORD PTR _u$[esp+20]
	call	?gcd@@YA_J_J0@Z				; gcd
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	esi, edx
	push	DWORD PTR _v$[esp+12]
	push	DWORD PTR _v$[esp+12]
	push	DWORD PTR _u$[esp+20]
	push	DWORD PTR _u$[esp+20]
	call	__allmul

; 83   : 	const __int64		lcm_uv = prod / gcd_uv;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldiv

; 84   : 
; 85   : 	return (lcm_uv);
; 86   : }

	pop	edi
	pop	esi
	pop	ecx
	ret	0
?lcm@@YA_J_J0@Z ENDP					; lcm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ?BitsPerPixel@VideoInfo@@QBEHXZ
_TEXT	SEGMENT
?BitsPerPixel@VideoInfo@@QBEHXZ PROC			; VideoInfo::BitsPerPixel, COMDAT
; _this$ = ecx

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN3@BitsPerPix
	cmp	DWORD PTR [eax], 152			; 00000098H
	jbe	SHORT $LN3@BitsPerPix
	mov	eax, DWORD PTR [eax+152]
	jmp	eax
$LN3@BitsPerPix:
	xor	eax, eax
	ret	0
?BitsPerPixel@VideoInfo@@QBEHXZ ENDP			; VideoInfo::BitsPerPixel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??CPClip@@QBEPAVIClip@@XZ
_TEXT	SEGMENT
??CPClip@@QBEPAVIClip@@XZ PROC				; PClip::operator->, COMDAT
; _this$ = ecx

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ecx]
	ret	0
??CPClip@@QBEPAVIClip@@XZ ENDP				; PClip::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\clipfnc.cpp
;	COMDAT ?compute_fieldshift@ClipFnc@@SAHAAVPClip@@_NHHH@Z
_TEXT	SEGMENT
_nsrc$ = 8						; size = 4
_nref$ = 12						; size = 4
?compute_fieldshift@ClipFnc@@SAHAAVPClip@@_NHHH@Z PROC	; ClipFnc::compute_fieldshift, COMDAT
; _clp$ = ecx
; _npel$ = edx

; 45   : {

	push	ebp
	push	esi
	mov	esi, edx
	mov	ebp, ecx

; 46   : 	assert (clp != 0);
; 47   : 	assert (npel > 0);
; 48   : 	assert (nsrc >= 0);
; 49   : 	assert (nsrc < clp->GetVideoInfo ().num_frames);
; 50   : 	assert (nref >= 0);
; 51   : 	assert (nref < clp->GetVideoInfo ().num_frames);
; 52   : 
; 53   : 	int				fieldshift = 0;
; 54   : 
; 55   : 	if (field_flag && npel > 1 && ((nsrc - nref) & 1) != 0)

	cmp	esi, 1
	jle	SHORT $LN18@compute_fi
	mov	edx, DWORD PTR _nsrc$[esp+4]
	mov	eax, edx
	sub	eax, DWORD PTR _nref$[esp+4]
	test	al, 1
	je	SHORT $LN18@compute_fi
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebp]
	push	ebx
; File c:\github\mvtools\sources\clipfnc.cpp

; 57   : 		const bool		parity_src = clp->GetParity (nsrc);

	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 58   : 		const bool		parity_ref = clp->GetParity (nref);

	push	DWORD PTR _nref$[esp+8]
	mov	bl, al
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebp]
; File c:\github\mvtools\sources\clipfnc.cpp

; 58   : 		const bool		parity_ref = clp->GetParity (nref);

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 59   : 
; 60   : 		if (parity_src && ! parity_ref)

	test	bl, bl
	pop	ebx
	je	SHORT $LN3@compute_fi
	test	al, al
	jne	SHORT $LN18@compute_fi

; 61   : 		{
; 62   : 			fieldshift = npel / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	pop	esi
	sar	eax, 1
	pop	ebp

; 71   : }

	ret	0
$LN3@compute_fi:

; 63   : 		}
; 64   : 		else if (parity_ref && ! parity_src)

	test	al, al
	je	SHORT $LN18@compute_fi

; 65   : 		{
; 66   : 			fieldshift = -(npel / 2);

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	pop	esi
	neg	eax
	pop	ebp

; 71   : }

	ret	0
$LN18@compute_fi:
	pop	esi

; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	return (fieldshift);

	xor	eax, eax
	pop	ebp

; 71   : }

	ret	0
?compute_fieldshift@ClipFnc@@SAHAAVPClip@@_NHHH@Z ENDP	; ClipFnc::compute_fieldshift
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\clipfnc.cpp
;	COMDAT ?format_vector_clip@ClipFnc@@SAXAAUVideoInfo@@_NHPBDH2AAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_single_line_flag$1$ = -1				; size = 1
_nbr_blk_x$ = 8						; size = 4
_vccs_0$ = 12						; size = 4
_size_bytes$ = 16					; size = 4
_funcname_0$ = 20					; size = 4
_env$ = 24						; size = 4
?format_vector_clip@ClipFnc@@SAXAAUVideoInfo@@_NHPBDH2AAVIScriptEnvironment@@@Z PROC ; ClipFnc::format_vector_clip, COMDAT
; _vi$ = ecx
; _single_line_flag$ = dl

; 79   : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 80   : 	assert (&vi != 0);
; 81   : 	assert (nbr_blk_x > 0);
; 82   : 	assert (size_bytes > 0);
; 83   : 	assert (funcname_0 != 0);
; 84   : 	assert (&env != 0);
; 85   : 
; 86   : 	int				nbr_pix_per_group = 1;
; 87   : 	if (vccs_0 == 0)

	mov	esi, DWORD PTR _vccs_0$[esp+12]
	mov	ebp, 1
	mov	BYTE PTR _single_line_flag$1$[esp+16], dl
	push	edi
	mov	edi, ecx
	test	esi, esi
	jne	SHORT $LN2@format_vec

; 88   : 	{
; 89   : 		if (   vi.pixel_type != VideoInfo::CS_BGR32
; 90   : 		    && vi.pixel_type != VideoInfo::CS_BGR24
; 91   : 		    && vi.pixel_type != VideoInfo::CS_YUY2)

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, 1342177282				; 50000002H
	je	SHORT $LN11@format_vec
	cmp	eax, 1342177281				; 50000001H
	je	SHORT $LN11@format_vec
	cmp	eax, 1610612740				; 60000004H
	je	SHORT $LN11@format_vec
$LN10@format_vec:

; 92   : 		{
; 93   : 			env.ThrowError (

	mov	eax, DWORD PTR _env$[esp+16]
	push	DWORD PTR _funcname_0$[esp+16]
	push	OFFSET ??_C@_0DA@HILKLKFM@?$CFs?3?5unsupported?5colorspace?5for?5t@
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+20]
	add	esp, 12					; 0000000cH

; 94   : 				"%s: unsupported colorspace for the vector clip.",
; 95   : 				funcname_0
; 96   : 			);
; 97   : 		}
; 98   : 	}

	jmp	SHORT $LN11@format_vec
$LN2@format_vec:

; 99   : 	else if (vccs_0 [0] == '\0' || _stricmp (vccs_0, "rgb32") == 0)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN7@format_vec
	mov	ebx, DWORD PTR __imp___stricmp
	push	OFFSET ??_C@_05HJLHGJPL@rgb32?$AA@
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@format_vec

; 102  : 	}
; 103  : 	else if (_stricmp (vccs_0, "rgb24") == 0)

	push	OFFSET ??_C@_05COCPKEEK@rgb24?$AA@
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@format_vec

; 104  : 	{
; 105  : 		vi.pixel_type = VideoInfo::CS_BGR24;

	mov	DWORD PTR [edi+20], 1342177281		; 50000001H
	jmp	SHORT $LN11@format_vec
$LN8@format_vec:

; 106  : 	}
; 107  : 	else if (_stricmp (vccs_0, "yuy2") == 0)

	push	OFFSET ??_C@_04CHKONNFM@yuy2?$AA@
	push	esi
	call	ebx
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@format_vec

; 108  : 	{
; 109  : 		vi.pixel_type = VideoInfo::CS_YUY2;

	mov	DWORD PTR [edi+20], 1610612740		; 60000004H

; 110  : 		nbr_pix_per_group = 2;

	lea	ebp, DWORD PTR [eax+2]

; 111  : 	}
; 112  : 	else

	jmp	SHORT $LN11@format_vec
$LN7@format_vec:

; 100  : 	{
; 101  : 		vi.pixel_type = VideoInfo::CS_BGR32;

	mov	DWORD PTR [edi+20], 1342177282		; 50000002H
$LN11@format_vec:
; File c:\github\mvtools\sources\include\avisynth.h

; 663  :   int BitsPerPixel() const AVS_BakedCode(return AVS_LinkCall(BitsPerPixel)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN17@format_vec
	cmp	DWORD PTR [eax], 152			; 00000098H
	jbe	SHORT $LN17@format_vec
	mov	eax, DWORD PTR [eax+152]
	mov	ecx, edi
	call	eax
	mov	ebx, eax
	jmp	SHORT $LN18@format_vec
$LN17@format_vec:
	xor	ebx, ebx
$LN18@format_vec:
; File c:\github\mvtools\sources\clipfnc.cpp

; 120  : 	const int		bytes_per_pix = vi.BitsPerPixel () >> 3;

	sar	ebx, 3

; 121  : 	const int		unit_size = bytes_per_pix * nbr_pix_per_group;

	mov	ecx, ebx
	imul	ecx, ebp

; 122  : 
; 123  : 	if (single_line_flag)

	cmp	BYTE PTR _single_line_flag$1$[esp+20], 0
	je	SHORT $LN12@format_vec

; 124  : 	{
; 125  : 		const int		nbr_groups = (size_bytes + unit_size - 1) / unit_size;
; 126  : 		vi.width  = nbr_groups * nbr_pix_per_group;

	mov	eax, DWORD PTR _size_bytes$[esp+16]
	dec	eax

; 127  : 		vi.height = 1;

	mov	DWORD PTR [edi+4], 1
	add	eax, ecx

; 133  : 		vi.width  = width_bytes / bytes_per_pix;
; 134  : 		vi.height = (size_bytes + width_bytes - 1) / width_bytes;
; 135  : 	}
; 136  : 
; 137  : 	vi.audio_samples_per_second = 0; //v1.8.1

	mov	DWORD PTR [edi+24], 0
	cdq
	idiv	ecx
	imul	eax, ebp
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 138  : }

	pop	ecx
	ret	0
$LN12@format_vec:

; 128  : 	}
; 129  : 	else
; 130  : 	{
; 131  : 		const int		width_bytes =
; 132  : 			compute_mvclip_best_width (nbr_blk_x, unit_size, FRAME_ALIGN);

	push	ecx
	mov	edx, ecx
	mov	ecx, DWORD PTR _nbr_blk_x$[esp+20]
	call	?compute_mvclip_best_width@ClipFnc@@SAHHHH@Z ; ClipFnc::compute_mvclip_best_width
	mov	esi, eax

; 133  : 		vi.width  = width_bytes / bytes_per_pix;
; 134  : 		vi.height = (size_bytes + width_bytes - 1) / width_bytes;
; 135  : 	}
; 136  : 
; 137  : 	vi.audio_samples_per_second = 0; //v1.8.1

	mov	DWORD PTR [edi+24], 0
	cdq
	add	esp, 4
	idiv	ebx
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _size_bytes$[esp+16]
	dec	eax
	add	eax, esi
	cdq
	idiv	esi
	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 138  : }

	pop	ecx
	ret	0
?format_vector_clip@ClipFnc@@SAXAAUVideoInfo@@_NHPBDH2AAVIScriptEnvironment@@@Z ENDP ; ClipFnc::format_vector_clip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\clipfnc.cpp
;	COMDAT ?compute_mvclip_best_width@ClipFnc@@SAHHHH@Z
_TEXT	SEGMENT
_v$1$ = -8						; size = 4
_u$1$ = -4						; size = 4
_align$dead$ = 8					; size = 4
?compute_mvclip_best_width@ClipFnc@@SAHHHH@Z PROC	; ClipFnc::compute_mvclip_best_width, COMDAT
; _nbr_blk_x$ = ecx
; _unit_size$ = edx

; 148  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 155  : 	const int		aligned_unit = int (lcm (unit_size, align));

	mov	eax, edx
	mov	ebx, ecx
	cdq
; File c:\github\mvtools\sources\commonfunctions.h

; 82   : 	const __int64		gcd_uv = gcd (u, v);

	push	0
; File c:\github\mvtools\sources\clipfnc.cpp

; 155  : 	const int		aligned_unit = int (lcm (unit_size, align));

	mov	esi, edx
	mov	edi, eax
; File c:\github\mvtools\sources\commonfunctions.h

; 82   : 	const __int64		gcd_uv = gcd (u, v);

	push	32					; 00000020H
	push	esi
	push	edi
	call	?gcd@@YA_J_J0@Z				; gcd
	add	esp, 16					; 00000010H
	shld	esi, edi, 5
	shl	edi, 5

; 83   : 	const __int64		lcm_uv = prod / gcd_uv;

	push	edx
	push	eax
	push	esi
	push	edi
	call	__alldiv
; File c:\github\mvtools\sources\clipfnc.cpp

; 160  : 	const int		best_width = int (lcm (line_width, aligned_unit));	// Guess what

	cdq
	mov	ecx, eax
	mov	ebp, edx
	lea	eax, DWORD PTR [ebx+ebx*2]
	mov	DWORD PTR _v$1$[esp+24], ecx
	shl	eax, 2
	cdq
; File c:\github\mvtools\sources\commonfunctions.h

; 82   : 	const __int64		gcd_uv = gcd (u, v);

	push	ebp
	push	ecx
; File c:\github\mvtools\sources\clipfnc.cpp

; 160  : 	const int		best_width = int (lcm (line_width, aligned_unit));	// Guess what

	mov	ebx, edx
	mov	DWORD PTR _u$1$[esp+32], eax
; File c:\github\mvtools\sources\commonfunctions.h

; 82   : 	const __int64		gcd_uv = gcd (u, v);

	push	ebx
	push	eax
	call	?gcd@@YA_J_J0@Z				; gcd
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	esi, edx
	push	ebp
	push	DWORD PTR _v$1$[esp+28]
	push	ebx
	push	DWORD PTR _u$1$[esp+36]
	call	__allmul

; 83   : 	const __int64		lcm_uv = prod / gcd_uv;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldiv
; File c:\github\mvtools\sources\clipfnc.cpp

; 166  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?compute_mvclip_best_width@ClipFnc@@SAHHHH@Z ENDP	; ClipFnc::compute_mvclip_best_width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\clipfnc.cpp
;	COMDAT ?interpolate_thsad@ClipFnc@@SAHHHHH@Z
_TEXT	SEGMENT
tv176 = -8						; size = 8
tv168 = -8						; size = 8
_d$ = 8							; size = 4
_tr$ = 12						; size = 4
?interpolate_thsad@ClipFnc@@SAHHHHH@Z PROC		; ClipFnc::interpolate_thsad, COMDAT
; _thsad1$ = ecx
; _thsad2$ = edx

; 172  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H

; 173  : 	assert (thsad1 >= 0);
; 174  : 	assert (thsad2 >= 0);
; 175  : 	assert (d >= 0);
; 176  : 	assert (tr >= 0);
; 177  : 	//assert (d <= tr); PF 
; 178  : 
; 179  : 	sad_t			thsad = thsad1;
; 180  : 
; 181  : 	if (d > 1)

	mov	eax, DWORD PTR _d$[ebp]
	sub	esp, 56					; 00000038H
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, edx
	cmp	eax, 1
	jle	$LN4@interpolat

; 182  : 	{
; 183  : 		assert (tr > 1);
; 184  : 		const double   x    = (d - 1) * PI / (tr - 1);

	dec	eax
	movd	xmm0, eax
	mov	eax, DWORD PTR _tr$[ebp]
	cvtdq2pd xmm0, xmm0
	dec	eax
	movd	xmm1, eax
	mulsd	xmm0, QWORD PTR __real@400921fb54442d18
	cvtdq2pd xmm1, xmm1
	divsd	xmm0, xmm1

; 185  : 		const double   lerp = (1 - cos (x)) * 0.5;

	call	__libm_sse2_cos_precise
	movsd	xmm2, QWORD PTR __real@3ff0000000000000

; 186  : 		thsad = sad_t (floor (thsad1 + lerp * (thsad2  - thsad1) + 0.5));

	sub	edi, esi
	subsd	xmm2, xmm0
	sub	esp, 8
	movd	xmm0, edi
	cvtdq2pd xmm0, xmm0
	mulsd	xmm2, QWORD PTR __real@3fe0000000000000
	mulsd	xmm2, xmm0
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	addsd	xmm2, xmm0
	addsd	xmm2, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv176[esp+72], xmm2
	fld	QWORD PTR tv176[esp+72]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv168[esp+72]
	cvttsd2si eax, QWORD PTR tv168[esp+72]
	add	esp, 8

; 187  : 	}
; 188  : 
; 189  : 	return (thsad);
; 190  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@interpolat:
	pop	edi
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?interpolate_thsad@ClipFnc@@SAHHHHH@Z ENDP		; ClipFnc::interpolate_thsad
_TEXT	ENDS
END
