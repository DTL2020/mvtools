; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvplane.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@		; MTSlicer<MVPlane,MVPlane,64>::`vftable'
PUBLIC	??_R4?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8 ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$MTSlicer@VMVPlane@@V1@$0EA@@@8		; MTSlicer<MVPlane,MVPlane,64>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$MTFlowGraphSimple@$0BA@@@8		; MTFlowGraphSimple<16>::`RTTI Base Class Array'
PUBLIC	??_7?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`vftable'
PUBLIC	??_R0?AV?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@8 ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16> `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$MTSlicer@VMVPlane@@V1@$0EA@@@@8	; MTSlicer<MVPlane,MVPlane,64> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$MTFlowGraphSimple@$0BA@@@8	; MTFlowGraphSimple<16>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$MTFlowGraphSimple@$0BA@@@6B@		; MTFlowGraphSimple<16>::`vftable'
PUBLIC	??_R2?$MTSlicer@VMVPlane@@V1@$0EA@@@8		; MTSlicer<MVPlane,MVPlane,64>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8 ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$MTFlowGraphSimple@$0BA@@@@8		; MTFlowGraphSimple<16> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$MTSlicer@VMVPlane@@V1@$0EA@@@8	; MTSlicer<MVPlane,MVPlane,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$MTFlowGraphSimple@$0BA@@@6B@		; MTFlowGraphSimple<16>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$MTFlowGraphSimple@$0BA@@@8		; MTFlowGraphSimple<16>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@		; MTSlicer<MVPlane,MVPlane,64>::`RTTI Complete Object Locator'
PUBLIC	??_R2?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8 ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Base Class Array'
EXTRN	_HorizontalWiener_iSSE:PROC
EXTRN	_DiagonalBilin_iSSE:PROC
EXTRN	_HorizontalBilin_iSSE:PROC
EXTRN	_HorizontalBicubic_iSSE:PROC
EXTRN	_Average2_iSSE:PROC
EXTRN	_VerticalBilin_iSSE:PROC
EXTRN	_VerticalBicubic_iSSE:PROC
EXTRN	_VerticalWiener_iSSE:PROC
;	COMDAT ??_R2?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8
rdata$r	SEGMENT
??_R2?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8 DD FLAT:??_R1A@?0A@EA@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8 ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@
rdata$r	SEGMENT
??_R4?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@ DD 00H		; MTSlicer<MVPlane,MVPlane,64>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$MTSlicer@VMVPlane@@V1@$0EA@@@@8
	DD	FLAT:??_R3?$MTSlicer@VMVPlane@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R3?$MTFlowGraphSimple@$0BA@@@8
rdata$r	SEGMENT
??_R3?$MTFlowGraphSimple@$0BA@@@8 DD 00H		; MTFlowGraphSimple<16>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$MTFlowGraphSimple@$0BA@@@8
rdata$r	ENDS
;	COMDAT ??_R4?$MTFlowGraphSimple@$0BA@@@6B@
rdata$r	SEGMENT
??_R4?$MTFlowGraphSimple@$0BA@@@6B@ DD 00H		; MTFlowGraphSimple<16>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$MTFlowGraphSimple@$0BA@@@@8
	DD	FLAT:??_R3?$MTFlowGraphSimple@$0BA@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$MTSlicer@VMVPlane@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$MTSlicer@VMVPlane@@V1@$0EA@@@8 DD FLAT:??_R0?AV?$MTSlicer@VMVPlane@@V1@$0EA@@@@8 ; MTSlicer<MVPlane,MVPlane,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$MTSlicer@VMVPlane@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$MTFlowGraphSimple@$0BA@@@@8
data$r	SEGMENT
??_R0?AV?$MTFlowGraphSimple@$0BA@@@@8 DD FLAT:??_7type_info@@6B@ ; MTFlowGraphSimple<16> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$MTFlowGraphSimple@$0BA@@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8 DD FLAT:??_R0?AV?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@8 ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$MTSlicer@VMVPlane@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R2?$MTSlicer@VMVPlane@@V1@$0EA@@@8 DD FLAT:??_R1A@?0A@EA@?$MTSlicer@VMVPlane@@V1@$0EA@@@8 ; MTSlicer<MVPlane,MVPlane,64>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_7?$MTFlowGraphSimple@$0BA@@@6B@
CONST	SEGMENT
??_7?$MTFlowGraphSimple@$0BA@@@6B@ DD FLAT:??_R4?$MTFlowGraphSimple@$0BA@@@6B@ ; MTFlowGraphSimple<16>::`vftable'
	DD	FLAT:??_E?$MTFlowGraphSimple@$0BA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$MTFlowGraphSimple@$0BA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$MTFlowGraphSimple@$0BA@@@8 DD FLAT:??_R0?AV?$MTFlowGraphSimple@$0BA@@@@8 ; MTFlowGraphSimple<16>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$MTFlowGraphSimple@$0BA@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$MTSlicer@VMVPlane@@V1@$0EA@@@@8
data$r	SEGMENT
??_R0?AV?$MTSlicer@VMVPlane@@V1@$0EA@@@@8 DD FLAT:??_7type_info@@6B@ ; MTSlicer<MVPlane,MVPlane,64> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$MTSlicer@VMVPlane@@V1@$0EA@@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@8
data$r	SEGMENT
??_R0?AV?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@8 DD FLAT:??_7type_info@@6B@ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0'
	DB	'BA@@@V1@$0BA@@@', 00H
data$r	ENDS
;	COMDAT ??_7?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@
CONST	SEGMENT
??_7?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@ DD FLAT:??_R4?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`vftable'
	DD	FLAT:??_E?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$MTFlowGraphSimple@$0BA@@@8
rdata$r	SEGMENT
??_R2?$MTFlowGraphSimple@$0BA@@@8 DD FLAT:??_R1A@?0A@EA@?$MTFlowGraphSimple@$0BA@@@8 ; MTFlowGraphSimple<16>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$MTSlicer@VMVPlane@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R3?$MTSlicer@VMVPlane@@V1@$0EA@@@8 DD 00H		; MTSlicer<MVPlane,MVPlane,64>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$MTSlicer@VMVPlane@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R3?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8
rdata$r	SEGMENT
??_R3?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8 DD 00H ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8
rdata$r	ENDS
;	COMDAT ??_R4?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@
rdata$r	SEGMENT
??_R4?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@ DD 00H ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@8
	DD	FLAT:??_R3?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@8
rdata$r	ENDS
;	COMDAT ??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@
CONST	SEGMENT
??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@ DD FLAT:??_R4?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@ ; MTSlicer<MVPlane,MVPlane,64>::`vftable'
	DD	FLAT:??_E?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z
PUBLIC	??$exec_both@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@AAH2@Z ; conc::AtomicIntOp::exec_both<int,conc::AioAdd<int> >
PUBLIC	??$exec@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@@Z ; conc::AtomicIntOp::exec<int,conc::AioAdd<int> >
PUBLIC	??0Iterator@?$MTFlowGraphSimple@$0BA@@@QAE@ABV1@H@Z ; MTFlowGraphSimple<16>::Iterator::Iterator
PUBLIC	??A?$Array@F$0BA@@conc@@QBEABFJ@Z		; conc::Array<short,16>::operator[]
PUBLIC	??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QBEABVNode@?$MTFlowGraphSimple@$0BA@@@J@Z ; conc::Array<MTFlowGraphSimple<16>::Node,16>::operator[]
PUBLIC	??Y?$AtomicInt@H@conc@@QAEAAV01@ABH@Z		; conc::AtomicInt<int>::operator+=
PUBLIC	?get_index@Iterator@?$MTFlowGraphSimple@$0BA@@@QBEHXZ ; MTFlowGraphSimple<16>::Iterator::get_index
PUBLIC	?cont@Iterator@?$MTFlowGraphSimple@$0BA@@@QBE_NXZ ; MTFlowGraphSimple<16>::Iterator::cont
PUBLIC	?next@Iterator@?$MTFlowGraphSimple@$0BA@@@QAEXXZ ; MTFlowGraphSimple<16>::Iterator::next
PUBLIC	?get_out_node_it@?$MTFlowGraphSimple@$0BA@@@QBE?AVIterator@1@H@Z ; MTFlowGraphSimple<16>::get_out_node_it
PUBLIC	?get_nbr_in@?$MTFlowGraphSimple@$0BA@@@QBEHH@Z	; MTFlowGraphSimple<16>::get_nbr_in
PUBLIC	??E?$AtomicInt@H@conc@@QAEAAV01@XZ		; conc::AtomicInt<int>::operator++
PUBLIC	??A?$Array@F$0BA@@conc@@QAEAAFJ@Z		; conc::Array<short,16>::operator[]
PUBLIC	??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QAEAAVNode@?$MTFlowGraphSimple@$0BA@@@J@Z ; conc::Array<MTFlowGraphSimple<16>::Node,16>::operator[]
PUBLIC	??A?$Array@VTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@J@Z ; conc::Array<MTSlicer<MVPlane,MVPlane,64>::TaskData,64>::operator[]
PUBLIC	??A?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAEAAV?$AtomicInt@H@1@J@Z ; conc::Array<conc::AtomicInt<int>,16>::operator[]
PUBLIC	??A?$Array@VTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@$0BA@@conc@@QAEAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@J@Z ; conc::Array<MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::TaskData,16>::operator[]
PUBLIC	?redirect_task@?$MTSlicer@VMVPlane@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<MVPlane,MVPlane,64>::redirect_task
PUBLIC	?redirect_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::redirect_task
PUBLIC	?complete_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@AAEXAAVTaskData@1@@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::complete_task
PUBLIC	?get_last_node@?$MTFlowGraphSimple@$0BA@@@QBEHXZ ; MTFlowGraphSimple<16>::get_last_node
PUBLIC	?access@?$MTFlowGraphSched_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z ; MTFlowGraphSched_Access<MVPlane,MVPlane>::access
PUBLIC	?access@?$MTSlicer_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z ; MTSlicer_Access<MVPlane,MVPlane>::access
PUBLIC	??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z	; MTSlicer<MVPlane,MVPlane,64>::`scalar deleting destructor'
PUBLIC	??0?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAE@XZ ; conc::Array<conc::AtomicInt<int>,16>::Array<conc::AtomicInt<int>,16>
PUBLIC	??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`scalar deleting destructor'
PUBLIC	??$RefineExt@G@MVPlane@@QAEXPBEH_N@Z		; MVPlane::RefineExt<unsigned short>
PUBLIC	??$RefineExt@E@MVPlane@@QAEXPBEH_N@Z		; MVPlane::RefineExt<unsigned char>
PUBLIC	?wait@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXXZ	; MTSlicer<MVPlane,MVPlane,64>::wait
PUBLIC	?start@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXHAAVMVPlane@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MVPlane,MVPlane,64>::start
PUBLIC	??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ	; MTSlicer<MVPlane,MVPlane,64>::~MTSlicer<MVPlane,MVPlane,64>
PUBLIC	??0?$MTSlicer@VMVPlane@@V1@$0EA@@@QAE@_N@Z	; MTSlicer<MVPlane,MVPlane,64>::MTSlicer<MVPlane,MVPlane,64>
PUBLIC	?wait@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXXZ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::wait
PUBLIC	?start@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXABV?$MTFlowGraphSimple@$0BA@@@AAVMVPlane@@P83@AEXAAVTaskData@1@@Z@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::start
PUBLIC	??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::~MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>
PUBLIC	??0?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAE@_N@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>
PUBLIC	?clear@?$MTFlowGraphSimple@$0BA@@@QAEXXZ	; MTFlowGraphSimple<16>::clear
PUBLIC	?add_dep@?$MTFlowGraphSimple@$0BA@@@QAEXHH@Z	; MTFlowGraphSimple<16>::add_dep
PUBLIC	??0?$MTFlowGraphSimple@$0BA@@@QAE@XZ		; MTFlowGraphSimple<16>::MTFlowGraphSimple<16>
PUBLIC	??_G?$MTFlowGraphSimple@$0BA@@@UAEPAXI@Z	; MTFlowGraphSimple<16>::`scalar deleting destructor'
PUBLIC	??1?$MTFlowGraphSimple@$0BA@@@UAE@XZ		; MTFlowGraphSimple<16>::~MTFlowGraphSimple<16>
PUBLIC	?reduce_slice@MVPlane@@AAEXAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@@Z ; MVPlane::reduce_slice
PUBLIC	?refine_pel4@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z ; MVPlane::refine_pel4
PUBLIC	?refine_pel2@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z ; MVPlane::refine_pel2
PUBLIC	?reduce_wait@MVPlane@@QAEXXZ			; MVPlane::reduce_wait
PUBLIC	?reduce_start@MVPlane@@QAEXPAV1@@Z		; MVPlane::reduce_start
PUBLIC	?refine_wait@MVPlane@@QAEXXZ			; MVPlane::refine_wait
PUBLIC	?refine_start@MVPlane@@QAEXXZ			; MVPlane::refine_start
PUBLIC	?Pad@MVPlane@@QAEXXZ				; MVPlane::Pad
PUBLIC	?ChangePlane@MVPlane@@QAEXPBEH@Z		; MVPlane::ChangePlane
PUBLIC	?Update@MVPlane@@QAEXPAEH@Z			; MVPlane::Update
PUBLIC	?set_interp@MVPlane@@QAEXHH@Z			; MVPlane::set_interp
PUBLIC	??1MVPlane@@QAE@XZ				; MVPlane::~MVPlane
PUBLIC	??0MVPlane@@QAE@HHHHHHH_N0@Z			; MVPlane::MVPlane
EXTRN	??_E?$MTFlowGraphSimple@$0BA@@@UAEPAXI@Z:PROC	; MTFlowGraphSimple<16>::`vector deleting destructor'
EXTRN	??_E?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z:PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`vector deleting destructor'
EXTRN	??_E?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z:PROC ; MTSlicer<MVPlane,MVPlane,64>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVPlane@@QAE@HHHHHHH_N0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0MVPlane@@QAE@HHHHHHH_N0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MVPlane@@QAE@HHHHHHH_N0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVPlane@@QAE@HHHHHHH_N0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVPlane@@QAE@HHHHHHH_N0@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVPlane@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1MVPlane@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVPlane@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVPlane@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVPlane@@QAE@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ??0MVPlane@@QAE@HHHHHHH_N0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__nWidth$ = 8						; size = 4
__nHeight$ = 12						; size = 4
__nPel$ = 16						; size = 4
__nHPad$ = 20						; size = 4
__nVPad$ = 24						; size = 4
__pixelsize$ = 28					; size = 4
__bits_per_pixel$ = 32					; size = 4
__isse$ = 36						; size = 1
_mt_flag$ = 40						; size = 1
??0MVPlane@@QAE@HHHHHHH_N0@Z PROC			; MVPlane::MVPlane, COMDAT
; _this$ = ecx

; 69   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVPlane@@QAE@HHHHHHH_N0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 44   : :	pPlane (new uint8_t* [_nPel * _nPel * _pixelsize])

	mov	eax, DWORD PTR __nPel$[ebp]
	mov	edx, 4
	imul	eax, eax
	push	ebx
	mov	ebx, ecx
	xor	ecx, ecx
	push	esi
	push	edi
	imul	eax, DWORD PTR __pixelsize$[ebp]
	mov	DWORD PTR _this$[ebp], ebx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 45   : ,	nWidth (_nWidth)
; 46   : ,	nHeight (_nHeight)
; 47   : ,	nPitch (0)
; 48   : ,	nHPadding (_nHPad)

	mov	ecx, DWORD PTR __nHPad$[ebp]
	add	esp, 4

; 49   : ,	nVPadding (_nVPad)

	mov	edx, DWORD PTR __nVPad$[ebp]
	mov	esi, DWORD PTR __nWidth$[ebp]
	mov	edi, DWORD PTR __nHeight$[ebp]
	mov	DWORD PTR [ebx], eax

; 50   : ,	nOffsetPadding (0)
; 51   : ,	nHPaddingPel (_nHPad * _nPel)

	mov	eax, DWORD PTR __nPel$[ebp]
	imul	eax, ecx
	mov	DWORD PTR [ebx+4], esi
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR [ebx+8], edi
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+28], eax

; 52   : ,	nVPaddingPel (_nVPad * _nPel)

	mov	eax, DWORD PTR __nPel$[ebp]
	imul	eax, edx
	mov	DWORD PTR [ebx+20], edx
	mov	DWORD PTR [ebx+24], 0
	mov	DWORD PTR [ebx+32], eax

; 53   : ,	nExtendedWidth (_nWidth + 2 * _nHPad)

	lea	eax, DWORD PTR [esi+ecx*2]

; 54   : ,	nExtendedHeight(_nHeight + 2 * _nVPad)
; 55   : ,	nPel (_nPel)
; 56   : ,	nSharp (2)
; 57   : ,	pixelsize(_pixelsize)

	mov	ecx, DWORD PTR __pixelsize$[ebp]
	mov	esi, ebx
	mov	DWORD PTR [esi+36], eax
	lea	eax, DWORD PTR [edi+edx*2]
	mov	DWORD PTR [esi+40], eax

; 59   : ,	bits_per_pixel(_bits_per_pixel)

	mov	eax, DWORD PTR __bits_per_pixel$[ebp]
	mov	DWORD PTR [esi+48], eax

; 58   : , pixelsize_shift((_pixelsize == 1) ? 0 : (_pixelsize == 2 ? 1 : 2)) // pixelsize 1/2/4: shift 0/1/2

	xor	eax, eax
	mov	DWORD PTR [esi+44], ecx
	cmp	ecx, 1
	je	SHORT $LN8@MVPlane
	cmp	ecx, 2
	setne	al
	inc	eax
$LN8@MVPlane:

; 60   : ,	isse (_isse)

	mov	bh, BYTE PTR __isse$[ebp]

; 61   : ,	_mt_flag (mt_flag)

	mov	bl, BYTE PTR _mt_flag$[ebp]
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR __nPel$[ebp]

; 62   : ,	isPadded (false)
; 63   : ,	isRefined (false)
; 64   : ,	isFilled (false)
; 65   : ,	_sched_refine (mt_flag)

	push	ecx
	lea	ecx, DWORD PTR [esi+112]
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], 2
	mov	BYTE PTR [esi+68], bh
	mov	BYTE PTR [esi+69], bl
	mov	WORD PTR [esi+70], 0
	mov	BYTE PTR [esi+72], 0
	call	??0?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAE@_N@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>

; 66   : ,	_plan_refine ()

	lea	ecx, DWORD PTR [esi+392]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??0?$MTFlowGraphSimple@$0BA@@@QAE@XZ	; MTFlowGraphSimple<16>::MTFlowGraphSimple<16>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\github\mvtools\sources\mtslicer.hpp

; 70   : {

	mov	DWORD PTR [esi+1040], OFFSET ??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR [esi+1044], eax

; 66   : ,	_proc_ptr (0)
; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR [esi+1056]
	push	1024					; 00000400H
	push	0
	mov	DWORD PTR [esi+1048], 0
	push	eax
	mov	DWORD PTR [esi+1052], 0
	call	_memset

; 69   : ,	_mt_flag (mt_flag)

	mov	BYTE PTR [esi+2080], bl
	add	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\mvplane.cpp

; 70   :     if(pixelsize==1) {

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+2084], 0
	cmp	eax, 1
	jne	$LN2@MVPlane

; 71   :         _bilin_hor_ptr = _isse ? HorizontalBilin_iSSE : HorizontalBilin<uint8_t>;

	test	bh, bh

; 72   :         _bilin_ver_ptr = _isse ? VerticalBilin_iSSE : VerticalBilin<uint8_t>;
; 73   :         _bilin_dia_ptr = _isse ? DiagonalBilin_iSSE : DiagonalBilin<uint8_t>;
; 74   :         _bicubic_hor_ptr = _isse ? HorizontalBicubic_iSSE : HorizontalBicubic<uint8_t>;
; 75   :         _bicubic_ver_ptr = _isse ? VerticalBicubic_iSSE : VerticalBicubic<uint8_t>;
; 76   :         _wiener_hor_ptr = _isse ? HorizontalWiener_iSSE : HorizontalWiener<uint8_t>;
; 77   :         _wiener_ver_ptr = _isse ? VerticalWiener_iSSE : VerticalWiener<uint8_t>;
; 78   :         _average_ptr = _isse ? Average2_iSSE : Average2<uint8_t>;
; 79   :         _reduce_ptr = &RB2BilinearFiltered<uint8_t>;

	mov	DWORD PTR [esi+108], OFFSET ??$RB2BilinearFiltered@E@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFiltered<unsigned char>
	mov	ecx, OFFSET _HorizontalBilin_iSSE
	mov	eax, OFFSET ??$HorizontalBilin@E@@YAXPAEPBEHHHHH@Z ; HorizontalBilin<unsigned char>
	cmovne	eax, ecx
	mov	ecx, OFFSET _VerticalBilin_iSSE
	mov	DWORD PTR [esi+76], eax
	mov	eax, OFFSET ??$VerticalBilin@E@@YAXPAEPBEHHHHH@Z ; VerticalBilin<unsigned char>
	cmovne	eax, ecx
	mov	ecx, OFFSET _DiagonalBilin_iSSE
	mov	DWORD PTR [esi+80], eax
	mov	eax, OFFSET ??$DiagonalBilin@E@@YAXPAEPBEHHHHH@Z ; DiagonalBilin<unsigned char>
	cmovne	eax, ecx
	mov	ecx, OFFSET _HorizontalBicubic_iSSE
	mov	DWORD PTR [esi+84], eax
	mov	eax, OFFSET ??$HorizontalBicubic@E@@YAXPAEPBEHHHHH@Z ; HorizontalBicubic<unsigned char>
	cmovne	eax, ecx
	mov	ecx, OFFSET _VerticalBicubic_iSSE
	mov	DWORD PTR [esi+88], eax
	mov	eax, OFFSET ??$VerticalBicubic@E@@YAXPAEPBEHHHHH@Z ; VerticalBicubic<unsigned char>
	cmovne	eax, ecx
	mov	ecx, OFFSET _HorizontalWiener_iSSE
	mov	DWORD PTR [esi+92], eax
	mov	eax, OFFSET ??$HorizontalWiener@E@@YAXPAEPBEHHHHH@Z ; HorizontalWiener<unsigned char>
	cmovne	eax, ecx
	mov	ecx, OFFSET _VerticalWiener_iSSE
	mov	DWORD PTR [esi+96], eax
	mov	eax, OFFSET ??$VerticalWiener@E@@YAXPAEPBEHHHHH@Z ; VerticalWiener<unsigned char>
	cmovne	eax, ecx
	mov	ecx, OFFSET _Average2_iSSE
	mov	DWORD PTR [esi+100], eax
	mov	eax, OFFSET ??$Average2@E@@YAXPAEPBE1HHH@Z ; Average2<unsigned char>
	cmovne	eax, ecx
	mov	DWORD PTR [esi+104], eax
	jmp	SHORT $LN14@MVPlane
$LN2@MVPlane:

; 80   :     }
; 81   :     else if (pixelsize==2) {

	cmp	eax, 2
	jne	SHORT $LN14@MVPlane

; 82   :         _bilin_hor_ptr = HorizontalBilin<uint16_t>;

	mov	DWORD PTR [esi+76], OFFSET ??$HorizontalBilin@G@@YAXPAEPBEHHHHH@Z ; HorizontalBilin<unsigned short>

; 83   :         _bilin_ver_ptr = VerticalBilin<uint16_t>;

	mov	DWORD PTR [esi+80], OFFSET ??$VerticalBilin@G@@YAXPAEPBEHHHHH@Z ; VerticalBilin<unsigned short>

; 84   :         _bilin_dia_ptr = DiagonalBilin<uint16_t>;

	mov	DWORD PTR [esi+84], OFFSET ??$DiagonalBilin@G@@YAXPAEPBEHHHHH@Z ; DiagonalBilin<unsigned short>

; 85   :         _bicubic_hor_ptr = HorizontalBicubic<uint16_t>;

	mov	DWORD PTR [esi+88], OFFSET ??$HorizontalBicubic@G@@YAXPAEPBEHHHHH@Z ; HorizontalBicubic<unsigned short>

; 86   :         _bicubic_ver_ptr = VerticalBicubic<uint16_t>;

	mov	DWORD PTR [esi+92], OFFSET ??$VerticalBicubic@G@@YAXPAEPBEHHHHH@Z ; VerticalBicubic<unsigned short>

; 87   :         _wiener_hor_ptr = HorizontalWiener<uint16_t>;

	mov	DWORD PTR [esi+96], OFFSET ??$HorizontalWiener@G@@YAXPAEPBEHHHHH@Z ; HorizontalWiener<unsigned short>

; 88   :         _wiener_ver_ptr = VerticalWiener<uint16_t>;

	mov	DWORD PTR [esi+100], OFFSET ??$VerticalWiener@G@@YAXPAEPBEHHHHH@Z ; VerticalWiener<unsigned short>

; 89   :         _average_ptr = Average2<uint16_t>;

	mov	DWORD PTR [esi+104], OFFSET ??$Average2@G@@YAXPAEPBE1HHH@Z ; Average2<unsigned short>

; 90   :         _reduce_ptr = &RB2BilinearFiltered<uint16_t>;

	mov	DWORD PTR [esi+108], OFFSET ??$RB2BilinearFiltered@G@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFiltered<unsigned short>
$LN14@MVPlane:

; 91   :     }
; 92   :     else {
; 93   :         // float? not supported
; 94   :     }
; 95   :         // Nothing
; 96   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVPlane@@QAE@HHHHHHH_N0@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::~MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>
__unwindfunclet$??0MVPlane@@QAE@HHHHHHH_N0@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1?$MTFlowGraphSimple@$0BA@@@UAE@XZ	; MTFlowGraphSimple<16>::~MTFlowGraphSimple<16>
__ehhandler$??0MVPlane@@QAE@HHHHHHH_N0@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVPlane@@QAE@HHHHHHH_N0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVPlane@@QAE@HHHHHHH_N0@Z ENDP			; MVPlane::MVPlane
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.h
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ??1MVPlane@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1MVPlane@@QAE@XZ PROC					; MVPlane::~MVPlane, COMDAT
; _this$ = ecx

; 101  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1MVPlane@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 102  : 	delete [] pPlane;

	push	DWORD PTR [esi]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 103  : 	pPlane = 0;

	mov	DWORD PTR [esi], 0
; File c:\github\mvtools\sources\mtslicer.hpp

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+1052], 0
	mov	DWORD PTR [esi+1040], OFFSET ??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@
	je	SHORT $LN4@MVPlane

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+2080], 0
	je	SHORT $LN8@MVPlane

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+1052]
	mov	eax, DWORD PTR [esi+1044]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+1052]
	mov	ecx, DWORD PTR [esi+1044]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN8@MVPlane:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+1048], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+1052], 0
$LN4@MVPlane:
; File c:\github\mvtools\sources\mtflowgraphsimple.h

; 66   : 	virtual			~MTFlowGraphSimple () {}

	mov	DWORD PTR [esi+392], OFFSET ??_7?$MTFlowGraphSimple@$0BA@@@6B@
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 89   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 90   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+112], OFFSET ??_7?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@
	je	SHORT $LN18@MVPlane

; 202  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+388], 0
	je	SHORT $LN22@MVPlane

; 203  : 	{
; 204  : 		assert (_dispatcher_ptr != 0);
; 205  : 
; 206  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+124]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+116]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 207  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+124]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+116]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN22@MVPlane:
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 210  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+120], 0

; 211  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+124], 0

; 212  : 	_dep_graph_ptr = 0;

	mov	DWORD PTR [esi+128], 0
$LN18@MVPlane:
; File c:\github\mvtools\sources\mvplane.cpp

; 104  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVPlane@@QAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVPlane@@QAE@XZ$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVPlane@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVPlane@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVPlane@@QAE@XZ ENDP					; MVPlane::~MVPlane
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?set_interp@MVPlane@@QAEXHH@Z
_TEXT	SEGMENT
_rfilter$ = 8						; size = 4
tv4235 = 12						; size = 4
_sharp$ = 12						; size = 4
?set_interp@MVPlane@@QAEXHH@Z PROC			; MVPlane::set_interp, COMDAT
; _this$ = ecx

; 110  : 	nSharp   = sharp;

	mov	eax, DWORD PTR _sharp$[esp-4]
	mov	DWORD PTR [ecx+60], eax

; 111  : 	nRfilter = nRfilter;
; 112  : 
; 113  : 	switch (rfilter)

	mov	eax, DWORD PTR _rfilter$[esp-4]
	cmp	eax, 4
	ja	SHORT $LN9@set_interp
	jmp	DWORD PTR $LN540@set_interp[eax*4]
$LN4@set_interp:

; 114  : 	{
; 115  :     case	0:	_reduce_ptr = (pixelsize==1) ? &RB2F<uint8_t> : &RB2F<uint16_t>; break;

	mov	eax, OFFSET ??$RB2F@G@@YAXPAEPBEHHHHHH_N@Z ; RB2F<unsigned short>
	mov	edx, OFFSET ??$RB2F@E@@YAXPAEPBEHHHHHH_N@Z ; RB2F<unsigned char>
	jmp	SHORT $LN535@set_interp
$LN5@set_interp:

; 116  : 	case	1:	_reduce_ptr = (pixelsize==1) ? &RB2Filtered<uint8_t> : &RB2Filtered<uint16_t>; break;

	mov	eax, OFFSET ??$RB2Filtered@G@@YAXPAEPBEHHHHHH_N@Z ; RB2Filtered<unsigned short>
	mov	edx, OFFSET ??$RB2Filtered@E@@YAXPAEPBEHHHHHH_N@Z ; RB2Filtered<unsigned char>
	jmp	SHORT $LN535@set_interp
$LN6@set_interp:

; 117  : 	case	2:	_reduce_ptr = (pixelsize==1) ? &RB2BilinearFiltered<uint8_t> : &RB2BilinearFiltered<uint16_t>; break;

	mov	eax, OFFSET ??$RB2BilinearFiltered@G@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFiltered<unsigned short>
	mov	edx, OFFSET ??$RB2BilinearFiltered@E@@YAXPAEPBEHHHHHH_N@Z ; RB2BilinearFiltered<unsigned char>
	jmp	SHORT $LN535@set_interp
$LN7@set_interp:

; 118  : 	case	3:	_reduce_ptr = (pixelsize==1) ? &RB2Quadratic<uint8_t> : &RB2Quadratic<uint16_t> ; break;

	mov	eax, OFFSET ??$RB2Quadratic@G@@YAXPAEPBEHHHHHH_N@Z ; RB2Quadratic<unsigned short>
	mov	edx, OFFSET ??$RB2Quadratic@E@@YAXPAEPBEHHHHHH_N@Z ; RB2Quadratic<unsigned char>
	jmp	SHORT $LN535@set_interp
$LN8@set_interp:

; 119  : 	case	4:	_reduce_ptr = (pixelsize==1) ? &RB2Cubic<uint8_t> : &RB2Cubic<uint16_t>; break;

	mov	eax, OFFSET ??$RB2Cubic@G@@YAXPAEPBEHHHHHH_N@Z ; RB2Cubic<unsigned short>
	mov	edx, OFFSET ??$RB2Cubic@E@@YAXPAEPBEHHHHHH_N@Z ; RB2Cubic<unsigned char>
$LN535@set_interp:
	cmp	DWORD PTR [ecx+44], 1
	cmove	eax, edx
	mov	DWORD PTR [ecx+108], eax
$LN9@set_interp:
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 105  : 	_last_node = 0;

	mov	DWORD PTR [ecx+396], 0
; File c:\github\mvtools\sources\mvplane.cpp

; 125  : 	_plan_refine.clear ();

	lea	eax, DWORD PTR [ecx+400]
	mov	edx, 16					; 00000010H
$LL23@set_interp:
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 109  : 		node._nbr_in  = 0;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+40]

; 110  : 		node._nbr_out = 0;

	mov	DWORD PTR [eax-36], 0
	sub	edx, 1
	jne	SHORT $LL23@set_interp
; File c:\github\mvtools\sources\mvplane.cpp

; 126  : 	if (nSharp == 0)

	mov	eax, DWORD PTR [ecx+56]
	push	ebx
	lea	ebx, DWORD PTR [edx+1]
	mov	DWORD PTR tv4235[esp], 10		; 0000000aH
	push	ebp
	lea	ebp, DWORD PTR [edx+3]
	push	esi
	lea	esi, DWORD PTR [edx+8]
	push	edi
	lea	edi, DWORD PTR [edx+2]
	cmp	DWORD PTR [ecx+60], edx
	jne	$LN10@set_interp

; 127  : 	{
; 128  : 		if (nPel == 2)

	cmp	eax, edi
	jne	$LN12@set_interp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], bx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+440]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ebx
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], di

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+480]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edi
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], bp

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+520]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
$LN538@set_interp:
	cmp	eax, 3
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 89   : }

	jmp	$LN536@set_interp
$LN12@set_interp:
; File c:\github\mvtools\sources\mvplane.cpp

; 134  : 		else if (nPel == 4)

	cmp	eax, 4
	jne	$LN17@set_interp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	edx, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	WORD PTR [ecx+eax*2+408], di

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+480]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 2
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], si

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+720]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edx, 10					; 0000000aH

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 8
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	edx, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+800]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
	mov	edx, 10					; 0000000aH
; File c:\github\mvtools\sources\mvplane.cpp

; 141  : 	else	// nSharp == 1 or 2

	jmp	$LN537@set_interp
$LN10@set_interp:

; 142  : 	{
; 143  : 		if (nPel == 2)

	cmp	eax, 2
	jne	$LN15@set_interp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	edx, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	WORD PTR [ecx+eax*2+408], bx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+440]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 1
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], di

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+480]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 2
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+484]
	mov	WORD PTR [ecx+eax*2+488], bp

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+484]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+520]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 2
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 89   : }

	jmp	$LN538@set_interp
$LN15@set_interp:
; File c:\github\mvtools\sources\mvplane.cpp

; 149  : 		else if (nPel == 4)

	cmp	eax, 4
	jne	$LN17@set_interp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	edx, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	WORD PTR [ecx+eax*2+408], di

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+480]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 2
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], si

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+720]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edx, 10					; 0000000aH

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 8
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+724]
	mov	WORD PTR [ecx+eax*2+728], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+724]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+800]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 8
	cmovl	eax, esi
$LN537@set_interp:
	cmp	eax, 10					; 0000000aH
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, edx
$LN536@set_interp:
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax
$LN17@set_interp:
; File c:\github\mvtools\sources\mvplane.cpp

; 156  : 	if (nPel == 4)

	cmp	DWORD PTR [ecx+56], 4
	jne	$LN18@set_interp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	xor	edx, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	WORD PTR [ecx+eax*2+408], bx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+440]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 1
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+484]
	mov	WORD PTR [ecx+eax*2+488], bx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+484]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+440]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 2
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 1
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	ebx, 4

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], bp

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+520]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 3
	cmovl	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+484]
	mov	WORD PTR [ecx+eax*2+488], bp

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+484]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+520]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 2
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, 3
	cmovl	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	ebp, 12					; 0000000cH

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], bx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+560]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ebx
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+724]
	mov	WORD PTR [ecx+eax*2+728], bx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+724]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+560]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 8
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ebx
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+404]
	mov	WORD PTR [ecx+eax*2+408], bp

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+404]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+880]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	test	eax, eax
	cmovs	eax, edx
	cmp	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+724]
	mov	WORD PTR [ecx+eax*2+728], bp
	mov	edx, 9

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+724]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+880]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 8
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, ebp
	cmovl	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+724]
	mov	WORD PTR [ecx+eax*2+728], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+724]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+760]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 8
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+804]
	mov	WORD PTR [ecx+eax*2+808], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+804]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+760]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 10					; 0000000aH
	cmovl	eax, DWORD PTR tv4235[esp+12]
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edx, 11					; 0000000bH

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+724]
	mov	WORD PTR [ecx+eax*2+728], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+724]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+840]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 8
	cmovl	eax, esi
	mov	esi, 10					; 0000000aH
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+804]
	mov	WORD PTR [ecx+eax*2+808], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+804]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+840]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 10					; 0000000aH
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	esi, 6

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
	mov	edx, 10					; 0000000aH
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+484]
	mov	WORD PTR [ecx+eax*2+488], si

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+484]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+640]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 2
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, esi
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+804]
	mov	WORD PTR [ecx+eax*2+808], si

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+804]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+640]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 10					; 0000000aH
	cmovl	eax, edx
	cmp	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+484]
	mov	edi, 14					; 0000000eH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, 2
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	WORD PTR [ecx+eax*2+488], di

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+484]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+960]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 2
	cmovl	eax, edx
	mov	edx, 10					; 0000000aH
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edi
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+804]
	mov	WORD PTR [ecx+eax*2+808], di

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+804]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+960]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, 10					; 0000000aH
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edx, 5

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edi
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+564]
	mov	WORD PTR [ecx+eax*2+568], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+564]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+600]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, ebx
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+644]
	mov	WORD PTR [ecx+eax*2+648], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+644]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+600]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, esi
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edx, 7

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+564]
	mov	WORD PTR [ecx+eax*2+568], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+564]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+680]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, ebx
	cmovl	eax, ebx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+644]
	mov	WORD PTR [ecx+eax*2+648], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+644]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+680]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, esi
	cmovl	eax, esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edx, 13					; 0000000dH

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+884]
	mov	WORD PTR [ecx+eax*2+888], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+884]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+920]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, ebp
	cmovl	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+964]
	mov	WORD PTR [ecx+eax*2+968], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+964]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+920]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, edi
	cmovl	eax, edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edx, 15					; 0000000fH

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+884]
	mov	WORD PTR [ecx+eax*2+888], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+884]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+1000]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, ebp
	cmovl	eax, ebp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	eax, edx
	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [ecx+964]
	mov	WORD PTR [ecx+eax*2+968], dx

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [ecx+964]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+1000]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx+396]
	cmp	eax, edi
	cmovl	eax, edi
	cmp	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	DWORD PTR [ecx+396], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovl	eax, edx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	DWORD PTR [ecx+396], eax
$LN18@set_interp:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File c:\github\mvtools\sources\mvplane.cpp

; 183  : }

	ret	8
	npad	1
$LN540@set_interp:
	DD	$LN4@set_interp
	DD	$LN5@set_interp
	DD	$LN6@set_interp
	DD	$LN7@set_interp
	DD	$LN8@set_interp
?set_interp@MVPlane@@QAEXHH@Z ENDP			; MVPlane::set_interp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?Update@MVPlane@@QAEXPAEH@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
__nPitch$ = 12						; size = 4
?Update@MVPlane@@QAEXPAEH@Z PROC			; MVPlane::Update, COMDAT
; _this$ = ecx

; 189  :     // npitch is pixelsize aware
; 190  :     nPitch = _nPitch;

	mov	edx, DWORD PTR __nPitch$[esp-4]
	mov	eax, ecx
	push	esi

; 191  : 
; 192  : 	nOffsetPadding = nPitch * nVPadding + (nHPadding << pixelsize_shift);

	mov	esi, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+52]
	shl	esi, cl
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, edx
	mov	DWORD PTR [eax+12], edx
	add	esi, ecx

; 193  : 
; 194  : 	for ( int i = 0; i < nPel * nPel; i++ )

	mov	ecx, DWORD PTR [eax+56]
	imul	ecx, ecx
	mov	DWORD PTR [eax+24], esi
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN3@Update
	push	edi
	mov	edi, DWORD PTR _pSrc$[esp+4]
	npad	2
$LL4@Update:

; 195  : 	{
; 196  : 		pPlane[i] = pSrc + i * nPitch * nExtendedHeight;

	mov	edx, DWORD PTR [eax+40]
	mov	ecx, DWORD PTR [eax]
	imul	edx, esi
	imul	edx, DWORD PTR [eax+12]
	add	edx, edi
	mov	DWORD PTR [ecx+esi*4], edx
	inc	esi
	mov	ecx, DWORD PTR [eax+56]
	imul	ecx, ecx
	cmp	esi, ecx
	jl	SHORT $LL4@Update
	pop	edi
$LN3@Update:
; File c:\github\mvtools\sources\mvplane.h

; 119  :    inline void ResetState() { isRefined = isFilled = isPadded = false; }

	mov	WORD PTR [eax+70], 0
	mov	BYTE PTR [eax+72], 0
	pop	esi
; File c:\github\mvtools\sources\mvplane.cpp

; 200  : }

	ret	8
?Update@MVPlane@@QAEXPAEH@Z ENDP			; MVPlane::Update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?ChangePlane@MVPlane@@QAEXPBEH@Z
_TEXT	SEGMENT
_pNewPlane$ = 8						; size = 4
_nNewPitch$ = 12					; size = 4
?ChangePlane@MVPlane@@QAEXPBEH@Z PROC			; MVPlane::ChangePlane, COMDAT
; _this$ = ecx

; 205  : {

	push	esi
	mov	esi, ecx

; 206  :    if (! isFilled)

	cmp	BYTE PTR [esi+72], 0
	jne	SHORT $LN2@ChangePlan

; 209  : 		BitBlt(pPlane[0] + nOffsetPadding, nPitch, pNewPlane, nNewPitch, (nWidth << pixelsize_shift), nHeight, isse);

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	eax, eax
	je	SHORT $LN9@ChangePlan
; File c:\github\mvtools\sources\mvplane.cpp

; 209  : 		BitBlt(pPlane[0] + nOffsetPadding, nPitch, pNewPlane, nNewPitch, (nWidth << pixelsize_shift), nHeight, isse);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+12]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	shl	eax, cl
	mov	ecx, DWORD PTR [esi+24]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR _nNewPitch$[esp+8]
	push	DWORD PTR _pNewPlane$[esp+12]
	add	ecx, DWORD PTR [eax]
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN9@ChangePlan:

; 210  : 		isFilled = true;

	mov	BYTE PTR [esi+72], 1
$LN2@ChangePlan:
	pop	esi

; 211  : 	}
; 212  : }

	ret	8
?ChangePlane@MVPlane@@QAEXPBEH@Z ENDP			; MVPlane::ChangePlane
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?Pad@MVPlane@@QAEXXZ
_TEXT	SEGMENT
?Pad@MVPlane@@QAEXXZ PROC				; MVPlane::Pad, COMDAT
; _this$ = ecx

; 217  : {

	push	esi
	mov	esi, ecx

; 218  :     // npitch is pixelsize aware
; 219  :     if (! isPadded)

	cmp	BYTE PTR [esi+70], 0
	jne	SHORT $LN2@Pad

; 220  : 	{
; 221  :        if(pixelsize==1)

	cmp	DWORD PTR [esi+44], 1

; 222  : 		   Padding::PadReferenceFrame<uint8_t>(pPlane[0], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx]
	push	DWORD PTR [esi+16]
	jne	SHORT $LN3@Pad
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 223  :        else
; 224  :            Padding::PadReferenceFrame<uint16_t>(pPlane[0], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	add	esp, 16					; 00000010H

; 225  :        isPadded = true;

	mov	BYTE PTR [esi+70], 1
	pop	esi

; 226  : 	}
; 227  : }

	ret	0
$LN3@Pad:

; 223  :        else
; 224  :            Padding::PadReferenceFrame<uint16_t>(pPlane[0], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>
	add	esp, 16					; 00000010H

; 225  :        isPadded = true;

	mov	BYTE PTR [esi+70], 1
$LN2@Pad:
	pop	esi

; 226  : 	}
; 227  : }

	ret	0
?Pad@MVPlane@@QAEXXZ ENDP				; MVPlane::Pad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?refine_start@MVPlane@@QAEXXZ
_TEXT	SEGMENT
?refine_start@MVPlane@@QAEXXZ PROC			; MVPlane::refine_start, COMDAT
; _this$ = ecx

; 233  : 	if (! isRefined)

	cmp	BYTE PTR [ecx+71], 0
	jne	SHORT $LN5@refine_sta

; 234  : 	{
; 235  : 		if (nPel == 2)

	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, 2
	jne	SHORT $LN3@refine_sta

; 236  : 		{
; 237  : 			_sched_refine.start (_plan_refine, *this, &MVPlane::refine_pel2);

	push	OFFSET ?refine_pel2@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z ; MVPlane::refine_pel2

; 240  : 		{
; 241  : 			_sched_refine.start (_plan_refine, *this, &MVPlane::refine_pel4);

	push	ecx
	lea	eax, DWORD PTR [ecx+392]
	add	ecx, 112				; 00000070H
	push	eax
	call	?start@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXABV?$MTFlowGraphSimple@$0BA@@@AAVMVPlane@@P83@AEXAAVTaskData@1@@Z@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::start

; 242  : 		}
; 243  : 	}
; 244  : }

	ret	0
$LN3@refine_sta:

; 238  : 		}
; 239  : 		else if (nPel == 4)

	cmp	eax, 4
	jne	SHORT $LN5@refine_sta

; 240  : 		{
; 241  : 			_sched_refine.start (_plan_refine, *this, &MVPlane::refine_pel4);

	push	OFFSET ?refine_pel4@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z ; MVPlane::refine_pel4
	push	ecx
	lea	eax, DWORD PTR [ecx+392]
	add	ecx, 112				; 00000070H
	push	eax
	call	?start@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXABV?$MTFlowGraphSimple@$0BA@@@AAVMVPlane@@P83@AEXAAVTaskData@1@@Z@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::start
$LN5@refine_sta:

; 242  : 		}
; 243  : 	}
; 244  : }

	ret	0
?refine_start@MVPlane@@QAEXXZ ENDP			; MVPlane::refine_start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?refine_wait@MVPlane@@QAEXXZ
_TEXT	SEGMENT
?refine_wait@MVPlane@@QAEXXZ PROC			; MVPlane::refine_wait, COMDAT
; _this$ = ecx

; 249  : {

	push	esi
	mov	esi, ecx

; 250  : 	if (! isRefined)

	cmp	BYTE PTR [esi+71], 0
	jne	SHORT $LN2@refine_wai

; 251  : 	{
; 252  : 		if (nPel > 1)

	cmp	DWORD PTR [esi+56], 1
	jle	SHORT $LN3@refine_wai

; 253  : 		{
; 254  : 			_sched_refine.wait ();

	lea	ecx, DWORD PTR [esi+112]
	call	?wait@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXXZ ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::wait
$LN3@refine_wai:

; 255  : 		}
; 256  : 
; 257  : 		isRefined = true;

	mov	BYTE PTR [esi+71], 1
$LN2@refine_wai:
	pop	esi

; 258  : 	}
; 259  : }

	ret	0
?refine_wait@MVPlane@@QAEXXZ ENDP			; MVPlane::refine_wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?reduce_start@MVPlane@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pReducedPlane$ = 8					; size = 4
?reduce_start@MVPlane@@QAEXPAV1@@Z PROC			; MVPlane::reduce_start, COMDAT
; _this$ = ecx

; 385  : 	if (! pReducedPlane->isFilled)

	mov	eax, DWORD PTR _pReducedPlane$[esp-4]
	cmp	BYTE PTR [eax+72], 0
	jne	SHORT $LN2@reduce_sta

; 386  : 	{
; 387  : 		_redp_ptr = pReducedPlane;
; 388  : 		_slicer_reduce.start (pReducedPlane->nHeight, *this, &MVPlane::reduce_slice, 4);

	sub	esp, 8
	mov	DWORD PTR [ecx+2084], eax
	push	ecx
	push	DWORD PTR [eax+8]
	add	ecx, 1040				; 00000410H
	call	?start@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXHAAVMVPlane@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MVPlane,MVPlane,64>::start
$LN2@reduce_sta:

; 389  : 	}
; 390  : }

	ret	4
?reduce_start@MVPlane@@QAEXPAV1@@Z ENDP			; MVPlane::reduce_start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?reduce_wait@MVPlane@@QAEXXZ
_TEXT	SEGMENT
?reduce_wait@MVPlane@@QAEXXZ PROC			; MVPlane::reduce_wait, COMDAT
; _this$ = ecx

; 395  : {

	push	esi
	mov	esi, ecx

; 396  : 	assert (_redp_ptr != 0);
; 397  : 
; 398  : 	if (! _redp_ptr->isFilled)

	mov	eax, DWORD PTR [esi+2084]
	cmp	BYTE PTR [eax+72], 0
	jne	SHORT $LN2@reduce_wai
; File c:\github\mvtools\sources\mtslicer.hpp

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+2080], 0
	je	SHORT $LN5@reduce_wai

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+1052]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+1044]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+1052]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+1044]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN5@reduce_wai:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+1048], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+1052], 0
; File c:\github\mvtools\sources\mvplane.cpp

; 402  : 		_redp_ptr->isFilled = true;

	mov	eax, DWORD PTR [esi+2084]
	mov	BYTE PTR [eax+72], 1

; 403  : 		_redp_ptr = 0;

	mov	DWORD PTR [esi+2084], 0
$LN2@reduce_wai:
	pop	esi

; 404  : 	}
; 405  : }

	ret	0
?reduce_wait@MVPlane@@QAEXXZ ENDP			; MVPlane::reduce_wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?refine_pel2@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z
_TEXT	SEGMENT
_td$ = 8						; size = 4
?refine_pel2@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z PROC ; MVPlane::refine_pel2, COMDAT
; _this$ = ecx

; 422  : 	assert (&td != 0);
; 423  : 
; 424  : 	switch (td._task_index)

	mov	eax, DWORD PTR _td$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [eax+8]
	sub	eax, 1
	je	SHORT $LN11@refine_pel
	sub	eax, 1
	je	$LN4@refine_pel
	sub	eax, 1
	jne	$LN6@refine_pel

; 447  : 		default: _wiener_hor_ptr  (pPlane[3], pPlane[2], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;	// faster from ready-made horizontal

	push	DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	sub	eax, 0
	je	SHORT $LN20@refine_pel
	sub	eax, 1
	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+12]
	je	SHORT $LN21@refine_pel
	mov	eax, DWORD PTR [esi+96]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 448  : 		}
; 449  : 		break;
; 450  : 	default:
; 451  : 		assert (false);
; 452  : 		break;
; 453  : 	}
; 454  : }

	ret	4
$LN21@refine_pel:

; 446  : 		case	1: _bicubic_hor_ptr (pPlane[3], pPlane[2], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;	// faster from ready-made horizontal

	mov	eax, DWORD PTR [esi+88]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 448  : 		}
; 449  : 		break;
; 450  : 	default:
; 451  : 		assert (false);
; 452  : 		break;
; 453  : 	}
; 454  : }

	ret	4
$LN20@refine_pel:

; 440  : 		}
; 441  : 		break;
; 442  : 	case	3:
; 443  : 		switch (nSharp)
; 444  : 		{
; 445  : 		case	0: _bilin_dia_ptr   (pPlane[3], pPlane[0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+84]
	push	DWORD PTR [ecx+12]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 448  : 		}
; 449  : 		break;
; 450  : 	default:
; 451  : 		assert (false);
; 452  : 		break;
; 453  : 	}
; 454  : }

	ret	4
$LN11@refine_pel:

; 432  : 		default: _wiener_hor_ptr  (pPlane[1], pPlane[0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	push	DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	sub	eax, 0
	je	SHORT $LN12@refine_pel
	sub	eax, 1
	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	push	DWORD PTR [ecx+4]
	je	SHORT $LN13@refine_pel
	mov	eax, DWORD PTR [esi+96]
	jmp	SHORT $LN26@refine_pel
$LN13@refine_pel:

; 431  : 		case	1: _bicubic_hor_ptr (pPlane[1], pPlane[0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+88]
	jmp	SHORT $LN26@refine_pel
$LN12@refine_pel:

; 425  : 	{
; 426  : 	case	0:  break;	// Nothing on the root node
; 427  : 	case	1:
; 428  : 		switch (nSharp)
; 429  : 		{
; 430  : 		case	0: _bilin_hor_ptr   (pPlane[1], pPlane[0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+76]
	push	DWORD PTR [ecx+4]
$LN26@refine_pel:
	call	eax
	add	esp, 28					; 0000001cH
$LN4@refine_pel:

; 439  : 		default: _wiener_ver_ptr  (pPlane[2], pPlane[0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	push	DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	sub	eax, 0
	je	SHORT $LN16@refine_pel
	sub	eax, 1
	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	push	DWORD PTR [ecx+8]
	je	SHORT $LN17@refine_pel
	mov	eax, DWORD PTR [esi+100]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 448  : 		}
; 449  : 		break;
; 450  : 	default:
; 451  : 		assert (false);
; 452  : 		break;
; 453  : 	}
; 454  : }

	ret	4
$LN17@refine_pel:

; 438  : 		case	1: _bicubic_ver_ptr (pPlane[2], pPlane[0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+92]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 448  : 		}
; 449  : 		break;
; 450  : 	default:
; 451  : 		assert (false);
; 452  : 		break;
; 453  : 	}
; 454  : }

	ret	4
$LN16@refine_pel:

; 433  : 		}
; 434  : 	case	2:
; 435  : 		switch (nSharp)
; 436  : 		{
; 437  : 		case	0: _bilin_ver_ptr   (pPlane[2], pPlane[0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+80]
	push	DWORD PTR [ecx+8]
	call	eax
	add	esp, 28					; 0000001cH
$LN6@refine_pel:
	pop	esi

; 448  : 		}
; 449  : 		break;
; 450  : 	default:
; 451  : 		assert (false);
; 452  : 		break;
; 453  : 	}
; 454  : }

	ret	4
?refine_pel2@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z ENDP ; MVPlane::refine_pel2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?refine_pel4@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z
_TEXT	SEGMENT
_td$ = 8						; size = 4
?refine_pel4@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z PROC ; MVPlane::refine_pel4, COMDAT
; _this$ = ecx

; 460  : 	assert (&td != 0);
; 461  : 
; 462  : 	switch (td._task_index)

	mov	eax, DWORD PTR _td$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [eax+8]
	dec	eax
	cmp	eax, 14					; 0000000eH
	ja	$LN35@refine_pel
	jmp	DWORD PTR $LN39@refine_pel[eax*4]
$LN11@refine_pel:

; 463  : 	{
; 464  : 	case	0:  break;	// Nothing on the root node
; 465  : 	case	1:  _average_ptr (pPlane[ 1], pPlane[ 0],          pPlane[ 2], nPitch, nExtendedWidth,   nExtendedHeight); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [eax]
	push	DWORD PTR [eax+4]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN12@refine_pel:

; 471  : 		default: _wiener_hor_ptr  (pPlane[ 2], pPlane[ 0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	push	DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	sub	eax, 0
	je	SHORT $LN13@refine_pel
	sub	eax, 1
	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	push	DWORD PTR [ecx+8]
	je	SHORT $LN14@refine_pel
	mov	eax, DWORD PTR [esi+96]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN14@refine_pel:

; 470  : 		case	1: _bicubic_hor_ptr (pPlane[ 2], pPlane[ 0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+88]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN13@refine_pel:

; 466  : 	case	2:
; 467  : 		switch (nSharp)
; 468  : 		{
; 469  : 		case	0: _bilin_hor_ptr   (pPlane[ 2], pPlane[ 0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+76]
	push	DWORD PTR [ecx+8]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN16@refine_pel:

; 472  : 		}
; 473  : 		break;
; 474  : 	case	3:  _average_ptr (pPlane[ 3], pPlane[ 0] + 1,      pPlane[ 2], nPitch, nExtendedWidth-1, nExtendedHeight); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi]
	dec	eax
	push	eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx]
	inc	eax
	push	eax
	push	DWORD PTR [ecx+12]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN17@refine_pel:

; 475  : 	case	4:  _average_ptr (pPlane[ 4], pPlane[ 0],          pPlane[ 8], nPitch, nExtendedWidth,   nExtendedHeight); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [eax+32]
	push	DWORD PTR [eax]
	push	DWORD PTR [eax+16]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN18@refine_pel:

; 476  : 	case	5:  _average_ptr (pPlane[ 5], pPlane[ 4],          pPlane[ 6], nPitch, nExtendedWidth,   nExtendedHeight); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [eax+24]
	push	DWORD PTR [eax+16]
	push	DWORD PTR [eax+20]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN19@refine_pel:

; 477  : 	case	6:  _average_ptr (pPlane[ 6], pPlane[ 2],          pPlane[10], nPitch, nExtendedWidth,   nExtendedHeight); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [eax+40]
	push	DWORD PTR [eax+8]
	push	DWORD PTR [eax+24]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN20@refine_pel:

; 478  : 	case	7:  _average_ptr (pPlane[ 7], pPlane[ 4] + 1,      pPlane[ 6], nPitch, nExtendedWidth-1, nExtendedHeight); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi]
	dec	eax
	push	eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [ecx+16]
	inc	eax
	push	eax
	push	DWORD PTR [ecx+28]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN21@refine_pel:

; 484  : 		default: _wiener_ver_ptr  (pPlane[ 8], pPlane[ 0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	push	DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	sub	eax, 0
	je	SHORT $LN22@refine_pel
	sub	eax, 1
	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	push	DWORD PTR [ecx+32]
	je	SHORT $LN23@refine_pel
	mov	eax, DWORD PTR [esi+100]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN23@refine_pel:

; 483  : 		case	1: _bicubic_ver_ptr (pPlane[ 8], pPlane[ 0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+92]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN22@refine_pel:

; 479  : 	case	8:
; 480  : 		switch (nSharp)
; 481  : 		{
; 482  : 		case	0: _bilin_ver_ptr   (pPlane[ 8], pPlane[ 0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+80]
	push	DWORD PTR [ecx+32]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN25@refine_pel:

; 485  : 		}
; 486  : 		break;
; 487  : 	case	9:  _average_ptr (pPlane[ 9], pPlane[ 8],          pPlane[10], nPitch, nExtendedWidth,   nExtendedHeight); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [eax+40]
	push	DWORD PTR [eax+32]
	push	DWORD PTR [eax+36]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN26@refine_pel:

; 492  : 		case	1: _bicubic_hor_ptr (pPlane[10], pPlane[ 8], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;	// faster from ready-made horizontal
; 493  : 		default: _wiener_hor_ptr  (pPlane[10], pPlane[ 8], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;	// faster from ready-made horizontal

	push	DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	sub	eax, 0
	je	SHORT $LN27@refine_pel
	sub	eax, 1
	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx+32]
	push	DWORD PTR [ecx+40]
	je	$LN14@refine_pel
	mov	eax, DWORD PTR [esi+96]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN27@refine_pel:

; 488  : 	case	10:
; 489  : 		switch (nSharp)
; 490  : 		{
; 491  : 		case	0: _bilin_dia_ptr   (pPlane[10], pPlane[ 0], nPitch, nPitch, nExtendedWidth, nExtendedHeight, bits_per_pixel); break;

	mov	eax, DWORD PTR [esi+12]
	push	eax
	push	eax
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+84]
	push	DWORD PTR [ecx+40]
	call	eax
	add	esp, 28					; 0000001cH
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN30@refine_pel:

; 494  : 		}
; 495  : 		break;
; 496  : 	case	11: _average_ptr (pPlane[11], pPlane[ 8] + 1,      pPlane[10], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi]
	dec	eax
	push	eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [ecx+32]
	inc	eax
	push	eax
	push	DWORD PTR [ecx+44]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN31@refine_pel:

; 497  : 	case	12: _average_ptr (pPlane[12], pPlane[ 0] + nPitch, pPlane[ 8], nPitch, nExtendedWidth,   nExtendedHeight-1); break;

	mov	eax, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [esi]
	dec	eax
	mov	ecx, DWORD PTR [esi+12]
	push	eax
	push	DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	DWORD PTR [edx+32]
	add	eax, ecx
	push	eax
	push	DWORD PTR [edx+48]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN32@refine_pel:

; 498  : 	case	13: _average_ptr (pPlane[13], pPlane[12],          pPlane[14], nPitch, nExtendedWidth,   nExtendedHeight  ); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [eax+56]
	push	DWORD PTR [eax+48]
	push	DWORD PTR [eax+52]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN33@refine_pel:

; 499  : 	case	14: _average_ptr (pPlane[14], pPlane[ 2] + nPitch, pPlane[10], nPitch, nExtendedWidth,   nExtendedHeight-1); break;

	mov	eax, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [esi]
	dec	eax
	mov	ecx, DWORD PTR [esi+12]
	push	eax
	push	DWORD PTR [esi+36]
	mov	eax, DWORD PTR [edx+8]
	push	ecx
	push	DWORD PTR [edx+40]
	add	eax, ecx
	push	eax
	push	DWORD PTR [edx+56]

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN34@refine_pel:

; 500  : 	case	15: _average_ptr (pPlane[15], pPlane[12] + 1,      pPlane[14], nPitch, nExtendedWidth-1, nExtendedHeight  ); break;

	push	DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi]
	dec	eax
	push	eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [ecx+48]
	inc	eax
	push	eax
	push	DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [esi+104]
	call	eax
	add	esp, 24					; 00000018H
$LN35@refine_pel:
	pop	esi

; 501  : 	default:
; 502  : 		assert (false);
; 503  : 		break;
; 504  : 	}
; 505  : }

	ret	4
$LN39@refine_pel:
	DD	$LN11@refine_pel
	DD	$LN12@refine_pel
	DD	$LN16@refine_pel
	DD	$LN17@refine_pel
	DD	$LN18@refine_pel
	DD	$LN19@refine_pel
	DD	$LN20@refine_pel
	DD	$LN21@refine_pel
	DD	$LN25@refine_pel
	DD	$LN26@refine_pel
	DD	$LN30@refine_pel
	DD	$LN31@refine_pel
	DD	$LN32@refine_pel
	DD	$LN33@refine_pel
	DD	$LN34@refine_pel
?refine_pel4@MVPlane@@AAEXAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@@Z ENDP ; MVPlane::refine_pel4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ?reduce_slice@MVPlane@@AAEXAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_td$ = 8						; size = 4
?reduce_slice@MVPlane@@AAEXAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@@Z PROC ; MVPlane::reduce_slice, COMDAT
; _this$ = ecx

; 510  : {

	push	esi
	mov	esi, ecx

; 511  : 	assert (&td != 0);
; 512  : 	assert (_redp_ptr != 0);
; 513  :     // noffsetPadding is pixelsize aware
; 514  : 	MVPlane &		red = *_redp_ptr;
; 515  : 	_reduce_ptr (

	movzx	eax, BYTE PTR [esi+68]
	mov	edx, DWORD PTR [esi+2084]
	mov	ecx, DWORD PTR [esi+24]
	push	eax
	mov	eax, DWORD PTR _td$[esp+4]
	push	DWORD PTR [eax+12]
	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [edx+8]
	push	DWORD PTR [edx+4]
	add	ecx, DWORD PTR [eax]
	push	DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edx]
	push	DWORD PTR [edx+12]
	push	ecx
	mov	ecx, DWORD PTR [edx+24]
	add	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+108]
	push	ecx
	call	eax
	add	esp, 36					; 00000024H
	pop	esi

; 516  : 		red.pPlane[0] + red.nOffsetPadding, pPlane[0] + nOffsetPadding,
; 517  : 		red.nPitch, nPitch,
; 518  : 		red.nWidth, red.nHeight, td._y_beg, td._y_end,
; 519  : 		isse
; 520  : 	);
; 521  : }

	ret	4
?reduce_slice@MVPlane@@AAEXAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@@Z ENDP ; MVPlane::reduce_slice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.h
;	COMDAT ??1?$MTFlowGraphSimple@$0BA@@@UAE@XZ
_TEXT	SEGMENT
??1?$MTFlowGraphSimple@$0BA@@@UAE@XZ PROC		; MTFlowGraphSimple<16>::~MTFlowGraphSimple<16>, COMDAT
; _this$ = ecx

; 66   : 	virtual			~MTFlowGraphSimple () {}

	mov	DWORD PTR [ecx], OFFSET ??_7?$MTFlowGraphSimple@$0BA@@@6B@
	ret	0
??1?$MTFlowGraphSimple@$0BA@@@UAE@XZ ENDP		; MTFlowGraphSimple<16>::~MTFlowGraphSimple<16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.h
;	COMDAT ??_G?$MTFlowGraphSimple@$0BA@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$MTFlowGraphSimple@$0BA@@@UAEPAXI@Z PROC		; MTFlowGraphSimple<16>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx

; 66   : 	virtual			~MTFlowGraphSimple () {}

	mov	DWORD PTR [esi], OFFSET ??_7?$MTFlowGraphSimple@$0BA@@@6B@
	je	SHORT $LN7@scalar
	push	648					; 00000288H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$MTFlowGraphSimple@$0BA@@@UAEPAXI@Z ENDP		; MTFlowGraphSimple<16>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ??0?$MTFlowGraphSimple@$0BA@@@QAE@XZ
_TEXT	SEGMENT
??0?$MTFlowGraphSimple@$0BA@@@QAE@XZ PROC		; MTFlowGraphSimple<16>::MTFlowGraphSimple<16>, COMDAT
; _this$ = ecx

; 48   : {

	push	esi
	push	edi
	mov	edi, ecx

; 47   : ,	_node_arr ()

	push	640					; 00000280H
	push	0
	lea	esi, DWORD PTR [edi+8]
	mov	DWORD PTR [edi], OFFSET ??_7?$MTFlowGraphSimple@$0BA@@@6B@
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 105  : 	_last_node = 0;

	mov	DWORD PTR [edi+4], 0

; 48   : {

	mov	eax, 16					; 00000010H
	npad	7
$LL6@MTFlowGrap:

; 109  : 		node._nbr_in  = 0;

	mov	DWORD PTR [esi], 0
	lea	esi, DWORD PTR [esi+40]

; 110  : 		node._nbr_out = 0;

	mov	DWORD PTR [esi-36], 0
	sub	eax, 1
	jne	SHORT $LL6@MTFlowGrap

; 49   : 	clear ();
; 50   : }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	0
??0?$MTFlowGraphSimple@$0BA@@@QAE@XZ ENDP		; MTFlowGraphSimple<16>::MTFlowGraphSimple<16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?add_dep@?$MTFlowGraphSimple@$0BA@@@QAEXHH@Z
_TEXT	SEGMENT
_index_from$ = 8					; size = 4
_index_to$ = 12						; size = 4
?add_dep@?$MTFlowGraphSimple@$0BA@@@QAEXHH@Z PROC	; MTFlowGraphSimple<16>::add_dep, COMDAT
; _this$ = ecx

; 72   : {

	push	esi
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	mov	esi, DWORD PTR _index_from$[esp]
	push	edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	edi, DWORD PTR _index_to$[esp+4]
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	eax, DWORD PTR [esi+esi*4]
	lea	edx, DWORD PTR [ecx+eax*8]
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 81   : 	node_from._out_arr [node_from._nbr_out] = index_to;

	mov	eax, DWORD PTR [edx+12]
	mov	WORD PTR [edx+eax*2+16], di
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	eax, DWORD PTR [edi+edi*4]
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 82   : 	++ node_from._nbr_out;

	inc	DWORD PTR [edx+12]

; 83   : 
; 84   : 	Node &			node_to   = _node_arr [index_to];
; 85   : 	++ node_to._nbr_in;

	inc	DWORD PTR [ecx+eax*8+8]

; 87   : 	_last_node = std::max (_last_node, index_from);

	add	ecx, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR _index_from$[esp+4]
	cmp	DWORD PTR [ecx], esi
	cmovge	eax, ecx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 87   : 	_last_node = std::max (_last_node, index_from);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR _index_to$[esp+4]
	cmp	DWORD PTR [ecx], edi
	pop	edi
	cmovge	eax, ecx
	pop	esi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 88   : 	_last_node = std::max (_last_node, index_to);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 89   : }

	ret	8
?add_dep@?$MTFlowGraphSimple@$0BA@@@QAEXHH@Z ENDP	; MTFlowGraphSimple<16>::add_dep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?clear@?$MTFlowGraphSimple@$0BA@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$MTFlowGraphSimple@$0BA@@@QAEXXZ PROC		; MTFlowGraphSimple<16>::clear, COMDAT
; _this$ = ecx

; 105  : 	_last_node = 0;

	mov	DWORD PTR [ecx+4], 0
	lea	eax, DWORD PTR [ecx+8]
	mov	ecx, 16					; 00000010H
	npad	1
$LL4@clear:

; 106  : 	for (int k = 0; k < MAXT; ++k)
; 107  : 	{
; 108  : 		Node &			node = _node_arr [k];
; 109  : 		node._nbr_in  = 0;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+40]

; 110  : 		node._nbr_out = 0;

	mov	DWORD PTR [eax-36], 0
	sub	ecx, 1
	jne	SHORT $LL4@clear

; 111  : 	}
; 112  : }

	ret	0
?clear@?$MTFlowGraphSimple@$0BA@@@QAEXXZ ENDP		; MTFlowGraphSimple<16>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ??0?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAE@_N@Z
_TEXT	SEGMENT
_mt_flag$dead$ = 8					; size = 1
??0?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAE@_N@Z PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>, COMDAT
; _this$ = ecx

; 73   : {

	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi], OFFSET ??_7?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@

; 66   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR [edi+4], eax

; 67   : ,	_proc_ptr (0)
; 68   : ,	_dispatcher_ptr (0)
; 69   : ,	_dep_graph_ptr (0)
; 70   : ,	_task_data_arr ()

	lea	eax, DWORD PTR [edi+20]
	push	192					; 000000c0H
	mov	DWORD PTR [edi+8], 0
	push	0
	mov	DWORD PTR [edi+12], 0
	push	eax
	mov	DWORD PTR [edi+16], 0
	call	_memset

; 71   : ,	_in_cnt_arr ()

	push	64					; 00000040H
	lea	esi, DWORD PTR [edi+212]
	push	0
	push	esi
	call	_memset
	add	esp, 24					; 00000018H
	mov	eax, 16					; 00000010H
	npad	1
$LL6@MTFlowGrap:
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 54   : :	_val ()

	mov	DWORD PTR [esi], 0
	lea	esi, DWORD PTR [esi+4]
	sub	eax, 1
	jne	SHORT $LL6@MTFlowGrap
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 72   : ,	_mt_flag ()

	mov	BYTE PTR [edi+276], al

; 74   : 	// Nothing
; 75   : }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAE@_N@Z ENDP ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::~MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>, COMDAT
; _this$ = ecx

; 89   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 90   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@
	je	SHORT $LN2@MTFlowGrap

; 202  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+276], 0
	je	SHORT $LN5@MTFlowGrap

; 203  : 	{
; 204  : 		assert (_dispatcher_ptr != 0);
; 205  : 
; 206  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 207  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN5@MTFlowGrap:
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 210  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 211  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0

; 212  : 	_dep_graph_ptr = 0;

	mov	DWORD PTR [esi+16], 0
$LN2@MTFlowGrap:

; 91   : 	{
; 92   : 		wait ();
; 93   : 	}
; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAE@XZ ENDP ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::~MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ?start@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXABV?$MTFlowGraphSimple@$0BA@@@AAVMVPlane@@P83@AEXAAVTaskData@1@@Z@Z
_TEXT	SEGMENT
_dep_graph$ = 8						; size = 4
_glob_data$ = 12					; size = 4
_proc_ptr$ = 16						; size = 4
?start@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXABV?$MTFlowGraphSimple@$0BA@@@AAVMVPlane@@P83@AEXAAVTaskData@1@@Z@Z PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::start, COMDAT
; _this$ = ecx

; 149  : 	assert (&dep_graph != 0);
; 150  : 	assert (&glob_data != 0);
; 151  : 	assert (proc_ptr != 0);
; 152  : 
; 153  : 	_proc_ptr      = proc_ptr;
; 154  : 	_dep_graph_ptr = &dep_graph;

	mov	eax, DWORD PTR _dep_graph$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR _proc_ptr$[esp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+16], eax

; 155  : 
; 156  : 	const int		last_node_index = _dep_graph_ptr->get_last_node ();

	mov	eax, DWORD PTR [esi+16]

; 157  : 	memset (	// Not very clean but should work correctly.

	mov	eax, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [eax*4+4]
	push	eax
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	eax, DWORD PTR [esi+212]
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 157  : 	memset (	// Not very clean but should work correctly.

	push	0
	push	eax
	call	_memset

; 158  : 		&_in_cnt_arr [0],
; 159  : 		0,
; 160  : 		sizeof (_in_cnt_arr [0]) * (last_node_index + 1)
; 161  : 	);
; 162  : 
; 163  : 	// Enqueues the root task
; 164  : 	TaskData &		root = _task_data_arr [0];
; 165  : 	root._glob_data_ptr = &glob_data;

	mov	ecx, DWORD PTR _glob_data$[esp+20]
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	edi, DWORD PTR [esi+20]
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 157  : 	memset (	// Not very clean but should work correctly.

	add	esp, 12					; 0000000cH

; 158  : 		&_in_cnt_arr [0],
; 159  : 		0,
; 160  : 		sizeof (_in_cnt_arr [0]) * (last_node_index + 1)
; 161  : 	);
; 162  : 
; 163  : 	// Enqueues the root task
; 164  : 	TaskData &		root = _task_data_arr [0];
; 165  : 	root._glob_data_ptr = &glob_data;

	mov	DWORD PTR [edi], ecx

; 166  : 	root._scheduler_ptr = this;

	mov	DWORD PTR [edi+4], esi

; 167  : 	root._task_index    = 0;

	mov	DWORD PTR [edi+8], 0

; 168  : 
; 169  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+276], 0
	je	SHORT $LN2@start

; 171  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	eax, DWORD PTR [esi+4]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 118  : 	return (_avstp_create_dispatcher_ptr ());

	mov	eax, DWORD PTR [eax+8]
	call	eax
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 171  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	DWORD PTR [esi+12], eax

; 172  : 		_avstp.enqueue_task (_dispatcher_ptr, &redirect_task, &root);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 139  : 	return (_avstp_enqueue_task_ptr (td_ptr, task_ptr, user_data_ptr));

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	push	OFFSET ?redirect_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::redirect_task
	push	eax
	mov	eax, DWORD PTR [ecx+20]
	call	eax
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 182  : }

	ret	12					; 0000000cH
$LN2@start:

; 173  : 	}
; 174  : 	else
; 175  : 	{
; 176  : 		T *				this_ptr =
; 177  : 			MTFlowGraphSched_Access <T, GD>::access (&glob_data);
; 178  : 		((*this_ptr).*(proc_ptr)) (root);

	push	edi
	call	ebx

; 179  : 
; 180  : 		complete_task (root);

	push	edi
	mov	ecx, esi
	call	?complete_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@AAEXAAVTaskData@1@@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::complete_task
	pop	edi
	pop	esi
	pop	ebx

; 182  : }

	ret	12					; 0000000cH
?start@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXABV?$MTFlowGraphSimple@$0BA@@@AAVMVPlane@@P83@AEXAAVTaskData@1@@Z@Z ENDP ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ?wait@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXXZ
_TEXT	SEGMENT
?wait@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXXZ PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::wait, COMDAT
; _this$ = ecx

; 199  : {

	push	esi
	mov	esi, ecx

; 200  : 	assert (_proc_ptr != 0);
; 201  : 
; 202  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+276], 0
	je	SHORT $LN2@wait

; 203  : 	{
; 204  : 		assert (_dispatcher_ptr != 0);
; 205  : 
; 206  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	edx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	edx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 207  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN2@wait:
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 210  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 211  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0

; 212  : 	_dep_graph_ptr = 0;

	mov	DWORD PTR [esi+16], 0
	pop	esi

; 213  : }

	ret	0
?wait@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@QAEXXZ ENDP ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??0?$MTSlicer@VMVPlane@@V1@$0EA@@@QAE@_N@Z
_TEXT	SEGMENT
_mt_flag$ = 8						; size = 1
??0?$MTSlicer@VMVPlane@@V1@$0EA@@@QAE@_N@Z PROC		; MTSlicer<MVPlane,MVPlane,64>::MTSlicer<MVPlane,MVPlane,64>, COMDAT
; _this$ = ecx

; 70   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR [esi+4], eax

; 66   : ,	_proc_ptr (0)
; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR [esi+16]
	push	1024					; 00000400H
	push	0
	mov	DWORD PTR [esi+8], 0
	push	eax
	mov	DWORD PTR [esi+12], 0
	call	_memset

; 69   : ,	_mt_flag (mt_flag)

	mov	al, BYTE PTR _mt_flag$[esp+12]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [esi+1040], al

; 71   : 	// Nothing
; 72   : }

	mov	eax, esi
	pop	esi
	ret	4
??0?$MTSlicer@VMVPlane@@V1@$0EA@@@QAE@_N@Z ENDP		; MTSlicer<MVPlane,MVPlane,64>::MTSlicer<MVPlane,MVPlane,64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ PROC		; MTSlicer<MVPlane,MVPlane,64>::~MTSlicer<MVPlane,MVPlane,64>, COMDAT
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@
	je	SHORT $LN2@MTSlicer

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	je	SHORT $LN5@MTSlicer

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN5@MTSlicer:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0
$LN2@MTSlicer:

; 88   : 	{
; 89   : 		wait ();
; 90   : 	}
; 91   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$MTSlicer@VMVPlane@@V1@$0EA@@@UAE@XZ ENDP		; MTSlicer<MVPlane,MVPlane,64>::~MTSlicer<MVPlane,MVPlane,64>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?start@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXHAAVMVPlane@@P82@AEXAAVTaskData@1@@ZH@Z
_TEXT	SEGMENT
_y_beg$1$ = -36						; size = 4
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_nbr_threads$4 = -20					; size = 4
_task_data$5 = -16					; size = 16
_height$ = 8						; size = 4
_glob_data$ = 12					; size = 4
_proc_ptr$dead$ = 16					; size = 4
_min_slice_h$dead$ = 20					; size = 4
?start@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXHAAVMVPlane@@P82@AEXAAVTaskData@1@@ZH@Z PROC ; MTSlicer<MVPlane,MVPlane,64>::start, COMDAT
; _this$ = ecx

; 144  : {

	sub	esp, 36					; 00000024H
	push	esi
	mov	esi, ecx

; 145  : 	assert (height > 0);
; 146  : 	assert (&glob_data != 0);
; 147  : 	assert (proc_ptr != 0);
; 148  : 	assert (min_slice_h > 0);
; 149  : 
; 150  : 	_proc_ptr = proc_ptr;
; 151  : 
; 152  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	mov	DWORD PTR [esi+8], OFFSET ?reduce_slice@MVPlane@@AAEXAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@@Z ; MVPlane::reduce_slice
	je	$LN8@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	push	edi
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 132  : 	return (_avstp_get_nbr_threads_ptr ());

	mov	eax, DWORD PTR [eax+16]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	ecx, DWORD PTR _height$[esp+44]
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, 64					; 00000040H
; File c:\github\mvtools\sources\mtslicer.hpp

; 155  : 		nbr_threads = std::min (nbr_threads, int (MAXT));

	mov	DWORD PTR $T1[esp+48], 64		; 00000040H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR $T3[esp+48], 1

; 158  : 
; 159  : 		int				y_beg = 0;

	mov	DWORD PTR _y_beg$1$[esp+48], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovg	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	eax, ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, edi
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	DWORD PTR $T2[esp+48], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	edi, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmp	edi, eax
	cmovl	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR _nbr_threads$4[esp+48], edi

; 160  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN3@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	push	ebp
	mov	ebx, ecx
	mov	ebp, edi
	lea	ecx, DWORD PTR [esi+24]
	npad	6
$LL4@start:

; 161  : 		{
; 162  : 			const int		y_end = (t_cnt + 1) * height / nbr_threads;

	mov	eax, ebx

; 163  : 			TaskData &		task_data = _task_data_arr [t_cnt];
; 164  : 			task_data._glob_data_ptr = &glob_data;
; 165  : 			task_data._slicer_ptr    = this;

	mov	DWORD PTR [ecx-4], esi
	cdq
	lea	ecx, DWORD PTR [ecx+16]
	idiv	edi
	mov	edx, DWORD PTR _glob_data$[esp+48]
	add	ebx, DWORD PTR _height$[esp+48]
	mov	DWORD PTR [ecx-24], edx

; 166  : 			task_data._y_beg         = y_beg;

	mov	edx, DWORD PTR _y_beg$1$[esp+52]
	mov	DWORD PTR [ecx-16], edx

; 167  : 			task_data._y_end         = y_end;

	mov	DWORD PTR [ecx-12], eax

; 168  : 			y_beg = y_end;

	mov	DWORD PTR _y_beg$1$[esp+52], eax
	sub	ebp, 1
	jne	SHORT $LL4@start
	pop	ebp
$LN3@start:

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	eax, DWORD PTR [esi+4]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 118  : 	return (_avstp_create_dispatcher_ptr ());

	mov	eax, DWORD PTR [eax+8]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	DWORD PTR [esi+12], eax

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN42@start

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	lea	ebx, DWORD PTR [esi+16]
	npad	4
$LL7@start:

; 175  : 		{
; 176  : 			_avstp.enqueue_task (

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 139  : 	return (_avstp_enqueue_task_ptr (td_ptr, task_ptr, user_data_ptr));

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	OFFSET ?redirect_task@?$MTSlicer@VMVPlane@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<MVPlane,MVPlane,64>::redirect_task
	push	eax
	mov	eax, DWORD PTR [ecx+20]
	call	eax
	add	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\mtslicer.hpp

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	add	ebx, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL7@start
$LN42@start:
	pop	edi
	pop	ebx
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 36					; 00000024H
	ret	16					; 00000010H
$LN8@start:

; 177  : 				_dispatcher_ptr,
; 178  : 				&redirect_task,
; 179  : 				&_task_data_arr [t_cnt]
; 180  : 			);
; 181  : 		}
; 182  : 	}
; 183  : 
; 184  : 	// Multi-threading disabled
; 185  : 	else
; 186  : 	{
; 187  : 		TaskData			task_data;
; 188  : 		task_data._glob_data_ptr = &glob_data;
; 189  : 		task_data._slicer_ptr    = this;
; 190  : 		task_data._y_beg         = 0;
; 191  : 		task_data._y_end         = height;

	mov	eax, DWORD PTR _height$[esp+36]
	mov	ecx, DWORD PTR _glob_data$[esp+36]
	mov	DWORD PTR _task_data$5[esp+52], eax

; 192  : 
; 193  : 		T *				this_ptr =
; 194  : 			MTSlicer_Access <T, GD>::access (&glob_data);
; 195  : 		((*this_ptr).*(proc_ptr)) (task_data);

	lea	eax, DWORD PTR _task_data$5[esp+40]
	push	eax
	mov	DWORD PTR _task_data$5[esp+44], ecx
	mov	DWORD PTR _task_data$5[esp+48], esi
	mov	DWORD PTR _task_data$5[esp+52], 0
	call	?reduce_slice@MVPlane@@AAEXAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@@Z ; MVPlane::reduce_slice
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 36					; 00000024H
	ret	16					; 00000010H
?start@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXHAAVMVPlane@@P82@AEXAAVTaskData@1@@ZH@Z ENDP ; MTSlicer<MVPlane,MVPlane,64>::start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?wait@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXXZ
_TEXT	SEGMENT
?wait@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXXZ PROC	; MTSlicer<MVPlane,MVPlane,64>::wait, COMDAT
; _this$ = ecx

; 214  : {

	push	esi
	mov	esi, ecx

; 215  : 	assert (_proc_ptr != 0);
; 216  : 
; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	je	SHORT $LN8@wait

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	edx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	edx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN8@wait:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0
	pop	esi

; 227  : }

	ret	0
?wait@?$MTSlicer@VMVPlane@@V1@$0EA@@@QAEXXZ ENDP	; MTSlicer<MVPlane,MVPlane,64>::wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ??$RefineExt@E@MVPlane@@QAEXPBEH_N@Z
_TEXT	SEGMENT
_pp3$1$ = -140						; size = 4
_pp2$1$ = -140						; size = 4
_pp3$1$ = -136						; size = 4
tv1742 = -136						; size = 4
_pp14$1$ = -132						; size = 4
_h$1$ = -132						; size = 4
_pp15$1$ = -128						; size = 4
_pp1$1$ = -128						; size = 4
tv1756 = -124						; size = 4
tv1744 = -124						; size = 4
_pp2$1$ = -120						; size = 4
tv1752 = -120						; size = 4
_h$1$ = -116						; size = 4
tv1750 = -116						; size = 4
tv1748 = -112						; size = 4
_pp1$1$ = -108						; size = 4
_pp4$1$ = -104						; size = 4
_pp5$1$ = -100						; size = 4
_pp6$1$ = -96						; size = 4
_pp7$1$ = -92						; size = 4
_pp8$1$ = -88						; size = 4
_pp9$1$ = -84						; size = 4
_pp10$1$ = -80						; size = 4
_pp11$1$ = -76						; size = 4
_pp12$1$ = -72						; size = 4
_pp13$1$ = -68						; size = 4
_w$1$ = -64						; size = 4
tv1741 = -60						; size = 4
tv1740 = -56						; size = 4
tv1739 = -52						; size = 4
tv1737 = -48						; size = 4
tv1736 = -44						; size = 4
tv1735 = -40						; size = 4
tv1734 = -36						; size = 4
tv1733 = -32						; size = 4
tv1732 = -28						; size = 4
tv1731 = -24						; size = 4
tv1730 = -20						; size = 4
tv1729 = -16						; size = 4
tv1728 = -12						; size = 4
tv1727 = -8						; size = 4
_this$1$ = -4						; size = 4
_pSrc2x_8$ = 8						; size = 4
_nSrc2xPitch$ = 12					; size = 4
_isExtPadded$ = 16					; size = 1
??$RefineExt@E@MVPlane@@QAEXPBEH_N@Z PROC		; MVPlane::RefineExt<unsigned char>, COMDAT
; _this$ = ecx

; 268  : {

	sub	esp, 140				; 0000008cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$1$[esp+156], esi

; 269  :     const pixel_t *pSrc2x = reinterpret_cast<const pixel_t *>(pSrc2x_8);
; 270  :     nSrc2xPitch /= sizeof(pixel_t);
; 271  : 
; 272  : 	if (( nPel == 2 ) && ( !isRefined ))

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 2
	jne	$LN14@RefineExt
	cmp	BYTE PTR [esi+71], 0
	jne	$LN14@RefineExt

; 273  : 	{
; 274  : 		// pel clip may be already padded (i.e. is finest clip)
; 275  : 		int offset = isExtPadded ? 0 : nPitch*nVPadding/sizeof(pixel_t) + nHPadding;

	cmp	BYTE PTR _isExtPadded$[esp+152], 0
	je	SHORT $LN20@RefineExt
	xor	edi, edi
	jmp	SHORT $LN21@RefineExt
$LN20@RefineExt:
	mov	edi, DWORD PTR [esi+20]
	imul	edi, DWORD PTR [esi+12]
	add	edi, DWORD PTR [esi+16]
$LN21@RefineExt:

; 276  : 		pixel_t* pp1 = reinterpret_cast<pixel_t *>(pPlane[1]) + offset;

	mov	eax, DWORD PTR [esi]

; 277  : 		pixel_t* pp2 = reinterpret_cast<pixel_t *>(pPlane[2]) + offset;
; 278  : 		pixel_t* pp3 = reinterpret_cast<pixel_t *>(pPlane[3]) + offset;
; 279  : 
; 280  :         for (int h=0; h<nHeight; h++) // assembler optimization?

	mov	DWORD PTR _h$1$[esp+156], 0
	mov	ebp, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	add	ebp, edi
	mov	edx, DWORD PTR [eax+12]
	add	ecx, edi
	add	edx, edi
	mov	DWORD PTR _pp1$1$[esp+156], ebp
	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _pp2$1$[esp+156], ecx
	mov	DWORD PTR _pp3$1$[esp+156], edx
	jle	$LN3@RefineExt
	mov	eax, DWORD PTR _nSrc2xPitch$[esp+152]
	lea	ebx, DWORD PTR [eax+eax]
	mov	DWORD PTR tv1756[esp+156], ebx
	mov	ebx, DWORD PTR _pSrc2x_8$[esp+152]
$LL4@RefineExt:

; 281  : 		{
; 282  : 			for (int w=0; w<nWidth; w++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN6@RefineExt
	sub	ebp, DWORD PTR _pp2$1$[esp+156]
	lea	edx, DWORD PTR [ebx+1]
	dec	eax
	mov	DWORD PTR tv1752[esp+156], eax
	mov	eax, DWORD PTR _pp3$1$[esp+156]
	sub	eax, DWORD PTR _pp2$1$[esp+156]
	mov	DWORD PTR tv1750[esp+156], eax
	mov	ebx, eax
$LL7@RefineExt:

; 283  : 			{
; 284  : 				pp1[w] = pSrc2x[(w<<1)               + 1];

	movzx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [ecx+ebp-1], al
	lea	edx, DWORD PTR [edx+2]

; 285  : 				pp2[w] = pSrc2x[(w<<1) + nSrc2xPitch    ];

	mov	eax, DWORD PTR tv1752[esp+156]
	inc	edi
	movzx	eax, BYTE PTR [eax+edx-2]
	mov	BYTE PTR [ecx-1], al

; 286  : 				pp3[w] = pSrc2x[(w<<1) + nSrc2xPitch + 1];

	mov	eax, DWORD PTR _nSrc2xPitch$[esp+152]
	movzx	eax, BYTE PTR [edx+eax-2]
	mov	BYTE PTR [ebx+ecx-1], al
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL7@RefineExt
	mov	ebx, DWORD PTR _pSrc2x_8$[esp+152]
	mov	ecx, DWORD PTR _pp2$1$[esp+156]
	mov	ebp, DWORD PTR _pp1$1$[esp+156]
	mov	edx, DWORD PTR _pp3$1$[esp+156]
$LN6@RefineExt:

; 287  : 			}
; 288  : 			pp1 += nPitch/sizeof(pixel_t);

	mov	eax, DWORD PTR [esi+12]
	add	ebp, eax

; 289  : 			pp2 += nPitch/sizeof(pixel_t);
; 290  : 			pp3 += nPitch/sizeof(pixel_t);
; 291  : 			pSrc2x += nSrc2xPitch*2;

	add	ebx, DWORD PTR tv1756[esp+156]
	add	ecx, eax
	add	edx, eax
	mov	DWORD PTR _pp1$1$[esp+156], ebp
	mov	eax, DWORD PTR _h$1$[esp+156]
	inc	eax
	mov	DWORD PTR _pp2$1$[esp+156], ecx
	cmp	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _h$1$[esp+156], eax
	mov	eax, DWORD PTR _nSrc2xPitch$[esp+152]
	mov	DWORD PTR _pp3$1$[esp+156], edx
	mov	DWORD PTR _pSrc2x_8$[esp+152], ebx
	jl	$LL4@RefineExt
$LN3@RefineExt:

; 292  : 		}
; 293  : 		if (! isExtPadded)

	cmp	BYTE PTR _isExtPadded$[esp+152], 0
	jne	SHORT $LN16@RefineExt

; 294  : 		{
; 295  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[1], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 296  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[2], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 297  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[3], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+12]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>
	add	esp, 48					; 00000030H
$LN16@RefineExt:

; 298  : 		}
; 299  : 		isPadded = true;

	pop	edi
	mov	WORD PTR [esi+70], 257			; 00000101H
	pop	esi
	pop	ebp
	pop	ebx

; 379  : }

	add	esp, 140				; 0000008cH
	ret	12					; 0000000cH
$LN14@RefineExt:

; 300  : 	}
; 301  : 	else if (( nPel == 4 ) && ( !isRefined ))

	cmp	eax, 4
	jne	$LN40@RefineExt
	cmp	BYTE PTR [esi+71], 0
	jne	$LN40@RefineExt

; 302  : 	{
; 303  :         // pel clip may be already padded (i.e. is finest clip)
; 304  : 		int offset = isExtPadded ? 0 : nPitch*nVPadding/sizeof(pixel_t) + nHPadding;

	cmp	BYTE PTR _isExtPadded$[esp+152], 0
	je	SHORT $LN22@RefineExt
	xor	ecx, ecx
	jmp	SHORT $LN23@RefineExt
$LN22@RefineExt:
	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, DWORD PTR [esi+12]
	add	ecx, DWORD PTR [esi+16]
$LN23@RefineExt:

; 305  :         pixel_t* pp1  = reinterpret_cast<pixel_t *>(pPlane[ 1]) + offset;

	mov	eax, DWORD PTR [esi]

; 306  :         pixel_t* pp2  = reinterpret_cast<pixel_t *>(pPlane[ 2]) + offset;
; 307  :         pixel_t* pp3  = reinterpret_cast<pixel_t *>(pPlane[ 3]) + offset;
; 308  :         pixel_t* pp4  = reinterpret_cast<pixel_t *>(pPlane[ 4]) + offset;
; 309  :         pixel_t* pp5  = reinterpret_cast<pixel_t *>(pPlane[ 5]) + offset;
; 310  :         pixel_t* pp6  = reinterpret_cast<pixel_t *>(pPlane[ 6]) + offset;
; 311  :         pixel_t* pp7  = reinterpret_cast<pixel_t *>(pPlane[ 7]) + offset;
; 312  :         pixel_t* pp8  = reinterpret_cast<pixel_t *>(pPlane[ 8]) + offset;
; 313  :         pixel_t* pp9  = reinterpret_cast<pixel_t *>(pPlane[ 9]) + offset;
; 314  :         pixel_t* pp10 = reinterpret_cast<pixel_t *>(pPlane[10]) + offset;
; 315  :         pixel_t* pp11 = reinterpret_cast<pixel_t *>(pPlane[11]) + offset;
; 316  :         pixel_t* pp12 = reinterpret_cast<pixel_t *>(pPlane[12]) + offset;
; 317  :         pixel_t* pp13 = reinterpret_cast<pixel_t *>(pPlane[13]) + offset;
; 318  :         pixel_t* pp14 = reinterpret_cast<pixel_t *>(pPlane[14]) + offset;
; 319  :         pixel_t* pp15 = reinterpret_cast<pixel_t *>(pPlane[15]) + offset;
; 320  : 
; 321  : 		for (int h=0; h<nHeight; h++) // assembler optimization?

	mov	DWORD PTR _h$1$[esp+156], 0
	mov	edx, DWORD PTR [eax+12]
	add	edx, ecx
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR _pp3$1$[esp+156], edx
	add	edi, ecx
	mov	edx, DWORD PTR [eax+16]
	add	edx, ecx
	mov	ebp, DWORD PTR [eax+8]
	mov	DWORD PTR _pp4$1$[esp+156], edx
	add	ebp, ecx
	mov	edx, DWORD PTR [eax+20]
	add	edx, ecx
	mov	DWORD PTR _pp1$1$[esp+156], edi
	mov	DWORD PTR _pp5$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+24]
	add	edx, ecx
	mov	DWORD PTR _pp2$1$[esp+156], ebp
	mov	DWORD PTR _pp6$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+28]
	add	edx, ecx
	mov	DWORD PTR _pp7$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+32]
	add	edx, ecx
	mov	DWORD PTR _pp8$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+36]
	add	edx, ecx
	mov	DWORD PTR _pp9$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+40]
	add	edx, ecx
	mov	DWORD PTR _pp10$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+44]
	add	edx, ecx
	mov	DWORD PTR _pp11$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+48]
	add	edx, ecx
	mov	DWORD PTR _pp12$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+52]
	add	edx, ecx
	mov	DWORD PTR _pp13$1$[esp+156], edx
	mov	edx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [eax+60]
	add	edx, ecx
	add	eax, ecx
	mov	DWORD PTR _pp14$1$[esp+156], edx
	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _pp15$1$[esp+156], eax
	jle	$LN9@RefineExt
	mov	edx, DWORD PTR _nSrc2xPitch$[esp+152]
	mov	ebx, DWORD PTR _pSrc2x_8$[esp+152]
	mov	ecx, DWORD PTR _pp3$1$[esp+156]
$LL10@RefineExt:

; 322  : 		{
; 323  : 			for (int w=0; w<nWidth; w++)

	cmp	DWORD PTR [esi+4], 0
	mov	DWORD PTR _w$1$[esp+156], 0
	jle	$LN12@RefineExt
	lea	ecx, DWORD PTR [ebx+2]
	mov	DWORD PTR tv1742[esp+156], 1
	mov	DWORD PTR tv1748[esp+156], ecx
	lea	edi, DWORD PTR [edx+1]
	mov	ecx, DWORD PTR _nSrc2xPitch$[esp+152]
	lea	edi, DWORD PTR [ebx+edi*2]
	add	edi, edx
	mov	eax, ebp
	add	edx, 2
	add	edx, ebx
	lea	ebx, DWORD PTR [ebx+ecx*2]
	or	ecx, -1
	sub	ecx, DWORD PTR _nSrc2xPitch$[esp+152]
	add	ebx, 2
	mov	DWORD PTR tv1744[esp+156], ecx
	mov	ecx, DWORD PTR _nSrc2xPitch$[esp+152]
	sub	DWORD PTR tv1742[esp+156], ecx
	mov	ecx, DWORD PTR _pp1$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1741[esp+156], ecx
	mov	ecx, DWORD PTR _pp3$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1740[esp+156], ecx
	mov	ecx, DWORD PTR _pp4$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1739[esp+156], ecx
	mov	ecx, DWORD PTR _pp5$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1737[esp+156], ecx
	mov	ecx, DWORD PTR _pp6$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1736[esp+156], ecx
	mov	ecx, DWORD PTR _pp7$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1735[esp+156], ecx
	mov	ecx, DWORD PTR _pp8$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1734[esp+156], ecx
	mov	ecx, DWORD PTR _pp9$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1733[esp+156], ecx
	mov	ecx, DWORD PTR _pp10$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1732[esp+156], ecx
	mov	ecx, DWORD PTR _pp11$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1731[esp+156], ecx
	mov	ecx, DWORD PTR _pp12$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1730[esp+156], ecx
	mov	ecx, DWORD PTR _pp13$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1729[esp+156], ecx
	mov	ecx, DWORD PTR _pp14$1$[esp+156]
	sub	ecx, ebp
	mov	DWORD PTR tv1728[esp+156], ecx
	mov	ecx, DWORD PTR _pp15$1$[esp+156]
	sub	ecx, ebp
	mov	ebp, DWORD PTR _w$1$[esp+156]
	mov	DWORD PTR tv1727[esp+156], ecx
	mov	ecx, DWORD PTR tv1744[esp+156]
$LL13@RefineExt:

; 324  : 			{
; 325  : 				pp1 [w] = pSrc2x[(w<<2)                 + 1];

	movzx	ecx, BYTE PTR [ecx+edx]
	lea	eax, DWORD PTR [eax+1]
	mov	esi, DWORD PTR tv1741[esp+156]
	lea	ebx, DWORD PTR [ebx+4]
	inc	ebp
	lea	edx, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [edi+4]
	mov	BYTE PTR [esi+eax-1], cl

; 326  : 				pp2 [w] = pSrc2x[(w<<2)                 + 2];

	mov	ecx, DWORD PTR tv1748[esp+156]

; 327  : 				pp3 [w] = pSrc2x[(w<<2)                 + 3];

	mov	esi, DWORD PTR tv1740[esp+156]
	add	DWORD PTR tv1748[esp+156], 4
	movzx	ecx, BYTE PTR [ecx]
	mov	BYTE PTR [eax-1], cl
	mov	ecx, DWORD PTR tv1742[esp+156]
	movzx	ecx, BYTE PTR [ecx+edx-4]
	mov	BYTE PTR [esi+eax-1], cl

; 328  : 				pp4 [w] = pSrc2x[(w<<2) + nSrc2xPitch      ];

	movzx	ecx, BYTE PTR [edx-6]
	mov	esi, DWORD PTR tv1739[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 329  : 				pp5 [w] = pSrc2x[(w<<2) + nSrc2xPitch   + 1];

	movzx	ecx, BYTE PTR [edx-5]
	mov	esi, DWORD PTR tv1737[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 330  : 				pp6 [w] = pSrc2x[(w<<2) + nSrc2xPitch   + 2];

	movzx	ecx, BYTE PTR [edx-4]
	mov	esi, DWORD PTR tv1736[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 331  : 				pp7 [w] = pSrc2x[(w<<2) + nSrc2xPitch   + 3];

	movzx	ecx, BYTE PTR [edx-3]
	mov	esi, DWORD PTR tv1735[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 332  : 				pp8 [w] = pSrc2x[(w<<2) + nSrc2xPitch*2    ];

	movzx	ecx, BYTE PTR [ebx-6]
	mov	esi, DWORD PTR tv1734[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 333  : 				pp9 [w] = pSrc2x[(w<<2) + nSrc2xPitch*2 + 1];

	movzx	ecx, BYTE PTR [ebx-5]
	mov	esi, DWORD PTR tv1733[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 334  : 				pp10[w] = pSrc2x[(w<<2) + nSrc2xPitch*2 + 2];

	movzx	ecx, BYTE PTR [ebx-4]
	mov	esi, DWORD PTR tv1732[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 335  : 				pp11[w] = pSrc2x[(w<<2) + nSrc2xPitch*2 + 3];

	movzx	ecx, BYTE PTR [ebx-3]
	mov	esi, DWORD PTR tv1731[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 336  : 				pp12[w] = pSrc2x[(w<<2) + nSrc2xPitch*3    ];

	movzx	ecx, BYTE PTR [edi-6]
	mov	esi, DWORD PTR tv1730[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 337  : 				pp13[w] = pSrc2x[(w<<2) + nSrc2xPitch*3 + 1];

	movzx	ecx, BYTE PTR [edi-5]
	mov	esi, DWORD PTR tv1729[esp+156]
	mov	BYTE PTR [esi+eax-1], cl

; 338  : 				pp14[w] = pSrc2x[(w<<2) + nSrc2xPitch*3 + 2];

	mov	esi, DWORD PTR tv1728[esp+156]
	movzx	ecx, BYTE PTR [edi-4]
	mov	BYTE PTR [esi+eax-1], cl

; 339  : 				pp15[w] = pSrc2x[(w<<2) + nSrc2xPitch*3 + 3];

	mov	esi, DWORD PTR tv1727[esp+156]
	movzx	ecx, BYTE PTR [edi-3]
	mov	BYTE PTR [esi+eax-1], cl
	mov	esi, DWORD PTR _this$1$[esp+156]
	mov	ecx, DWORD PTR tv1744[esp+156]
	cmp	ebp, DWORD PTR [esi+4]
	jl	$LL13@RefineExt
	mov	ebp, DWORD PTR _pp2$1$[esp+156]
	mov	ebx, DWORD PTR _pSrc2x_8$[esp+152]
	mov	edx, DWORD PTR _nSrc2xPitch$[esp+152]
	mov	edi, DWORD PTR _pp1$1$[esp+156]
	mov	ecx, DWORD PTR _pp3$1$[esp+156]
$LN12@RefineExt:

; 340  : 			}
; 341  : 			pp1  += nPitch/sizeof(pixel_t);

	mov	eax, DWORD PTR [esi+12]
	add	edi, eax

; 342  : 			pp2  += nPitch/sizeof(pixel_t);
; 343  : 			pp3  += nPitch/sizeof(pixel_t);
; 344  : 			pp4  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp4$1$[esp+156], eax
	add	ebp, eax

; 345  : 			pp5  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp5$1$[esp+156], eax
	add	ecx, eax

; 346  : 			pp6  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp6$1$[esp+156], eax

; 347  : 			pp7  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp7$1$[esp+156], eax

; 348  : 			pp8  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp8$1$[esp+156], eax

; 349  : 			pp9  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp9$1$[esp+156], eax

; 350  : 			pp10 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp10$1$[esp+156], eax

; 351  : 			pp11 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp11$1$[esp+156], eax

; 352  : 			pp12 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp12$1$[esp+156], eax

; 353  : 			pp13 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp13$1$[esp+156], eax

; 354  : 			pp14 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp14$1$[esp+156], eax

; 355  : 			pp15 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp15$1$[esp+156], eax

; 356  : 			pSrc2x += nSrc2xPitch*4;

	lea	eax, DWORD PTR [edx*4]
	add	ebx, eax
	mov	DWORD PTR _pp1$1$[esp+156], edi
	mov	eax, DWORD PTR _h$1$[esp+156]
	inc	eax
	mov	DWORD PTR _pp2$1$[esp+156], ebp
	mov	DWORD PTR _pp3$1$[esp+156], ecx
	mov	DWORD PTR _pSrc2x_8$[esp+152], ebx
	mov	DWORD PTR _h$1$[esp+156], eax
	cmp	eax, DWORD PTR [esi+8]
	jl	$LL10@RefineExt
$LN9@RefineExt:

; 357  : 		}
; 358  : 		if (!isExtPadded)

	cmp	BYTE PTR _isExtPadded$[esp+152], 0
	jne	$LN16@RefineExt

; 359  : 		{
; 360  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 1], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 361  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 2], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 362  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 3], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+12]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 363  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 4], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+16]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 364  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 5], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	mov	ecx, DWORD PTR [esi]
	add	esp, 64					; 00000040H
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ecx+20]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 365  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 6], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+24]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 366  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 7], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+28]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 367  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 8], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+32]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 368  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 9], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	mov	ecx, DWORD PTR [esi]
	add	esp, 64					; 00000040H
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ecx+36]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 369  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[10], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+40]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 370  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[11], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+44]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 371  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[12], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+48]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 372  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[13], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	mov	ecx, DWORD PTR [esi]
	add	esp, 64					; 00000040H
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ecx+52]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 373  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[14], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+56]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 374  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[15], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+60]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>
	add	esp, 48					; 00000030H

; 375  : 		}
; 376  : 		isPadded = true;

	mov	WORD PTR [esi+70], 257			; 00000101H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 379  : }

	add	esp, 140				; 0000008cH
	ret	12					; 0000000cH
$LN40@RefineExt:
	pop	edi

; 377  : 	}
; 378  : 	isRefined = true;

	mov	BYTE PTR [esi+71], 1
	pop	esi
	pop	ebp
	pop	ebx

; 379  : }

	add	esp, 140				; 0000008cH
	ret	12					; 0000000cH
??$RefineExt@E@MVPlane@@QAEXPBEH_N@Z ENDP		; MVPlane::RefineExt<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvplane.cpp
;	COMDAT ??$RefineExt@G@MVPlane@@QAEXPBEH_N@Z
_TEXT	SEGMENT
_pp3$1$ = -128						; size = 4
_pp3$1$ = -128						; size = 4
_pp1$1$ = -124						; size = 4
_pp1$1$ = -124						; size = 4
_pp2$1$ = -120						; size = 4
tv2010 = -120						; size = 4
_pp2$1$ = -116						; size = 4
_pp4$1$ = -112						; size = 4
_pp5$1$ = -108						; size = 4
_pp6$1$ = -104						; size = 4
_pp7$1$ = -100						; size = 4
_pp8$1$ = -96						; size = 4
_pp9$1$ = -92						; size = 4
_pp10$1$ = -88						; size = 4
_pp11$1$ = -84						; size = 4
_pp12$1$ = -80						; size = 4
_pp13$1$ = -76						; size = 4
_pp14$1$ = -72						; size = 4
_h$1$ = -72						; size = 4
_pp15$1$ = -68						; size = 4
tv2017 = -68						; size = 4
_w$1$ = -64						; size = 4
tv2023 = -64						; size = 4
_h$1$ = -60						; size = 4
tv2016 = -60						; size = 4
tv2009 = -56						; size = 4
tv2008 = -52						; size = 4
tv2007 = -48						; size = 4
tv2006 = -44						; size = 4
tv2005 = -40						; size = 4
tv2004 = -36						; size = 4
tv2003 = -32						; size = 4
tv2002 = -28						; size = 4
tv2001 = -24						; size = 4
tv2000 = -20						; size = 4
tv1999 = -16						; size = 4
tv1998 = -12						; size = 4
tv1997 = -8						; size = 4
_this$1$ = -4						; size = 4
_pSrc2x_8$ = 8						; size = 4
_nSrc2xPitch$ = 12					; size = 4
_isExtPadded$ = 16					; size = 1
??$RefineExt@G@MVPlane@@QAEXPBEH_N@Z PROC		; MVPlane::RefineExt<unsigned short>, COMDAT
; _this$ = ecx

; 268  : {

	sub	esp, 128				; 00000080H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 269  :     const pixel_t *pSrc2x = reinterpret_cast<const pixel_t *>(pSrc2x_8);
; 270  :     nSrc2xPitch /= sizeof(pixel_t);

	mov	edi, DWORD PTR _nSrc2xPitch$[esp+140]
	shr	edi, 1

; 271  : 
; 272  : 	if (( nPel == 2 ) && ( !isRefined ))

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR _this$1$[esp+144], esi
	mov	DWORD PTR _nSrc2xPitch$[esp+140], edi
	cmp	eax, 2
	jne	$LN14@RefineExt
	cmp	BYTE PTR [esi+71], 0
	jne	$LN14@RefineExt

; 273  : 	{
; 274  : 		// pel clip may be already padded (i.e. is finest clip)
; 275  : 		int offset = isExtPadded ? 0 : nPitch*nVPadding/sizeof(pixel_t) + nHPadding;

	cmp	BYTE PTR _isExtPadded$[esp+140], 0
	je	SHORT $LN20@RefineExt
	xor	ecx, ecx
	jmp	SHORT $LN21@RefineExt
$LN20@RefineExt:
	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, DWORD PTR [esi+12]
	shr	ecx, 1
	add	ecx, DWORD PTR [esi+16]
$LN21@RefineExt:

; 276  : 		pixel_t* pp1 = reinterpret_cast<pixel_t *>(pPlane[1]) + offset;

	mov	eax, DWORD PTR [esi]
	add	ecx, ecx

; 277  : 		pixel_t* pp2 = reinterpret_cast<pixel_t *>(pPlane[2]) + offset;
; 278  : 		pixel_t* pp3 = reinterpret_cast<pixel_t *>(pPlane[3]) + offset;
; 279  : 
; 280  :         for (int h=0; h<nHeight; h++) // assembler optimization?

	mov	DWORD PTR _h$1$[esp+144], 0
	mov	ebx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	add	ebx, ecx
	mov	eax, DWORD PTR [eax+12]
	add	edx, ecx
	add	eax, ecx
	mov	DWORD PTR _pp1$1$[esp+144], ebx
	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _pp2$1$[esp+144], edx
	mov	DWORD PTR _pp3$1$[esp+144], eax
	jle	$LN3@RefineExt
	mov	ebp, DWORD PTR _pSrc2x_8$[esp+140]
	lea	eax, DWORD PTR [edi*4]
	mov	ecx, DWORD PTR _pp3$1$[esp+144]
	mov	DWORD PTR tv2023[esp+144], eax
	npad	6
$LL4@RefineExt:

; 281  : 		{
; 282  : 			for (int w=0; w<nWidth; w++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN6@RefineExt
	mov	eax, DWORD PTR _nSrc2xPitch$[esp+140]
	lea	ebx, DWORD PTR [ebp+2]
	mov	ecx, edx
	lea	edx, DWORD PTR [eax*2]
	mov	eax, DWORD PTR _pp1$1$[esp+144]
	sub	eax, DWORD PTR _pp2$1$[esp+144]
	add	edx, ebp
	mov	DWORD PTR tv2017[esp+144], eax
	mov	eax, DWORD PTR _pp3$1$[esp+144]
	sub	eax, DWORD PTR _pp2$1$[esp+144]
	mov	ebp, DWORD PTR tv2017[esp+144]
	mov	DWORD PTR tv2016[esp+144], eax
	npad	8
$LL7@RefineExt:

; 283  : 			{
; 284  : 				pp1[w] = pSrc2x[(w<<1)               + 1];

	movzx	eax, WORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+4]
	mov	WORD PTR [ecx+ebp], ax
	lea	edx, DWORD PTR [edx+4]

; 285  : 				pp2[w] = pSrc2x[(w<<1) + nSrc2xPitch    ];

	movzx	eax, WORD PTR [edx-4]
	lea	ecx, DWORD PTR [ecx+2]

; 286  : 				pp3[w] = pSrc2x[(w<<1) + nSrc2xPitch + 1];

	mov	ebp, DWORD PTR tv2016[esp+144]
	inc	edi
	mov	WORD PTR [ecx-2], ax
	movzx	eax, WORD PTR [edx-2]
	mov	WORD PTR [ecx+ebp-2], ax
	mov	ebp, DWORD PTR tv2017[esp+144]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL7@RefineExt
	mov	ebp, DWORD PTR _pSrc2x_8$[esp+140]
	mov	edx, DWORD PTR _pp2$1$[esp+144]
	mov	ebx, DWORD PTR _pp1$1$[esp+144]
	mov	ecx, DWORD PTR _pp3$1$[esp+144]
$LN6@RefineExt:

; 287  : 			}
; 288  : 			pp1 += nPitch/sizeof(pixel_t);

	mov	eax, DWORD PTR [esi+12]

; 289  : 			pp2 += nPitch/sizeof(pixel_t);
; 290  : 			pp3 += nPitch/sizeof(pixel_t);
; 291  : 			pSrc2x += nSrc2xPitch*2;

	add	ebp, DWORD PTR tv2023[esp+144]
	and	eax, -2					; fffffffeH
	add	ebx, eax
	mov	DWORD PTR _pSrc2x_8$[esp+140], ebp
	add	edx, eax
	mov	DWORD PTR _pp1$1$[esp+144], ebx
	add	ecx, eax
	mov	DWORD PTR _pp2$1$[esp+144], edx
	mov	eax, DWORD PTR _h$1$[esp+144]
	inc	eax
	mov	DWORD PTR _pp3$1$[esp+144], ecx
	mov	DWORD PTR _h$1$[esp+144], eax
	cmp	eax, DWORD PTR [esi+8]
	jl	$LL4@RefineExt
$LN3@RefineExt:

; 292  : 		}
; 293  : 		if (! isExtPadded)

	cmp	BYTE PTR _isExtPadded$[esp+140], 0
	jne	SHORT $LN16@RefineExt

; 294  : 		{
; 295  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[1], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 296  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[2], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 297  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[3], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+12]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>
	add	esp, 48					; 00000030H
$LN16@RefineExt:

; 298  : 		}
; 299  : 		isPadded = true;

	pop	edi
	mov	WORD PTR [esi+70], 257			; 00000101H
	pop	esi
	pop	ebp
	pop	ebx

; 379  : }

	add	esp, 128				; 00000080H
	ret	12					; 0000000cH
$LN14@RefineExt:

; 300  : 	}
; 301  : 	else if (( nPel == 4 ) && ( !isRefined ))

	cmp	eax, 4
	jne	$LN40@RefineExt
	cmp	BYTE PTR [esi+71], 0
	jne	$LN40@RefineExt

; 302  : 	{
; 303  :         // pel clip may be already padded (i.e. is finest clip)
; 304  : 		int offset = isExtPadded ? 0 : nPitch*nVPadding/sizeof(pixel_t) + nHPadding;

	cmp	BYTE PTR _isExtPadded$[esp+140], 0
	je	SHORT $LN22@RefineExt
	xor	ecx, ecx
	jmp	SHORT $LN23@RefineExt
$LN22@RefineExt:
	mov	ecx, DWORD PTR [esi+20]
	imul	ecx, DWORD PTR [esi+12]
	shr	ecx, 1
	add	ecx, DWORD PTR [esi+16]
$LN23@RefineExt:

; 305  :         pixel_t* pp1  = reinterpret_cast<pixel_t *>(pPlane[ 1]) + offset;

	mov	eax, DWORD PTR [esi]
	add	ecx, ecx

; 306  :         pixel_t* pp2  = reinterpret_cast<pixel_t *>(pPlane[ 2]) + offset;
; 307  :         pixel_t* pp3  = reinterpret_cast<pixel_t *>(pPlane[ 3]) + offset;
; 308  :         pixel_t* pp4  = reinterpret_cast<pixel_t *>(pPlane[ 4]) + offset;
; 309  :         pixel_t* pp5  = reinterpret_cast<pixel_t *>(pPlane[ 5]) + offset;
; 310  :         pixel_t* pp6  = reinterpret_cast<pixel_t *>(pPlane[ 6]) + offset;
; 311  :         pixel_t* pp7  = reinterpret_cast<pixel_t *>(pPlane[ 7]) + offset;
; 312  :         pixel_t* pp8  = reinterpret_cast<pixel_t *>(pPlane[ 8]) + offset;
; 313  :         pixel_t* pp9  = reinterpret_cast<pixel_t *>(pPlane[ 9]) + offset;
; 314  :         pixel_t* pp10 = reinterpret_cast<pixel_t *>(pPlane[10]) + offset;
; 315  :         pixel_t* pp11 = reinterpret_cast<pixel_t *>(pPlane[11]) + offset;
; 316  :         pixel_t* pp12 = reinterpret_cast<pixel_t *>(pPlane[12]) + offset;
; 317  :         pixel_t* pp13 = reinterpret_cast<pixel_t *>(pPlane[13]) + offset;
; 318  :         pixel_t* pp14 = reinterpret_cast<pixel_t *>(pPlane[14]) + offset;
; 319  :         pixel_t* pp15 = reinterpret_cast<pixel_t *>(pPlane[15]) + offset;
; 320  : 
; 321  : 		for (int h=0; h<nHeight; h++) // assembler optimization?

	mov	DWORD PTR _h$1$[esp+144], 0
	mov	ebx, DWORD PTR [eax+12]
	add	ebx, ecx
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR _pp3$1$[esp+144], ebx
	add	ebp, ecx
	mov	ebx, DWORD PTR [eax+16]
	add	ebx, ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _pp4$1$[esp+144], ebx
	add	edx, ecx
	mov	ebx, DWORD PTR [eax+20]
	add	ebx, ecx
	mov	DWORD PTR _pp1$1$[esp+144], ebp
	mov	DWORD PTR _pp5$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+24]
	add	ebx, ecx
	mov	DWORD PTR _pp2$1$[esp+144], edx
	mov	DWORD PTR _pp6$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+28]
	add	ebx, ecx
	mov	DWORD PTR _pp7$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+32]
	add	ebx, ecx
	mov	DWORD PTR _pp8$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+36]
	add	ebx, ecx
	mov	DWORD PTR _pp9$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+40]
	add	ebx, ecx
	mov	DWORD PTR _pp10$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+44]
	add	ebx, ecx
	mov	DWORD PTR _pp11$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+48]
	add	ebx, ecx
	mov	DWORD PTR _pp12$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+52]
	add	ebx, ecx
	mov	DWORD PTR _pp13$1$[esp+144], ebx
	mov	ebx, DWORD PTR [eax+56]
	mov	eax, DWORD PTR [eax+60]
	add	ebx, ecx
	add	eax, ecx
	mov	DWORD PTR _pp14$1$[esp+144], ebx
	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _pp15$1$[esp+144], eax
	jle	$LN9@RefineExt
	mov	ebx, DWORD PTR _pSrc2x_8$[esp+140]
	mov	ecx, DWORD PTR _pp3$1$[esp+144]
	npad	9
$LL10@RefineExt:

; 322  : 		{
; 323  : 			for (int w=0; w<nWidth; w++)

	cmp	DWORD PTR [esi+4], 0
	mov	DWORD PTR _w$1$[esp+144], 0
	jle	$LN12@RefineExt
	mov	esi, DWORD PTR _pp3$1$[esp+144]
	lea	ecx, DWORD PTR [edi+1]
	lea	ecx, DWORD PTR [edi+ecx*2]
	mov	eax, edx
	lea	edx, DWORD PTR [ebx+ecx*2]
	inc	edi
	mov	ecx, DWORD PTR _nSrc2xPitch$[esp+140]
	lea	ebp, DWORD PTR [ebx+4]
	lea	edi, DWORD PTR [ebx+edi*4]
	lea	ebx, DWORD PTR [ebx+ecx*2]
	mov	ecx, DWORD PTR _pp1$1$[esp+144]
	mov	DWORD PTR tv2010[esp+144], ecx
	add	ebx, 4
	mov	ecx, DWORD PTR _pp2$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2009[esp+144], esi
	mov	esi, DWORD PTR _pp4$1$[esp+144]
	sub	esi, ecx
	sub	DWORD PTR tv2010[esp+144], ecx
	mov	DWORD PTR tv2008[esp+144], esi
	mov	esi, DWORD PTR _pp5$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2007[esp+144], esi
	mov	esi, DWORD PTR _pp6$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2006[esp+144], esi
	mov	esi, DWORD PTR _pp7$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2005[esp+144], esi
	mov	esi, DWORD PTR _pp8$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2004[esp+144], esi
	mov	esi, DWORD PTR _pp9$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2003[esp+144], esi
	mov	esi, DWORD PTR _pp10$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2002[esp+144], esi
	mov	esi, DWORD PTR _pp11$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2001[esp+144], esi
	mov	esi, DWORD PTR _pp12$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv2000[esp+144], esi
	mov	esi, DWORD PTR _pp13$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv1999[esp+144], esi
	mov	esi, DWORD PTR _pp14$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv1998[esp+144], esi
	mov	esi, DWORD PTR _pp15$1$[esp+144]
	sub	esi, ecx
	mov	DWORD PTR tv1997[esp+144], esi
	npad	4
$LL13@RefineExt:

; 324  : 			{
; 325  : 				pp1 [w] = pSrc2x[(w<<2)                 + 1];

	movzx	ecx, WORD PTR [ebp-2]
	lea	ebx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR tv2010[esp+144]
	lea	ebp, DWORD PTR [ebp+8]
	lea	edx, DWORD PTR [edx+8]
	lea	edi, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+2]
	mov	WORD PTR [eax+esi-2], cx

; 326  : 				pp2 [w] = pSrc2x[(w<<2)                 + 2];

	movzx	ecx, WORD PTR [ebp-8]

; 327  : 				pp3 [w] = pSrc2x[(w<<2)                 + 3];

	mov	esi, DWORD PTR tv2009[esp+144]
	mov	WORD PTR [eax-2], cx
	movzx	ecx, WORD PTR [ebp-6]
	mov	WORD PTR [eax+esi-2], cx

; 328  : 				pp4 [w] = pSrc2x[(w<<2) + nSrc2xPitch      ];

	movzx	ecx, WORD PTR [ebx-12]
	mov	esi, DWORD PTR tv2008[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 329  : 				pp5 [w] = pSrc2x[(w<<2) + nSrc2xPitch   + 1];

	movzx	ecx, WORD PTR [ebx-10]
	mov	esi, DWORD PTR tv2007[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 330  : 				pp6 [w] = pSrc2x[(w<<2) + nSrc2xPitch   + 2];

	movzx	ecx, WORD PTR [ebx-8]
	mov	esi, DWORD PTR tv2006[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 331  : 				pp7 [w] = pSrc2x[(w<<2) + nSrc2xPitch   + 3];

	movzx	ecx, WORD PTR [ebx-6]
	mov	esi, DWORD PTR tv2005[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 332  : 				pp8 [w] = pSrc2x[(w<<2) + nSrc2xPitch*2    ];

	movzx	ecx, WORD PTR [edi-12]
	mov	esi, DWORD PTR tv2004[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 333  : 				pp9 [w] = pSrc2x[(w<<2) + nSrc2xPitch*2 + 1];

	movzx	ecx, WORD PTR [edi-10]
	mov	esi, DWORD PTR tv2003[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 334  : 				pp10[w] = pSrc2x[(w<<2) + nSrc2xPitch*2 + 2];

	movzx	ecx, WORD PTR [edi-8]
	mov	esi, DWORD PTR tv2002[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 335  : 				pp11[w] = pSrc2x[(w<<2) + nSrc2xPitch*2 + 3];

	movzx	ecx, WORD PTR [edi-6]
	mov	esi, DWORD PTR tv2001[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 336  : 				pp12[w] = pSrc2x[(w<<2) + nSrc2xPitch*3    ];

	movzx	ecx, WORD PTR [edx-12]
	mov	esi, DWORD PTR tv2000[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 337  : 				pp13[w] = pSrc2x[(w<<2) + nSrc2xPitch*3 + 1];

	movzx	ecx, WORD PTR [edx-10]
	mov	esi, DWORD PTR tv1999[esp+144]
	mov	WORD PTR [eax+esi-2], cx

; 338  : 				pp14[w] = pSrc2x[(w<<2) + nSrc2xPitch*3 + 2];

	mov	esi, DWORD PTR tv1998[esp+144]
	movzx	ecx, WORD PTR [edx-8]
	mov	WORD PTR [eax+esi-2], cx

; 339  : 				pp15[w] = pSrc2x[(w<<2) + nSrc2xPitch*3 + 3];

	mov	esi, DWORD PTR tv1997[esp+144]
	movzx	ecx, WORD PTR [edx-6]
	mov	WORD PTR [eax+esi-2], cx
	mov	ecx, DWORD PTR _w$1$[esp+144]
	mov	esi, DWORD PTR _this$1$[esp+144]
	inc	ecx
	mov	DWORD PTR _w$1$[esp+144], ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	$LL13@RefineExt
	mov	edx, DWORD PTR _pp2$1$[esp+144]
	mov	ebx, DWORD PTR _pSrc2x_8$[esp+140]
	mov	edi, DWORD PTR _nSrc2xPitch$[esp+140]
	mov	ebp, DWORD PTR _pp1$1$[esp+144]
	mov	ecx, DWORD PTR _pp3$1$[esp+144]
$LN12@RefineExt:

; 340  : 			}
; 341  : 			pp1  += nPitch/sizeof(pixel_t);

	mov	eax, DWORD PTR [esi+12]
	and	eax, -2					; fffffffeH

; 342  : 			pp2  += nPitch/sizeof(pixel_t);
; 343  : 			pp3  += nPitch/sizeof(pixel_t);
; 344  : 			pp4  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp4$1$[esp+144], eax
	add	ebp, eax

; 345  : 			pp5  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp5$1$[esp+144], eax
	add	edx, eax

; 346  : 			pp6  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp6$1$[esp+144], eax
	add	ecx, eax

; 347  : 			pp7  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp7$1$[esp+144], eax

; 348  : 			pp8  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp8$1$[esp+144], eax

; 349  : 			pp9  += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp9$1$[esp+144], eax

; 350  : 			pp10 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp10$1$[esp+144], eax

; 351  : 			pp11 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp11$1$[esp+144], eax

; 352  : 			pp12 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp12$1$[esp+144], eax

; 353  : 			pp13 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp13$1$[esp+144], eax

; 354  : 			pp14 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp14$1$[esp+144], eax

; 355  : 			pp15 += nPitch/sizeof(pixel_t);

	add	DWORD PTR _pp15$1$[esp+144], eax

; 356  : 			pSrc2x += nSrc2xPitch*4;

	lea	eax, DWORD PTR [edi*8]
	add	ebx, eax
	mov	DWORD PTR _pp1$1$[esp+144], ebp
	mov	eax, DWORD PTR _h$1$[esp+144]
	inc	eax
	mov	DWORD PTR _pp2$1$[esp+144], edx
	mov	DWORD PTR _pp3$1$[esp+144], ecx
	mov	DWORD PTR _pSrc2x_8$[esp+140], ebx
	mov	DWORD PTR _h$1$[esp+144], eax
	cmp	eax, DWORD PTR [esi+8]
	jl	$LL10@RefineExt
$LN9@RefineExt:

; 357  : 		}
; 358  : 		if (!isExtPadded)

	cmp	BYTE PTR _isExtPadded$[esp+140], 0
	jne	$LN16@RefineExt

; 359  : 		{
; 360  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 1], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 361  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 2], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+8]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 362  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 3], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+12]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 363  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 4], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+16]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 364  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 5], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	mov	ecx, DWORD PTR [esi]
	add	esp, 64					; 00000040H
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ecx+20]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 365  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 6], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+24]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 366  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 7], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+28]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 367  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 8], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+32]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 368  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[ 9], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	mov	ecx, DWORD PTR [esi]
	add	esp, 64					; 00000040H
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ecx+36]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 369  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[10], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+40]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 370  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[11], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+44]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 371  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[12], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+48]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 372  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[13], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	mov	ecx, DWORD PTR [esi]
	add	esp, 64					; 00000040H
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ecx+52]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 373  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[14], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+56]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>

; 374  : 			Padding::PadReferenceFrame<pixel_t>(pPlane[15], nPitch, nHPadding, nVPadding, nWidth, nHeight);

	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	push	DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [ecx+60]
	push	DWORD PTR [esi+16]
	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>
	add	esp, 48					; 00000030H

; 375  : 		}
; 376  : 		isPadded = true;

	mov	WORD PTR [esi+70], 257			; 00000101H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 379  : }

	add	esp, 128				; 00000080H
	ret	12					; 0000000cH
$LN40@RefineExt:
	pop	edi

; 377  : 	}
; 378  : 	isRefined = true;

	mov	BYTE PTR [esi+71], 1
	pop	esi
	pop	ebp
	pop	ebx

; 379  : }

	add	esp, 128				; 00000080H
	ret	12					; 0000000cH
??$RefineExt@G@MVPlane@@QAEXPBEH_N@Z ENDP		; MVPlane::RefineExt<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 89   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 90   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@6B@
	je	SHORT $LN5@scalar

; 202  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+276], 0
	je	SHORT $LN9@scalar

; 203  : 	{
; 204  : 		assert (_dispatcher_ptr != 0);
; 205  : 
; 206  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 207  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN9@scalar:
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 210  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 211  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0

; 212  : 	_dep_graph_ptr = 0;

	mov	DWORD PTR [esi+16], 0
$LN5@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN15@scalar
	push	280					; 00000118H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN15@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@UAEPAXI@Z ENDP ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??0?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAE@XZ
_TEXT	SEGMENT
??0?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAE@XZ PROC	; conc::Array<conc::AtomicInt<int>,16>::Array<conc::AtomicInt<int>,16>, COMDAT
; _this$ = ecx
	mov	edx, 16					; 00000010H
	mov	eax, ecx
	npad	9
$LL4@Array:

; 54   : :	_val ()

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+4]
	sub	edx, 1
	jne	SHORT $LL4@Array
	mov	eax, ecx
	ret	0
??0?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAE@XZ ENDP	; conc::Array<conc::AtomicInt<int>,16>::Array<conc::AtomicInt<int>,16>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z PROC	; MTSlicer<MVPlane,MVPlane,64>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VMVPlane@@V1@$0EA@@@6B@
	je	SHORT $LN5@scalar

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	je	SHORT $LN9@scalar

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN9@scalar:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0
$LN5@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN15@scalar
	push	1044					; 00000414H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN15@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$MTSlicer@VMVPlane@@V1@$0EA@@@UAEPAXI@Z ENDP	; MTSlicer<MVPlane,MVPlane,64>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?access@?$MTSlicer_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z
_TEXT	SEGMENT
?access@?$MTSlicer_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z PROC ; MTSlicer_Access<MVPlane,MVPlane>::access, COMDAT
; _ptr$ = ecx

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	eax, ecx
	ret	0
?access@?$MTSlicer_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z ENDP ; MTSlicer_Access<MVPlane,MVPlane>::access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ?access@?$MTFlowGraphSched_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z
_TEXT	SEGMENT
?access@?$MTFlowGraphSched_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z PROC ; MTFlowGraphSched_Access<MVPlane,MVPlane>::access, COMDAT
; _ptr$ = ecx

; 45   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	eax, ecx
	ret	0
?access@?$MTFlowGraphSched_Access@VMVPlane@@V1@@@SAPAVMVPlane@@PAV2@@Z ENDP ; MTFlowGraphSched_Access<MVPlane,MVPlane>::access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?get_last_node@?$MTFlowGraphSimple@$0BA@@@QBEHXZ
_TEXT	SEGMENT
?get_last_node@?$MTFlowGraphSimple@$0BA@@@QBEHXZ PROC	; MTFlowGraphSimple<16>::get_last_node, COMDAT
; _this$ = ecx

; 130  : 	assert (_last_node >= 0);
; 131  : 	assert (_last_node < MAXT);
; 132  : 
; 133  : 	return (_last_node);

	mov	eax, DWORD PTR [ecx+4]

; 134  : }

	ret	0
?get_last_node@?$MTFlowGraphSimple@$0BA@@@QBEHXZ ENDP	; MTFlowGraphSimple<16>::get_last_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ?complete_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@AAEXAAVTaskData@1@@Z
_TEXT	SEGMENT
_it$2$ = -12						; size = 4
tv386 = -8						; size = 4
tv389 = -4						; size = 4
_td$ = 8						; size = 4
?complete_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@AAEXAAVTaskData@1@@Z PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::complete_task, COMDAT
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 259  : 	for (GR::Iterator it = _dep_graph_ptr->get_out_node_it (td._task_index)

	mov	eax, DWORD PTR _td$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 202  : ,	_pos (0)

	mov	DWORD PTR _it$2$[esp+20], 0
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 259  : 	for (GR::Iterator it = _dep_graph_ptr->get_out_node_it (td._task_index)

	mov	eax, DWORD PTR [eax+8]
	push	edi
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 200  : :	_fg (fg)

	mov	ecx, DWORD PTR [esi+16]
; File c:\github\mvtools\sources\conc\array.hpp

; 44   : 	return (_data [pos]);

	lea	eax, DWORD PTR [eax+eax*4]
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 246  : 	return (_pos < _fg._node_arr [_node]._nbr_out);

	cmp	DWORD PTR [ecx+eax*8+12], 0
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv389[esp+24], eax
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 260  : 	;	it.cont ()

	jle	$LN3@complete_t

; 259  : 	for (GR::Iterator it = _dep_graph_ptr->get_out_node_it (td._task_index)

	add	eax, 16					; 00000010H
	mov	DWORD PTR tv386[esp+24], eax
	npad	5
$LL4@complete_t:
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 267  : 	return (_fg._node_arr [_node]._out_arr [_pos]);

	movsx	ebx, WORD PTR [eax]
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	edi, DWORD PTR [esi+212]
	lea	edi, DWORD PTR [edi+ebx*4]
	npad	4
$LL38@complete_t:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ecx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [edi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL38@complete_t
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 266  : 		const int		count_new = ++ _in_cnt_arr [out_index];

	mov	edx, DWORD PTR [edi]
; File c:\github\mvtools\sources\conc\array.hpp

; 44   : 	return (_data [pos]);

	lea	eax, DWORD PTR [ebx+ebx*4]
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 267  : 		const int		nbr_in    = _dep_graph_ptr->get_nbr_in (out_index);

	mov	ecx, DWORD PTR [esi+16]

; 268  : 		if (count_new >= nbr_in)

	cmp	edx, DWORD PTR [ecx+eax*8+8]
	jl	SHORT $LN2@complete_t
; File c:\github\mvtools\sources\conc\array.hpp

; 55   : 	return (_data [pos]);

	lea	eax, DWORD PTR [ebx*2+5]
	add	eax, ebx
	lea	edi, DWORD PTR [esi+eax*4]
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 271  : 			out_node._glob_data_ptr = td._glob_data_ptr;

	mov	eax, DWORD PTR _td$[ebp]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 139  : 	return (_avstp_enqueue_task_ptr (td_ptr, task_ptr, user_data_ptr));

	push	edi
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 271  : 			out_node._glob_data_ptr = td._glob_data_ptr;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi], eax

; 272  : 			out_node._scheduler_ptr = this;

	mov	DWORD PTR [edi+4], esi

; 273  : 			out_node._task_index    = out_index;

	mov	DWORD PTR [edi+8], ebx

; 274  : 
; 275  : 			if (_mt_flag)

	cmp	BYTE PTR [esi+276], 0
	je	SHORT $LN6@complete_t

; 276  : 			{
; 277  : 				assert (_dispatcher_ptr != 0);
; 278  : 				_avstp.enqueue_task (_dispatcher_ptr, &redirect_task, &out_node);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 139  : 	return (_avstp_enqueue_task_ptr (td_ptr, task_ptr, user_data_ptr));

	mov	ecx, DWORD PTR [esi+4]
	push	OFFSET ?redirect_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::redirect_task
	push	eax
	mov	eax, DWORD PTR [ecx+20]
	call	eax
	add	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 280  : 			else

	jmp	SHORT $LN2@complete_t
$LN6@complete_t:

; 45   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	ecx, eax

; 281  : 			{
; 282  : 				T *				this_ptr =
; 283  : 					MTFlowGraphSched_Access <T, GD>::access (out_node._glob_data_ptr);
; 284  : 
; 285  : 				((*this_ptr).*(_proc_ptr)) (out_node);

	mov	eax, DWORD PTR [esi+8]
	call	eax

; 286  : 
; 287  : 				complete_task (out_node);

	push	edi
	mov	ecx, esi
	call	?complete_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@AAEXAAVTaskData@1@@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::complete_task
$LN2@complete_t:
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 226  : 	++ _pos;

	mov	edx, DWORD PTR _it$2$[esp+24]

; 246  : 	return (_pos < _fg._node_arr [_node]._nbr_out);

	mov	ecx, DWORD PTR tv389[esp+24]

; 226  : 	++ _pos;

	inc	edx
	mov	eax, DWORD PTR tv386[esp+24]
	add	eax, 2
	mov	DWORD PTR _it$2$[esp+24], edx
	mov	DWORD PTR tv386[esp+24], eax

; 246  : 	return (_pos < _fg._node_arr [_node]._nbr_out);

	cmp	edx, DWORD PTR [ecx+12]
; File c:\github\mvtools\sources\mtflowgraphsched.hpp

; 260  : 	;	it.cont ()

	jl	$LL4@complete_t
$LN3@complete_t:

; 288  : 			}
; 289  : 		}
; 290  : 	}
; 291  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?complete_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@AAEXAAVTaskData@1@@Z ENDP ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::complete_task
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsched.hpp
;	COMDAT ?redirect_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z
_TEXT	SEGMENT
_dispatcher_ptr$ = 8					; size = 4
_data_ptr$ = 12						; size = 4
?redirect_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z PROC ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::redirect_task, COMDAT

; 297  : {

	push	esi
	push	edi

; 45   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	edi, DWORD PTR _data_ptr$[esp+4]

; 309  : 	assert (proc_ptr != 0);
; 310  : 
; 311  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	push	edi
	mov	esi, DWORD PTR [edi+4]

; 45   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	ecx, DWORD PTR [edi]

; 298  : 	TaskData *		td_ptr   = reinterpret_cast <TaskData *> (data_ptr);
; 299  : 	assert (td_ptr != 0);
; 300  : 	assert (td_ptr->_glob_data_ptr != 0);
; 301  : 	assert (td_ptr->_scheduler_ptr != 0);
; 302  : 
; 303  : 	T *				this_ptr =
; 304  : 		MTFlowGraphSched_Access <T, GD>::access (td_ptr->_glob_data_ptr);
; 305  : 	assert (this_ptr != 0);
; 306  : 
; 307  : 	ThisType &		scheduler = *(td_ptr->_scheduler_ptr);
; 308  : 	ProcPtr			proc_ptr = scheduler._proc_ptr;

	mov	eax, DWORD PTR [esi+8]

; 309  : 	assert (proc_ptr != 0);
; 310  : 
; 311  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	call	eax

; 312  : 
; 313  : 	scheduler.complete_task (*td_ptr);

	push	edi
	mov	ecx, esi
	call	?complete_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@AAEXAAVTaskData@1@@Z ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::complete_task
	pop	edi
	pop	esi

; 314  : }

	ret	0
?redirect_task@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ENDP ; MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::redirect_task
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?redirect_task@?$MTSlicer@VMVPlane@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z
_TEXT	SEGMENT
_dispatcher_ptr$ = 8					; size = 4
_data_ptr$ = 12						; size = 4
?redirect_task@?$MTSlicer@VMVPlane@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z PROC ; MTSlicer<MVPlane,MVPlane,64>::redirect_task, COMDAT

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	edx, DWORD PTR _data_ptr$[esp-4]

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	push	edx
	mov	eax, DWORD PTR [edx+4]

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	ecx, DWORD PTR [edx]

; 268  : 	TaskData *		td_ptr   = reinterpret_cast <TaskData *> (data_ptr);
; 269  : 	assert (td_ptr != 0);
; 270  : 	assert (td_ptr->_glob_data_ptr != 0);
; 271  : 	assert (td_ptr->_slicer_ptr != 0);
; 272  : 
; 273  : 	T *				this_ptr =
; 274  : 		MTSlicer_Access <T, GD>::access (td_ptr->_glob_data_ptr);
; 275  : 	assert (this_ptr != 0);
; 276  : 
; 277  : 	ProcPtr			proc_ptr = td_ptr->_slicer_ptr->_proc_ptr;

	mov	eax, DWORD PTR [eax+8]

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	call	eax

; 281  : }

	ret	0
?redirect_task@?$MTSlicer@VMVPlane@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ENDP ; MTSlicer<MVPlane,MVPlane,64>::redirect_task
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@VTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@$0BA@@conc@@QAEAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@VTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@$0BA@@conc@@QAEAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@J@Z PROC ; conc::Array<MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::TaskData,16>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 56   : }

	ret	4
??A?$Array@VTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@$0BA@@conc@@QAEAAVTaskData@?$MTFlowGraphSched@VMVPlane@@V?$MTFlowGraphSimple@$0BA@@@V1@$0BA@@@J@Z ENDP ; conc::Array<MTFlowGraphSched<MVPlane,MTFlowGraphSimple<16>,MVPlane,16>::TaskData,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAEAAV?$AtomicInt@H@1@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAEAAV?$AtomicInt@H@1@J@Z PROC ; conc::Array<conc::AtomicInt<int>,16>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 56   : }

	ret	4
??A?$Array@V?$AtomicInt@H@conc@@$0BA@@conc@@QAEAAV?$AtomicInt@H@1@J@Z ENDP ; conc::Array<conc::AtomicInt<int>,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@VTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@VTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@J@Z PROC ; conc::Array<MTSlicer<MVPlane,MVPlane,64>::TaskData,64>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	shl	eax, 4
	add	eax, ecx

; 56   : }

	ret	4
??A?$Array@VTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVPlane@@V1@$0EA@@@J@Z ENDP ; conc::Array<MTSlicer<MVPlane,MVPlane,64>::TaskData,64>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QAEAAVNode@?$MTFlowGraphSimple@$0BA@@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QAEAAVNode@?$MTFlowGraphSimple@$0BA@@@J@Z PROC ; conc::Array<MTFlowGraphSimple<16>::Node,16>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*8]

; 56   : }

	ret	4
??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QAEAAVNode@?$MTFlowGraphSimple@$0BA@@@J@Z ENDP ; conc::Array<MTFlowGraphSimple<16>::Node,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@F$0BA@@conc@@QAEAAFJ@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@F$0BA@@conc@@QAEAAFJ@Z PROC			; conc::Array<short,16>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*2]

; 56   : }

	ret	4
??A?$Array@F$0BA@@conc@@QAEAAFJ@Z ENDP			; conc::Array<short,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??E?$AtomicInt@H@conc@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$AtomicInt@H@conc@@QAEAAV01@XZ PROC			; conc::AtomicInt<int>::operator++, COMDAT
; _this$ = ecx

; 142  : {

	push	esi
$LL12@operator:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	edx, DWORD PTR [esi+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL12@operator
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 144  : }

	mov	eax, ecx
	pop	esi
	ret	0
??E?$AtomicInt@H@conc@@QAEAAV01@XZ ENDP			; conc::AtomicInt<int>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?get_nbr_in@?$MTFlowGraphSimple@$0BA@@@QBEHH@Z
_TEXT	SEGMENT
_task_index$ = 8					; size = 4
?get_nbr_in@?$MTFlowGraphSimple@$0BA@@@QBEHH@Z PROC	; MTFlowGraphSimple<16>::get_nbr_in, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\array.hpp

; 44   : 	return (_data [pos]);

	mov	eax, DWORD PTR _task_index$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 157  : 	return (_node_arr [task_index]._nbr_in);

	mov	eax, DWORD PTR [ecx+eax*8+8]

; 158  : }

	ret	4
?get_nbr_in@?$MTFlowGraphSimple@$0BA@@@QBEHH@Z ENDP	; MTFlowGraphSimple<16>::get_nbr_in
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?get_out_node_it@?$MTFlowGraphSimple@$0BA@@@QBE?AVIterator@1@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_task_index$ = 12					; size = 4
?get_out_node_it@?$MTFlowGraphSimple@$0BA@@@QBE?AVIterator@1@H@Z PROC ; MTFlowGraphSimple<16>::get_out_node_it, COMDAT
; _this$ = ecx

; 200  : :	_fg (fg)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 201  : ,	_node (node)

	mov	ecx, DWORD PTR _task_index$[esp-4]
	mov	DWORD PTR [eax+4], ecx

; 202  : ,	_pos (0)

	mov	DWORD PTR [eax+8], 0

; 181  : 	assert (task_index >= 0);
; 182  : 	assert (task_index < MAXT);
; 183  : 
; 184  : 	return (Iterator (*this, task_index));
; 185  : }

	ret	8
?get_out_node_it@?$MTFlowGraphSimple@$0BA@@@QBE?AVIterator@1@H@Z ENDP ; MTFlowGraphSimple<16>::get_out_node_it
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?next@Iterator@?$MTFlowGraphSimple@$0BA@@@QAEXXZ
_TEXT	SEGMENT
?next@Iterator@?$MTFlowGraphSimple@$0BA@@@QAEXXZ PROC	; MTFlowGraphSimple<16>::Iterator::next, COMDAT
; _this$ = ecx

; 224  : 	assert (cont ());
; 225  : 
; 226  : 	++ _pos;

	inc	DWORD PTR [ecx+8]

; 227  : }

	ret	0
?next@Iterator@?$MTFlowGraphSimple@$0BA@@@QAEXXZ ENDP	; MTFlowGraphSimple<16>::Iterator::next
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
; File c:\github\mvtools\sources\conc\array.hpp
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?cont@Iterator@?$MTFlowGraphSimple@$0BA@@@QBE_NXZ
_TEXT	SEGMENT
?cont@Iterator@?$MTFlowGraphSimple@$0BA@@@QBE_NXZ PROC	; MTFlowGraphSimple<16>::Iterator::cont, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\array.hpp

; 44   : 	return (_data [pos]);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	lea	esi, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+esi*8+12]
	pop	esi
	setl	al
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp

; 247  : }

	ret	0
?cont@Iterator@?$MTFlowGraphSimple@$0BA@@@QBE_NXZ ENDP	; MTFlowGraphSimple<16>::Iterator::cont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ?get_index@Iterator@?$MTFlowGraphSimple@$0BA@@@QBEHXZ
_TEXT	SEGMENT
?get_index@Iterator@?$MTFlowGraphSimple@$0BA@@@QBEHXZ PROC ; MTFlowGraphSimple<16>::Iterator::get_index, COMDAT
; _this$ = ecx

; 265  : 	assert (cont ());
; 266  : 
; 267  : 	return (_fg._node_arr [_node]._out_arr [_pos]);

	mov	eax, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx]
	movsx	eax, WORD PTR [eax+edx*2+16]

; 268  : }

	ret	0
?get_index@Iterator@?$MTFlowGraphSimple@$0BA@@@QBEHXZ ENDP ; MTFlowGraphSimple<16>::Iterator::get_index
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\atomicint.hpp
;	COMDAT ??Y?$AtomicInt@H@conc@@QAEAAV01@ABH@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??Y?$AtomicInt@H@conc@@QAEAAV01@ABH@Z PROC		; conc::AtomicInt<int>::operator+=, COMDAT
; _this$ = ecx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	eax, DWORD PTR _other$[esp-4]
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 116  : {

	push	esi
	push	edi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 38   : :	_operand (operand)

	mov	edi, DWORD PTR [eax]
$LL10@operator:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	edx, DWORD PTR [esi+edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], edx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL10@operator
; File c:\github\mvtools\sources\conc\atomicint.hpp

; 122  : 	return (*this);

	pop	edi
	mov	eax, ecx

; 123  : }

	pop	esi
	ret	4
??Y?$AtomicInt@H@conc@@QAEAAV01@ABH@Z ENDP		; conc::AtomicInt<int>::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QBEABVNode@?$MTFlowGraphSimple@$0BA@@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QBEABVNode@?$MTFlowGraphSimple@$0BA@@@J@Z PROC ; conc::Array<MTFlowGraphSimple<16>::Node,16>::operator[], COMDAT
; _this$ = ecx

; 41   : 	assert (pos >= 0);
; 42   : 	assert (pos < LENGTH);
; 43   : 
; 44   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*8]

; 45   : }

	ret	4
??A?$Array@VNode@?$MTFlowGraphSimple@$0BA@@@$0BA@@conc@@QBEABVNode@?$MTFlowGraphSimple@$0BA@@@J@Z ENDP ; conc::Array<MTFlowGraphSimple<16>::Node,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@F$0BA@@conc@@QBEABFJ@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@F$0BA@@conc@@QBEABFJ@Z PROC			; conc::Array<short,16>::operator[], COMDAT
; _this$ = ecx

; 41   : 	assert (pos >= 0);
; 42   : 	assert (pos < LENGTH);
; 43   : 
; 44   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*2]

; 45   : }

	ret	4
??A?$Array@F$0BA@@conc@@QBEABFJ@Z ENDP			; conc::Array<short,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtflowgraphsimple.hpp
;	COMDAT ??0Iterator@?$MTFlowGraphSimple@$0BA@@@QAE@ABV1@H@Z
_TEXT	SEGMENT
_fg$ = 8						; size = 4
_node$ = 12						; size = 4
??0Iterator@?$MTFlowGraphSimple@$0BA@@@QAE@ABV1@H@Z PROC ; MTFlowGraphSimple<16>::Iterator::Iterator, COMDAT
; _this$ = ecx

; 200  : :	_fg (fg)

	mov	eax, DWORD PTR _fg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 201  : ,	_node (node)

	mov	eax, DWORD PTR _node$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 204  : 	assert (&fg != 0);
; 205  : 	assert (node >= 0);
; 206  : 	assert (node < MAXT);
; 207  : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	ret	8
??0Iterator@?$MTFlowGraphSimple@$0BA@@@QAE@ABV1@H@Z ENDP ; MTFlowGraphSimple<16>::Iterator::Iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@@Z
_TEXT	SEGMENT
??$exec@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@@Z PROC ; conc::AtomicIntOp::exec<int,conc::AioAdd<int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 40   : {

	push	esi
	push	edi
$LL6@exec:

; 90   : 		val_cur = atom;

	mov	edi, DWORD PTR [ecx]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	mov	esi, DWORD PTR [edx+4]
	add	esi, edi
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [ecx], esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edi
	jne	SHORT $LL6@exec

; 41   : 	assert (&atom != 0);
; 42   : 	assert (&ftor != 0);
; 43   : 
; 44   : 	T					val_new;
; 45   : 	T					val_old;
; 46   : 	exec_both (atom, ftor, val_old, val_new);
; 47   : }

	pop	edi
	pop	esi
	ret	0
??$exec@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@@Z ENDP ; conc::AtomicIntOp::exec<int,conc::AioAdd<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
;	COMDAT ??$exec_both@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@AAH2@Z
_TEXT	SEGMENT
_val_old$ = 8						; size = 4
_val_new$ = 12						; size = 4
??$exec_both@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@AAH2@Z PROC ; conc::AtomicIntOp::exec_both<int,conc::AioAdd<int> >, COMDAT
; _atom$ = ecx
; _ftor$ = edx

; 83   : {

	push	ebx
	mov	ebx, DWORD PTR _val_new$[esp]
	push	ebp
	mov	ebp, DWORD PTR _val_old$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	npad	2
$LL4@exec_both:

; 84   : 	assert (&atom != 0);
; 85   : 	assert (&ftor != 0);
; 86   : 
; 87   : 	T					val_cur;
; 88   : 	do
; 89   : 	{
; 90   : 		val_cur = atom;

	mov	esi, DWORD PTR [edi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, esi
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	mov	ecx, DWORD PTR [edx+4]
	add	ecx, esi
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 91   : 		val_new = ftor (val_cur);

	mov	DWORD PTR [ebx], ecx
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	lock	 cmpxchg DWORD PTR [edi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 92   : 		val_old = atom.cas (val_new, val_cur);

	mov	DWORD PTR [ebp], eax

; 93   : 	}
; 94   : 	while (val_old != val_cur);

	cmp	eax, esi
	jne	SHORT $LL4@exec_both

; 95   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
??$exec_both@HV?$AioAdd@H@conc@@@AtomicIntOp@conc@@SAXAAV?$AtomicInt@H@1@AAV?$AioAdd@H@1@AAH2@Z ENDP ; conc::AtomicIntOp::exec_both<int,conc::AioAdd<int> >
_TEXT	ENDS
END
