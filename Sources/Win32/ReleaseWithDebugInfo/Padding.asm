; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\padding.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DH@OFLMIJBC@Padding?5?3?5clip?5must?5be?5in?5the?5YU@ ; `string'
PUBLIC	??_R4Padding@@6B@				; Padding::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVPadding@@@8				; Padding `RTTI Type Descriptor'
PUBLIC	??_R2Padding@@8					; Padding::`RTTI Base Class Array'
PUBLIC	??_7Padding@@6B@				; Padding::`vftable'
PUBLIC	??_R1A@?0A@EA@Padding@@8			; Padding::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3Padding@@8					; Padding::`RTTI Class Hierarchy Descriptor'
;	COMDAT ??_R3Padding@@8
rdata$r	SEGMENT
??_R3Padding@@8 DD 00H					; Padding::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2Padding@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Padding@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Padding@@8 DD FLAT:??_R0?AVPadding@@@8	; Padding::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Padding@@8
rdata$r	ENDS
;	COMDAT ??_7Padding@@6B@
CONST	SEGMENT
??_7Padding@@6B@ DD FLAT:??_R4Padding@@6B@		; Padding::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@GenericVideoFilter@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EPadding@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2Padding@@8
rdata$r	SEGMENT
??_R2Padding@@8 DD FLAT:??_R1A@?0A@EA@Padding@@8	; Padding::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPadding@@@8
data$r	SEGMENT
??_R0?AVPadding@@@8 DD FLAT:??_7type_info@@6B@		; Padding `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPadding@@', 00H
data$r	ENDS
;	COMDAT ??_R4Padding@@6B@
rdata$r	SEGMENT
??_R4Padding@@6B@ DD 00H				; Padding::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPadding@@@8
	DD	FLAT:??_R3Padding@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DH@OFLMIJBC@Padding?5?3?5clip?5must?5be?5in?5the?5YU@
CONST	SEGMENT
??_C@_0DH@OFLMIJBC@Padding?5?3?5clip?5must?5be?5in?5the?5YU@ DB 'Padding '
	DB	': clip must be in the YUV or YUY2 color format', 00H ; `string'
PUBLIC	??$_Fill_n_unchecked1@PAGHG@std@@YAPAGPAGHABGU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_n_unchecked1<unsigned short *,int,unsigned short>
PUBLIC	??$_Fill_n_unchecked1@PAEHE@std@@YAPAEPAEHABEU?$integral_constant@_N$00@0@@Z ; std::_Fill_n_unchecked1<unsigned char *,int,unsigned char>
PUBLIC	??$_Fill_n_unchecked@PAGHG@std@@YAPAGPAGHABG@Z	; std::_Fill_n_unchecked<unsigned short *,int,unsigned short>
PUBLIC	??$_Fill_n_unchecked@PAEHE@std@@YAPAEPAEHABE@Z	; std::_Fill_n_unchecked<unsigned char *,int,unsigned char>
PUBLIC	??$_Unchecked_n@PAGH@std@@YA@PAGH@Z		; std::_Unchecked_n<unsigned short *,int>
PUBLIC	??$fill_n@PAGHG@std@@YAPAGPAGHABG@Z		; std::fill_n<unsigned short *,int,unsigned short>
PUBLIC	??$_Unchecked_n@PAEH@std@@YA@PAEH@Z		; std::_Unchecked_n<unsigned char *,int>
PUBLIC	??$fill_n@PAEHE@std@@YAPAEPAEHABE@Z		; std::fill_n<unsigned char *,int,unsigned char>
PUBLIC	??$PadCorner@G@@YAXPAGGHHH@Z			; PadCorner<unsigned short>
PUBLIC	??$PadCorner@E@@YAXPAEEHHH@Z			; PadCorner<unsigned char>
PUBLIC	?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; Padding::GetFrame
PUBLIC	??1Padding@@UAE@XZ				; Padding::~Padding
PUBLIC	??_GPadding@@UAEPAXI@Z				; Padding::`scalar deleting destructor'
PUBLIC	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z	; Padding::PadReferenceFrame<unsigned short>
PUBLIC	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z	; Padding::PadReferenceFrame<unsigned char>
EXTRN	??_EPadding@@UAEPAXI@Z:PROC			; Padding::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1Padding@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Padding@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1Padding@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Padding@@UAE@XZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\padding.cpp
;	COMDAT ??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z
_TEXT	SEGMENT
_v$1$ = -29						; size = 1
_v$1$ = -29						; size = 1
_v$1$ = -29						; size = 1
_pfoff$1$ = -28						; size = 4
tv1171 = -24						; size = 4
_p_r$1$ = -24						; size = 4
_refFrame8$1$ = -24					; size = 4
tv1156 = -20						; size = 4
tv1173 = -16						; size = 4
tv1172 = -16						; size = 4
tv1169 = -16						; size = 4
tv1168 = -12						; size = 4
tv1162 = -12						; size = 4
tv1163 = -8						; size = 4
tv1153 = -8						; size = 4
tv1170 = -4						; size = 4
tv1167 = -4						; size = 4
_hPad$ = 8						; size = 4
_value_l$1$ = 12					; size = 1
_vPad$ = 12						; size = 4
_value_r$1$ = 16					; size = 1
_width$ = 16						; size = 4
_height$ = 20						; size = 4
??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z PROC	; Padding::PadReferenceFrame<unsigned char>, COMDAT
; _refFrame8$ = ecx
; _refPitch$ = edx

; 195  : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	mov	ebp, edx
	mov	DWORD PTR _refFrame8$1$[esp+40], ecx

; 196  :     pixel_t *refFrame = reinterpret_cast<pixel_t *>(refFrame8);
; 197  :     refPitch /= sizeof(pixel_t);
; 198  : 
; 199  : 	pixel_t *pfoff = refFrame + vPad * refPitch + hPad;

	mov	edx, DWORD PTR _vPad$[esp+36]
	mov	eax, ebp
	imul	eax, edx
	push	esi
	mov	esi, DWORD PTR _hPad$[esp+40]
	push	edi

; 200  : 
; 201  : 	// Up-Left
; 202  : 	PadCorner<pixel_t>(refFrame, pfoff[0], hPad, vPad, refPitch); // PF refPitch is already pixelsize aware!

	mov	edi, ecx
	add	eax, ecx
	mov	DWORD PTR tv1156[esp+48], eax
	lea	ebx, DWORD PTR [eax+esi]
	mov	al, BYTE PTR [ebx]
	mov	DWORD PTR _pfoff$1$[esp+48], ebx

; 28   : 	for ( int i = 0; i < vPad; i++ )

	test	edx, edx
	jle	SHORT $LN17@PadReferen

; 196  :     pixel_t *refFrame = reinterpret_cast<pixel_t *>(refFrame8);
; 197  :     refPitch /= sizeof(pixel_t);
; 198  : 
; 199  : 	pixel_t *pfoff = refFrame + vPad * refPitch + hPad;

	movzx	eax, al
	mov	ebx, edx
	mov	DWORD PTR tv1173[esp+48], eax
$LL18@PadReferen:

; 31   :             memset(p, v, hPad); // faster than loop

	push	esi
	push	eax
	push	edi
	call	_memset
	mov	eax, DWORD PTR tv1173[esp+60]
	add	esp, 12					; 0000000cH

; 32   :         else {
; 33   :             /*
; 34   :             for (int j = 0; j < hPad; j++)
; 35   :                 p[j] = v;
; 36   :             */
; 37   :             std::fill_n(p, hPad, v); 
; 38   :         }
; 39   : //		for ( int j = 0; j < hPad; j++ )
; 40   : //		{
; 41   : //			p[j] = v;
; 42   : //		}
; 43   : 		p += refPitch;

	add	edi, ebp
	sub	ebx, 1
	jne	SHORT $LL18@PadReferen
	mov	ebx, DWORD PTR _pfoff$1$[esp+48]
	mov	ecx, DWORD PTR _refFrame8$1$[esp+48]
$LN17@PadReferen:

; 203  : 	// Up-Right
; 204  : 	PadCorner<pixel_t>(refFrame + hPad + width, pfoff[width - 1], hPad, vPad, refPitch);

	mov	eax, DWORD PTR _width$[esp+44]
	mov	dl, BYTE PTR [ebx+eax-1]
	mov	BYTE PTR _v$1$[esp+48], dl
	lea	edx, DWORD PTR [ecx+esi]
	mov	DWORD PTR tv1163[esp+48], edx
	lea	edi, DWORD PTR [edx+eax]

; 28   : 	for ( int i = 0; i < vPad; i++ )

	mov	edx, DWORD PTR _vPad$[esp+44]
	test	edx, edx
	jle	SHORT $LN39@PadReferen

; 203  : 	// Up-Right
; 204  : 	PadCorner<pixel_t>(refFrame + hPad + width, pfoff[width - 1], hPad, vPad, refPitch);

	movzx	eax, BYTE PTR _v$1$[esp+48]
	mov	ebx, edx
	mov	DWORD PTR tv1172[esp+48], eax
	npad	1
$LL40@PadReferen:

; 31   :             memset(p, v, hPad); // faster than loop

	push	esi
	push	eax
	push	edi
	call	_memset
	mov	eax, DWORD PTR tv1172[esp+60]
	add	esp, 12					; 0000000cH

; 32   :         else {
; 33   :             /*
; 34   :             for (int j = 0; j < hPad; j++)
; 35   :                 p[j] = v;
; 36   :             */
; 37   :             std::fill_n(p, hPad, v); 
; 38   :         }
; 39   : //		for ( int j = 0; j < hPad; j++ )
; 40   : //		{
; 41   : //			p[j] = v;
; 42   : //		}
; 43   : 		p += refPitch;

	add	edi, ebp
	sub	ebx, 1
	jne	SHORT $LL40@PadReferen
	mov	ebx, DWORD PTR _pfoff$1$[esp+48]
	mov	edx, DWORD PTR _vPad$[esp+44]
	mov	ecx, DWORD PTR _refFrame8$1$[esp+48]
$LN39@PadReferen:

; 205  : 	// Down-Left
; 206  : 	PadCorner<pixel_t>(refFrame + (vPad + height) * refPitch,

	mov	edi, DWORD PTR _height$[esp+44]
	lea	eax, DWORD PTR [edi-1]
	imul	eax, ebp
	lea	esi, DWORD PTR [eax+ebx]
	mov	al, BYTE PTR [eax+ebx]
	mov	BYTE PTR _v$1$[esp+48], al
	lea	eax, DWORD PTR [edx+edi]
	imul	eax, ebp
	mov	DWORD PTR tv1171[esp+48], esi

; 28   : 	for ( int i = 0; i < vPad; i++ )

	mov	esi, DWORD PTR _hPad$[esp+44]

; 205  : 	// Down-Left
; 206  : 	PadCorner<pixel_t>(refFrame + (vPad + height) * refPitch,

	mov	DWORD PTR tv1170[esp+48], eax
	add	eax, ecx
	mov	DWORD PTR tv1162[esp+48], eax
	mov	edi, eax

; 28   : 	for ( int i = 0; i < vPad; i++ )

	test	edx, edx
	jle	SHORT $LN61@PadReferen

; 205  : 	// Down-Left
; 206  : 	PadCorner<pixel_t>(refFrame + (vPad + height) * refPitch,

	movzx	eax, BYTE PTR _v$1$[esp+48]
	mov	ebx, edx
	mov	DWORD PTR tv1169[esp+48], eax
	npad	1
$LL62@PadReferen:

; 31   :             memset(p, v, hPad); // faster than loop

	push	esi
	push	eax
	push	edi
	call	_memset
	mov	eax, DWORD PTR tv1169[esp+60]
	add	esp, 12					; 0000000cH

; 32   :         else {
; 33   :             /*
; 34   :             for (int j = 0; j < hPad; j++)
; 35   :                 p[j] = v;
; 36   :             */
; 37   :             std::fill_n(p, hPad, v); 
; 38   :         }
; 39   : //		for ( int j = 0; j < hPad; j++ )
; 40   : //		{
; 41   : //			p[j] = v;
; 42   : //		}
; 43   : 		p += refPitch;

	add	edi, ebp
	sub	ebx, 1
	jne	SHORT $LL62@PadReferen
	mov	edx, DWORD PTR _vPad$[esp+44]
$LN61@PadReferen:

; 207  : 		pfoff[(height - 1) * refPitch], hPad, vPad, refPitch);
; 208  : 	// Down-Right
; 209  : 	PadCorner<pixel_t>(refFrame + hPad + width + (vPad + height) * refPitch,

	mov	eax, DWORD PTR _width$[esp+44]
	mov	ecx, DWORD PTR tv1171[esp+48]
	mov	edi, DWORD PTR tv1162[esp+48]
	add	edi, esi
	add	edi, eax
	mov	bl, BYTE PTR [ecx+eax-1]
	mov	BYTE PTR _v$1$[esp+48], bl

; 28   : 	for ( int i = 0; i < vPad; i++ )

	mov	ebx, DWORD PTR _pfoff$1$[esp+48]
	test	edx, edx
	jle	SHORT $LN83@PadReferen

; 207  : 		pfoff[(height - 1) * refPitch], hPad, vPad, refPitch);
; 208  : 	// Down-Right
; 209  : 	PadCorner<pixel_t>(refFrame + hPad + width + (vPad + height) * refPitch,

	movzx	eax, BYTE PTR _v$1$[esp+48]
	mov	ebx, edx
	mov	DWORD PTR tv1168[esp+48], eax
$LL84@PadReferen:

; 31   :             memset(p, v, hPad); // faster than loop

	push	esi
	push	eax
	push	edi
	call	_memset
	mov	eax, DWORD PTR tv1168[esp+60]
	add	esp, 12					; 0000000cH

; 32   :         else {
; 33   :             /*
; 34   :             for (int j = 0; j < hPad; j++)
; 35   :                 p[j] = v;
; 36   :             */
; 37   :             std::fill_n(p, hPad, v); 
; 38   :         }
; 39   : //		for ( int j = 0; j < hPad; j++ )
; 40   : //		{
; 41   : //			p[j] = v;
; 42   : //		}
; 43   : 		p += refPitch;

	add	edi, ebp
	sub	ebx, 1
	jne	SHORT $LL84@PadReferen
	mov	ebx, DWORD PTR _pfoff$1$[esp+48]
	mov	edx, DWORD PTR _vPad$[esp+44]
	mov	eax, DWORD PTR _width$[esp+44]
	mov	ecx, DWORD PTR tv1171[esp+48]
$LN83@PadReferen:

; 210  : 		pfoff[(height - 1) * refPitch + width - 1], hPad, vPad, refPitch);
; 211  : 
; 212  : 	// Top and bottom
; 213  : 	// LDS: would multiple memcpy be faster? The inner loop is very short
; 214  : 	// and the offset calculations are not trivial.
; 215  : 	for ( int i = 0; i < width; i++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN3@PadReferen
	mov	esi, DWORD PTR _pfoff$1$[esp+48]
$LL4@PadReferen:

; 216  : 	{
; 217  : 		pixel_t value_t = pfoff[i                          ];
; 218  :         pixel_t value_b = pfoff[i + (height - 1) * refPitch];

	mov	bh, BYTE PTR [ecx+edi]

; 219  :         pixel_t *p_t = refFrame + hPad + i;

	mov	eax, DWORD PTR tv1163[esp+48]

; 220  :         pixel_t *p_b = p_t + (height + vPad) * refPitch;

	mov	ecx, DWORD PTR tv1170[esp+48]
	add	eax, edi
	mov	bl, BYTE PTR [edi+esi]
	add	ecx, eax

; 221  : 		for ( int j = 0; j < vPad; j++ )

	test	edx, edx
	jle	SHORT $LN2@PadReferen
	npad	5
$LL7@PadReferen:

; 222  : 		{
; 223  : 			p_t [0] = value_t;

	mov	BYTE PTR [eax], bl

; 224  : 			p_b [0] = value_b;
; 225  : 			p_t += refPitch;

	add	eax, ebp
	mov	BYTE PTR [ecx], bh

; 226  : 			p_b += refPitch;

	add	ecx, ebp
	sub	edx, 1
	jne	SHORT $LL7@PadReferen
	mov	edx, DWORD PTR _vPad$[esp+44]
$LN2@PadReferen:

; 210  : 		pfoff[(height - 1) * refPitch + width - 1], hPad, vPad, refPitch);
; 211  : 
; 212  : 	// Top and bottom
; 213  : 	// LDS: would multiple memcpy be faster? The inner loop is very short
; 214  : 	// and the offset calculations are not trivial.
; 215  : 	for ( int i = 0; i < width; i++ )

	mov	eax, DWORD PTR _width$[esp+44]
	inc	edi
	mov	ecx, DWORD PTR tv1171[esp+48]
	cmp	edi, eax
	jl	SHORT $LL4@PadReferen
	mov	esi, DWORD PTR _hPad$[esp+44]
	mov	ebx, DWORD PTR _pfoff$1$[esp+48]
$LN3@PadReferen:

; 227  : 		}
; 228  : 	}
; 229  : 
; 230  : 	// Left and right
; 231  : 	for ( int i = 0; i < height; i++ )

	cmp	DWORD PTR _height$[esp+44], 0
	jle	$LN9@PadReferen
	mov	edi, DWORD PTR tv1156[esp+48]
	lea	ecx, DWORD PTR [esi+eax]
	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR tv1167[esp+48], ecx
	mov	DWORD PTR tv1153[esp+48], edx
$LL10@PadReferen:

; 232  : 	{
; 233  :         pixel_t value_l = pfoff[i * refPitch            ];

	mov	al, BYTE PTR [ebx]

; 234  :         pixel_t value_r = pfoff[i * refPitch + width - 1];
; 235  :         pixel_t *p_l = refFrame + (vPad + i) * refPitch;
; 236  :         pixel_t *p_r = p_l + width + hPad;

	add	ecx, edi
	mov	BYTE PTR _value_l$1$[esp+44], al
	mov	al, BYTE PTR [ebx+edx]

; 237  : 		for ( int j = 0; j < hPad; j++ )

	xor	ebx, ebx
	mov	BYTE PTR _value_r$1$[esp+44], al
	mov	DWORD PTR _p_r$1$[esp+48], ecx
	test	esi, esi
	jle	$LN8@PadReferen
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN120@PadReferen
	lea	eax, DWORD PTR [esi-1]
	lea	edx, DWORD PTR [ecx-1]
	add	eax, edi
	add	edx, esi
	cmp	ecx, eax
	ja	SHORT $LN121@PadReferen
	cmp	edx, edi
	jae	SHORT $LN120@PadReferen
$LN121@PadReferen:
	mov	eax, esi
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN140@PadReferen
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN140@PadReferen:
	sub	esi, eax
$LL13@PadReferen:
	add	ebx, 16					; 00000010H
	cmp	ebx, esi
	jl	SHORT $LL13@PadReferen

; 238  : 		{
; 239  : 			p_l [j] = value_l;

	lea	eax, DWORD PTR [esi+15]
	cdq
	and	edx, 15					; 0000000fH
	lea	esi, DWORD PTR [edx+eax]
	movzx	eax, BYTE PTR _value_l$1$[esp+44]
	and	esi, -16				; fffffff0H
	imul	eax, 16843009				; 01010101H
	mov	ecx, esi

; 240  : 			p_r [j] = value_r;

	shr	esi, 2
	shr	ecx, 2
	rep stosd
	movzx	eax, BYTE PTR _value_r$1$[esp+44]
	mov	ecx, esi
	mov	edi, DWORD PTR _p_r$1$[esp+48]
	mov	esi, DWORD PTR _hPad$[esp+44]
	imul	eax, 16843009				; 01010101H
	rep stosd
	mov	edi, DWORD PTR tv1156[esp+48]
	mov	ecx, DWORD PTR _p_r$1$[esp+48]
$LN120@PadReferen:

; 237  : 		for ( int j = 0; j < hPad; j++ )

	cmp	ebx, esi
	jge	SHORT $LN8@PadReferen
	lea	eax, DWORD PTR [ebx+ecx]

; 238  : 		{
; 239  : 			p_l [j] = value_l;

	mov	edx, edi
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, ebx
	mov	bl, BYTE PTR _value_l$1$[esp+44]
	mov	bh, BYTE PTR _value_r$1$[esp+44]
$LL119@PadReferen:
	mov	BYTE PTR [eax+edx], bl
	lea	eax, DWORD PTR [eax+1]

; 240  : 			p_r [j] = value_r;

	mov	BYTE PTR [eax-1], bh
	sub	ecx, 1
	jne	SHORT $LL119@PadReferen
$LN8@PadReferen:

; 227  : 		}
; 228  : 	}
; 229  : 
; 230  : 	// Left and right
; 231  : 	for ( int i = 0; i < height; i++ )

	mov	ebx, DWORD PTR _pfoff$1$[esp+48]
	add	edi, ebp
	mov	ecx, DWORD PTR tv1167[esp+48]
	add	ebx, ebp
	sub	DWORD PTR _height$[esp+44], 1
	mov	edx, DWORD PTR tv1153[esp+48]
	mov	DWORD PTR _pfoff$1$[esp+48], ebx
	mov	DWORD PTR tv1156[esp+48], edi
	jne	$LL10@PadReferen
$LN9@PadReferen:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 241  : 		}
; 242  : 	}
; 243  : }

	add	esp, 32					; 00000020H
	ret	0
??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ENDP	; Padding::PadReferenceFrame<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\padding.cpp
;	COMDAT ??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z
_TEXT	SEGMENT
_refFrame8$1$ = -40					; size = 4
_refPitch$2$ = -36					; size = 4
_pfoff$1$ = -32						; size = 4
tv1097 = -28						; size = 4
tv1093 = -28						; size = 4
tv1091 = -24						; size = 4
_i$1$ = -20						; size = 4
tv1102 = -20						; size = 4
tv1098 = -16						; size = 4
tv1101 = -12						; size = 4
tv1109 = -8						; size = 4
tv1107 = -4						; size = 4
_value_r$1$ = 8						; size = 4
_hPad$ = 8						; size = 4
_value_l$1$ = 12					; size = 4
_vPad$ = 12						; size = 4
_p_r$1$ = 16						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z PROC	; Padding::PadReferenceFrame<unsigned short>, COMDAT
; _refFrame8$ = ecx
; _refPitch$ = edx

; 195  : {

	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp

; 198  : 
; 199  : 	pixel_t *pfoff = refFrame + vPad * refPitch + hPad;

	mov	ebp, DWORD PTR _hPad$[esp+44]
	push	esi
	mov	esi, DWORD PTR _vPad$[esp+48]
	push	edi
	mov	edi, edx
	mov	DWORD PTR _refFrame8$1$[esp+56], ecx
	shr	edi, 1
	mov	eax, edi
	mov	DWORD PTR _refPitch$2$[esp+56], edi
	imul	eax, esi

; 200  : 
; 201  : 	// Up-Left
; 202  : 	PadCorner<pixel_t>(refFrame, pfoff[0], hPad, vPad, refPitch); // PF refPitch is already pixelsize aware!

	push	edi
	push	esi
	push	ebp
	mov	DWORD PTR tv1109[esp+68], eax
	add	eax, ebp
	mov	dx, WORD PTR [ecx+eax*2]
	lea	ebx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _pfoff$1$[esp+68], ebx
	call	??$PadCorner@G@@YAXPAGGHHH@Z		; PadCorner<unsigned short>

; 203  : 	// Up-Right
; 204  : 	PadCorner<pixel_t>(refFrame + hPad + width, pfoff[width - 1], hPad, vPad, refPitch);

	mov	ecx, DWORD PTR _width$[esp+64]
	push	edi
	push	esi
	push	ebp
	lea	edx, DWORD PTR [ecx+ebp]
	lea	eax, DWORD PTR [ecx-1]
	add	edx, edx
	mov	ecx, DWORD PTR _refFrame8$1$[esp+80]
	lea	eax, DWORD PTR [ebx+eax*2]
	mov	DWORD PTR tv1107[esp+80], edx
	add	ecx, edx
	mov	dx, WORD PTR [eax]
	mov	DWORD PTR tv1091[esp+80], eax
	call	??$PadCorner@G@@YAXPAGGHHH@Z		; PadCorner<unsigned short>

; 205  : 	// Down-Left
; 206  : 	PadCorner<pixel_t>(refFrame + (vPad + height) * refPitch,

	mov	ecx, DWORD PTR _height$[esp+76]
	add	esi, ecx
	mov	edx, DWORD PTR _refPitch$2$[esp+80]
	imul	esi, edx
	push	edx
	push	DWORD PTR _vPad$[esp+80]
	lea	edi, DWORD PTR [ecx-1]
	imul	edi, edx
	mov	dx, WORD PTR [ebx+edi*2]
	push	ebp
	lea	ecx, DWORD PTR [esi+esi]
	mov	DWORD PTR tv1101[esp+92], ecx
	add	ecx, DWORD PTR _refFrame8$1$[esp+92]
	lea	eax, DWORD PTR [ebx+edi*2]
	mov	DWORD PTR tv1097[esp+92], eax
	call	??$PadCorner@G@@YAXPAGGHHH@Z		; PadCorner<unsigned short>

; 207  : 		pfoff[(height - 1) * refPitch], hPad, vPad, refPitch);
; 208  : 	// Down-Right
; 209  : 	PadCorner<pixel_t>(refFrame + hPad + width + (vPad + height) * refPitch,

	mov	ecx, DWORD PTR _width$[esp+88]
	lea	eax, DWORD PTR [esi+ebp]
	push	DWORD PTR _refPitch$2$[esp+92]
	mov	esi, DWORD PTR _refFrame8$1$[esp+96]
	add	eax, ecx
	push	DWORD PTR _vPad$[esp+92]
	lea	edx, DWORD PTR [edi+ecx]
	mov	dx, WORD PTR [ebx+edx*2-2]
	push	ebp
	lea	ecx, DWORD PTR [esi+eax*2]
	call	??$PadCorner@G@@YAXPAGGHHH@Z		; PadCorner<unsigned short>

; 210  : 		pfoff[(height - 1) * refPitch + width - 1], hPad, vPad, refPitch);
; 211  : 
; 212  : 	// Top and bottom
; 213  : 	// LDS: would multiple memcpy be faster? The inner loop is very short
; 214  : 	// and the offset calculations are not trivial.
; 215  : 	for ( int i = 0; i < width; i++ )

	xor	ecx, ecx
	add	esp, 48					; 00000030H
	mov	DWORD PTR _i$1$[esp+56], ecx
	cmp	DWORD PTR _width$[esp+52], ecx
	jle	SHORT $LN3@PadReferen

; 196  :     pixel_t *refFrame = reinterpret_cast<pixel_t *>(refFrame8);
; 197  :     refPitch /= sizeof(pixel_t);

	mov	edx, DWORD PTR _width$[esp+52]
	lea	eax, DWORD PTR [esi+ebp*2]
	mov	esi, DWORD PTR _vPad$[esp+52]
	mov	ebp, eax
	mov	eax, DWORD PTR tv1097[esp+56]
	npad	5
$LL4@PadReferen:

; 216  : 	{
; 217  : 		pixel_t value_t = pfoff[i                          ];

	movzx	edi, WORD PTR [ebx+ecx*2]

; 218  :         pixel_t value_b = pfoff[i + (height - 1) * refPitch];
; 219  :         pixel_t *p_t = refFrame + hPad + i;
; 220  :         pixel_t *p_b = p_t + (height + vPad) * refPitch;

	mov	ecx, DWORD PTR tv1101[esp+56]
	movzx	ebx, WORD PTR [eax]
	add	ecx, ebp
	mov	eax, ebp

; 221  : 		for ( int j = 0; j < vPad; j++ )

	test	esi, esi
	jle	SHORT $LN2@PadReferen
	mov	edx, DWORD PTR _refPitch$2$[esp+56]
	add	edx, edx
	npad	7
$LL7@PadReferen:

; 222  : 		{
; 223  : 			p_t [0] = value_t;

	mov	WORD PTR [eax], di

; 224  : 			p_b [0] = value_b;
; 225  : 			p_t += refPitch;

	add	eax, edx
	mov	WORD PTR [ecx], bx

; 226  : 			p_b += refPitch;

	add	ecx, edx
	sub	esi, 1
	jne	SHORT $LL7@PadReferen
	mov	esi, DWORD PTR _vPad$[esp+52]
	mov	edx, DWORD PTR _width$[esp+52]
$LN2@PadReferen:

; 210  : 		pfoff[(height - 1) * refPitch + width - 1], hPad, vPad, refPitch);
; 211  : 
; 212  : 	// Top and bottom
; 213  : 	// LDS: would multiple memcpy be faster? The inner loop is very short
; 214  : 	// and the offset calculations are not trivial.
; 215  : 	for ( int i = 0; i < width; i++ )

	mov	ecx, DWORD PTR _i$1$[esp+56]
	add	ebp, 2
	mov	eax, DWORD PTR tv1097[esp+56]
	inc	ecx
	mov	ebx, DWORD PTR _pfoff$1$[esp+56]
	add	eax, 2
	mov	DWORD PTR _i$1$[esp+56], ecx
	mov	DWORD PTR tv1097[esp+56], eax
	cmp	ecx, edx
	jl	SHORT $LL4@PadReferen
	mov	ebp, DWORD PTR _hPad$[esp+52]
	mov	esi, DWORD PTR _refFrame8$1$[esp+56]
$LN3@PadReferen:

; 227  : 		}
; 228  : 	}
; 229  : 
; 230  : 	// Left and right
; 231  : 	for ( int i = 0; i < height; i++ )

	cmp	DWORD PTR _height$[esp+52], 0
	jle	$LN9@PadReferen
	mov	eax, DWORD PTR _refPitch$2$[esp+56]
	lea	edx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR tv1109[esp+56]
	mov	DWORD PTR tv1102[esp+56], edx
	lea	edi, DWORD PTR [esi+eax*2]
	mov	eax, DWORD PTR tv1091[esp+56]
	mov	DWORD PTR tv1093[esp+56], edi
$LL10@PadReferen:

; 232  : 	{
; 233  :         pixel_t value_l = pfoff[i * refPitch            ];

	movzx	esi, WORD PTR [ebx]

; 234  :         pixel_t value_r = pfoff[i * refPitch + width - 1];
; 235  :         pixel_t *p_l = refFrame + (vPad + i) * refPitch;
; 236  :         pixel_t *p_r = p_l + width + hPad;
; 237  : 		for ( int j = 0; j < hPad; j++ )

	xor	ebx, ebx
	mov	ecx, DWORD PTR tv1107[esp+56]
	movzx	eax, WORD PTR [eax]
	add	ecx, edi
	mov	DWORD PTR _value_l$1$[esp+52], esi
	mov	DWORD PTR _value_r$1$[esp+52], eax
	mov	DWORD PTR _p_r$1$[esp+52], ecx
	test	ebp, ebp
	jle	$LN8@PadReferen
	cmp	ebp, 8
	jb	$LN24@PadReferen
	lea	eax, DWORD PTR [ebp-1]
	lea	eax, DWORD PTR [edi+eax*2]
	cmp	ecx, eax
	ja	SHORT $LN25@PadReferen
	lea	eax, DWORD PTR [ebp-1]
	lea	eax, DWORD PTR [ecx+eax*2]
	cmp	eax, edi
	jae	SHORT $LN24@PadReferen
$LN25@PadReferen:
	mov	eax, ebp
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN36@PadReferen
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN36@PadReferen:
	mov	ecx, ebp
	sub	ecx, eax
$LL13@PadReferen:
	add	ebx, 8
	cmp	ebx, ecx
	jl	SHORT $LL13@PadReferen

; 238  : 		{
; 239  : 			p_l [j] = value_l;

	lea	eax, DWORD PTR [ecx+7]
	cdq
	and	edx, 7
	lea	esi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _value_l$1$[esp+52]
	sar	esi, 3
	movzx	edx, ax
	shl	esi, 4
	mov	eax, edx
	shl	edx, 16					; 00000010H
	mov	ecx, esi
	shr	ecx, 1
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx

; 240  : 			p_r [j] = value_r;

	shr	esi, 1
	rep stosw
	mov	eax, DWORD PTR _value_r$1$[esp+52]
	mov	ecx, esi
	mov	edi, DWORD PTR _p_r$1$[esp+52]
	movzx	edx, ax
	mov	eax, edx
	mov	esi, DWORD PTR _value_l$1$[esp+52]
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	rep stosd
	mov	edx, DWORD PTR tv1102[esp+56]
	adc	ecx, ecx
	rep stosw
	mov	edi, DWORD PTR tv1093[esp+56]
	mov	ecx, DWORD PTR _p_r$1$[esp+52]
$LN24@PadReferen:

; 234  :         pixel_t value_r = pfoff[i * refPitch + width - 1];
; 235  :         pixel_t *p_l = refFrame + (vPad + i) * refPitch;
; 236  :         pixel_t *p_r = p_l + width + hPad;
; 237  : 		for ( int j = 0; j < hPad; j++ )

	cmp	ebx, ebp
	jge	SHORT $LN8@PadReferen
	lea	eax, DWORD PTR [ecx+ebx*2]

; 238  : 		{
; 239  : 			p_l [j] = value_l;

	mov	edx, edi
	sub	edx, ecx
	mov	ecx, ebp
	sub	ecx, ebx
	mov	ebx, DWORD PTR _value_r$1$[esp+52]
	npad	8
$LL23@PadReferen:
	mov	WORD PTR [edx+eax], si
	lea	eax, DWORD PTR [eax+2]

; 240  : 			p_r [j] = value_r;

	mov	WORD PTR [eax-2], bx
	sub	ecx, 1
	jne	SHORT $LL23@PadReferen
	mov	edx, DWORD PTR tv1102[esp+56]
$LN8@PadReferen:

; 227  : 		}
; 228  : 	}
; 229  : 
; 230  : 	// Left and right
; 231  : 	for ( int i = 0; i < height; i++ )

	mov	ebx, DWORD PTR _pfoff$1$[esp+56]
	add	edi, edx
	mov	eax, DWORD PTR tv1091[esp+56]
	add	ebx, edx
	add	eax, edx
	mov	DWORD PTR _pfoff$1$[esp+56], ebx
	sub	DWORD PTR _height$[esp+52], 1
	mov	DWORD PTR tv1091[esp+56], eax
	mov	DWORD PTR tv1093[esp+56], edi
	jne	$LL10@PadReferen
$LN9@PadReferen:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 241  : 		}
; 242  : 	}
; 243  : }

	add	esp, 40					; 00000028H
	ret	0
??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ENDP	; Padding::PadReferenceFrame<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GPadding@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPadding@@UAEPAXI@Z PROC				; Padding::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1Padding@@UAE@XZ			; Padding::~Padding
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	96					; 00000060H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GPadding@@UAEPAXI@Z ENDP				; Padding::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
;	COMDAT ??1Padding@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1Padding@@UAE@XZ PROC					; Padding::~Padding, COMDAT
; _this$ = ecx

; 72   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1Padding@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 73   :    if ( (vi.pixel_type & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [esi+36]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [esi], OFFSET ??_7Padding@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN16@Padding
	cmp	BYTE PTR [esi+72], 0
	jne	SHORT $LN16@Padding

; 74   :    {
; 75   : 	delete SrcPlanes;

	mov	ebx, DWORD PTR [esi+88]
	mov	edi, DWORD PTR __imp___aligned_free
	test	ebx, ebx
	je	SHORT $LN9@Padding
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN9@Padding:
; File c:\github\mvtools\sources\padding.cpp

; 76   : 	delete DstPlanes;

	mov	ebx, DWORD PTR [esi+84]
	test	ebx, ebx
	je	SHORT $LN16@Padding
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	call	edi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	edi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	edi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN16@Padding:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN33@Padding
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN33@Padding
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [esi+8]
	call	eax
$LN33@Padding:
; File c:\github\mvtools\sources\padding.cpp

; 78   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [esi], OFFSET ??_7IClip@@6B@
; File c:\github\mvtools\sources\padding.cpp

; 78   : }

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Padding@@UAE@XZ$5:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1Padding@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1Padding@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Padding@@UAE@XZ ENDP					; Padding::~Padding
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\padding.cpp
;	COMDAT ?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
_isse$ = -72						; size = 1
_pSrc$3$ = -68						; size = 4
_nSrcPitches$3$ = -64					; size = 4
_pSrc$2$ = -60						; size = 4
_nSrcPitches$2$ = -56					; size = 4
_nSrcPitches$1$ = -52					; size = 4
_nDstPitches$1$ = -48					; size = 4
_pSrcYUY2$1$ = -48					; size = 4
_pDst$3$ = -44						; size = 4
_pSrc$1$ = -40						; size = 4
_pDst$2$ = -36						; size = 4
_nDstPitches$3$ = -32					; size = 4
_yRatioUV$1$ = -28					; size = 4
_pDst$1$ = -24						; size = 4
_nDstPitches$2$ = -20					; size = 4
_xRatioUV$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_src$ = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_pixelsize$1$ = 16					; size = 4
_n$ = 16						; size = 4
_pDstYUY2$1$ = 20					; size = 4
_env$ = 20						; size = 4
?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; Padding::GetFrame, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi

; 82   : 	PVideoFrame src = child->GetFrame(n, env);

	mov	esi, DWORD PTR _env$[ebp]
	lea	edx, DWORD PTR _src$[ebp]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	edi, DWORD PTR _this$[ebp]
; File c:\github\mvtools\sources\padding.cpp

; 82   : 	PVideoFrame src = child->GetFrame(n, env);

	push	esi
	push	DWORD PTR _n$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [edi+8]
; File c:\github\mvtools\sources\padding.cpp

; 82   : 	PVideoFrame src = child->GetFrame(n, env);

	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]

; 83   : 	PVideoFrame dst = env->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	push	ebx
	push	esi
	call	DWORD PTR [eax+56]

; 188  : 					  pDst[0], nDstPitches[0], pDst[1], pDst[2], nDstPitches[1], isse);
; 189  : 	}
; 190  : 	return dst;

	mov	eax, DWORD PTR [esi]
	push	esi
	mov	DWORD PTR $T2[ebp], 1
	call	DWORD PTR [eax+4]
; File c:\github\mvtools\sources\include\avisynth.h

; 707  :   bool IsY()   const AVS_BakedCode( return AVS_LinkCallOpt(IsY, IsY8) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\padding.cpp

; 92   : 	bool isse = env->GetCPUFlags() >= CPUF_INTEGER_SSE;

	cmp	eax, 8
	setge	BYTE PTR _isse$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 707  :   bool IsY()   const AVS_BakedCode( return AVS_LinkCallOpt(IsY, IsY8) )

	test	esi, esi
	je	$LN39@GetFrame
	mov	eax, DWORD PTR [esi]
	cmp	eax, 552				; 00000228H
	ja	SHORT $LN29@GetFrame
	cmp	eax, 48					; 00000030H
	jbe	SHORT $LN250@GetFrame
	mov	eax, DWORD PTR [esi+48]
	jmp	SHORT $LN257@GetFrame
$LN29@GetFrame:
	mov	eax, DWORD PTR [esi+552]
$LN257@GetFrame:
	lea	ecx, DWORD PTR [edi+16]
	call	eax
; File c:\github\mvtools\sources\padding.cpp

; 97   :     if(!vi.IsY()) {

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\include\avisynth.h

; 707  :   bool IsY()   const AVS_BakedCode( return AVS_LinkCallOpt(IsY, IsY8) )

	movzx	eax, al
; File c:\github\mvtools\sources\padding.cpp

; 97   :     if(!vi.IsY()) {

	test	al, al
	jne	SHORT $LN2@GetFrame
$LN250@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	test	esi, esi
	je	SHORT $LN39@GetFrame
	cmp	DWORD PTR [esi], 28			; 0000001cH
	jbe	SHORT $LN16@GetFrame
	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [edi+16]
	call	eax
; File c:\github\mvtools\sources\padding.cpp

; 98   :         xRatioUV = vi.IsYUY2() ? 2 : (1 << vi.GetPlaneWidthSubsampling(PLANAR_U)); // PF

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	movzx	eax, al
; File c:\github\mvtools\sources\padding.cpp

; 98   :         xRatioUV = vi.IsYUY2() ? 2 : (1 << vi.GetPlaneWidthSubsampling(PLANAR_U)); // PF

	test	al, al
	je	SHORT $LN16@GetFrame
	mov	DWORD PTR _xRatioUV$1$[ebp], 2
	jmp	SHORT $LN17@GetFrame
$LN16@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 661  :   int GetPlaneWidthSubsampling(int plane) const AVS_BakedCode(return AVS_LinkCall(GetPlaneWidthSubsampling)(plane))

	test	esi, esi
	je	SHORT $LN39@GetFrame
	cmp	DWORD PTR [esi], 144			; 00000090H
	jbe	SHORT $LN39@GetFrame
	mov	eax, DWORD PTR [esi+144]
	lea	ecx, DWORD PTR [edi+16]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN40@GetFrame
$LN2@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 101  :         xRatioUV = 1; // n/a

	mov	DWORD PTR _xRatioUV$1$[ebp], 1

; 102  :         yRatioUV = 1; // n/a

	mov	DWORD PTR _yRatioUV$1$[ebp], 1
	jmp	SHORT $LN3@GetFrame
$LN39@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 661  :   int GetPlaneWidthSubsampling(int plane) const AVS_BakedCode(return AVS_LinkCall(GetPlaneWidthSubsampling)(plane))

	xor	eax, eax
$LN40@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 98   :         xRatioUV = vi.IsYUY2() ? 2 : (1 << vi.GetPlaneWidthSubsampling(PLANAR_U)); // PF

	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	mov	DWORD PTR _xRatioUV$1$[ebp], edx
$LN17@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	test	esi, esi
	je	SHORT $LN47@GetFrame
	cmp	DWORD PTR [esi], 28			; 0000001cH
	jbe	SHORT $LN18@GetFrame
	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [edi+16]
	call	eax
; File c:\github\mvtools\sources\padding.cpp

; 99   :         yRatioUV = vi.IsYUY2() ? 1 : (1 << vi.GetPlaneHeightSubsampling(PLANAR_U)); // PF

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\include\avisynth.h

; 624  :   bool IsYUY2() const AVS_BakedCode(return AVS_LinkCall(IsYUY2)())

	movzx	eax, al
; File c:\github\mvtools\sources\padding.cpp

; 99   :         yRatioUV = vi.IsYUY2() ? 1 : (1 << vi.GetPlaneHeightSubsampling(PLANAR_U)); // PF

	test	al, al
	je	SHORT $LN18@GetFrame
	mov	DWORD PTR _yRatioUV$1$[ebp], 1
	jmp	SHORT $LN3@GetFrame
$LN18@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 662  :   int GetPlaneHeightSubsampling(int plane) const AVS_BakedCode(return AVS_LinkCall(GetPlaneHeightSubsampling)(plane))

	test	esi, esi
	je	SHORT $LN47@GetFrame
	cmp	DWORD PTR [esi], 148			; 00000094H
	jbe	SHORT $LN47@GetFrame
	mov	eax, DWORD PTR [esi+148]
	lea	ecx, DWORD PTR [edi+16]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN48@GetFrame
$LN47@GetFrame:
	xor	eax, eax
$LN48@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 99   :         yRatioUV = vi.IsYUY2() ? 1 : (1 << vi.GetPlaneHeightSubsampling(PLANAR_U)); // PF

	mov	ecx, eax
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _yRatioUV$1$[ebp], eax
$LN3@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 692  :   int ComponentSize() const AVS_BakedCode(return AVS_LinkCallOptDefault(ComponentSize, 1))

	test	esi, esi
	je	SHORT $LN51@GetFrame
	cmp	DWORD PTR [esi], 532			; 00000214H
	jbe	SHORT $LN51@GetFrame
	mov	eax, DWORD PTR [esi+532]
	lea	ecx, DWORD PTR [edi+16]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pixelsize$1$[ebp], eax
	jmp	SHORT $LN52@GetFrame
$LN51@GetFrame:
	mov	DWORD PTR _pixelsize$1$[ebp], 1
$LN52@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 106  :   		if ( (vi.pixel_type & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 )

	mov	eax, DWORD PTR [edi+36]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN4@GetFrame

; 107  : 		{
; 108  : 		  if (!planar)

	cmp	BYTE PTR [edi+72], 0
	jne	$LN6@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN57@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN57@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrcYUY2$1$[ebp], eax
	jmp	SHORT $LN58@GetFrame
$LN57@GetFrame:
	mov	DWORD PTR _pSrcYUY2$1$[ebp], 0
$LN58@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN63@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN63@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, eax
	jmp	SHORT $LN64@GetFrame
$LN63@GetFrame:
	xor	esi, esi
$LN64@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [edi+88]
; File c:\github\mvtools\sources\padding.cpp

; 118  : 			YUY2ToPlanes(pSrcYUY2, nSrcPitchYUY2, width, height,

	push	DWORD PTR _isse$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+20]
	mov	DWORD PTR _pSrc$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\padding.cpp

; 118  : 			YUY2ToPlanes(pSrcYUY2, nSrcPitchYUY2, width, height,

	push	eax
	push	edx
	push	ecx
	push	ebx
	push	DWORD PTR _pSrc$1$[ebp]
	mov	DWORD PTR _pSrc$2$[ebp], ecx
	push	DWORD PTR [edi+80]
	mov	ecx, DWORD PTR _pSrcYUY2$1$[ebp]
	push	DWORD PTR [edi+76]
	mov	DWORD PTR _pSrc$3$[ebp], edx
	mov	edx, esi
	mov	DWORD PTR _nSrcPitches$1$[ebp], ebx
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	DWORD PTR _nSrcPitches$2$[ebp], eax
; File c:\github\mvtools\sources\padding.cpp

; 117  : 			nSrcPitches[2]  = SrcPlanes->GetPitchUV();

	mov	DWORD PTR _nSrcPitches$3$[ebp], eax

; 118  : 			YUY2ToPlanes(pSrcYUY2, nSrcPitchYUY2, width, height,

	call	?YUY2ToPlanes@@YAXPBEHHH0H00H_N@Z	; YUY2ToPlanes
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [edi+84]
; File c:\github\mvtools\sources\padding.cpp

; 118  : 			YUY2ToPlanes(pSrcYUY2, nSrcPitchYUY2, width, height,

	add	esp, 32					; 00000020H

; 126  :           }
; 127  :           else // planar YUY2

	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+20]
	mov	DWORD PTR _pDst$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pDst$2$[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\padding.cpp

; 122  : 			pDst[2] = DstPlanes->GetPtrV();

	mov	DWORD PTR _pDst$3$[ebp], ecx

; 123  : 			nDstPitches[0]  = DstPlanes->GetPitch();

	mov	DWORD PTR _nDstPitches$1$[ebp], esi
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	DWORD PTR _nDstPitches$2$[ebp], eax
; File c:\github\mvtools\sources\padding.cpp

; 125  : 			nDstPitches[2]  = DstPlanes->GetPitchUV();

	mov	DWORD PTR _nDstPitches$3$[ebp], eax

; 126  :           }
; 127  :           else // planar YUY2

	jmp	$LN5@GetFrame
$LN6@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN93@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN93@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$1$[ebp], eax
	jmp	SHORT $LN94@GetFrame
$LN93@GetFrame:
	mov	DWORD PTR _pSrc$1$[ebp], 0
$LN94@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN99@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN99@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$1$[ebp], eax
	jmp	SHORT $LN100@GetFrame
$LN99@GetFrame:
	mov	DWORD PTR _nSrcPitches$1$[ebp], 0
$LN100@GetFrame:
	test	esi, esi
	je	SHORT $LN105@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN105@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$2$[ebp], eax
	jmp	SHORT $LN106@GetFrame
$LN105@GetFrame:
	mov	DWORD PTR _nSrcPitches$2$[ebp], 0
$LN106@GetFrame:
	test	esi, esi
	je	SHORT $LN111@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN111@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$3$[ebp], eax
	jmp	SHORT $LN112@GetFrame
$LN111@GetFrame:
	mov	DWORD PTR _nSrcPitches$3$[ebp], 0
$LN112@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN117@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN117@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN118@GetFrame
$LN117@GetFrame:
	xor	eax, eax
$LN118@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 133  : 			pSrc[1] = pSrc[0] + src->GetRowSize()/2;

	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _pSrc$1$[ebp]
	mov	DWORD PTR _pSrc$2$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN123@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN123@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN124@GetFrame
$LN123@GetFrame:
	xor	eax, eax
$LN124@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 134  : 			pSrc[2] = pSrc[1] + src->GetRowSize()/4;

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR _pSrc$2$[ebp]
	mov	DWORD PTR _pSrc$3$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN129@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN129@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN130@GetFrame
$LN129@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN130@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN135@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN135@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN258@GetFrame
$LN135@GetFrame:
	xor	ecx, ecx
$LN258@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], ecx
	test	esi, esi
	je	SHORT $LN141@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN141@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	jmp	SHORT $LN142@GetFrame
$LN141@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN142@GetFrame:
	test	esi, esi
	je	SHORT $LN147@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN147@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	jmp	SHORT $LN148@GetFrame
$LN147@GetFrame:
	mov	DWORD PTR _nDstPitches$3$[ebp], 0
$LN148@GetFrame:

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN153@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN153@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN154@GetFrame
$LN153@GetFrame:
	xor	eax, eax
$LN154@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 139  : 			pDst[1] = pDst[0] + dst->GetRowSize()/2;

	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _pDst$1$[ebp]
	mov	DWORD PTR _pDst$2$[ebp], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 798  :   int GetRowSize(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetRowSize)(plane) )

	test	esi, esi
	je	SHORT $LN159@GetFrame
	cmp	DWORD PTR [esi], 196			; 000000c4H
	jbe	SHORT $LN159@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+196]
	push	0
	call	eax
	jmp	SHORT $LN160@GetFrame
$LN159@GetFrame:
	xor	eax, eax
$LN160@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 140  : 			pDst[2] = pDst[1] + dst->GetRowSize()/4;

	cdq
	and	edx, 3
	lea	esi, DWORD PTR [edx+eax]
	sar	esi, 2
	add	esi, DWORD PTR _pDst$2$[ebp]
	mov	DWORD PTR _pDst$3$[ebp], esi

; 141  :           }
; 142  : 		}
; 143  : 		else

	jmp	$LN232@GetFrame
$LN4@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN165@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN165@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+220]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$1$[ebp], eax
	jmp	SHORT $LN166@GetFrame
$LN165@GetFrame:
	mov	DWORD PTR _pDst$1$[ebp], 0
$LN166@GetFrame:
	test	esi, esi
	je	SHORT $LN171@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN171@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+220]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$2$[ebp], eax
	jmp	SHORT $LN172@GetFrame
$LN171@GetFrame:
	mov	DWORD PTR _pDst$2$[ebp], 0
$LN172@GetFrame:
	test	esi, esi
	je	SHORT $LN177@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN177@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+220]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDst$3$[ebp], eax
	jmp	SHORT $LN178@GetFrame
$LN177@GetFrame:
	mov	DWORD PTR _pDst$3$[ebp], 0
$LN178@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN183@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN183@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN259@GetFrame
$LN183@GetFrame:
	xor	ecx, ecx
$LN259@GetFrame:
	mov	DWORD PTR _nDstPitches$1$[ebp], ecx
	test	esi, esi
	je	SHORT $LN189@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN189@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$2$[ebp], eax
	jmp	SHORT $LN190@GetFrame
$LN189@GetFrame:
	mov	DWORD PTR _nDstPitches$2$[ebp], 0
$LN190@GetFrame:
	test	esi, esi
	je	SHORT $LN195@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN195@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitches$3$[ebp], eax
	jmp	SHORT $LN196@GetFrame
$LN195@GetFrame:
	mov	DWORD PTR _nDstPitches$3$[ebp], 0
$LN196@GetFrame:

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN201@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN201@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$1$[ebp], eax
	jmp	SHORT $LN202@GetFrame
$LN201@GetFrame:
	mov	DWORD PTR _pSrc$1$[ebp], 0
$LN202@GetFrame:
	test	esi, esi
	je	SHORT $LN207@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN207@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$2$[ebp], eax
	jmp	SHORT $LN208@GetFrame
$LN207@GetFrame:
	mov	DWORD PTR _pSrc$2$[ebp], 0
$LN208@GetFrame:
	test	esi, esi
	je	SHORT $LN213@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN213@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pSrc$3$[ebp], eax
	jmp	SHORT $LN214@GetFrame
$LN213@GetFrame:
	mov	DWORD PTR _pSrc$3$[ebp], 0
$LN214@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN219@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN219@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$1$[ebp], eax
	jmp	SHORT $LN220@GetFrame
$LN219@GetFrame:
	mov	DWORD PTR _nSrcPitches$1$[ebp], 0
$LN220@GetFrame:
	test	esi, esi
	je	SHORT $LN225@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN225@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nSrcPitches$2$[ebp], eax
	jmp	SHORT $LN226@GetFrame
$LN225@GetFrame:
	mov	DWORD PTR _nSrcPitches$2$[ebp], 0
$LN226@GetFrame:
	test	esi, esi
	je	SHORT $LN231@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN231@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	DWORD PTR _nSrcPitches$3$[ebp], eax
	jmp	SHORT $LN232@GetFrame
$LN231@GetFrame:
	mov	DWORD PTR _nSrcPitches$3$[ebp], 0
$LN232@GetFrame:
	mov	esi, DWORD PTR _nDstPitches$1$[ebp]
$LN5@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 160  : 	env->BitBlt(pDst[0] + horizontalPadding*pixelsize + verticalPadding * nDstPitches[0], nDstPitches[0],

	push	DWORD PTR [edi+80]
	mov	eax, DWORD PTR [edi+76]
	imul	eax, DWORD PTR _pixelsize$1$[ebp]
	mov	ecx, DWORD PTR [edi+68]
	mov	edx, DWORD PTR _env$[ebp]
	imul	ecx, esi
	push	eax
	push	DWORD PTR _nSrcPitches$1$[ebp]
	mov	eax, DWORD PTR [edi+64]
	imul	eax, DWORD PTR _pixelsize$1$[ebp]
	push	DWORD PTR _pSrc$1$[ebp]
	add	ecx, DWORD PTR _pDst$1$[ebp]
	mov	edx, DWORD PTR [edx]
	push	esi
	add	eax, ecx
	push	eax
	push	DWORD PTR _env$[ebp]
	call	DWORD PTR [edx+64]

; 161  : 		pSrc[0], nSrcPitches[0], width*pixelsize, height);
; 162  :     if(pixelsize==1)

	cmp	DWORD PTR _pixelsize$1$[ebp], 1

; 163  :         PadReferenceFrame<uint8_t>(pDst[0], nDstPitches[0], horizontalPadding, verticalPadding, width, height);

	mov	edx, esi
	push	DWORD PTR [edi+80]
	mov	ecx, DWORD PTR _pDst$1$[ebp]
	push	DWORD PTR [edi+76]
	push	DWORD PTR [edi+68]
	push	DWORD PTR [edi+64]
	jne	SHORT $LN8@GetFrame
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 164  :     else

	jmp	SHORT $LN260@GetFrame
$LN8@GetFrame:

; 165  :         PadReferenceFrame<uint16_t>(pDst[0], nDstPitches[0], horizontalPadding, verticalPadding, width, height);

	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>
$LN260@GetFrame:

; 166  : 
; 167  : 
; 168  : 	env->BitBlt(pDst[1] + horizontalPadding/xRatioUV*pixelsize + verticalPadding/yRatioUV * nDstPitches[1],

	mov	eax, DWORD PTR _env$[ebp]
	add	esp, 16					; 00000010H
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+80]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	imul	eax, DWORD PTR _pixelsize$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+68]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	push	DWORD PTR _nSrcPitches$2$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [edi+64]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	imul	ecx, DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pSrc$2$[ebp]
	imul	eax, DWORD PTR _pixelsize$1$[ebp]
	push	DWORD PTR _nDstPitches$2$[ebp]
	add	ecx, DWORD PTR _pDst$2$[ebp]
	add	eax, ecx
	push	eax
	push	DWORD PTR _env$[ebp]
	call	DWORD PTR [esi+64]

; 169  : 		nDstPitches[1],	pSrc[1], nSrcPitches[1], width/xRatioUV*pixelsize, height/yRatioUV);
; 170  :     if(pixelsize==1)
; 171  :         PadReferenceFrame<uint8_t>(pDst[1], nDstPitches[1], horizontalPadding/xRatioUV, verticalPadding/yRatioUV, width/xRatioUV, height/yRatioUV);

	mov	eax, DWORD PTR [edi+80]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	mov	ecx, DWORD PTR _pDst$2$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+68]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+64]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	cmp	DWORD PTR _pixelsize$1$[ebp], 1
	mov	edx, DWORD PTR _nDstPitches$2$[ebp]
	push	eax
	jne	SHORT $LN10@GetFrame
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 172  :     else

	jmp	SHORT $LN261@GetFrame
$LN10@GetFrame:

; 173  :         PadReferenceFrame<uint16_t>(pDst[1], nDstPitches[1], horizontalPadding/xRatioUV, verticalPadding/yRatioUV, width/xRatioUV, height/yRatioUV);

	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>
$LN261@GetFrame:

; 174  : 
; 175  : 
; 176  : 	env->BitBlt(pDst[2] + horizontalPadding/xRatioUV*pixelsize + verticalPadding/yRatioUV * nDstPitches[2],

	mov	eax, DWORD PTR _env$[ebp]
	add	esp, 16					; 00000010H
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+80]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	imul	eax, DWORD PTR _pixelsize$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+68]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	push	DWORD PTR _nSrcPitches$3$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR [edi+64]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	imul	ecx, DWORD PTR _nDstPitches$3$[ebp]
	push	DWORD PTR _pSrc$3$[ebp]
	imul	eax, DWORD PTR _pixelsize$1$[ebp]
	push	DWORD PTR _nDstPitches$3$[ebp]
	add	ecx, DWORD PTR _pDst$3$[ebp]
	add	eax, ecx
	push	eax
	push	DWORD PTR _env$[ebp]
	call	DWORD PTR [esi+64]

; 177  : 		nDstPitches[2],	pSrc[2], nSrcPitches[2], width/xRatioUV*pixelsize, height/yRatioUV);
; 178  :     if(pixelsize==1)
; 179  :         PadReferenceFrame<uint8_t>(pDst[2], nDstPitches[2], horizontalPadding/xRatioUV, verticalPadding/yRatioUV, width/xRatioUV, height/yRatioUV);

	mov	eax, DWORD PTR [edi+80]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	mov	ecx, DWORD PTR _pDst$3$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+68]
	cdq
	idiv	DWORD PTR _yRatioUV$1$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+64]
	cdq
	idiv	DWORD PTR _xRatioUV$1$[ebp]
	cmp	DWORD PTR _pixelsize$1$[ebp], 1
	mov	edx, DWORD PTR _nDstPitches$3$[ebp]
	push	eax
	jne	SHORT $LN12@GetFrame
	call	??$PadReferenceFrame@E@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned char>

; 180  :     else

	jmp	SHORT $LN262@GetFrame
$LN12@GetFrame:

; 181  :         PadReferenceFrame<uint16_t>(pDst[2], nDstPitches[2], horizontalPadding/xRatioUV, verticalPadding/yRatioUV, width/xRatioUV, height/yRatioUV);

	call	??$PadReferenceFrame@G@Padding@@SAXPAEHHHHH@Z ; Padding::PadReferenceFrame<unsigned short>
$LN262@GetFrame:

; 182  : 
; 183  : 	if ( (vi.pixel_type & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [edi+36]
	add	esp, 16					; 00000010H
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN255@GetFrame
	cmp	BYTE PTR [edi+72], 0
	jne	SHORT $LN255@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN237@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN237@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	jmp	SHORT $LN238@GetFrame
$LN237@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN238@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN243@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN243@GetFrame
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN244@GetFrame
$LN243@GetFrame:
	xor	eax, eax
$LN244@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 187  : 		YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, vi.width, vi.height,

	push	DWORD PTR _isse$[ebp]
	mov	ecx, DWORD PTR _nDstPitches$1$[ebp]
	mov	edx, eax
	push	DWORD PTR _nDstPitches$2$[ebp]
	push	DWORD PTR _pDst$3$[ebp]
	push	DWORD PTR _pDst$2$[ebp]
	push	ecx
	push	DWORD PTR _pDst$1$[ebp]
	mov	ecx, DWORD PTR _pDstYUY2$1$[ebp]
	push	DWORD PTR [edi+20]
	push	DWORD PTR [edi+16]
	call	?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z	; YUY2FromPlanes
	add	esp, 32					; 00000020H
	jmp	SHORT $LN14@GetFrame
$LN255@GetFrame:
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN14@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	esi, esi
	je	SHORT $LN251@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN251@GetFrame
	mov	edx, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	edx
$LN251@GetFrame:
; File c:\github\mvtools\sources\padding.cpp

; 191  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN22@GetFrame
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
$LN22@GetFrame:
	ret	0
__unwindfunclet$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@Padding@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; Padding::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\padding.cpp
;	COMDAT ??$PadCorner@E@@YAXPAEEHHH@Z
_TEXT	SEGMENT
_hPad$ = 8						; size = 4
_vPad$ = 12						; size = 4
_refPitch$ = 16						; size = 4
??$PadCorner@E@@YAXPAEEHHH@Z PROC			; PadCorner<unsigned char>, COMDAT
; _p$ = ecx
; _v$ = dl

; 26   : {

	push	esi
	push	edi

; 27   :     // refPitch here is pixel_t aware
; 28   : 	for ( int i = 0; i < vPad; i++ )

	mov	edi, DWORD PTR _vPad$[esp+4]
	mov	esi, ecx
	test	edi, edi
	jle	SHORT $LN3@PadCorner
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _refPitch$[esp+12]
	movzx	ebx, dl
$LL4@PadCorner:

; 29   : 	{
; 30   :         if(sizeof(pixel_t) == 1)
; 31   :             memset(p, v, hPad); // faster than loop

	push	DWORD PTR _hPad$[esp+12]
	push	ebx
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 32   :         else {
; 33   :             /*
; 34   :             for (int j = 0; j < hPad; j++)
; 35   :                 p[j] = v;
; 36   :             */
; 37   :             std::fill_n(p, hPad, v); 
; 38   :         }
; 39   : //		for ( int j = 0; j < hPad; j++ )
; 40   : //		{
; 41   : //			p[j] = v;
; 42   : //		}
; 43   : 		p += refPitch;

	add	esi, ebp
	sub	edi, 1
	jne	SHORT $LL4@PadCorner
	pop	ebp
	pop	ebx
$LN3@PadCorner:
	pop	edi
	pop	esi

; 44   : 	}
; 45   : }

	ret	0
??$PadCorner@E@@YAXPAEEHHH@Z ENDP			; PadCorner<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\padding.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\github\mvtools\sources\padding.cpp
;	COMDAT ??$PadCorner@G@@YAXPAGGHHH@Z
_TEXT	SEGMENT
_v$1$ = -4						; size = 4
_hPad$ = 8						; size = 4
tv179 = 12						; size = 4
_vPad$ = 12						; size = 4
_refPitch$ = 16						; size = 4
??$PadCorner@G@@YAXPAGGHHH@Z PROC			; PadCorner<unsigned short>, COMDAT
; _p$ = ecx
; _v$ = edx

; 26   : {

	push	ecx
	push	ebx

; 27   :     // refPitch here is pixel_t aware
; 28   : 	for ( int i = 0; i < vPad; i++ )

	mov	ebx, DWORD PTR _vPad$[esp+4]
	mov	DWORD PTR _v$1$[esp+8], edx
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	jle	SHORT $LN3@PadCorner
	mov	eax, DWORD PTR _refPitch$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _hPad$[esp+12]
	add	eax, eax
	push	edi
	mov	DWORD PTR tv179[esp+16], eax
$LL4@PadCorner:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2797 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

	test	ebp, ebp
	jle	SHORT $LN21@PadCorner

; 2822 : 	return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));

	mov	eax, edx
	mov	ecx, ebp
	movzx	edx, ax
	mov	edi, esi
	mov	eax, edx
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	mov	edx, DWORD PTR _v$1$[esp+20]
	rep stosd
	adc	ecx, ecx
	rep stosw
	mov	eax, DWORD PTR tv179[esp+16]
$LN21@PadCorner:
; File c:\github\mvtools\sources\padding.cpp

; 43   : 		p += refPitch;

	add	esi, eax
	sub	ebx, 1
	jne	SHORT $LL4@PadCorner
	pop	edi
	pop	ebp
$LN3@PadCorner:
	pop	esi
	pop	ebx

; 44   : 	}
; 45   : }

	pop	ecx
	ret	0
??$PadCorner@G@@YAXPAGGHHH@Z ENDP			; PadCorner<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$fill_n@PAEHE@std@@YAPAEPAEHABE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill_n@PAEHE@std@@YAPAEPAEHABE@Z PROC		; std::fill_n<unsigned char *,int,unsigned char>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2829 : 	{	// copy _Val _Count times through [_Dest, ...)

	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 2807 : 	if (0 < _Count)

	test	edi, edi
	jle	SHORT $LN12@fill_n

; 2808 : 		{
; 2809 : 		_CSTD memset(_Dest, _Val, _Count);

	mov	eax, DWORD PTR __Val$[esp+4]
	push	edi
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 2810 : 		return (_Dest + _Count);

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 2831 : 		_Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
; 2832 : 	}

	ret	0
$LN12@fill_n:
	pop	edi

; 2830 : 	return (_Rechecked(_Dest,

	mov	eax, esi
	pop	esi

; 2831 : 		_Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
; 2832 : 	}

	ret	0
??$fill_n@PAEHE@std@@YAPAEPAEHABE@Z ENDP		; std::fill_n<unsigned char *,int,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked_n@PAEH@std@@YA@PAEH@Z
_TEXT	SEGMENT
??$_Unchecked_n@PAEH@std@@YA@PAEH@Z PROC		; std::_Unchecked_n<unsigned char *,int>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 680  : 	return (_Unchecked(_Src));

	mov	eax, ecx

; 681  : 	}

	ret	0
??$_Unchecked_n@PAEH@std@@YA@PAEH@Z ENDP		; std::_Unchecked_n<unsigned char *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$fill_n@PAGHG@std@@YAPAGPAGHABG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill_n@PAGHG@std@@YAPAGPAGHABG@Z PROC		; std::fill_n<unsigned short *,int,unsigned short>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2797 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

	test	edx, edx
	jle	SHORT $LN22@fill_n
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	npad	7
$LL14@fill_n:

; 2798 : 		*_Dest = _Val;

	mov	ax, WORD PTR [esi]
	dec	edx
	mov	WORD PTR [ecx], ax
	add	ecx, 2
	test	edx, edx
	jg	SHORT $LL14@fill_n
	pop	esi
$LN22@fill_n:

; 2830 : 	return (_Rechecked(_Dest,

	mov	eax, ecx

; 2831 : 		_Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
; 2832 : 	}

	ret	0
??$fill_n@PAGHG@std@@YAPAGPAGHABG@Z ENDP		; std::fill_n<unsigned short *,int,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked_n@PAGH@std@@YA@PAGH@Z
_TEXT	SEGMENT
??$_Unchecked_n@PAGH@std@@YA@PAGH@Z PROC		; std::_Unchecked_n<unsigned short *,int>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 680  : 	return (_Unchecked(_Src));

	mov	eax, ecx

; 681  : 	}

	ret	0
??$_Unchecked_n@PAGH@std@@YA@PAGH@Z ENDP		; std::_Unchecked_n<unsigned short *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Fill_n_unchecked@PAEHE@std@@YAPAEPAEHABE@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill_n_unchecked@PAEHE@std@@YAPAEPAEHABE@Z PROC	; std::_Fill_n_unchecked<unsigned char *,int,unsigned char>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2820 : 	{	// copy _Val _Count times through [_Dest, ...), choose optimization

	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx

; 2807 : 	if (0 < _Count)

	test	edi, edi
	jle	SHORT $LN6@Fill_n_unc

; 2808 : 		{
; 2809 : 		_CSTD memset(_Dest, _Val, _Count);

	mov	eax, DWORD PTR __Val$[esp+4]
	push	edi
	movzx	eax, BYTE PTR [eax]
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 2810 : 		return (_Dest + _Count);

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 2823 : 	}

	ret	0
$LN6@Fill_n_unc:
	pop	edi

; 2821 : 		// note: This is called directly from elsewhere in the STL
; 2822 : 	return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));

	mov	eax, esi
	pop	esi

; 2823 : 	}

	ret	0
??$_Fill_n_unchecked@PAEHE@std@@YAPAEPAEHABE@Z ENDP	; std::_Fill_n_unchecked<unsigned char *,int,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Fill_n_unchecked@PAGHG@std@@YAPAGPAGHABG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill_n_unchecked@PAGHG@std@@YAPAGPAGHABG@Z PROC	; std::_Fill_n_unchecked<unsigned short *,int,unsigned short>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2797 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

	test	edx, edx
	jle	SHORT $LN14@Fill_n_unc
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	npad	7
$LL8@Fill_n_unc:

; 2798 : 		*_Dest = _Val;

	mov	ax, WORD PTR [esi]
	dec	edx
	mov	WORD PTR [ecx], ax
	add	ecx, 2
	test	edx, edx
	jg	SHORT $LL8@Fill_n_unc
	pop	esi
$LN14@Fill_n_unc:

; 2821 : 		// note: This is called directly from elsewhere in the STL
; 2822 : 	return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));

	mov	eax, ecx

; 2823 : 	}

	ret	0
??$_Fill_n_unchecked@PAGHG@std@@YAPAGPAGHABG@Z ENDP	; std::_Fill_n_unchecked<unsigned short *,int,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Fill_n_unchecked1@PAEHE@std@@YAPAEPAEHABEU?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill_n_unchecked1@PAEHE@std@@YAPAEPAEHABEU?$integral_constant@_N$00@0@@Z PROC ; std::_Fill_n_unchecked1<unsigned char *,int,unsigned char>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2807 : 	if (0 < _Count)
; 2808 : 		{
; 2809 : 		_CSTD memset(_Dest, _Val, _Count);

	mov	eax, DWORD PTR __Val$[esp-4]
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx
	movzx	eax, BYTE PTR [eax]
	push	edi
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 2810 : 		return (_Dest + _Count);

	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 2811 : 		}
; 2812 : 
; 2813 : 	return (_Dest);
; 2814 : 	}

	ret	0
??$_Fill_n_unchecked1@PAEHE@std@@YAPAEPAEHABEU?$integral_constant@_N$00@0@@Z ENDP ; std::_Fill_n_unchecked1<unsigned char *,int,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Fill_n_unchecked1@PAGHG@std@@YAPAGPAGHABGU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n_unchecked1@PAGHG@std@@YAPAGPAGHABGU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Fill_n_unchecked1<unsigned short *,int,unsigned short>, COMDAT
; __Dest$ = ecx
; __Count$ = edx

; 2797 : 	for (; 0 < _Count; --_Count, (void)++_Dest)

	test	edx, edx
	jle	SHORT $LN10@Fill_n_unc
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
	npad	7
$LL4@Fill_n_unc:

; 2798 : 		*_Dest = _Val;

	mov	ax, WORD PTR [esi]
	dec	edx
	mov	WORD PTR [ecx], ax
	add	ecx, 2
	test	edx, edx
	jg	SHORT $LL4@Fill_n_unc
	pop	esi
$LN10@Fill_n_unc:

; 2799 : 	return (_Dest);

	mov	eax, ecx

; 2800 : 	}

	ret	0
??$_Fill_n_unchecked1@PAGHG@std@@YAPAGPAGHABGU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Fill_n_unchecked1<unsigned short *,int,unsigned short>
_TEXT	ENDS
END
