; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\groupofplanes.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@HGMHDAEK@SearchType?5?$CFi?$AA@	; `string'
PUBLIC	??_R2?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@8	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64> `RTTI Type Descriptor'
PUBLIC	??_R3?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8 ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Complete Object Locator'
;	COMDAT ??_R4?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@
rdata$r	SEGMENT
??_R4?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@ DD 00H	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@8
	DD	FLAT:??_R3?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8 DD FLAT:??_R0?AV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@8 ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@
CONST	SEGMENT
??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@ DD FLAT:??_R4?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@ ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`vftable'
	DD	FLAT:??_E?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R3?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8 DD 00H	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@8
data$r	SEGMENT
??_R0?AV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@8 DD FLAT:??_7type_info@@6B@ ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R2?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8 DD FLAT:??_R1A@?0A@EA@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@8 ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_C@_0O@HGMHDAEK@SearchType?5?$CFi?$AA@
CONST	SEGMENT
??_C@_0O@HGMHDAEK@SearchType?5?$CFi?$AA@ DB 'SearchType %i', 00H ; `string'
?zeroMV@@3UVECTOR@@B DD 00H				; zeroMV
	DD	00H
	DD	0ffffffffH
PUBLIC	??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`scalar deleting destructor'
PUBLIC	?wait@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXXZ ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::wait
PUBLIC	??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::~MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>
PUBLIC	??0?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAE@_N@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>
PUBLIC	?ExtraDivide@GroupOfPlanes@@QAEXPAHH@Z		; GroupOfPlanes::ExtraDivide
PUBLIC	?GetMedian@@YAXPAH0HHHHHH@Z			; GetMedian
PUBLIC	?Median3@@YAHHHH@Z				; Median3
PUBLIC	?GetArraySize@GroupOfPlanes@@QAEHXZ		; GroupOfPlanes::GetArraySize
PUBLIC	?WriteDefaultToArray@GroupOfPlanes@@QAEXPAH@Z	; GroupOfPlanes::WriteDefaultToArray
PUBLIC	?RecalculateMVs@GroupOfPlanes@@QAEXAAVMVClip@@PAVMVGroupOfFrames@@1W4SearchType@@HHHHHPAHPAFHHH_N@Z ; GroupOfPlanes::RecalculateMVs
PUBLIC	?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z ; GroupOfPlanes::SearchMVs
PUBLIC	??_GPlaneOfBlocks@@QAEPAXI@Z			; PlaneOfBlocks::`scalar deleting destructor'
PUBLIC	??1GroupOfPlanes@@QAE@XZ			; GroupOfPlanes::~GroupOfPlanes
PUBLIC	??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z ; GroupOfPlanes::GroupOfPlanes
PUBLIC	?GetnBlkY@PlaneOfBlocks@@QAEHXZ			; PlaneOfBlocks::GetnBlkY
PUBLIC	?GetnBlkX@PlaneOfBlocks@@QAEHXZ			; PlaneOfBlocks::GetnBlkX
EXTRN	??_E?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z:PROC ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\debugprintf.h
;	COMDAT ?DebugPrintf@@YAXPADZZ
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?DebugPrintf@@YAXPADZZ PROC				; DebugPrintf, COMDAT

; 52   :   __noop(fmt); 	// Nothing
; 53   : }

	ret	0
?DebugPrintf@@YAXPADZZ ENDP				; DebugPrintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.h
;	COMDAT ?GetnBlkX@PlaneOfBlocks@@QAEHXZ
_TEXT	SEGMENT
?GetnBlkX@PlaneOfBlocks@@QAEHXZ PROC			; PlaneOfBlocks::GetnBlkX, COMDAT
; _this$ = ecx

; 81   :   inline int GetnBlkX() { return nBlkX; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetnBlkX@PlaneOfBlocks@@QAEHXZ ENDP			; PlaneOfBlocks::GetnBlkX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\planeofblocks.h
;	COMDAT ?GetnBlkY@PlaneOfBlocks@@QAEHXZ
_TEXT	SEGMENT
?GetnBlkY@PlaneOfBlocks@@QAEHXZ PROC			; PlaneOfBlocks::GetnBlkY, COMDAT
; _this$ = ecx

; 82   :   inline int GetnBlkY() { return nBlkY; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetnBlkY@PlaneOfBlocks@@QAEHXZ ENDP			; PlaneOfBlocks::GetnBlkY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_i$1$ = 8						; size = 4
__nBlkSizeX$ = 8					; size = 4
_nPelCurrent$1$ = 12					; size = 4
__nBlkSizeY$ = 12					; size = 4
_nFlagsCurrent$1$ = 16					; size = 4
__nLevelCount$ = 16					; size = 4
_nHeight_B$1$ = 20					; size = 4
__nPel$ = 20						; size = 4
_nWidth_B$1$ = 24					; size = 4
__nFlags$ = 24						; size = 4
$T2 = 28						; size = 4
__nOverlapX$ = 28					; size = 4
__nOverlapY$ = 32					; size = 4
__nBlkX$ = 36						; size = 4
__nBlkY$ = 40						; size = 4
__xRatioUV$ = 44					; size = 4
__yRatioUV$ = 48					; size = 4
__divideExtra$ = 52					; size = 4
__pixelsize$ = 56					; size = 4
__bits_per_pixel$ = 60					; size = 4
_dct_pool_ptr$ = 64					; size = 4
_mt_flag$ = 68						; size = 1
??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z PROC ; GroupOfPlanes::GroupOfPlanes, COMDAT
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
	push	eax

; 33   :   : nBlkSizeX(_nBlkSizeX)

	mov	eax, DWORD PTR __nBlkSizeX$[ebp]
	mov	DWORD PTR fs:0, esp

; 34   :   , nBlkSizeY(_nBlkSizeY)
; 35   :   , nLevelCount(_nLevelCount)

	mov	edx, DWORD PTR __nLevelCount$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx

; 36   :   , nPel(_nPel)
; 37   :   , nFlags(_nFlags)
; 38   :   , nOverlapX(_nOverlapX)
; 39   :   , nOverlapY(_nOverlapY)
; 40   :   , xRatioUV(_xRatioUV)
; 41   :   , yRatioUV(_yRatioUV)
; 42   :   , divideExtra(_divideExtra)
; 43   :   , pixelsize(_pixelsize)
; 44   :   , bits_per_pixel(_bits_per_pixel)

	mov	ecx, DWORD PTR __bits_per_pixel$[ebp]
	push	edi
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __nBlkSizeY$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __nPel$[ebp]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR __nFlags$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __nOverlapX$[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR __nOverlapY$[ebp]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR __yRatioUV$[ebp]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR __xRatioUV$[ebp]
	mov	DWORD PTR [esi+32], eax
	mov	eax, DWORD PTR __pixelsize$[ebp]
	mov	DWORD PTR [esi+36], eax

; 45   :   , _mt_flag(mt_flag)

	mov	eax, DWORD PTR _mt_flag$[ebp]
	mov	DWORD PTR [esi+40], ecx
	mov	ecx, DWORD PTR __divideExtra$[ebp]
	mov	BYTE PTR [esi+48], al

; 46   :   , _dct_pool_ptr(dct_pool_ptr)

	mov	eax, DWORD PTR _dct_pool_ptr$[ebp]
	mov	DWORD PTR [esi+44], ecx

; 48   :   planes = new PlaneOfBlocks*[nLevelCount];

	xor	ecx, ecx
	mov	DWORD PTR [esi+52], eax
	mov	eax, edx
	mov	DWORD PTR [esi+8], edx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 49   : 
; 50   :   int				nBlkX = _nBlkX;
; 51   :   int				nBlkY = _nBlkY;
; 52   : 
; 53   :   int				nPelCurrent = nPel;
; 54   :   int				nFlagsCurrent = nFlags;
; 55   : 
; 56   :   int				nWidth_B = (nBlkSizeX - nOverlapX) * nBlkX + nOverlapX;

	mov	ebx, DWORD PTR [esi]

; 57   :   int				nHeight_B = (nBlkSizeY - nOverlapY) * nBlkY + nOverlapY;
; 58   : 
; 59   :   for (int i = 0; i < nLevelCount; i++)

	xor	edi, edi
	sub	ebx, DWORD PTR [esi+20]
	add	esp, 4
	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi+24]
	imul	ebx, DWORD PTR __nBlkX$[ebp]
	imul	ecx, DWORD PTR __nBlkY$[ebp]
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+56], eax
	mov	eax, DWORD PTR [esi+12]
	add	ebx, DWORD PTR [esi+20]
	add	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR _nPelCurrent$1$[ebp], eax
	mov	DWORD PTR _nWidth_B$1$[ebp], ebx
	mov	DWORD PTR _nHeight_B$1$[ebp], ecx
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	DWORD PTR [esi+8], edi
	jle	$LN14@GroupOfPla
$LL4@GroupOfPla:

; 60   :   {
; 61   :     if (i == nLevelCount - 1)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, edx
	dec	eax
	or	ecx, 128				; 00000080H
	cmp	edi, eax

; 62   :     {
; 63   :       nFlagsCurrent |= MOTION_SMALLEST_PLANE;
; 64   :     }
; 65   :     nBlkX = ((nWidth_B >> i) - nOverlapX) / (nBlkSizeX - nOverlapX);

	mov	eax, ebx

; 66   :     nBlkY = ((nHeight_B >> i) - nOverlapY) / (nBlkSizeY - nOverlapY);
; 67   :     planes[i] = new PlaneOfBlocks(nBlkX, nBlkY, nBlkSizeX, nBlkSizeY, nPelCurrent, i, nFlagsCurrent, nOverlapX, nOverlapY, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, dct_pool_ptr, mt_flag);

	push	768					; 00000300H
	cmovne	ecx, edx
	mov	DWORD PTR _nFlagsCurrent$1$[ebp], ecx
	mov	ecx, edi
	sar	eax, cl
	sub	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [esi+20]
	cdq
	idiv	ecx
	mov	ecx, edi
	mov	ebx, eax
	mov	eax, DWORD PTR _nHeight_B$1$[ebp]
	sar	eax, cl
	sub	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi+24]
	cdq
	idiv	ecx
	mov	edi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	push	DWORD PTR _mt_flag$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, eax
	push	DWORD PTR _dct_pool_ptr$[ebp]
	push	DWORD PTR [esi+40]
	push	DWORD PTR [esi+36]
	push	DWORD PTR [esi+28]
	push	DWORD PTR [esi+32]
	push	DWORD PTR [esi+24]
	push	DWORD PTR [esi+20]
	push	DWORD PTR _nFlagsCurrent$1$[ebp]
	push	DWORD PTR _i$1$[ebp]
	push	DWORD PTR _nPelCurrent$1$[ebp]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	push	edi
	push	ebx
	call	??0PlaneOfBlocks@@QAE@HHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z ; PlaneOfBlocks::PlaneOfBlocks
	mov	edi, DWORD PTR _i$1$[ebp]
	mov	ebx, DWORD PTR _nWidth_B$1$[ebp]
	mov	edx, DWORD PTR _nFlagsCurrent$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR [esi+56]

; 68   :     nPelCurrent = 1;

	mov	DWORD PTR _nPelCurrent$1$[ebp], 1
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi
	mov	DWORD PTR _i$1$[ebp], edi
	cmp	edi, DWORD PTR [esi+8]
	jl	$LL4@GroupOfPla
$LN14@GroupOfPla:

; 69   :   }
; 70   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z$0:
	push	768					; 00000300H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0GroupOfPlanes@@QAE@HHHHHHHHHHHHHHPAV?$ObjPool@VDCTClass@@@conc@@_N@Z ENDP ; GroupOfPlanes::GroupOfPlanes
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ??1GroupOfPlanes@@QAE@XZ
_TEXT	SEGMENT
??1GroupOfPlanes@@QAE@XZ PROC				; GroupOfPlanes::~GroupOfPlanes, COMDAT
; _this$ = ecx

; 75   : {

	push	esi
	mov	esi, ecx
	push	edi

; 76   :   for (int i = 0; i < nLevelCount; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jle	SHORT $LN3@GroupOfPla
	push	ebx
	npad	4
$LL4@GroupOfPla:

; 77   :   {
; 78   :     delete planes[i];

	mov	eax, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [eax+edi*4]
	test	ebx, ebx
	je	SHORT $LN9@GroupOfPla
	mov	ecx, ebx
	call	??1PlaneOfBlocks@@QAE@XZ		; PlaneOfBlocks::~PlaneOfBlocks
	push	768					; 00000300H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@GroupOfPla:

; 79   :     planes[i] = 0;

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [eax+edi*4], 0
	inc	edi
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL4@GroupOfPla
	pop	ebx
$LN3@GroupOfPla:

; 80   :   }
; 81   :   delete[] planes;

	push	DWORD PTR [esi+56]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 82   :   planes = 0;

	mov	DWORD PTR [esi+56], 0
	pop	edi
	pop	esi

; 83   : }

	ret	0
??1GroupOfPlanes@@QAE@XZ ENDP				; GroupOfPlanes::~GroupOfPlanes
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GPlaneOfBlocks@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GPlaneOfBlocks@@QAEPAXI@Z PROC			; PlaneOfBlocks::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1PlaneOfBlocks@@QAE@XZ		; PlaneOfBlocks::~PlaneOfBlocks
	push	768					; 00000300H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	pop	esi
	ret	4
??_GPlaneOfBlocks@@QAEPAXI@Z ENDP			; PlaneOfBlocks::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z
_TEXT	SEGMENT
_slicer_glob$ = -1088					; size = 1044
_globalMV$ = -44					; size = 12
_this$1$ = -32						; size = 4
_meanLumaChange$ = -28					; size = 4
tv716 = -24						; size = 4
_nSearchParamLevel$1$ = -20				; size = 4
_fieldShiftCur$1$ = -20					; size = 4
$T2 = -16						; size = 4
_searchTypeLevel$1$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_pSrcGOF$ = 8						; size = 4
_pRefGOF$ = 12						; size = 4
_searchType$ = 16					; size = 4
_nSearchParam$ = 20					; size = 4
_nPelSearch$ = 24					; size = 4
_nLambda$ = 28						; size = 4
_lsad$ = 32						; size = 4
_pnew$ = 36						; size = 4
_plevel$ = 40						; size = 4
_global$ = 44						; size = 1
_flags$ = 48						; size = 4
_vecPrev$2$ = 52					; size = 4
_out$ = 52						; size = 4
_outfilebuf$ = 56					; size = 4
_fieldShift$ = 60					; size = 4
_pzero$ = 64						; size = 4
_searchTypeSmallest$1$ = 68				; size = 4
_out$2$ = 68						; size = 4
_pglobal$ = 68						; size = 4
_badSAD$ = 72						; size = 4
_badrange$ = 76						; size = 4
_meander$ = 80						; size = 1
_tryManyLevel$ = 84					; size = 1
_vecPrev$ = 84						; size = 4
_tryMany$ = 88						; size = 1
?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z PROC ; GroupOfPlanes::SearchMVs, COMDAT
; _this$ = ecx

; 109  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1076				; 00000434H

; 110  :   nFlags |= flags;

	mov	eax, DWORD PTR _flags$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	or	DWORD PTR [edi+16], eax

; 111  : 
; 112  :   // write group's size
; 113  :   out[0] = GetArraySize();

	call	?GetArraySize@GroupOfPlanes@@QAEHXZ	; GroupOfPlanes::GetArraySize
	mov	esi, DWORD PTR _out$[ebp]

; 114  : 
; 115  :   // write validity : 1 in that case
; 116  :   out[1] = 1;
; 117  : 
; 118  :   out += 2;
; 119  :   if (vecPrev)
; 120  :   {
; 121  :     vecPrev += 2;
; 122  :   }
; 123  : 
; 124  :   // may be non zero for finest level only
; 125  :   int				fieldShiftCur = (nLevelCount - 1 == 0) ? fieldShift : 0;
; 126  : 
; 127  :   // create and init global motion vector as zero
; 128  :   VECTOR globalMV;
; 129  :   globalMV.x = zeroMV.x;

	mov	DWORD PTR _globalMV$[ebp], 0

; 130  :   globalMV.y = zeroMV.y;

	mov	DWORD PTR _globalMV$[ebp+4], 0

; 131  :   globalMV.sad = zeroMV.sad;

	mov	DWORD PTR _globalMV$[ebp+8], -1
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _vecPrev$[ebp]
	mov	DWORD PTR [esi+4], 1
	add	esi, 8
	mov	edx, DWORD PTR [edi+8]
	test	eax, eax

; 132  : 
; 133  :   if (!global)
; 134  :   {
; 135  :     pglobal = pzero;
; 136  :   }
; 137  : 
; 138  :   int				meanLumaChange = 0;

	mov	DWORD PTR _meanLumaChange$[ebp], 0
	lea	ecx, DWORD PTR [eax+8]
	cmove	ecx, eax
	xor	eax, eax
	cmp	edx, 1
	mov	DWORD PTR _vecPrev$2$[ebp], ecx
	cmove	eax, DWORD PTR _fieldShift$[ebp]
	cmp	BYTE PTR _global$[ebp], 0
	mov	DWORD PTR _fieldShiftCur$1$[ebp], eax
	mov	eax, DWORD PTR _pzero$[ebp]
	cmovne	eax, DWORD PTR _pglobal$[ebp]
	mov	DWORD PTR tv716[ebp], eax

; 139  : 
; 140  :   // Search the motion vectors, for the low details interpolations first
; 141  :   SearchType		searchTypeSmallest =
; 142  :     (nLevelCount == 1 || searchType == HSEARCH || searchType == VSEARCH)

	mov	eax, DWORD PTR _searchType$[ebp]
	cmp	edx, 1
	je	SHORT $LN14@SearchMVs
	cmp	eax, 64					; 00000040H
	je	SHORT $LN14@SearchMVs
	mov	DWORD PTR _searchTypeSmallest$1$[ebp], 8
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN15@SearchMVs
$LN14@SearchMVs:
	mov	DWORD PTR _searchTypeSmallest$1$[ebp], eax
$LN15@SearchMVs:

; 143  :     ? searchType
; 144  :     : EXHAUSTIVE; // full search for smallest coarse plane
; 145  :   int				nSearchParamSmallest =
; 146  :     (nLevelCount == 1) ? nPelSearch : nSearchParam;

	mov	ebx, DWORD PTR _nSearchParam$[ebp]
	cmp	edx, 1
	cmove	ebx, DWORD PTR _nPelSearch$[ebp]

; 147  :   DebugPrintf("SearchType %i", searchType);
; 148  :   bool				tryManyLevel = (tryMany && nLevelCount > 1);

	cmp	BYTE PTR _tryMany$[ebp], 0
	je	SHORT $LN16@SearchMVs
	mov	BYTE PTR _tryManyLevel$[ebp], 1
	cmp	edx, 1
	jg	SHORT $LN17@SearchMVs
$LN16@SearchMVs:
	mov	BYTE PTR _tryManyLevel$[ebp], 0
$LN17@SearchMVs:

; 149  :   planes[nLevelCount - 1]->SearchMVs(

	lea	ecx, DWORD PTR [edx-1]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	test	ecx, ecx
	js	SHORT $LN25@SearchMVs
	mov	eax, DWORD PTR _pRefGOF$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN25@SearchMVs

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T2[ebp], eax
	jmp	SHORT $LN23@SearchMVs
$LN25@SearchMVs:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	mov	DWORD PTR $T2[ebp], 0
$LN23@SearchMVs:
	test	ecx, ecx
	js	SHORT $LN29@SearchMVs
	mov	eax, DWORD PTR _pSrcGOF$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN29@SearchMVs

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN27@SearchMVs
$LN29@SearchMVs:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	xor	eax, eax
$LN27@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 149  :   planes[nLevelCount - 1]->SearchMVs(

	push	DWORD PTR _tryManyLevel$[ebp]
	push	DWORD PTR _vecPrev$2$[ebp]
	push	DWORD PTR _meander$[ebp]
	push	DWORD PTR _badrange$[ebp]
	push	DWORD PTR _badSAD$[ebp]
	push	DWORD PTR tv716[ebp]
	push	DWORD PTR _pzero$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _meanLumaChange$[ebp]
	push	ecx
	push	DWORD PTR _fieldShiftCur$1$[ebp]
	lea	ecx, DWORD PTR _globalMV$[ebp]
	push	DWORD PTR _outfilebuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edi+56]
	push	esi
	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _plevel$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4-4]
	push	DWORD PTR _pnew$[ebp]
	push	DWORD PTR _lsad$[ebp]
	push	DWORD PTR _nLambda$[ebp]
	push	ebx
	push	DWORD PTR _searchTypeSmallest$1$[ebp]
	push	DWORD PTR $T2[ebp]
	push	eax
	call	?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z ; PlaneOfBlocks::SearchMVs

; 150  :     pSrcGOF->GetFrame(nLevelCount - 1),
; 151  :     pRefGOF->GetFrame(nLevelCount - 1),
; 152  :     searchTypeSmallest,
; 153  :     nSearchParamSmallest,
; 154  :     nLambda,
; 155  :     lsad,
; 156  :     pnew,
; 157  :     plevel,
; 158  :     flags,
; 159  :     out,
; 160  :     &globalMV,
; 161  :     outfilebuf,
; 162  :     fieldShiftCur,
; 163  :     &meanLumaChange,
; 164  :     divideExtra,
; 165  :     pzero,
; 166  :     pglobal,
; 167  :     badSAD,
; 168  :     badrange,
; 169  :     meander,
; 170  :     vecPrev,
; 171  :     tryManyLevel
; 172  :   );
; 173  : 
; 174  :   out += planes[nLevelCount - 1]->GetArraySize(divideExtra);

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+56]
	mov	edx, DWORD PTR [eax+ecx*4-4]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 572  :   size += nBlkCount * N_PER_BLOCK;  // vectors, sad, luma src, luma ref, var

	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax*2+1]
	add	ecx, eax

; 573  : 
; 574  :   if (nLogScale == 0)

	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN33@SearchMVs

; 575  :   {
; 576  :     if (divideMode)

	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN33@SearchMVs

; 577  :     {
; 578  :       size += 1 + nBlkCount * N_PER_BLOCK * 4; // reserve space for divided subblocks extra level

	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	inc	ecx
$LN33@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 175  :   if (vecPrev)

	mov	ebx, DWORD PTR _vecPrev$2$[ebp]
	lea	eax, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _out$2$[ebp], eax
	test	ebx, ebx
	je	SHORT $LN7@SearchMVs
; File c:\github\mvtools\sources\planeofblocks.cpp

; 572  :   size += nBlkCount * N_PER_BLOCK;  // vectors, sad, luma src, luma ref, var

	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax*2+1]
	add	ecx, eax

; 573  : 
; 574  :   if (nLogScale == 0)

	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN37@SearchMVs

; 575  :   {
; 576  :     if (divideMode)

	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN37@SearchMVs

; 577  :     {
; 578  :       size += 1 + nBlkCount * N_PER_BLOCK * 4; // reserve space for divided subblocks extra level

	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	inc	ecx
$LN37@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 177  :     vecPrev += planes[nLevelCount - 1]->GetArraySize(divideExtra);

	lea	ebx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR _vecPrev$2$[ebp], ebx
$LN7@SearchMVs:

; 181  :   PlaneOfBlocks::Slicer	slicer_glob(_mt_flag);

	mov	bl, BYTE PTR [edi+48]
; File c:\github\mvtools\sources\mtslicer.hpp

; 70   : {

	mov	DWORD PTR _slicer_glob$[ebp], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR _slicer_glob$[ebp+4], eax

; 66   : ,	_proc_ptr (0)
; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR _slicer_glob$[ebp+16]
	push	1024					; 00000400H
	push	0
	mov	DWORD PTR _slicer_glob$[ebp+8], 0
	push	eax
	mov	DWORD PTR _slicer_glob$[ebp+12], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 69   : ,	_mt_flag (mt_flag)

	mov	BYTE PTR _slicer_glob$[ebp+1040], bl
; File c:\github\mvtools\sources\groupofplanes.cpp

; 181  :   PlaneOfBlocks::Slicer	slicer_glob(_mt_flag);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 182  :   for (int i = nLevelCount - 2; i >= 0; i--)

	mov	esi, DWORD PTR [edi+8]
	sub	esi, 2
	js	$LN3@SearchMVs
$LL4@SearchMVs:

; 183  :   {
; 184  :     SearchType		searchTypeLevel =
; 185  :       (i == 0 || searchType == HSEARCH || searchType == VSEARCH)

	mov	eax, DWORD PTR _searchType$[ebp]
	test	esi, esi
	je	SHORT $LN18@SearchMVs
	cmp	eax, 64					; 00000040H
	je	SHORT $LN18@SearchMVs
	mov	DWORD PTR _searchTypeLevel$1$[ebp], 8
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN19@SearchMVs
$LN18@SearchMVs:
	mov	DWORD PTR _searchTypeLevel$1$[ebp], eax
$LN19@SearchMVs:

; 186  :       ? searchType
; 187  :       : EXHAUSTIVE; // full search for coarse planes
; 188  :     int				nSearchParamLevel =
; 189  :       (i == 0) ? nPelSearch : nSearchParam; // special case for finest level

	mov	eax, DWORD PTR _nSearchParam$[ebp]
	test	esi, esi
	cmove	eax, DWORD PTR _nPelSearch$[ebp]

; 190  : 
; 191  :     PROFILE_START(MOTION_PROFILE_PREDICTION);
; 192  :     if (global)

	cmp	BYTE PTR _global$[ebp], 0
	mov	DWORD PTR _nSearchParamLevel$1$[ebp], eax
	je	SHORT $LN8@SearchMVs

; 193  :     {
; 194  :       // get updated global MV (doubled)
; 195  :       planes[i + 1]->EstimateGlobalMVDoubled(&globalMV, slicer_glob);

	mov	eax, DWORD PTR [edi+56]
	mov	edx, DWORD PTR [eax+esi*4+4]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	mov	eax, 2
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1368 :   _gvect_result_count = 2;

	lea	ecx, DWORD PTR [edx+764]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 49   : 	return (

	xchg	DWORD PTR [ecx], eax
; File c:\github\mvtools\sources\planeofblocks.cpp

; 1371 :   slicer.start(2, *this, &PlaneOfBlocks::estimate_global_mv_doubled_slice);

	push	1
	push	OFFSET ?estimate_global_mv_doubled_slice@PlaneOfBlocks@@AAEXAAVTaskData@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@@Z ; PlaneOfBlocks::estimate_global_mv_doubled_slice
	push	edx
	lea	eax, DWORD PTR _globalMV$[ebp]
	push	2
	lea	ecx, DWORD PTR _slicer_glob$[ebp]
	mov	DWORD PTR [edx+760], eax
	call	?start@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXHAAVPlaneOfBlocks@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::start
$LN8@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 198  :     if(pixelsize==1)

	cmp	DWORD PTR [edi+36], 1
	lea	ebx, DWORD PTR [esi*4]
	mov	eax, DWORD PTR [edi+56]

; 199  :       planes[i]->InterpolatePrediction<uint8_t>(*(planes[i + 1]));

	push	DWORD PTR [ebx+eax+4]
	mov	ecx, DWORD PTR [ebx+eax]
	jne	SHORT $LN9@SearchMVs
	call	??$InterpolatePrediction@E@PlaneOfBlocks@@QAEXABV0@@Z ; PlaneOfBlocks::InterpolatePrediction<unsigned char>

; 200  :     else

	jmp	SHORT $LN10@SearchMVs
$LN9@SearchMVs:

; 201  :       planes[i]->InterpolatePrediction<uint16_t>(*(planes[i + 1]));

	call	??$InterpolatePrediction@G@PlaneOfBlocks@@QAEXABV0@@Z ; PlaneOfBlocks::InterpolatePrediction<unsigned short>
$LN10@SearchMVs:

; 202  :     if (global)

	cmp	BYTE PTR _global$[ebp], 0
	je	SHORT $LN11@SearchMVs
; File c:\github\mvtools\sources\mtslicer.hpp

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer_glob$[ebp+1040], 0
	je	SHORT $LN50@SearchMVs

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer_glob$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer_glob$[ebp+4]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer_glob$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer_glob$[ebp+4]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN50@SearchMVs:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR _slicer_glob$[ebp+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer_glob$[ebp+12], 0
$LN11@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 208  :     fieldShiftCur = (i == 0) ? fieldShift : 0; // may be non zero for finest level only

	xor	edx, edx
	test	esi, esi
	cmove	edx, DWORD PTR _fieldShift$[ebp]

; 209  : //		DebugPrintf("SearchMV level %i", i);
; 210  :     tryManyLevel = (tryMany && i > 0); // not for finest level to not decrease speed

	cmp	BYTE PTR _tryMany$[ebp], 0
	je	SHORT $LN20@SearchMVs
	mov	BYTE PTR _tryManyLevel$[ebp], 1
	test	esi, esi
	jg	SHORT $LN90@SearchMVs
$LN20@SearchMVs:
	mov	BYTE PTR _tryManyLevel$[ebp], 0
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	test	esi, esi
$LN90@SearchMVs:
	js	SHORT $LN58@SearchMVs
	mov	eax, DWORD PTR _pRefGOF$[ebp]
	cmp	esi, DWORD PTR [eax]
	jge	SHORT $LN58@SearchMVs

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ebx+eax]
	jmp	SHORT $LN56@SearchMVs
$LN58@SearchMVs:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	xor	ecx, ecx
$LN56@SearchMVs:
	test	esi, esi
	js	SHORT $LN62@SearchMVs
	mov	eax, DWORD PTR _pSrcGOF$[ebp]
	cmp	esi, DWORD PTR [eax]
	jge	SHORT $LN62@SearchMVs

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+eax]
	jmp	SHORT $LN60@SearchMVs
$LN62@SearchMVs:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	xor	eax, eax
$LN60@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 211  :     planes[i]->SearchMVs(

	push	DWORD PTR _tryManyLevel$[ebp]
	lea	edi, DWORD PTR _meanLumaChange$[ebp]
	push	DWORD PTR _vecPrev$2$[ebp]
	push	DWORD PTR _meander$[ebp]
	push	DWORD PTR _badrange$[ebp]
	push	DWORD PTR _badSAD$[ebp]
	push	DWORD PTR tv716[ebp]
	push	DWORD PTR _pzero$[ebp]
	push	ecx
	push	edi
	push	edx
	push	DWORD PTR _outfilebuf$[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
	lea	edx, DWORD PTR _globalMV$[ebp]
	push	edx
	push	DWORD PTR _out$2$[ebp]
	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _plevel$[ebp]
	push	DWORD PTR _pnew$[ebp]
	push	DWORD PTR _lsad$[ebp]
	push	DWORD PTR _nLambda$[ebp]
	push	DWORD PTR _nSearchParamLevel$1$[ebp]
	push	DWORD PTR _searchTypeLevel$1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edi+56]
	push	eax
	mov	ecx, DWORD PTR [ebx+ecx]
	call	?SearchMVs@PlaneOfBlocks@@QAEXPAVMVFrame@@0W4SearchType@@HHHHHHPAHPBUVECTOR@@PAFH2HHHHH_N25@Z ; PlaneOfBlocks::SearchMVs

; 236  :     out += planes[i]->GetArraySize(divideExtra);

	mov	eax, DWORD PTR [edi+56]
	mov	edx, DWORD PTR [ebx+eax]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 572  :   size += nBlkCount * N_PER_BLOCK;  // vectors, sad, luma src, luma ref, var

	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax*2+1]
	add	ecx, eax

; 573  : 
; 574  :   if (nLogScale == 0)

	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN66@SearchMVs

; 575  :   {
; 576  :     if (divideMode)

	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN66@SearchMVs

; 577  :     {
; 578  :       size += 1 + nBlkCount * N_PER_BLOCK * 4; // reserve space for divided subblocks extra level

	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	inc	ecx
$LN66@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 236  :     out += planes[i]->GetArraySize(divideExtra);

	mov	eax, DWORD PTR _out$2$[ebp]

; 237  :     if (vecPrev)

	mov	ebx, DWORD PTR _vecPrev$2$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _out$2$[ebp], eax
	test	ebx, ebx
	je	SHORT $LN2@SearchMVs
; File c:\github\mvtools\sources\planeofblocks.cpp

; 572  :   size += nBlkCount * N_PER_BLOCK;  // vectors, sad, luma src, luma ref, var

	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax*2+1]
	add	ecx, eax

; 573  : 
; 574  :   if (nLogScale == 0)

	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN70@SearchMVs

; 575  :   {
; 576  :     if (divideMode)

	cmp	DWORD PTR [edi+44], 0
	je	SHORT $LN70@SearchMVs

; 577  :     {
; 578  :       size += 1 + nBlkCount * N_PER_BLOCK * 4; // reserve space for divided subblocks extra level

	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [ecx+eax*4]
	inc	ecx
$LN70@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 239  :       vecPrev += planes[i]->GetArraySize(divideExtra);

	lea	ebx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR _vecPrev$2$[ebp], ebx
$LN2@SearchMVs:

; 182  :   for (int i = nLevelCount - 2; i >= 0; i--)

	sub	esi, 1
	jns	$LL4@SearchMVs
$LN3@SearchMVs:
	pop	edi
; File c:\github\mvtools\sources\mtslicer.hpp

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR _slicer_glob$[ebp+12], 0
	pop	esi

; 86   : {

	mov	DWORD PTR _slicer_glob$[ebp], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@
	pop	ebx

; 87   : 	if (_dispatcher_ptr != 0)

	je	SHORT $LN73@SearchMVs

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR _slicer_glob$[ebp+1040], 0
	je	SHORT $LN77@SearchMVs

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer_glob$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	push	eax
	mov	eax, DWORD PTR _slicer_glob$[ebp+4]
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR _slicer_glob$[ebp+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	push	eax
	mov	eax, DWORD PTR _slicer_glob$[ebp+4]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 8
$LN77@SearchMVs:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR _slicer_glob$[ebp+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR _slicer_glob$[ebp+12], 0
$LN73@SearchMVs:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 242  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	84					; 00000054H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z$0:
	lea	ecx, DWORD PTR _slicer_glob$[ebp]
	jmp	??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ ; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::~MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>
__unwindfunclet$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z:
	mov	eax, OFFSET __ehfuncinfo$?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SearchMVs@GroupOfPlanes@@QAEXPAVMVGroupOfFrames@@0W4SearchType@@HHHHHH_NHPAHPAFHHHHH232@Z ENDP ; GroupOfPlanes::SearchMVs
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ?RecalculateMVs@GroupOfPlanes@@QAEXAAVMVClip@@PAVMVGroupOfFrames@@1W4SearchType@@HHHHHPAHPAFHHH_N@Z
_TEXT	SEGMENT
_mvClip$ = 8						; size = 4
_pSrcGOF$ = 12						; size = 4
_pRefGOF$ = 16						; size = 4
_searchType$ = 20					; size = 4
_nSearchParam$ = 24					; size = 4
_nLambda$ = 28						; size = 4
_lsad$ = 32						; size = 4
_pnew$ = 36						; size = 4
_flags$ = 40						; size = 4
_out$ = 44						; size = 4
_outfilebuf$ = 48					; size = 4
_fieldShift$ = 52					; size = 4
_thSAD$ = 56						; size = 4
_smooth$ = 60						; size = 4
_meander$ = 64						; size = 1
?RecalculateMVs@GroupOfPlanes@@QAEXAAVMVClip@@PAVMVGroupOfFrames@@1W4SearchType@@HHHHHPAHPAFHHH_N@Z PROC ; GroupOfPlanes::RecalculateMVs, COMDAT
; _this$ = ecx

; 262  : {

	push	esi
	mov	esi, ecx
	push	edi

; 263  :   nFlags |= flags;

	mov	edi, DWORD PTR _flags$[esp+4]
	or	DWORD PTR [esi+16], edi

; 264  : 
; 265  :   // write group's size
; 266  :   out[0] = GetArraySize();

	call	?GetArraySize@GroupOfPlanes@@QAEHXZ	; GroupOfPlanes::GetArraySize
	mov	edx, DWORD PTR _out$[esp+4]
	mov	DWORD PTR [edx], eax
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	mov	eax, DWORD PTR _pRefGOF$[esp+4]
; File c:\github\mvtools\sources\groupofplanes.cpp

; 269  :   out[1] = 1;

	mov	DWORD PTR [edx+4], 1

; 270  : 
; 271  :   out += 2;

	add	edx, 8
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN4@Recalculat
	xor	ecx, ecx
	jmp	SHORT $LN3@Recalculat
$LN4@Recalculat:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
$LN3@Recalculat:

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	mov	eax, DWORD PTR _pSrcGOF$[esp+4]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN8@Recalculat
	xor	eax, eax
	jmp	SHORT $LN7@Recalculat
$LN8@Recalculat:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
$LN7@Recalculat:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 278  :   planes[0]->RecalculateMVs(

	push	DWORD PTR _meander$[esp+4]
	push	DWORD PTR _smooth$[esp+8]
	push	ecx
	push	DWORD PTR _thSAD$[esp+16]
	push	DWORD PTR _fieldShift$[esp+20]
	push	DWORD PTR _outfilebuf$[esp+24]
	push	edx
	push	edi
	push	DWORD PTR _pnew$[esp+36]
	push	DWORD PTR _lsad$[esp+40]
	push	DWORD PTR _nLambda$[esp+44]
	push	DWORD PTR _nSearchParam$[esp+48]
	push	DWORD PTR _searchType$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR [esi+56]
	push	eax
	push	DWORD PTR _mvClip$[esp+64]
	mov	ecx, DWORD PTR [ecx]
	call	?RecalculateMVs@PlaneOfBlocks@@QAEXAAVMVClip@@PAVMVFrame@@1W4SearchType@@HHHHHPAHPAFHHHH_N@Z ; PlaneOfBlocks::RecalculateMVs
	pop	edi
	pop	esi

; 279  :     mvClip,
; 280  :     pSrcGOF->GetFrame(0),
; 281  :     pRefGOF->GetFrame(0),
; 282  :     searchType,
; 283  :     nSearchParam,
; 284  :     nLambda,
; 285  :     lsad,
; 286  :     pnew,
; 287  :     flags,
; 288  :     out,
; 289  :     outfilebuf,
; 290  :     fieldShift,
; 291  :     thSAD,
; 292  :     divideExtra,
; 293  :     smooth,
; 294  :     meander
; 295  :   );
; 296  : 
; 297  :   out += planes[0]->GetArraySize(divideExtra);
; 298  : }

	ret	60					; 0000003cH
?RecalculateMVs@GroupOfPlanes@@QAEXAAVMVClip@@PAVMVGroupOfFrames@@1W4SearchType@@HHHHHPAHPAFHHH_N@Z ENDP ; GroupOfPlanes::RecalculateMVs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ?WriteDefaultToArray@GroupOfPlanes@@QAEXPAH@Z
_TEXT	SEGMENT
_array$ = 8						; size = 4
?WriteDefaultToArray@GroupOfPlanes@@QAEXPAH@Z PROC	; GroupOfPlanes::WriteDefaultToArray, COMDAT
; _this$ = ecx

; 303  : {

	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 304  :   // write group's size
; 305  :   array[0] = GetArraySize();

	call	?GetArraySize@GroupOfPlanes@@QAEHXZ	; GroupOfPlanes::GetArraySize
	mov	esi, DWORD PTR _array$[esp+8]
	mov	DWORD PTR [esi], eax

; 306  : 
; 307  :   // write validity : unvalid in that case
; 308  :   array[1] = 0;

	mov	DWORD PTR [esi+4], 0

; 309  : 
; 310  :   array += 2;

	add	esi, 8

; 311  : 
; 312  :   // write planes
; 313  :   for (int i = nLevelCount - 1; i >= 0; i--)

	mov	edi, DWORD PTR [ebx+8]
	sub	edi, 1
	js	SHORT $LN3@WriteDefau
$LL4@WriteDefau:

; 314  :   {
; 315  :     array += planes[i]->WriteDefaultToArray(array, divideExtra);

	mov	ecx, DWORD PTR [ebx+56]
	push	DWORD PTR [ebx+44]
	push	esi
	mov	ecx, DWORD PTR [ecx+edi*4]
	call	?WriteDefaultToArray@PlaneOfBlocks@@QAEHPAHH@Z ; PlaneOfBlocks::WriteDefaultToArray
	sub	edi, 1
	lea	esi, DWORD PTR [esi+eax*4]
	jns	SHORT $LL4@WriteDefau
$LN3@WriteDefau:
	pop	edi
	pop	esi
	pop	ebx

; 316  :   }
; 317  : }

	ret	4
?WriteDefaultToArray@GroupOfPlanes@@QAEXPAH@Z ENDP	; GroupOfPlanes::WriteDefaultToArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\planeofblocks.cpp
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ?GetArraySize@GroupOfPlanes@@QAEHXZ
_TEXT	SEGMENT
?GetArraySize@GroupOfPlanes@@QAEHXZ PROC		; GroupOfPlanes::GetArraySize, COMDAT
; _this$ = ecx

; 323  : {

	push	ebp
	mov	ebp, ecx
	push	edi

; 324  :   int				size = 2; // size, validity

	mov	edi, 2

; 325  :   for (int i = nLevelCount - 1; i >= 0; i--)

	mov	edx, DWORD PTR [ebp+8]
	sub	edx, 1
	js	SHORT $LN14@GetArraySi

; 327  :     size += planes[i]->GetArraySize(divideExtra);

	mov	eax, DWORD PTR [ebp+56]
	push	ebx
	push	esi
	lea	ebx, DWORD PTR [eax+edx*4]
	npad	7
$LL4@GetArraySi:
	mov	eax, DWORD PTR [ebx]
; File c:\github\mvtools\sources\planeofblocks.cpp

; 572  :   size += nBlkCount * N_PER_BLOCK;  // vectors, sad, luma src, luma ref, var

	mov	ecx, DWORD PTR [eax+16]
	lea	esi, DWORD PTR [ecx*2+1]
	add	esi, ecx

; 573  : 
; 574  :   if (nLogScale == 0)

	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN8@GetArraySi

; 575  :   {
; 576  :     if (divideMode)

	cmp	DWORD PTR [ebp+44], 0
	je	SHORT $LN8@GetArraySi

; 577  :     {
; 578  :       size += 1 + nBlkCount * N_PER_BLOCK * 4; // reserve space for divided subblocks extra level

	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	esi, DWORD PTR [esi+eax*4]
	inc	esi
$LN8@GetArraySi:
; File c:\github\mvtools\sources\groupofplanes.cpp

; 327  :     size += planes[i]->GetArraySize(divideExtra);

	add	edi, esi
	sub	ebx, 4
	sub	edx, 1
	jns	SHORT $LL4@GetArraySi
	pop	esi
	pop	ebx
$LN14@GetArraySi:

; 328  :   }
; 329  : 
; 330  :   return size;

	mov	eax, edi
	pop	edi
	pop	ebp

; 331  : }

	ret	0
?GetArraySize@GroupOfPlanes@@QAEHXZ ENDP		; GroupOfPlanes::GetArraySize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ?Median3@@YAHHHH@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?Median3@@YAHHHH@Z PROC					; Median3, COMDAT
; _a$ = ecx
; _b$ = edx

; 339  :   // b a c || c a b
; 340  :   if (((b <= a) && (a <= c)) || ((c <= a) && (a <= b)))

	mov	eax, DWORD PTR _c$[esp-4]
	cmp	edx, ecx
	jg	SHORT $LN5@Median3
	cmp	ecx, eax
	jle	SHORT $LN4@Median3
$LN5@Median3:
	cmp	eax, ecx
	jg	SHORT $LN2@Median3
	cmp	ecx, edx
	jg	SHORT $LN8@Median3
$LN4@Median3:

; 341  :   {
; 342  :     return a;

	mov	eax, ecx

; 349  :   }
; 350  : 
; 351  :   // b c a || a c b
; 352  :   return c;
; 353  : }

	ret	0
$LN2@Median3:

; 343  :   }
; 344  : 
; 345  :   // a b c || c b a
; 346  :   else if (((a <= b) && (b <= c)) || ((c <= b) && (b <= a)))

	cmp	ecx, edx
	jg	SHORT $LN8@Median3
	cmp	edx, eax
	jle	SHORT $LN7@Median3
$LN8@Median3:
	cmp	eax, edx
	jg	SHORT $LN1@Median3
	cmp	edx, ecx
	jg	SHORT $LN1@Median3
$LN7@Median3:

; 347  :   {
; 348  :     return b;

	mov	eax, edx
$LN1@Median3:

; 349  :   }
; 350  : 
; 351  :   // b c a || a c b
; 352  :   return c;
; 353  : }

	ret	0
?Median3@@YAHHHH@Z ENDP					; Median3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ?GetMedian@@YAXPAH0HHHHHH@Z
_TEXT	SEGMENT
_vy$1$ = -8						; size = 4
_vx$1$ = -4						; size = 4
_vx1$ = 8						; size = 4
_vy1$ = 12						; size = 4
_vx2$ = 16						; size = 4
_vy2$ = 20						; size = 4
_vx3$ = 24						; size = 4
_vy3$ = 28						; size = 4
?GetMedian@@YAXPAH0HHHHHH@Z PROC			; GetMedian, COMDAT
; _vx$ = ecx
; _vy$ = edx

; 359  : {

	sub	esp, 8

; 340  :   if (((b <= a) && (a <= c)) || ((c <= a) && (a <= b)))

	mov	eax, DWORD PTR _vx1$[esp+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _vx2$[esp+16]

; 359  : {

	mov	DWORD PTR _vy$1$[esp+20], edx
	mov	DWORD PTR _vx$1$[esp+20], ecx
	push	edi

; 340  :   if (((b <= a) && (a <= c)) || ((c <= a) && (a <= b)))

	mov	edi, DWORD PTR _vx3$[esp+20]
	cmp	esi, eax
	jg	SHORT $LN11@GetMedian
	cmp	eax, edi
	jle	SHORT $LN10@GetMedian
$LN11@GetMedian:
	cmp	edi, eax
	jg	SHORT $LN8@GetMedian
	cmp	eax, esi
	jg	SHORT $LN14@GetMedian
$LN10@GetMedian:

; 341  :   {
; 342  :     return a;

	mov	ebp, eax
	jmp	SHORT $LN7@GetMedian
$LN8@GetMedian:

; 343  :   }
; 344  : 
; 345  :   // a b c || c b a
; 346  :   else if (((a <= b) && (b <= c)) || ((c <= b) && (b <= a)))

	cmp	eax, esi
	jg	SHORT $LN14@GetMedian
	cmp	esi, edi
	jle	SHORT $LN13@GetMedian
$LN14@GetMedian:
	cmp	edi, esi
	jg	SHORT $LN12@GetMedian
	cmp	esi, eax
	jg	SHORT $LN12@GetMedian
$LN13@GetMedian:

; 347  :   {
; 348  :     return b;

	mov	ebp, esi
	jmp	SHORT $LN7@GetMedian
$LN12@GetMedian:

; 349  :   }
; 350  : 
; 351  :   // b c a || a c b
; 352  :   return c;

	mov	ebp, edi
$LN7@GetMedian:

; 340  :   if (((b <= a) && (a <= c)) || ((c <= a) && (a <= b)))

	mov	edx, DWORD PTR _vy2$[esp+20]
	mov	ebx, DWORD PTR _vy3$[esp+20]

; 360  :   *vx = Median3(vx1, vx2, vx3);

	mov	DWORD PTR [ecx], ebp

; 340  :   if (((b <= a) && (a <= c)) || ((c <= a) && (a <= b)))

	mov	ecx, DWORD PTR _vy1$[esp+20]
	cmp	edx, ecx
	jg	SHORT $LN20@GetMedian
	cmp	ecx, ebx
	jle	SHORT $LN19@GetMedian
$LN20@GetMedian:
	cmp	ebx, ecx
	jg	SHORT $LN17@GetMedian
	cmp	ecx, edx
	jg	SHORT $LN23@GetMedian
$LN19@GetMedian:

; 341  :   {
; 342  :     return a;

	mov	ebx, ecx
	jmp	SHORT $LN21@GetMedian
$LN17@GetMedian:

; 343  :   }
; 344  : 
; 345  :   // a b c || c b a
; 346  :   else if (((a <= b) && (b <= c)) || ((c <= b) && (b <= a)))

	cmp	ecx, edx
	jg	SHORT $LN23@GetMedian
	cmp	edx, ebx
	jle	SHORT $LN22@GetMedian
$LN23@GetMedian:
	cmp	ebx, edx
	jg	SHORT $LN21@GetMedian
	cmp	edx, ecx
	jg	SHORT $LN21@GetMedian
$LN22@GetMedian:

; 347  :   {
; 348  :     return b;

	mov	ebx, edx
$LN21@GetMedian:

; 361  :   *vy = Median3(vy1, vy2, vy3);

	mov	edi, DWORD PTR _vy$1$[esp+24]
	mov	DWORD PTR [edi], ebx

; 362  : 
; 363  :   if (!((*vx == vx1 && *vy == vy1)

	mov	edi, DWORD PTR _vx3$[esp+20]
	cmp	ebp, eax
	jne	SHORT $LN3@GetMedian
	cmp	ebx, ecx
	je	SHORT $LN2@GetMedian
$LN3@GetMedian:
	cmp	ebp, esi
	jne	SHORT $LN4@GetMedian
	cmp	ebx, edx
	je	SHORT $LN2@GetMedian
$LN4@GetMedian:
	cmp	ebp, edi
	jne	SHORT $LN5@GetMedian
	cmp	ebx, DWORD PTR _vy3$[esp+20]
	je	SHORT $LN2@GetMedian
$LN5@GetMedian:

; 364  :     || (*vx == vx2 && *vy == vy2)
; 365  :     || (*vx == vx3 && *vy == vy3)))
; 366  :   {
; 367  :     *vx = vx1;

	mov	edx, DWORD PTR _vx$1$[esp+24]
	mov	DWORD PTR [edx], eax

; 368  :     *vy = vy1;

	mov	eax, DWORD PTR _vy$1$[esp+24]
	mov	DWORD PTR [eax], ecx
$LN2@GetMedian:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 369  :   }
; 370  : }

	add	esp, 8
	ret	0
?GetMedian@@YAXPAH0HHHHHH@Z ENDP			; GetMedian
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\planeofblocks.h
; File c:\github\mvtools\sources\groupofplanes.cpp
; File c:\github\mvtools\sources\planeofblocks.h
; File c:\github\mvtools\sources\groupofplanes.cpp
;	COMDAT ?ExtraDivide@GroupOfPlanes@@QAEXPAHH@Z
_TEXT	SEGMENT
_vy$1 = -56						; size = 4
tv6305 = -52						; size = 4
_inp$1$ = -48						; size = 4
_nBlkXN$1$ = -44					; size = 4
tv6298 = -40						; size = 4
tv6300 = -36						; size = 4
_nBlkY$1$ = -32						; size = 4
tv6290 = -32						; size = 4
_out$2$ = -28						; size = 4
tv6318 = -24						; size = 4
tv6289 = -24						; size = 4
tv6303 = -20						; size = 4
_this$1$ = -16						; size = 4
_bx$1$ = -12						; size = 4
tv6336 = -8						; size = 4
tv6335 = -4						; size = 4
tv6356 = 8						; size = 4
tv6286 = 8						; size = 4
_vx$2 = 8						; size = 4
_out$ = 8						; size = 4
_flags$dead$ = 12					; size = 4
?ExtraDivide@GroupOfPlanes@@QAEXPAHH@Z PROC		; GroupOfPlanes::ExtraDivide, COMDAT
; _this$ = ecx

; 373  : {

	sub	esp, 56					; 00000038H

; 374  :   // skip full size and validity
; 375  :   out += 2;

	mov	edx, DWORD PTR _out$[esp+52]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	add	edx, 8
	mov	DWORD PTR _this$1$[esp+72], edi

; 376  : 
; 377  :   // skip all levels up to finest estimated
; 378  :   for (int i = nLevelCount - 1; i >= 1; i--)

	mov	esi, DWORD PTR [edi+8]
	dec	esi
	cmp	esi, 1
	jl	SHORT $LN3@ExtraDivid

; 379  :   {
; 380  :     out += planes[i]->GetArraySize(0);

	mov	eax, DWORD PTR [edi+56]
	lea	ecx, DWORD PTR [eax+esi*4]
$LL4@ExtraDivid:

; 376  : 
; 377  :   // skip all levels up to finest estimated
; 378  :   for (int i = nLevelCount - 1; i >= 1; i--)

	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx-4]
	mov	eax, DWORD PTR [eax+16]
	lea	eax, DWORD PTR [eax+eax*2]

; 379  :   {
; 380  :     out += planes[i]->GetArraySize(0);

	lea	edx, DWORD PTR [edx+eax*4]
	add	edx, 4
	sub	esi, 1
	jne	SHORT $LL4@ExtraDivid
$LN3@ExtraDivid:

; 384  :   out += out[0] + 1;	// position for divided sublocks data

	mov	eax, DWORD PTR [edx]
	lea	ebx, DWORD PTR [edx+4]
	inc	eax
	mov	DWORD PTR _inp$1$[esp+72], ebx
	lea	ebp, DWORD PTR [edx+eax*4]

; 385  : 
; 386  :   int            nBlkY = planes[0]->GetnBlkY();

	mov	eax, DWORD PTR [edi+56]
; File c:\github\mvtools\sources\planeofblocks.h

; 82   :   inline int GetnBlkY() { return nBlkY; }

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\groupofplanes.cpp

; 387  :   int            nBlkXN = planes[0]->GetnBlkX() * N_PER_BLOCK;	// 6 stored variables

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\planeofblocks.h

; 82   :   inline int GetnBlkY() { return nBlkY; }

	mov	DWORD PTR _nBlkY$1$[esp+72], ecx
; File c:\github\mvtools\sources\groupofplanes.cpp

; 387  :   int            nBlkXN = planes[0]->GetnBlkX() * N_PER_BLOCK;	// 6 stored variables

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _nBlkXN$1$[esp+72], ecx

; 388  : 
; 389  :   // top blocks
; 390  :   int            by = 0;
; 391  :   for (int bx = 0; bx < nBlkXN; bx += N_PER_BLOCK)

	test	ecx, ecx
	jle	$LN6@ExtraDivid

; 381  :   }
; 382  : 
; 383  :   int *          inp = out + 1;	// finest estimated plane

	lea	eax, DWORD PTR [ecx*8+4]
	add	eax, ebp
	lea	esi, DWORD PTR [ebx+8]
	mov	DWORD PTR tv6318[esp+72], eax
	lea	ebx, DWORD PTR [ecx*8+8]
	dec	ecx
	lea	edi, DWORD PTR [ebp+4]
	mov	eax, -1431655765			; aaaaaaabH
	add	ebx, ebp
	mul	ecx
	mov	ecx, DWORD PTR tv6318[esp+72]
	mov	eax, edx
	lea	edx, DWORD PTR [ebp+8]
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv6356[esp+68], eax
$LL7@ExtraDivid:

; 392  :   {
; 393  :     for (int i = 0; i < 2; i++) // vx, vy
; 394  :     {
; 395  :       out[bx * 2 + i] = inp[bx + i];	// top left subblock

	mov	eax, DWORD PTR [esi-8]
	lea	edi, DWORD PTR [edi+24]
	mov	DWORD PTR [edi-28], eax
	lea	ecx, DWORD PTR [ecx+24]

; 396  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i];	// top right subblock

	mov	eax, DWORD PTR [esi-8]
	lea	ebx, DWORD PTR [ebx+24]
	mov	DWORD PTR [edi-16], eax
	lea	edx, DWORD PTR [edx+24]

; 397  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i];	// bottom left subblock

	mov	eax, DWORD PTR [esi-8]
	lea	esi, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx-28], eax

; 398  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i];	// bottom right subblock

	mov	eax, DWORD PTR [esi-20]
	mov	DWORD PTR [ecx-16], eax
	mov	eax, DWORD PTR [esi-16]
	mov	DWORD PTR [edi-24], eax
	mov	eax, DWORD PTR [esi-16]
	mov	DWORD PTR [edi-12], eax
	mov	eax, DWORD PTR [esi-16]
	mov	DWORD PTR [ecx-24], eax
	mov	eax, DWORD PTR [esi-16]
	mov	DWORD PTR [ecx-12], eax

; 399  :     }
; 400  :     for (int i = 2; i < N_PER_BLOCK; i++) // sad, var, luma, ref
; 401  :     {
; 402  :       out[bx * 2 + i] = inp[bx + i] >> 2;	// top left subblock

	mov	eax, DWORD PTR [esi-12]
	sar	eax, 2
	mov	DWORD PTR [edx-24], eax

; 403  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i] >> 2;	// top right subblock

	mov	eax, DWORD PTR [esi-12]
	sar	eax, 2
	mov	DWORD PTR [edx-12], eax

; 404  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i] >> 2;	// bottom left subblock

	mov	eax, DWORD PTR [esi-12]
	sar	eax, 2
	mov	DWORD PTR [ebx-24], eax

; 405  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i] >> 2;	// bottom right subblock

	mov	eax, DWORD PTR [esi-12]
	sar	eax, 2
	sub	DWORD PTR tv6356[esp+68], 1
	mov	DWORD PTR [ebx-12], eax
	jne	SHORT $LL7@ExtraDivid
	mov	ebx, DWORD PTR _inp$1$[esp+72]
	mov	ecx, DWORD PTR _nBlkXN$1$[esp+72]
$LN6@ExtraDivid:

; 406  :     }
; 407  :   }
; 408  :   out += nBlkXN * 4;

	mov	eax, ecx
	shl	eax, 4
	add	ebp, eax
	mov	DWORD PTR tv6336[esp+72], eax

; 409  :   inp += nBlkXN;

	lea	eax, DWORD PTR [ecx*4]
	mov	DWORD PTR _out$2$[esp+72], ebp
	add	ebx, eax
	mov	DWORD PTR tv6335[esp+72], eax

; 410  : 
; 411  :   // middle blocks
; 412  :   for (by = 1; by < nBlkY - 1; by++)

	mov	eax, DWORD PTR _nBlkY$1$[esp+72]
	dec	eax
	mov	DWORD PTR _inp$1$[esp+72], ebx
	cmp	eax, 1
	jle	$LN15@ExtraDivid

; 406  :     }
; 407  :   }
; 408  :   out += nBlkXN * 4;

	lea	esi, DWORD PTR [ecx-3]
	dec	eax
	mov	DWORD PTR _bx$1$[esp+72], esi
	mov	DWORD PTR tv6289[esp+72], eax
$LL16@ExtraDivid:

; 413  :   {
; 414  :     int            bx = 0;
; 415  :     for (int i = 0; i < 2; i++)
; 416  :     {
; 417  :       out[bx * 2 + i] = inp[bx + i]; // top left subblock

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebp], eax

; 418  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i]; // top right subblock

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebp+12], eax

; 419  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i]; // bottom left subblock

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebp+ecx*8], eax

; 420  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i]; // bottom right subblock

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebp+ecx*8+12], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+4], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+16], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+ecx*8+4], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebp+ecx*8+16], eax

; 421  :     }
; 422  : 
; 423  :     for (int i = 2; i < N_PER_BLOCK; i++)
; 424  :     {
; 425  :       out[bx * 2 + i] = inp[bx + i] >> 2; // top left subblock

	mov	eax, DWORD PTR [ebx+8]
	sar	eax, 2
	mov	DWORD PTR [ebp+8], eax

; 426  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i] >> 2; // top right subblock

	mov	eax, DWORD PTR [ebx+8]
	sar	eax, 2
	mov	DWORD PTR [ebp+20], eax

; 427  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom left subblock

	mov	eax, DWORD PTR [ebx+8]
	sar	eax, 2
	mov	DWORD PTR [ebp+ecx*8+8], eax

; 428  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom right subblock

	mov	eax, DWORD PTR [ebx+8]
	sar	eax, 2
	mov	DWORD PTR [ebp+ecx*8+20], eax

; 429  :     }
; 430  : 
; 431  :     for (bx = N_PER_BLOCK; bx < nBlkXN - N_PER_BLOCK; bx += N_PER_BLOCK)

	cmp	esi, 3
	jle	$LN24@ExtraDivid
	lea	eax, DWORD PTR [ecx+3]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv6305[esp+72], eax
	lea	esi, DWORD PTR [ebx+16]
	mov	eax, 3
	lea	edi, DWORD PTR [ebp+36]
	sub	eax, ecx
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv6303[esp+72], eax
	lea	ebx, DWORD PTR [ecx*8+36]
	lea	eax, DWORD PTR [ebp+32]
	add	ebx, ebp
	mov	DWORD PTR tv6300[esp+72], eax
	lea	eax, DWORD PTR [ebp+32]
	mov	ebp, DWORD PTR tv6303[esp+72]
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR tv6298[esp+72], eax
	add	ecx, -7					; fffffff9H
	mov	eax, -1431655765			; aaaaaaabH
	mul	ecx
	mov	ecx, DWORD PTR tv6300[esp+72]
	mov	eax, edx
	mov	edx, DWORD PTR tv6298[esp+72]
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv6290[esp+72], eax
	npad	7
$LL25@ExtraDivid:

; 432  :     {
; 433  :       if (divideExtra == 1)

	mov	eax, DWORD PTR _this$1$[esp+72]
	cmp	DWORD PTR [eax+44], 1
	jne	SHORT $LN44@ExtraDivid

; 434  :       {
; 435  :         out[bx * 2] = inp[bx]; // top left subblock

	mov	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [edi-12], eax

; 436  :         out[bx * 2 + N_PER_BLOCK] = inp[bx]; // top right subblock

	mov	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [edi], eax

; 437  :         out[bx * 2 + nBlkXN * 2] = inp[bx]; // bottom left subblock

	mov	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [ebx-12], eax

; 438  :         out[bx * 2 + N_PER_BLOCK + nBlkXN * 2] = inp[bx]; // bottom right subblock

	mov	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [ebx], eax

; 439  :         out[bx * 2 + 1] = inp[bx + 1]; // top left subblock

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi-8], eax

; 440  :         out[bx * 2 + N_PER_BLOCK + 1] = inp[bx + 1]; // top right subblock

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+4], eax

; 441  :         out[bx * 2 + nBlkXN * 2 + 1] = inp[bx + 1]; // bottom left subblock

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ebx-8], eax

; 442  :         out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + 1] = inp[bx + 1]; // bottom right subblock

	mov	eax, DWORD PTR [esi]

; 443  :       }
; 444  :       else	// divideExtra == 2

	jmp	$LN119@ExtraDivid
$LN44@ExtraDivid:

; 445  :       {
; 446  :         int vx;
; 447  :         int vy;
; 448  : 
; 449  :         GetMedian(	// top left subblock

	push	DWORD PTR [ebp+4]
	lea	edx, DWORD PTR _vy$1[esp+76]
	push	DWORD PTR [ebp]
	lea	ecx, DWORD PTR _vx$2[esp+76]
	push	DWORD PTR [esi-12]
	push	DWORD PTR [esi-16]
	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	call	?GetMedian@@YAXPAH0HHHHHH@Z		; GetMedian

; 450  :           &vx, &vy,
; 451  :           inp[bx], inp[bx + 1],
; 452  :           inp[bx - N_PER_BLOCK], inp[bx + 1 - N_PER_BLOCK],
; 453  :           inp[bx - nBlkXN], inp[bx + 1 - nBlkXN]
; 454  :         );
; 455  :         out[bx * 2] = vx;

	mov	eax, DWORD PTR _vx$2[esp+92]

; 456  :         out[bx * 2 + 1] = vy;
; 457  : 
; 458  :         GetMedian(	// top right subblock

	lea	edx, DWORD PTR _vy$1[esp+96]
	mov	DWORD PTR [edi-12], eax
	lea	ecx, DWORD PTR _vx$2[esp+92]
	mov	eax, DWORD PTR _vy$1[esp+96]
	mov	DWORD PTR [edi-8], eax
	push	DWORD PTR [ebp+4]
	push	DWORD PTR [ebp]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	call	?GetMedian@@YAXPAH0HHHHHH@Z		; GetMedian

; 459  :           &vx, &vy,
; 460  :           inp[bx], inp[bx + 1],
; 461  :           inp[bx + N_PER_BLOCK], inp[bx + 1 + N_PER_BLOCK],
; 462  :           inp[bx - nBlkXN], inp[bx + 1 - nBlkXN]
; 463  :         );
; 464  :         out[bx * 2 + N_PER_BLOCK] = vx;

	mov	eax, DWORD PTR _vx$2[esp+116]

; 465  :         out[bx * 2 + N_PER_BLOCK + 1] = vy;
; 466  : 
; 467  :         GetMedian(	// bottom left subblock

	lea	edx, DWORD PTR _vy$1[esp+120]
	mov	DWORD PTR [edi], eax
	lea	ecx, DWORD PTR _vx$2[esp+116]
	mov	eax, DWORD PTR _vy$1[esp+120]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR tv6305[esp+120]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	push	DWORD PTR [esi-12]
	push	DWORD PTR [esi-16]
	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	call	?GetMedian@@YAXPAH0HHHHHH@Z		; GetMedian

; 468  :           &vx, &vy,
; 469  :           inp[bx], inp[bx + 1],
; 470  :           inp[bx - N_PER_BLOCK], inp[bx + 1 - N_PER_BLOCK],
; 471  :           inp[bx + nBlkXN], inp[bx + 1 + nBlkXN]
; 472  :         );
; 473  :         out[bx * 2 + nBlkXN * 2] = vx;

	mov	eax, DWORD PTR _vx$2[esp+140]

; 474  :         out[bx * 2 + nBlkXN * 2 + 1] = vy;
; 475  : 
; 476  :         GetMedian(	// bottom right subblock

	lea	edx, DWORD PTR _vy$1[esp+144]
	mov	DWORD PTR [ebx-12], eax
	lea	ecx, DWORD PTR _vx$2[esp+140]
	mov	eax, DWORD PTR _vy$1[esp+144]
	add	esp, 72					; 00000048H
	mov	DWORD PTR [ebx-8], eax
	mov	eax, DWORD PTR tv6305[esp+72]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi]
	push	DWORD PTR [esi-4]
	call	?GetMedian@@YAXPAH0HHHHHH@Z		; GetMedian

; 477  :           &vx, &vy,
; 478  :           inp[bx], inp[bx + 1],
; 479  :           inp[bx + N_PER_BLOCK], inp[bx + 1 + N_PER_BLOCK],
; 480  :           inp[bx + nBlkXN], inp[bx + 1 + nBlkXN]
; 481  :         );
; 482  :         out[bx * 2 + N_PER_BLOCK + nBlkXN * 2] = vx;

	mov	eax, DWORD PTR _vx$2[esp+92]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR tv6300[esp+72]
	mov	edx, DWORD PTR tv6298[esp+72]
	mov	DWORD PTR [ebx], eax

; 483  :         out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + 1] = vy;

	mov	eax, DWORD PTR _vy$1[esp+72]
$LN119@ExtraDivid:
	mov	DWORD PTR [ebx+4], eax
	add	edi, 24					; 00000018H

; 484  :       }
; 485  : 
; 486  :       for (int i = 2; i < N_PER_BLOCK; i++)
; 487  :       {
; 488  :         out[bx * 2 + i] = inp[bx + i] >> 2; // top left subblock

	mov	eax, DWORD PTR [esi+4]
	add	ebx, 24					; 00000018H
	add	DWORD PTR tv6305[esp+72], 12		; 0000000cH
	add	ebp, 12					; 0000000cH
	sar	eax, 2
	mov	DWORD PTR [ecx], eax

; 489  :         out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i] >> 2; // top right subblock

	mov	eax, DWORD PTR [esi+4]
	sar	eax, 2
	mov	DWORD PTR [ecx+12], eax
	add	ecx, 24					; 00000018H

; 490  :         out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom left subblock

	mov	eax, DWORD PTR [esi+4]
	sar	eax, 2
	mov	DWORD PTR [edx], eax

; 491  :         out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom right subblock

	mov	eax, DWORD PTR [esi+4]
	add	esi, 12					; 0000000cH
	sar	eax, 2
	mov	DWORD PTR [edx+12], eax
	add	edx, 24					; 00000018H
	sub	DWORD PTR tv6290[esp+72], 1
	mov	DWORD PTR tv6298[esp+72], edx
	mov	DWORD PTR tv6300[esp+72], ecx
	jne	$LL25@ExtraDivid
	mov	ebp, DWORD PTR _out$2$[esp+72]
	mov	ebx, DWORD PTR _inp$1$[esp+72]
	mov	esi, DWORD PTR _bx$1$[esp+72]
	mov	ecx, DWORD PTR _nBlkXN$1$[esp+72]
$LN24@ExtraDivid:

; 492  :       }
; 493  :     }
; 494  : 
; 495  :     bx = nBlkXN - N_PER_BLOCK;
; 496  :     for (int i = 0; i < 2; i++)
; 497  :     {
; 498  :       out[bx * 2 + i] = inp[bx + i]; // top left subblock

	mov	eax, DWORD PTR [ebx+esi*4]

; 499  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i]; // top right subblock
; 500  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i]; // bottom left subblock

	lea	edx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [ebp+esi*8], eax

; 501  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i]; // bottom right subblock

	add	ecx, esi
	mov	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebp+esi*8+12], eax
	mov	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebp+edx*8], eax
	mov	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [ebp+edx*8+12], eax
	mov	eax, DWORD PTR [ebx+esi*4+4]
	mov	DWORD PTR [ebp+esi*8+4], eax
	mov	eax, DWORD PTR [ebx+esi*4+4]
	mov	DWORD PTR [ebp+esi*8+16], eax
	mov	eax, DWORD PTR [ebx+esi*4+4]
	mov	DWORD PTR [ebp+edx*8+4], eax
	mov	eax, DWORD PTR [ebx+esi*4+4]
	mov	DWORD PTR [ebp+ecx*8+16], eax

; 502  :     }
; 503  :     for (int i = 2; i < N_PER_BLOCK; i++)
; 504  :     {
; 505  :       out[bx * 2 + i] = inp[bx + i] >> 2; // top left subblock

	lea	ecx, DWORD PTR [esi*2+2]
	mov	eax, DWORD PTR [ebx+esi*4+8]
	sar	eax, 2
	mov	DWORD PTR [ebp+ecx*4], eax

; 506  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i] >> 2; // top right subblock

	mov	eax, DWORD PTR [ebx+esi*4+8]
	sar	eax, 2
	mov	DWORD PTR [ebp+ecx*4+12], eax

; 507  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom left subblock

	lea	ecx, DWORD PTR [edx*2+2]
	mov	eax, DWORD PTR [ebx+esi*4+8]
	sar	eax, 2
	mov	DWORD PTR [ebp+ecx*4], eax

; 508  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom right subblock

	mov	eax, DWORD PTR [ebx+esi*4+8]

; 509  :     }
; 510  :     out += nBlkXN * 4;
; 511  :     inp += nBlkXN;

	add	ebx, DWORD PTR tv6335[esp+72]
	sar	eax, 2
	mov	DWORD PTR [ebp+ecx*4+12], eax
	add	ebp, DWORD PTR tv6336[esp+72]
	sub	DWORD PTR tv6289[esp+72], 1
	mov	ecx, DWORD PTR _nBlkXN$1$[esp+72]
	mov	DWORD PTR _out$2$[esp+72], ebp
	mov	DWORD PTR _inp$1$[esp+72], ebx
	jne	$LL16@ExtraDivid
$LN15@ExtraDivid:

; 512  :   }
; 513  : 
; 514  :   // bottom blocks
; 515  :   by = nBlkY - 1;
; 516  :   for (int bx = 0; bx < nBlkXN; bx += N_PER_BLOCK)

	test	ecx, ecx
	jle	$LN36@ExtraDivid
	lea	edi, DWORD PTR [ecx*8+4]
	mov	eax, -1431655765			; aaaaaaabH
	lea	edx, DWORD PTR [ebp+8]
	add	edi, ebp
	lea	esi, DWORD PTR [ebp+4]
	mov	DWORD PTR tv6286[esp+68], edx
	lea	ebp, DWORD PTR [ebp+ecx*8]
	add	ebx, 8
	dec	ecx
	add	ebp, 8
	mul	ecx
	mov	ecx, DWORD PTR tv6286[esp+68]
	shr	edx, 1
	inc	edx
	npad	8
$LL37@ExtraDivid:

; 517  :   {
; 518  :     for (int i = 0; i < 2; i++)
; 519  :     {
; 520  :       out[bx * 2 + i] = inp[bx + i]; // top left subblock

	mov	eax, DWORD PTR [ebx-8]
	lea	esi, DWORD PTR [esi+24]
	mov	DWORD PTR [esi-28], eax
	lea	edi, DWORD PTR [edi+24]

; 521  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i]; // top right subblock

	mov	eax, DWORD PTR [ebx-8]
	lea	ebp, DWORD PTR [ebp+24]
	mov	DWORD PTR [esi-16], eax
	lea	ecx, DWORD PTR [ecx+24]

; 522  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i]; // bottom left subblock

	mov	eax, DWORD PTR [ebx-8]
	lea	ebx, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi-28], eax

; 523  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i]; // bottom right subblock

	mov	eax, DWORD PTR [ebx-20]
	mov	DWORD PTR [edi-16], eax
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR [esi-24], eax
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR [esi-12], eax
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR [edi-24], eax
	mov	eax, DWORD PTR [ebx-16]
	mov	DWORD PTR [edi-12], eax

; 524  :     }
; 525  :     for (int i = 2; i < N_PER_BLOCK; i++)
; 526  :     {
; 527  :       out[bx * 2 + i] = inp[bx + i] >> 2; // top left subblock

	mov	eax, DWORD PTR [ebx-12]
	sar	eax, 2
	mov	DWORD PTR [ecx-24], eax

; 528  :       out[bx * 2 + N_PER_BLOCK + i] = inp[bx + i] >> 2; // top right subblock

	mov	eax, DWORD PTR [ebx-12]
	sar	eax, 2
	mov	DWORD PTR [ecx-12], eax

; 529  :       out[bx * 2 + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom left subblock

	mov	eax, DWORD PTR [ebx-12]
	sar	eax, 2
	mov	DWORD PTR [ebp-24], eax

; 530  :       out[bx * 2 + N_PER_BLOCK + nBlkXN * 2 + i] = inp[bx + i] >> 2; // bottom right subblock

	mov	eax, DWORD PTR [ebx-12]
	sar	eax, 2
	mov	DWORD PTR [ebp-12], eax
	sub	edx, 1
	jne	SHORT $LL37@ExtraDivid
$LN36@ExtraDivid:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 531  :     }
; 532  :   }
; 533  : }

	add	esp, 56					; 00000038H
	ret	8
?ExtraDivide@GroupOfPlanes@@QAEXPAHH@Z ENDP		; GroupOfPlanes::ExtraDivide
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??0?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAE@_N@Z
_TEXT	SEGMENT
_mt_flag$ = 8						; size = 1
??0?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAE@_N@Z PROC	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>, COMDAT
; _this$ = ecx

; 70   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR [esi+4], eax

; 66   : ,	_proc_ptr (0)
; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR [esi+16]
	push	1024					; 00000400H
	push	0
	mov	DWORD PTR [esi+8], 0
	push	eax
	mov	DWORD PTR [esi+12], 0
	call	_memset

; 69   : ,	_mt_flag (mt_flag)

	mov	al, BYTE PTR _mt_flag$[esp+12]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [esi+1040], al

; 71   : 	// Nothing
; 72   : }

	mov	eax, esi
	pop	esi
	ret	4
??0?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAE@_N@Z ENDP	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ PROC	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::~MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>, COMDAT
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@
	je	SHORT $LN2@MTSlicer

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	je	SHORT $LN5@MTSlicer

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN5@MTSlicer:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0
$LN2@MTSlicer:

; 88   : 	{
; 89   : 		wait ();
; 90   : 	}
; 91   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAE@XZ ENDP	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::~MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?wait@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXXZ
_TEXT	SEGMENT
?wait@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXXZ PROC	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::wait, COMDAT
; _this$ = ecx

; 214  : {

	push	esi
	mov	esi, ecx

; 215  : 	assert (_proc_ptr != 0);
; 216  : 
; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	je	SHORT $LN8@wait

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	edx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	edx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN8@wait:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0
	pop	esi

; 227  : }

	ret	0
?wait@?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@QAEXXZ ENDP	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z PROC	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@6B@
	je	SHORT $LN5@scalar

; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1040], 0
	je	SHORT $LN9@scalar

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	ecx, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN9@scalar:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR [esi+8], 0

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+12], 0
$LN5@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN15@scalar
	push	1044					; 00000414H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN15@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$MTSlicer@VPlaneOfBlocks@@V1@$0EA@@@UAEPAXI@Z ENDP	; MTSlicer<PlaneOfBlocks,PlaneOfBlocks,64>::`scalar deleting destructor'
END
