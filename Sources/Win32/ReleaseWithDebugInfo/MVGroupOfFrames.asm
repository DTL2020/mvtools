; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvgroupofframes.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?Reduce@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z	; MVGroupOfFrames::Reduce
PUBLIC	?Pad@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z	; MVGroupOfFrames::Pad
PUBLIC	?Refine@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z	; MVGroupOfFrames::Refine
PUBLIC	?set_interp@MVGroupOfFrames@@QAEXW4MVPlaneSet@@HH@Z ; MVGroupOfFrames::set_interp
PUBLIC	?SetPlane@MVGroupOfFrames@@QAEXPBEHW4MVPlaneSet@@@Z ; MVGroupOfFrames::SetPlane
PUBLIC	??_GMVFrame@@QAEPAXI@Z				; MVFrame::`scalar deleting destructor'
PUBLIC	?PlaneSuperOffset@@YAI_NHHHHHH@Z		; PlaneSuperOffset
PUBLIC	?PlaneWidthLuma@@YAHHHHH@Z			; PlaneWidthLuma
PUBLIC	?PlaneHeightLuma@@YAHHHHH@Z			; PlaneHeightLuma
PUBLIC	?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z	; MVGroupOfFrames::Update
PUBLIC	??1MVGroupOfFrames@@QAE@XZ			; MVGroupOfFrames::~MVGroupOfFrames
PUBLIC	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z	; MVGroupOfFrames::MVGroupOfFrames
PUBLIC	?GetFrame@MVGroupOfFrames@@QAEPAVMVFrame@@H@Z	; MVGroupOfFrames::GetFrame
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z$1
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ?GetFrame@MVGroupOfFrames@@QAEPAVMVFrame@@H@Z
_TEXT	SEGMENT
_nLevel$ = 8						; size = 4
?GetFrame@MVGroupOfFrames@@QAEPAVMVFrame@@H@Z PROC	; MVGroupOfFrames::GetFrame, COMDAT
; _this$ = ecx

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	mov	edx, DWORD PTR _nLevel$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN2@GetFrame
	xor	eax, eax

; 84   : }

	ret	4
$LN2@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edx*4]

; 84   : }

	ret	4
?GetFrame@MVGroupOfFrames@@QAEPAVMVFrame@@H@Z ENDP	; MVGroupOfFrames::GetFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvsuper.h
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvsuper.h
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_i$1$ = 8						; size = 4
$T2 = 8							; size = 4
__nLevelCount$ = 8					; size = 4
tv431 = 12						; size = 4
__nWidth$ = 12						; size = 4
$T3 = 16						; size = 4
__nHeight$ = 16						; size = 4
__nPel$ = 20						; size = 4
__nHPad$ = 24						; size = 4
__nVPad$ = 28						; size = 4
_nMode$ = 32						; size = 4
_isse$ = 36						; size = 1
__xRatioUV$ = 40					; size = 4
__yRatioUV$ = 44					; size = 4
__pixelsize$ = 48					; size = 4
__bits_per_pixel$ = 52					; size = 4
_mt_flag$ = 56						; size = 1
??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z PROC		; MVGroupOfFrames::MVGroupOfFrames, COMDAT
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0

; 37   : ,	pFrames (new MVFrame* [_nLevelCount])

	mov	edx, 4
	push	-1
	push	__ehhandler$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR __nLevelCount$[ebp]
	push	ebx
	mov	ebx, ecx
	xor	ecx, ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebx], eax
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+4], eax

; 38   : ,	nWidth (_nWidth)

	mov	eax, DWORD PTR __nWidth$[ebp]
	mov	DWORD PTR [ebx+8], eax

; 39   : ,	nHeight (_nHeight)

	mov	eax, DWORD PTR __nHeight$[ebp]
	mov	DWORD PTR [ebx+12], eax

; 40   : ,	nPel (_nPel)

	mov	eax, DWORD PTR __nPel$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 41   : ,	nHPad (_nHPad)

	mov	eax, DWORD PTR __nHPad$[ebp]
	mov	DWORD PTR [ebx+20], eax

; 42   : ,	nVPad (_nVPad)

	mov	eax, DWORD PTR __nVPad$[ebp]
	mov	DWORD PTR [ebx+24], eax

; 43   : ,	xRatioUV (_xRatioUV)

	mov	eax, DWORD PTR __xRatioUV$[ebp]
	mov	DWORD PTR [ebx+28], eax

; 44   : ,	yRatioUV (_yRatioUV)

	mov	eax, DWORD PTR __yRatioUV$[ebp]
	mov	DWORD PTR [ebx+32], eax

; 45   : , pixelsize(_pixelsize)

	mov	eax, DWORD PTR __pixelsize$[ebp]
	mov	DWORD PTR [ebx+36], eax

; 46   : , bits_per_pixel(_bits_per_pixel)

	mov	eax, DWORD PTR __bits_per_pixel$[ebp]

; 48   : 
; 49   :    pFrames[0] = new MVFrame(nWidth, nHeight, nPel, nHPad, nVPad, nMode, isse, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	push	36					; 00000024H
	mov	DWORD PTR [ebx+40], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	push	DWORD PTR _mt_flag$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, eax
	push	DWORD PTR [ebx+40]
	push	DWORD PTR [ebx+36]
	push	DWORD PTR [ebx+32]
	push	DWORD PTR [ebx+28]
	push	DWORD PTR _isse$[ebp]
	push	DWORD PTR _nMode$[ebp]
	push	DWORD PTR [ebx+24]
	push	DWORD PTR [ebx+20]
	push	DWORD PTR [ebx+16]
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+8]
	call	??0MVFrame@@QAE@HHHHHH_NHHHH0@Z		; MVFrame::MVFrame
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 50   :    for ( int i = 1; i < nLevelCount; i++ )

	mov	edx, 1
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR _i$1$[ebp], edx
	mov	DWORD PTR [ecx], eax
	cmp	DWORD PTR [ebx], edx
	jle	$LN46@MVGroupOfF
	npad	4
$LL4@MVGroupOfF:

; 51   :    {
; 52   :       int nWidthi = PlaneWidthLuma(nWidth, i, xRatioUV /*PF instead of 2*/, nHPad);//(nWidthi / 2) - ((nWidthi / 2) % 2); //  even for YV12, YUY2

	mov	ecx, DWORD PTR [ebx+28]
; File c:\github\mvtools\sources\mvsuper.h

; 54   : 	int width = src_width;

	mov	edi, DWORD PTR [ebx+8]

; 55   : 
; 56   : 	for (int i=1; i<=level; i++)

	cmp	edx, 1
	jl	SHORT $LN14@MVGroupOfF

; 57   : 	{
; 58   : //		width = (width/2) - ((width/2) % xRatioUV) ;
; 59   : 		width = hpad >= xRatioUV ? ((width/xRatioUV + 1) / 2) * xRatioUV : ((width/xRatioUV) / 2) * xRatioUV;

	mov	esi, edx
	npad	3
$LL32@MVGroupOfF:
	mov	eax, edi
	cdq
	idiv	ecx
	cmp	DWORD PTR [ebx+20], ecx
	jl	SHORT $LN33@MVGroupOfF
	inc	eax
$LN33@MVGroupOfF:
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	imul	edi, ecx

; 55   : 
; 56   : 	for (int i=1; i<=level; i++)

	sub	esi, 1
	jne	SHORT $LL32@MVGroupOfF
	mov	edx, DWORD PTR _i$1$[ebp]
$LN14@MVGroupOfF:
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 53   :       int nHeighti = PlaneHeightLuma(nHeight, i, yRatioUV, nVPad);//(nHeighti / 2) - ((nHeighti / 2) % yRatioUV); // even for YV12

	mov	ecx, DWORD PTR [ebx+32]
; File c:\github\mvtools\sources\mvsuper.h

; 41   : 	int height = src_height;

	mov	esi, DWORD PTR [ebx+12]

; 42   : 
; 43   : 	for (int i=1; i<=level; i++)

	cmp	edx, 1
	jl	SHORT $LN21@MVGroupOfF

; 44   : 	{
; 45   : //		height = (height/2) - ((height/2) % yRatioUV) ;
; 46   : 		height = vpad >= yRatioUV ? ((height/yRatioUV + 1) / 2) * yRatioUV : ((height/yRatioUV) / 2) * yRatioUV;

	mov	DWORD PTR tv431[ebp], edx
	npad	5
$LL36@MVGroupOfF:
	mov	eax, esi
	cdq
	idiv	ecx
	cmp	DWORD PTR [ebx+24], ecx
	jl	SHORT $LN37@MVGroupOfF
	inc	eax
$LN37@MVGroupOfF:
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	imul	esi, ecx

; 42   : 
; 43   : 	for (int i=1; i<=level; i++)

	sub	DWORD PTR tv431[ebp], 1
	jne	SHORT $LL36@MVGroupOfF
$LN21@MVGroupOfF:
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 54   :       pFrames[i] = new MVFrame(nWidthi, nHeighti, 1, nHPad, nVPad, nMode, isse, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	push	DWORD PTR _mt_flag$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, eax
	push	DWORD PTR [ebx+40]
	push	DWORD PTR [ebx+36]
	push	DWORD PTR [ebx+32]
	push	DWORD PTR [ebx+28]
	push	DWORD PTR _isse$[ebp]
	push	DWORD PTR _nMode$[ebp]
	push	DWORD PTR [ebx+24]
	push	DWORD PTR [ebx+20]
	push	1
	push	esi
	push	edi
	call	??0MVFrame@@QAE@HHHHHH_NHHHH0@Z		; MVFrame::MVFrame
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _i$1$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	edx
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	edx, DWORD PTR [ebx]
	jl	$LL4@MVGroupOfF
$LN46@MVGroupOfF:

; 55   :    }
; 56   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z$0:
	push	36					; 00000024H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z$1:
	push	36					; 00000024H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ENDP		; MVGroupOfFrames::MVGroupOfFrames
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ??1MVGroupOfFrames@@QAE@XZ
_TEXT	SEGMENT
??1MVGroupOfFrames@@QAE@XZ PROC				; MVGroupOfFrames::~MVGroupOfFrames, COMDAT
; _this$ = ecx

; 71   : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 72   :    for ( int i = 0; i < nLevelCount; i++ )

	xor	esi, esi
	cmp	DWORD PTR [ebx], esi
	jle	SHORT $LN3@MVGroupOfF
	push	edi
	npad	5
$LL4@MVGroupOfF:

; 73   : 	{
; 74   :       delete pFrames[i];

	mov	eax, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR [eax+esi*4]
	test	edi, edi
	je	SHORT $LN2@MVGroupOfF
	mov	ecx, edi
	call	??1MVFrame@@QAE@XZ			; MVFrame::~MVFrame
	push	36					; 00000024H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@MVGroupOfF:

; 72   :    for ( int i = 0; i < nLevelCount; i++ )

	inc	esi
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LL4@MVGroupOfF
	pop	edi
$LN3@MVGroupOfF:

; 75   : 	}
; 76   : 
; 77   :    delete[] pFrames;

	push	DWORD PTR [ebx+4]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
	pop	ebx

; 78   : }

	ret	0
??1MVGroupOfFrames@@QAE@XZ ENDP				; MVGroupOfFrames::~MVGroupOfFrames
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z
_TEXT	SEGMENT
_offU$1$ = -8						; size = 4
_offV$1$ = -4						; size = 4
_nMode$ = 8						; size = 4
_pSrcY$ = 12						; size = 4
_pitchY$ = 16						; size = 4
_pSrcU$ = 20						; size = 4
_pitchU$ = 24						; size = 4
_pSrcV$ = 28						; size = 4
_pitchV$ = 32						; size = 4
?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z PROC		; MVGroupOfFrames::Update, COMDAT
; _this$ = ecx

; 59   : {

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, ecx

; 60   : 	for ( int i = 0; i < nLevelCount; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR [ebp], ebx
	jle	$LN3@Update
	push	esi
	push	edi
$LL4@Update:

; 64   : 		unsigned int offU = PlaneSuperOffset(true, nHeight/yRatioUV, i, nPel, nVPad/yRatioUV, pitchU, yRatioUV);

	mov	ecx, DWORD PTR [ebp+32]
	mov	eax, DWORD PTR [ebp+24]
	cdq
	idiv	ecx
	push	ecx
	mov	edi, eax
	mov	eax, DWORD PTR [ebp+12]
	cdq
	idiv	ecx
	push	DWORD PTR _pitchU$[esp+24]
	mov	esi, eax
	mov	cl, 1
	push	edi
	push	DWORD PTR [ebp+16]
	mov	edx, esi
	push	ebx
	call	?PlaneSuperOffset@@YAI_NHHHHHH@Z	; PlaneSuperOffset

; 65   : 		unsigned int offV = PlaneSuperOffset(true, nHeight/yRatioUV, i, nPel, nVPad/yRatioUV, pitchV, yRatioUV);

	push	DWORD PTR [ebp+32]
	mov	edx, esi
	mov	DWORD PTR _offU$1$[esp+48], eax
	push	DWORD PTR _pitchV$[esp+44]
	mov	cl, 1
	push	edi
	push	DWORD PTR [ebp+16]
	push	ebx
	call	?PlaneSuperOffset@@YAI_NHHHHHH@Z	; PlaneSuperOffset

; 66   : 		pFrames[i]->Update (nMode, pSrcY+offY, pitchY, pSrcU+offU, pitchU, pSrcV+offV, pitchV);

	mov	esi, DWORD PTR [ebp+4]
	add	esp, 40					; 00000028H
; File c:\github\mvtools\sources\mvframe.cpp

; 65   :    if ( _nMode & nMode & YPLANE  ) //v2.0.8

	mov	edi, DWORD PTR _nMode$[esp+20]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 65   : 		unsigned int offV = PlaneSuperOffset(true, nHeight/yRatioUV, i, nPel, nVPad/yRatioUV, pitchV, yRatioUV);

	mov	DWORD PTR _offV$1$[esp+24], eax

; 66   : 		pFrames[i]->Update (nMode, pSrcY+offY, pitchY, pSrcU+offU, pitchU, pSrcV+offV, pitchV);

	mov	esi, DWORD PTR [esi+ebx*4]
; File c:\github\mvtools\sources\mvframe.cpp

; 65   :    if ( _nMode & nMode & YPLANE  ) //v2.0.8

	mov	ecx, DWORD PTR [esi+12]
	and	ecx, edi
	test	cl, 1
	je	SHORT $LN7@Update

; 66   :       pYPlane->Update(pSrcY, pitchY);

	mov	eax, DWORD PTR _pitchY$[esp+20]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 63   : 		unsigned int offY = PlaneSuperOffset(false, nHeight, i, nPel, nVPad, pitchY, yRatioUV); // no need here xRatioUV and pixelsize

	xor	cl, cl
	mov	edx, DWORD PTR [ebp+12]
; File c:\github\mvtools\sources\mvframe.cpp

; 66   :       pYPlane->Update(pSrcY, pitchY);

	push	eax
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 63   : 		unsigned int offY = PlaneSuperOffset(false, nHeight, i, nPel, nVPad, pitchY, yRatioUV); // no need here xRatioUV and pixelsize

	push	DWORD PTR [ebp+32]
	push	eax
	push	DWORD PTR [ebp+24]
	push	DWORD PTR [ebp+16]
	push	ebx
	call	?PlaneSuperOffset@@YAI_NHHHHHH@Z	; PlaneSuperOffset

; 66   : 		pFrames[i]->Update (nMode, pSrcY+offY, pitchY, pSrcU+offU, pitchU, pSrcV+offV, pitchV);

	add	eax, DWORD PTR _pSrcY$[esp+44]
	add	esp, 20					; 00000014H
; File c:\github\mvtools\sources\mvframe.cpp

; 66   :       pYPlane->Update(pSrcY, pitchY);

	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?Update@MVPlane@@QAEXPAEH@Z		; MVPlane::Update
$LN7@Update:

; 67   : 
; 68   :    if ( _nMode & nMode & UPLANE  )

	mov	eax, DWORD PTR [esi+12]
	and	eax, edi
	test	al, 2
	je	SHORT $LN8@Update

; 69   :       pUPlane->Update(pSrcU, pitchU);

	push	DWORD PTR _pitchU$[esp+20]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 66   : 		pFrames[i]->Update (nMode, pSrcY+offY, pitchY, pSrcU+offU, pitchU, pSrcV+offV, pitchV);

	mov	eax, DWORD PTR _offU$1$[esp+28]
	add	eax, DWORD PTR _pSrcU$[esp+24]
; File c:\github\mvtools\sources\mvframe.cpp

; 69   :       pUPlane->Update(pSrcU, pitchU);

	mov	ecx, DWORD PTR [esi+4]
	push	eax
	call	?Update@MVPlane@@QAEXPAEH@Z		; MVPlane::Update
$LN8@Update:

; 70   : 
; 71   :    if ( _nMode & nMode & VPLANE  )

	mov	eax, DWORD PTR [esi+12]
	and	eax, edi
	test	al, 4
	je	SHORT $LN2@Update

; 72   :       pVPlane->Update(pSrcV, pitchV);

	push	DWORD PTR _pitchV$[esp+20]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 66   : 		pFrames[i]->Update (nMode, pSrcY+offY, pitchY, pSrcU+offU, pitchU, pSrcV+offV, pitchV);

	mov	eax, DWORD PTR _offV$1$[esp+28]
	add	eax, DWORD PTR _pSrcV$[esp+24]
; File c:\github\mvtools\sources\mvframe.cpp

; 72   :       pVPlane->Update(pSrcV, pitchV);

	mov	ecx, DWORD PTR [esi+8]
	push	eax
	call	?Update@MVPlane@@QAEXPAEH@Z		; MVPlane::Update
$LN2@Update:
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 60   : 	for ( int i = 0; i < nLevelCount; i++ )

	inc	ebx
	cmp	ebx, DWORD PTR [ebp]
	jl	$LL4@Update
	pop	edi
	pop	esi
$LN3@Update:
	pop	ebp
	pop	ebx

; 67   : 	}
; 68   : }

	add	esp, 8
	ret	28					; 0000001cH
?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z ENDP		; MVGroupOfFrames::Update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvsuper.h
;	COMDAT ?PlaneHeightLuma@@YAHHHHH@Z
_TEXT	SEGMENT
_yRatioUV$ = 8						; size = 4
_vpad$ = 12						; size = 4
?PlaneHeightLuma@@YAHHHHH@Z PROC			; PlaneHeightLuma, COMDAT
; _src_height$ = ecx
; _level$ = edx

; 40   : {

	push	edi
	mov	edi, edx

; 42   : 
; 43   : 	for (int i=1; i<=level; i++)

	cmp	edi, 1
	jl	SHORT $LN16@PlaneHeigh

; 41   : 	int height = src_height;

	push	ebx
	mov	ebx, DWORD PTR _vpad$[esp+4]
	push	esi
	mov	esi, DWORD PTR _yRatioUV$[esp+8]
$LL10@PlaneHeigh:

; 44   : 	{
; 45   : //		height = (height/2) - ((height/2) % yRatioUV) ;
; 46   : 		height = vpad >= yRatioUV ? ((height/yRatioUV + 1) / 2) * yRatioUV : ((height/yRatioUV) / 2) * yRatioUV;

	mov	eax, ecx
	cdq
	idiv	esi
	cmp	ebx, esi
	jl	SHORT $LN11@PlaneHeigh
	inc	eax
$LN11@PlaneHeigh:
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	imul	ecx, esi
	sub	edi, 1
	jne	SHORT $LL10@PlaneHeigh
	pop	esi
	pop	ebx
$LN16@PlaneHeigh:

; 47   : 	}
; 48   : 	return height;

	mov	eax, ecx
	pop	edi

; 49   : }

	ret	0
?PlaneHeightLuma@@YAHHHHH@Z ENDP			; PlaneHeightLuma
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvsuper.h
;	COMDAT ?PlaneWidthLuma@@YAHHHHH@Z
_TEXT	SEGMENT
_xRatioUV$ = 8						; size = 4
_hpad$ = 12						; size = 4
?PlaneWidthLuma@@YAHHHHH@Z PROC				; PlaneWidthLuma, COMDAT
; _src_width$ = ecx
; _level$ = edx

; 53   : {

	push	edi
	mov	edi, edx

; 55   : 
; 56   : 	for (int i=1; i<=level; i++)

	cmp	edi, 1
	jl	SHORT $LN16@PlaneWidth

; 54   : 	int width = src_width;

	push	ebx
	mov	ebx, DWORD PTR _hpad$[esp+4]
	push	esi
	mov	esi, DWORD PTR _xRatioUV$[esp+8]
$LL10@PlaneWidth:

; 57   : 	{
; 58   : //		width = (width/2) - ((width/2) % xRatioUV) ;
; 59   : 		width = hpad >= xRatioUV ? ((width/xRatioUV + 1) / 2) * xRatioUV : ((width/xRatioUV) / 2) * xRatioUV;

	mov	eax, ecx
	cdq
	idiv	esi
	cmp	ebx, esi
	jl	SHORT $LN11@PlaneWidth
	inc	eax
$LN11@PlaneWidth:
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	imul	ecx, esi
	sub	edi, 1
	jne	SHORT $LL10@PlaneWidth
	pop	esi
	pop	ebx
$LN16@PlaneWidth:

; 60   : 	}
; 61   : 	return width;

	mov	eax, ecx
	pop	edi

; 62   : }

	ret	0
?PlaneWidthLuma@@YAHHHHH@Z ENDP				; PlaneWidthLuma
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvsuper.h
;	COMDAT ?PlaneSuperOffset@@YAI_NHHHHHH@Z
_TEXT	SEGMENT
_chroma$1$ = -9						; size = 1
_offset$2$ = -8						; size = 4
_src_height$1$ = -4					; size = 4
_level$ = 8						; size = 4
_pel$ = 12						; size = 4
_vpad$ = 16						; size = 4
_plane_pitch$ = 20					; size = 4
_yRatioUV$ = 24						; size = 4
?PlaneSuperOffset@@YAI_NHHHHHH@Z PROC			; PlaneSuperOffset, COMDAT
; _chroma$ = cl
; _src_height$ = edx

; 67   : {

	sub	esp, 12					; 0000000cH
	push	edi

; 68   : 	// storing subplanes in superframes may be implemented by various ways
; 69   : 	int height = src_height; // luma or chroma
; 70   : 
; 71   : 	unsigned int offset;
; 72   : 
; 73   : 	if (level==0)

	mov	edi, DWORD PTR _level$[esp+12]
	mov	DWORD PTR _src_height$1$[esp+16], edx
	mov	BYTE PTR _chroma$1$[esp+16], cl
	test	edi, edi
	jne	SHORT $LN5@PlaneSuper

; 86   : 		}
; 87   : 	}
; 88   : 	return offset;

	xor	eax, eax
	pop	edi

; 89   : }

	add	esp, 12					; 0000000cH
	ret	0
$LN5@PlaneSuper:
	push	ebx
	push	ebp

; 74   : 	{
; 75   : 		offset = 0;
; 76   : 	}
; 77   : 	else
; 78   : 	{
; 79   : 		offset = pel*pel*plane_pitch*(src_height + vpad*2);

	mov	ebp, DWORD PTR _vpad$[esp+20]

; 80   : 
; 81   : 		for (int i=1; i<level; i++)

	mov	ebx, 1
	push	esi
	lea	esi, DWORD PTR [edx+ebp*2]
	imul	esi, DWORD PTR _pel$[esp+24]
	imul	esi, DWORD PTR _pel$[esp+24]
	imul	esi, DWORD PTR _plane_pitch$[esp+24]
	mov	DWORD PTR _offset$2$[esp+28], esi
	cmp	edi, ebx
	jle	SHORT $LN44@PlaneSuper
	mov	ecx, DWORD PTR _yRatioUV$[esp+24]
$LL4@PlaneSuper:

; 82   : 		{
; 83   : 			height = chroma ? PlaneHeightLuma(src_height*yRatioUV, i, yRatioUV, vpad*yRatioUV)/yRatioUV : PlaneHeightLuma(src_height, i, yRatioUV, vpad);

	cmp	BYTE PTR _chroma$1$[esp+28], 0
	mov	eax, edx
	je	SHORT $LN8@PlaneSuper
	imul	eax, ecx

; 43   : 	for (int i=1; i<=level; i++)

	cmp	ebx, 1
	jl	SHORT $LN12@PlaneSuper

; 82   : 		{
; 83   : 			height = chroma ? PlaneHeightLuma(src_height*yRatioUV, i, yRatioUV, vpad*yRatioUV)/yRatioUV : PlaneHeightLuma(src_height, i, yRatioUV, vpad);

	mov	edi, ebp
	mov	esi, ebx
	imul	edi, ecx
	npad	3
$LL30@PlaneSuper:

; 46   : 		height = vpad >= yRatioUV ? ((height/yRatioUV + 1) / 2) * yRatioUV : ((height/yRatioUV) / 2) * yRatioUV;

	cdq
	idiv	ecx
	cmp	edi, ecx
	jl	SHORT $LN31@PlaneSuper
	inc	eax
$LN31@PlaneSuper:
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, ecx

; 42   : 
; 43   : 	for (int i=1; i<=level; i++)

	sub	esi, 1
	jne	SHORT $LL30@PlaneSuper
	mov	esi, DWORD PTR _offset$2$[esp+28]
	mov	edi, DWORD PTR _level$[esp+24]
$LN12@PlaneSuper:

; 82   : 		{
; 83   : 			height = chroma ? PlaneHeightLuma(src_height*yRatioUV, i, yRatioUV, vpad*yRatioUV)/yRatioUV : PlaneHeightLuma(src_height, i, yRatioUV, vpad);

	cdq
	idiv	ecx
	jmp	SHORT $LN19@PlaneSuper
$LN8@PlaneSuper:

; 43   : 	for (int i=1; i<=level; i++)

	cmp	ebx, 1
	jl	SHORT $LN19@PlaneSuper

; 41   : 	int height = src_height;

	mov	esi, ebx
	npad	7
$LL34@PlaneSuper:

; 44   : 	{
; 45   : //		height = (height/2) - ((height/2) % yRatioUV) ;
; 46   : 		height = vpad >= yRatioUV ? ((height/yRatioUV + 1) / 2) * yRatioUV : ((height/yRatioUV) / 2) * yRatioUV;

	cdq
	idiv	ecx
	cmp	ebp, ecx
	jl	SHORT $LN35@PlaneSuper
	inc	eax
$LN35@PlaneSuper:
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, ecx

; 42   : 
; 43   : 	for (int i=1; i<=level; i++)

	sub	esi, 1
	jne	SHORT $LL34@PlaneSuper
	mov	esi, DWORD PTR _offset$2$[esp+28]
$LN19@PlaneSuper:

; 84   : 
; 85   : 			offset += plane_pitch*(height + vpad*2);

	lea	edx, DWORD PTR [eax+ebp*2]
	inc	ebx
	imul	edx, DWORD PTR _plane_pitch$[esp+24]
	add	esi, edx
	mov	edx, DWORD PTR _src_height$1$[esp+28]
	mov	DWORD PTR _offset$2$[esp+28], esi
	cmp	ebx, edi
	jl	SHORT $LL4@PlaneSuper
$LN44@PlaneSuper:

; 86   : 		}
; 87   : 	}
; 88   : 	return offset;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 89   : }

	add	esp, 12					; 0000000cH
	ret	0
?PlaneSuperOffset@@YAI_NHHHHHH@Z ENDP			; PlaneSuperOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVFrame@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GMVFrame@@QAEPAXI@Z PROC				; MVFrame::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVFrame@@QAE@XZ			; MVFrame::~MVFrame
	push	36					; 00000024H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	eax, esi
	pop	esi
	ret	4
??_GMVFrame@@QAEPAXI@Z ENDP				; MVFrame::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ?SetPlane@MVGroupOfFrames@@QAEXPBEHW4MVPlaneSet@@@Z
_TEXT	SEGMENT
_pNewSrc$ = 8						; size = 4
_nNewPitch$ = 12					; size = 4
_nMode$ = 16						; size = 4
?SetPlane@MVGroupOfFrames@@QAEXPBEHW4MVPlaneSet@@@Z PROC ; MVGroupOfFrames::SetPlane, COMDAT
; _this$ = ecx

; 88   :    pFrames[0]->ChangePlane(pNewSrc, nNewPitch, nMode);

	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	?ChangePlane@MVFrame@@QAEXPBEHW4MVPlaneSet@@@Z ; MVFrame::ChangePlane
?SetPlane@MVGroupOfFrames@@QAEXPBEHW4MVPlaneSet@@@Z ENDP ; MVGroupOfFrames::SetPlane
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ?set_interp@MVGroupOfFrames@@QAEXW4MVPlaneSet@@HH@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
_rfilter$ = 12						; size = 4
_sharp$ = 16						; size = 4
?set_interp@MVGroupOfFrames@@QAEXW4MVPlaneSet@@HH@Z PROC ; MVGroupOfFrames::set_interp, COMDAT
; _this$ = ecx

; 95   :    pFrames[0]->set_interp (nMode, rfilter, sharp);

	mov	eax, DWORD PTR [ecx+4]
	push	ebx
; File c:\github\mvtools\sources\mvframe.cpp

; 107  :    if (nMode & YPLANE & _nMode)

	mov	ebx, DWORD PTR _rfilter$[esp]
	push	ebp
	mov	ebp, DWORD PTR _nMode$[esp+4]
	push	esi
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 95   :    pFrames[0]->set_interp (nMode, rfilter, sharp);

	mov	esi, DWORD PTR [eax]
	push	edi
; File c:\github\mvtools\sources\mvframe.cpp

; 107  :    if (nMode & YPLANE & _nMode)

	mov	edi, DWORD PTR _sharp$[esp+12]
	mov	eax, DWORD PTR [esi+12]
	and	eax, ebp
	test	al, 1
	je	SHORT $LN4@set_interp

; 108  : 	{
; 109  :       pYPlane->set_interp (rfilter, sharp);

	mov	ecx, DWORD PTR [esi]
	push	edi
	push	ebx
	call	?set_interp@MVPlane@@QAEXHH@Z		; MVPlane::set_interp
$LN4@set_interp:

; 110  : 	}
; 111  :    if (nMode & UPLANE & _nMode)

	mov	eax, DWORD PTR [esi+12]
	and	eax, ebp
	test	al, 2
	je	SHORT $LN5@set_interp

; 112  : 	{
; 113  :       pUPlane->set_interp (rfilter, sharp);

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	push	ebx
	call	?set_interp@MVPlane@@QAEXHH@Z		; MVPlane::set_interp
$LN5@set_interp:

; 114  : 	}
; 115  :    if (nMode & VPLANE & _nMode)

	mov	eax, DWORD PTR [esi+12]
	and	eax, ebp
	test	al, 4
	je	SHORT $LN6@set_interp

; 116  : 	{
; 117  :       pVPlane->set_interp (rfilter, sharp);

	mov	ecx, DWORD PTR [esi+8]
	push	edi
	push	ebx
	call	?set_interp@MVPlane@@QAEXHH@Z		; MVPlane::set_interp
$LN6@set_interp:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 96   : }

	ret	12					; 0000000cH
?set_interp@MVGroupOfFrames@@QAEXW4MVPlaneSet@@HH@Z ENDP ; MVGroupOfFrames::set_interp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ?Refine@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
?Refine@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z PROC	; MVGroupOfFrames::Refine, COMDAT
; _this$ = ecx

; 102  :    pFrames[0]->Refine(nMode);

	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	?Refine@MVFrame@@QAEXW4MVPlaneSet@@@Z	; MVFrame::Refine
?Refine@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z ENDP	; MVGroupOfFrames::Refine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ?Pad@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z
_TEXT	SEGMENT
_nMode$ = 8						; size = 4
?Pad@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z PROC		; MVGroupOfFrames::Pad, COMDAT
; _this$ = ecx

; 109  :    pFrames[0]->Pad(nMode);

	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	jmp	?Pad@MVFrame@@QAEXW4MVPlaneSet@@@Z	; MVFrame::Pad
?Pad@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z ENDP		; MVGroupOfFrames::Pad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvgroupofframes.cpp
;	COMDAT ?Reduce@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z
_TEXT	SEGMENT
__nMode$ = 8						; size = 4
?Reduce@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z PROC	; MVGroupOfFrames::Reduce, COMDAT
; _this$ = ecx

; 115  : {

	push	esi
	push	edi
	mov	edi, ecx

; 116  :    for (int i = 0; i < nLevelCount - 1; i++ )

	xor	esi, esi
	mov	eax, DWORD PTR [edi]
	dec	eax
	test	eax, eax
	jle	SHORT $LN3@Reduce
	push	ebx
	mov	ebx, DWORD PTR __nMode$[esp+8]
$LL4@Reduce:
	mov	eax, DWORD PTR [edi+4]

; 117  :    {
; 118  :       pFrames[i]->ReduceTo(pFrames[i+1], _nMode);

	push	ebx
	push	DWORD PTR [eax+esi*4+4]
	mov	ecx, DWORD PTR [eax+esi*4]
	call	?ReduceTo@MVFrame@@QAEXPAV1@W4MVPlaneSet@@@Z ; MVFrame::ReduceTo

; 119  :       pFrames[i+1]->Pad(YUVPLANES);

	mov	ecx, DWORD PTR [edi+4]
	push	7
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	call	?Pad@MVFrame@@QAEXW4MVPlaneSet@@@Z	; MVFrame::Pad
	mov	eax, DWORD PTR [edi]
	inc	esi
	dec	eax
	cmp	esi, eax
	jl	SHORT $LL4@Reduce
	pop	ebx
$LN3@Reduce:
	pop	edi
	pop	esi

; 120  : 		// LDS: why padding all the planes when ReduceTo only applies to _nMode?
; 121  :    }
; 122  : }

	ret	4
?Reduce@MVGroupOfFrames@@QAEXW4MVPlaneSet@@@Z ENDP	; MVGroupOfFrames::Reduce
_TEXT	ENDS
END
