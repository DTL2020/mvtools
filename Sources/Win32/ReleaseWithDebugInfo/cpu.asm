; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\cpu.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@BDDFKIGD@GenuineIntel?$AA@		; `string'
PUBLIC	??_C@_0CH@FJMOIPKN@Error?3?5detected?5CPU?5types?5do?5not@ ; `string'
EXTRN	_x264_cpu_cpuid:PROC
EXTRN	_x264_cpu_cpuid_test:PROC
;	COMDAT ??_C@_0CH@FJMOIPKN@Error?3?5detected?5CPU?5types?5do?5not@
CONST	SEGMENT
??_C@_0CH@FJMOIPKN@Error?3?5detected?5CPU?5types?5do?5not@ DB 'Error: det'
	DB	'ected CPU types do not match', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDDFKIGD@GenuineIntel?$AA@
CONST	SEGMENT
??_C@_0N@BDDFKIGD@GenuineIntel?$AA@ DB 'GenuineIntel', 00H ; `string'
PUBLIC	?cpu_detect@@YAIXZ				; cpu_detect
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\debugprintf.h
;	COMDAT ?DebugPrintf@@YAXPADZZ
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?DebugPrintf@@YAXPADZZ PROC				; DebugPrintf, COMDAT

; 52   :   __noop(fmt); 	// Nothing
; 53   : }

	ret	0
?DebugPrintf@@YAXPADZZ ENDP				; DebugPrintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\cpu.cpp
;	COMDAT ?cpu_detect@@YAIXZ
_TEXT	SEGMENT
_eax$ = -32						; size = 4
_edx$ = -28						; size = 4
_ecx$ = -24						; size = 4
_ebx$ = -20						; size = 4
_vendor$ = -16						; size = 16
?cpu_detect@@YAIXZ PROC					; cpu_detect, COMDAT

; 39   : {

	sub	esp, 32					; 00000020H
	push	edi

; 40   : 	uint32_t cpu = 0;

	xor	edi, edi
	xorps	xmm0, xmm0

; 41   :     uint32_t eax, ebx, ecx, edx;
; 42   :     uint32_t vendor[4] = {0};

	mov	DWORD PTR _vendor$[esp+36], edi
	movq	QWORD PTR _vendor$[esp+40], xmm0
	mov	DWORD PTR _vendor$[esp+48], edi

; 43   :     int max_extended_cap;
; 44   : //    int cache;
; 45   : 
; 46   : #if !defined(_WIN64)
; 47   : 	if( !x264_cpu_cpuid_test() )

	call	_x264_cpu_cpuid_test
	test	eax, eax
	jne	SHORT $LN2@cpu_detect
$LN26@cpu_detect:

; 48   :         return 0;

	xor	eax, eax
	pop	edi

; 178  : }

	add	esp, 32					; 00000020H
	ret	0
$LN2@cpu_detect:

; 49   : #endif
; 50   : 
; 51   :     x264_cpu_cpuid( 0, &eax, vendor+0, vendor+2, vendor+1 );

	lea	eax, DWORD PTR _vendor$[esp+40]
	push	eax
	lea	eax, DWORD PTR _vendor$[esp+48]
	push	eax
	lea	eax, DWORD PTR _vendor$[esp+44]
	push	eax
	lea	eax, DWORD PTR _eax$[esp+48]
	push	eax
	push	0
	call	_x264_cpu_cpuid

; 52   :     if( eax == 0 )

	mov	eax, DWORD PTR _eax$[esp+56]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN26@cpu_detect

; 53   :         return 0;
; 54   : 
; 55   :     int nIds = eax;
; 56   : 
; 57   :     if(nIds >= 1) {

	cmp	eax, 1
	jl	$LN15@cpu_detect

; 58   :       x264_cpu_cpuid( 1, &eax, &ebx, &ecx, &edx );

	lea	eax, DWORD PTR _edx$[esp+36]
	push	eax
	lea	eax, DWORD PTR _ecx$[esp+40]
	push	eax
	lea	eax, DWORD PTR _ebx$[esp+44]
	push	eax
	lea	eax, DWORD PTR _eax$[esp+48]
	push	eax
	push	1
	call	_x264_cpu_cpuid

; 59   :       if( edx&0x00800000 ) // 1 << 23

	mov	ecx, DWORD PTR _edx$[esp+56]
	add	esp, 20					; 00000014H
	test	ecx, 8388608				; 00800000H
	je	SHORT $LN26@cpu_detect

; 60   :           cpu |= CPU_MMX;
; 61   :       else
; 62   :           return 0;
; 63   :       if( edx&0x02000000 ) // 1 << 25

	mov	eax, ecx
	and	eax, 33554432				; 02000000H
	neg	eax
	push	ebx
	sbb	eax, eax
	and	eax, 98304				; 00018000H
	add	eax, 16384				; 00004000H
	mov	edx, eax
	or	edx, 131072				; 00020000H

; 64   :           cpu |= CPU_MMXEXT|CPU_SSE;
; 65   :       if( edx&0x04000000 ) // 1 << 26

	and	ecx, 67108864				; 04000000H
	push	esi

; 66   :           cpu |= CPU_SSE2;
; 67   :       if( ecx&0x00000001 ) // 1 <<  0

	mov	esi, DWORD PTR _ecx$[esp+44]
	cmove	edx, eax
	mov	ecx, edx
	mov	eax, esi
	or	ecx, 1048576				; 00100000H
	and	al, 1

; 68   :           cpu |= CPU_SSE3;
; 69   :       if( ecx&0x00000200 ) // 1 <<  9

	mov	eax, esi
	cmove	ecx, edx
	mov	edx, ecx
	or	edx, 2097152				; 00200000H
	and	eax, 512				; 00000200H

; 70   :           cpu |= CPU_SSSE3;
; 71   :       if( ecx&0x00080000 ) // 1 << 19

	mov	eax, esi
	cmove	edx, ecx
	mov	ecx, edx
	or	ecx, 8388608				; 00800000H
	and	eax, 524288				; 00080000H

; 72   :           cpu |= CPU_SSE4;
; 73   :       if( ecx&0x00100000 ) // 1 << 20

	mov	eax, esi
	cmove	ecx, edx
	mov	ebx, ecx
	or	ebx, 16777216				; 01000000H
	and	eax, 1048576				; 00100000H
	cmove	ebx, ecx
	and	esi, 402653184				; 18000000H
	mov	edi, ebx
	cmp	esi, 402653184				; 18000000H

; 74   :           cpu |= CPU_SSE42;
; 75   :       // AVX
; 76   :       bool xgetbv_supported = ecx & 0x08000000; // IS_BIT_SET(cpuinfo[2], 27);
; 77   :       bool avx_supported = ecx & 0x10000000; // IS_BIT_SET(cpuinfo[2], 28);
; 78   :       if (xgetbv_supported && avx_supported)

	jne	SHORT $LN25@cpu_detect

; 79   :       {
; 80   :         if ((_xgetbv(_XCR_XFEATURE_ENABLED_MASK) & 0x6ull) == 0x6ull) {

	xor	ecx, ecx
	xgetbv
	and	eax, 6
	cmp	eax, 6
	jne	SHORT $LN25@cpu_detect
	test	ecx, ecx
	jne	SHORT $LN25@cpu_detect

; 81   :           cpu |= CPU_AVX;
; 82   :           x264_cpu_cpuid( 7, &eax, &ebx, &ecx, &edx ); // __cpuid(cpuinfo, 7);

	lea	eax, DWORD PTR _edx$[esp+44]
	or	edi, 33554432				; 02000000H
	push	eax
	lea	eax, DWORD PTR _ecx$[esp+48]
	push	eax
	lea	eax, DWORD PTR _ebx$[esp+52]
	push	eax
	lea	eax, DWORD PTR _eax$[esp+56]
	push	eax
	push	7
	call	_x264_cpu_cpuid
	add	esp, 20					; 00000014H

; 83   :           if (ebx&0x00000020 /*IS_BIT_SET(cpuinfo[1], 5)*/)

	test	BYTE PTR _ebx$[esp+44], 32		; 00000020H
	je	SHORT $LN25@cpu_detect

; 84   :             cpu |= CPU_AVX2;

	or	edi, 67108864				; 04000000H
$LN25@cpu_detect:
	pop	esi
	pop	ebx
$LN15@cpu_detect:

; 85   :         }
; 86   :       }
; 87   : #if 0
; 88   :       if( cpu & CPU_SSSE3 )
; 89   :           cpu |= CPU_SSE2_IS_FAST;
; 90   :       
; 91   :       if( cpu & CPU_SSE4 )
; 92   :           cpu |= CPU_PHADD_IS_FAST;
; 93   : #endif
; 94   :     }
; 95   : 
; 96   :     x264_cpu_cpuid( 0x80000000, &eax, &ebx, &ecx, &edx );

	lea	eax, DWORD PTR _edx$[esp+36]
	push	eax
	lea	eax, DWORD PTR _ecx$[esp+40]
	push	eax
	lea	eax, DWORD PTR _ebx$[esp+44]
	push	eax
	lea	eax, DWORD PTR _eax$[esp+48]
	push	eax
	push	-2147483648				; 80000000H
	call	_x264_cpu_cpuid
	add	esp, 20					; 00000014H

; 97   :     max_extended_cap = eax;
; 98   : 
; 99   : #if 0
; 100  :     if( !strcmp((char*)vendor, "AuthenticAMD") && max_extended_cap >= 0x80000001 )
; 101  :     {
; 102  :         x264_cpu_cpuid( 0x80000001, &eax, &ebx, &ecx, &edx );
; 103  :         if( edx&0x00400000 )
; 104  :             cpu |= CPU_MMXEXT;
; 105  :         if( cpu & CPU_SSE2 )
; 106  :         {
; 107  :             if( ecx&0x00000040 ) /* SSE4a */
; 108  :                 cpu |= CPU_SSE2_IS_FAST;
; 109  :             else
; 110  :                 cpu |= CPU_SSE2_IS_SLOW;
; 111  :         }
; 112  :     }
; 113  : #endif
; 114  : 
; 115  :     if( !strcmp((char*)vendor, "GenuineIntel") )

	lea	eax, DWORD PTR _vendor$[esp+36]
	mov	ecx, OFFSET ??_C@_0N@BDDFKIGD@GenuineIntel?$AA@
	npad	1
$LL21@cpu_detect:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN22@cpu_detect
	test	dl, dl
	je	SHORT $LN23@cpu_detect
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN22@cpu_detect
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL21@cpu_detect
$LN23@cpu_detect:
	xor	eax, eax
	jmp	SHORT $LN24@cpu_detect
$LN22@cpu_detect:
	sbb	eax, eax
	or	eax, 1
$LN24@cpu_detect:
	test	eax, eax
	jne	SHORT $LN19@cpu_detect

; 116  :     {
; 117  :         int family, model, stepping;
; 118  :         x264_cpu_cpuid( 1, &eax, &ebx, &ecx, &edx );

	lea	eax, DWORD PTR _edx$[esp+36]
	push	eax
	lea	eax, DWORD PTR _ecx$[esp+40]
	push	eax
	lea	eax, DWORD PTR _ebx$[esp+44]
	push	eax
	lea	eax, DWORD PTR _eax$[esp+48]
	push	eax
	push	1
	call	_x264_cpu_cpuid

; 119  :         family = ((eax>>8)&0xf) + ((eax>>20)&0xff);
; 120  :         model  = ((eax>>4)&0xf) + ((eax>>12)&0xf0);

	mov	edx, DWORD PTR _eax$[esp+56]
	add	esp, 20					; 00000014H
	mov	ecx, edx
	mov	eax, edx
	shr	eax, 4
	and	eax, 15					; 0000000fH
	shr	ecx, 12					; 0000000cH
	and	ecx, 240				; 000000f0H
	add	ecx, eax

; 121  :         stepping = eax&0xf;
; 122  :         /* 6/9 (pentium-m "banias"), 6/13 (pentium-m "dothan"), and 6/14 (core1 "yonah")
; 123  :          * theoretically support sse2, but it's significantly slower than mmx for
; 124  :          * almost all of x264's functions, so let's just pretend they don't. */
; 125  :         if( family==6 && (model==9 || model==13 || model==14) )

	mov	eax, edx
	shr	eax, 20					; 00000014H
	shr	edx, 8
	and	edx, 15					; 0000000fH
	movzx	eax, al
	add	eax, edx
	cmp	eax, 6
	jne	SHORT $LN19@cpu_detect
	cmp	ecx, 9
	je	SHORT $LN18@cpu_detect
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN18@cpu_detect
	cmp	ecx, 14					; 0000000eH
	jne	SHORT $LN19@cpu_detect
$LN18@cpu_detect:

; 126  :         {
; 127  :             cpu &= ~(CPU_SSE2|CPU_SSE3);

	and	edi, -1179649				; ffedffffH
$LN19@cpu_detect:

; 128  : 			if (cpu&(CPU_SSSE3|CPU_SSE4))
; 129  : 				DebugPrintf("Error: detected CPU types do not match");
; 130  :         }
; 131  :     }
; 132  : 
; 133  : #if 0
; 134  :     if( !strcmp((char*)vendor, "GenuineIntel") || !strcmp((char*)vendor, "CyrixInstead") )
; 135  :     {
; 136  :         /* cacheline size is specified in 3 places, any of which may be missing */
; 137  :         x264_cpu_cpuid( 1, &eax, &ebx, &ecx, &edx );
; 138  :         cache = (ebx&0xff00)>>5; // cflush size
; 139  :         if( !cache && max_extended_cap >= 0x80000006 )
; 140  :         {
; 141  :             x264_cpu_cpuid( 0x80000006, &eax, &ebx, &ecx, &edx );
; 142  :             cache = ecx&0xff; // cacheline size
; 143  :         }
; 144  :         if( !cache )
; 145  :         {
; 146  :             // Cache and TLB Information
; 147  :             static const unsigned char cache32_ids[] = { 0x0a, 0x0c, 0x41, 0x42, 0x43, 0x44, 0x45, 0x82, 0x83, 0x84, 0x85, 0 };
; 148  :             static const unsigned char cache64_ids[] = { 0x22, 0x23, 0x25, 0x29, 0x2c, 0x46, 0x47, 0x49, 0x60, 0x66, 0x67, 0x68, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7c, 0x7f, 0x86, 0x87, 0 };
; 149  :             uint32_t buf[4];
; 150  :             int max, i=0, j;
; 151  :             do {
; 152  :                 x264_cpu_cpuid( 2, buf+0, buf+1, buf+2, buf+3 );
; 153  :                 max = buf[0]&0xff;
; 154  :                 buf[0] &= ~0xff;
; 155  :                 for(j=0; j<4; j++)
; 156  :                     if( !(buf[j]>>31) )
; 157  :                         while( buf[j] )
; 158  :                         {
; 159  : 							if( strchr( (const char*)cache32_ids, buf[j]&0xff ) )
; 160  :                                 cache = 32;
; 161  :                             if( strchr( (const char*)cache64_ids, buf[j]&0xff ) )
; 162  :                                 cache = 64;
; 163  : 	                            buf[j] >>= 8;
; 164  :                         }
; 165  :             } while( ++i < max );
; 166  :         }
; 167  : 
; 168  :         if( cache == 32 )
; 169  :             cpu |= CPU_CACHELINE_32;
; 170  :         else if( cache == 64 )
; 171  :             cpu |= CPU_CACHELINE_64;
; 172  : 		}
; 173  : 		else
; 174  : 			DebugPrintf("unable to determine cacheline size");
; 175  : #endif
; 176  : 
; 177  :     return cpu;

	mov	eax, edi
	pop	edi

; 178  : }

	add	esp, 32					; 00000020H
	ret	0
?cpu_detect@@YAIXZ ENDP					; cpu_detect
_TEXT	ENDS
END
