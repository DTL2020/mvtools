; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\github\mvtools\sources\mvcompensate.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DJ@FCDPFOCD@MCompensate?3?5temporal?5radius?5mus@ ; `string'
PUBLIC	??_C@_07JLHMJBGG@vectors?$AA@			; `string'
PUBLIC	??_C@_0CH@IHPLPPID@MCompensate?3?5time?5must?5be?50?40?5to@ ; `string'
PUBLIC	??_C@_0DC@HONHEKNF@MCompensate?3?5recursion?5is?5not?5su@ ; `string'
PUBLIC	??_C@_0DP@PGJIDIOH@MCompensate?3?5fields?5option?5is?5fo@ ; `string'
PUBLIC	??_C@_0CP@GPGIFMBO@MCompensate?5?3?5wrong?5source?5or?5su@ ; `string'
PUBLIC	??_R4?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@	; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@MVCompensate@@8			; MVCompensate::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2MVCompensate@@8				; MVCompensate::`RTTI Base Class Array'
PUBLIC	??_R3?$MTSlicer@VMVCompensate@@V1@$0EA@@@8	; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3MVCompensate@@8				; MVCompensate::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7MVCompensate@@6B@				; MVCompensate::`vftable'
PUBLIC	??_R0?AVMVCompensate@@@8			; MVCompensate `RTTI Type Descriptor'
PUBLIC	??_R4MVCompensate@@6B@				; MVCompensate::`RTTI Complete Object Locator'
PUBLIC	??_R2?$MTSlicer@VMVCompensate@@V1@$0EA@@@8	; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Base Class Array'
PUBLIC	??_7?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@	; MTSlicer<MVCompensate,MVCompensate,64>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$MTSlicer@VMVCompensate@@V1@$0EA@@@8 ; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$MTSlicer@VMVCompensate@@V1@$0EA@@@@8	; MTSlicer<MVCompensate,MVCompensate,64> `RTTI Type Descriptor'
;	COMDAT ??_R0?AV?$MTSlicer@VMVCompensate@@V1@$0EA@@@@8
data$r	SEGMENT
??_R0?AV?$MTSlicer@VMVCompensate@@V1@$0EA@@@@8 DD FLAT:??_7type_info@@6B@ ; MTSlicer<MVCompensate,MVCompensate,64> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$MTSlicer@VMVCompensate@@V1@$0EA@@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$MTSlicer@VMVCompensate@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$MTSlicer@VMVCompensate@@V1@$0EA@@@8 DD FLAT:??_R0?AV?$MTSlicer@VMVCompensate@@V1@$0EA@@@@8 ; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$MTSlicer@VMVCompensate@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_7?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@
CONST	SEGMENT
??_7?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@ DD FLAT:??_R4?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@ ; MTSlicer<MVCompensate,MVCompensate,64>::`vftable'
	DD	FLAT:??_E?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$MTSlicer@VMVCompensate@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R2?$MTSlicer@VMVCompensate@@V1@$0EA@@@8 DD FLAT:??_R1A@?0A@EA@?$MTSlicer@VMVCompensate@@V1@$0EA@@@8 ; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4MVCompensate@@6B@
rdata$r	SEGMENT
??_R4MVCompensate@@6B@ DD 00H				; MVCompensate::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMVCompensate@@@8
	DD	FLAT:??_R3MVCompensate@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMVCompensate@@@8
data$r	SEGMENT
??_R0?AVMVCompensate@@@8 DD FLAT:??_7type_info@@6B@	; MVCompensate `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMVCompensate@@', 00H
data$r	ENDS
;	COMDAT ??_7MVCompensate@@6B@
CONST	SEGMENT
??_7MVCompensate@@6B@ DD FLAT:??_R4MVCompensate@@6B@	; MVCompensate::`vftable'
	DD	FLAT:?GetVersion@IClip@@UAGHXZ
	DD	FLAT:?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	FLAT:?GetParity@GenericVideoFilter@@UAG_NH@Z
	DD	FLAT:?GetAudio@GenericVideoFilter@@UAGXPAX_J1PAVIScriptEnvironment@@@Z
	DD	FLAT:?SetCacheHints@MVCompensate@@UAGHHH@Z
	DD	FLAT:?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ
	DD	FLAT:??_EMVCompensate@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R3MVCompensate@@8
rdata$r	SEGMENT
??_R3MVCompensate@@8 DD 00H				; MVCompensate::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2MVCompensate@@8
rdata$r	ENDS
;	COMDAT ??_R3?$MTSlicer@VMVCompensate@@V1@$0EA@@@8
rdata$r	SEGMENT
??_R3?$MTSlicer@VMVCompensate@@V1@$0EA@@@8 DD 00H	; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$MTSlicer@VMVCompensate@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_R2MVCompensate@@8
rdata$r	SEGMENT
??_R2MVCompensate@@8 DD FLAT:??_R1A@?0A@EA@MVCompensate@@8 ; MVCompensate::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GenericVideoFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IClip@@8
	DD	FLAT:??_R1EA@?0A@EA@MVFilter@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MVCompensate@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MVCompensate@@8 DD FLAT:??_R0?AVMVCompensate@@@8 ; MVCompensate::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MVCompensate@@8
rdata$r	ENDS
;	COMDAT ??_R4?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@
rdata$r	SEGMENT
??_R4?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@ DD 00H	; MTSlicer<MVCompensate,MVCompensate,64>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$MTSlicer@VMVCompensate@@V1@$0EA@@@@8
	DD	FLAT:??_R3?$MTSlicer@VMVCompensate@@V1@$0EA@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CP@GPGIFMBO@MCompensate?5?3?5wrong?5source?5or?5su@
CONST	SEGMENT
??_C@_0CP@GPGIFMBO@MCompensate?5?3?5wrong?5source?5or?5su@ DB 'MCompensat'
	DB	'e : wrong source or super frame size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@PGJIDIOH@MCompensate?3?5fields?5option?5is?5fo@
CONST	SEGMENT
??_C@_0DP@PGJIDIOH@MCompensate?3?5fields?5option?5is?5fo@ DB 'MCompensate'
	DB	': fields option is for fieldbased video and pel > 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HONHEKNF@MCompensate?3?5recursion?5is?5not?5su@
CONST	SEGMENT
??_C@_0DC@HONHEKNF@MCompensate?3?5recursion?5is?5not?5su@ DB 'MCompensate'
	DB	': recursion is not supported for Pel>1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IHPLPPID@MCompensate?3?5time?5must?5be?50?40?5to@
CONST	SEGMENT
??_C@_0CH@IHPLPPID@MCompensate?3?5time?5must?5be?50?40?5to@ DB 'MCompensa'
	DB	'te: time must be 0.0 to 100.0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLHMJBGG@vectors?$AA@
CONST	SEGMENT
??_C@_07JLHMJBGG@vectors?$AA@ DB 'vectors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@FCDPFOCD@MCompensate?3?5temporal?5radius?5mus@
CONST	SEGMENT
??_C@_0DJ@FCDPFOCD@MCompensate?3?5temporal?5radius?5mus@ DB 'MCompensate:'
	DB	' temporal radius must greater or equal to 0.', 00H ; `string'
PUBLIC	??0MvClipInfo@MVCompensate@@QAE@$$QAV01@@Z	; MVCompensate::MvClipInfo::MvClipInfo
PUBLIC	??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z ; std::allocator<MVCompensate::MvClipInfo>::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
PUBLIC	??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@$$QAV34@@Z ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
PUBLIC	??$forward@VMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z ; std::forward<MVCompensate::MvClipInfo>
PUBLIC	??1MvClipInfo@MVCompensate@@QAE@XZ		; MVCompensate::MvClipInfo::~MvClipInfo
PUBLIC	??_GMvClipInfo@MVCompensate@@QAEPAXI@Z		; MVCompensate::MvClipInfo::`scalar deleting destructor'
PUBLIC	??0MvClipInfo@MVCompensate@@QAE@XZ		; MVCompensate::MvClipInfo::MvClipInfo
PUBLIC	??$destroy@VMvClipInfo@MVCompensate@@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ; std::allocator<MVCompensate::MvClipInfo>::destroy<MVCompensate::MvClipInfo>
PUBLIC	??$construct@VMvClipInfo@MVCompensate@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
PUBLIC	??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ; std::allocator<MVCompensate::MvClipInfo>::construct<MVCompensate::MvClipInfo>
PUBLIC	??$move@AAVMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z ; std::move<MVCompensate::MvClipInfo &>
PUBLIC	??$destroy@VMvClipInfo@MVCompensate@@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::destroy<MVCompensate::MvClipInfo>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	??$_Ptr_move_cat@VMvClipInfo@MVCompensate@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MVCompensate@@0@Z ; std::_Ptr_move_cat<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
PUBLIC	??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo>
PUBLIC	??$destroy@VMvClipInfo@MVCompensate@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::destroy<MVCompensate::MvClipInfo>
PUBLIC	??$_Rechecked@PAVMvClipInfo@MVCompensate@@PAV12@@std@@YAAAPAVMvClipInfo@MVCompensate@@AAPAV12@PAV12@@Z ; std::_Rechecked<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	??$_Unchecked@PAVMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z ; std::_Unchecked<MVCompensate::MvClipInfo *>
PUBLIC	??$construct@VMvClipInfo@MVCompensate@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo>
PUBLIC	??$_Unfancy@VMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z ; std::_Unfancy<MVCompensate::MvClipInfo>
PUBLIC	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
PUBLIC	??$_Uninitialized_move@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ; std::_Uninitialized_move<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	??A?$Array@VTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@J@Z ; conc::Array<MTSlicer<MVCompensate,MVCompensate,64>::TaskData,64>::operator[]
PUBLIC	?redirect_task@?$MTSlicer@VMVCompensate@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<MVCompensate,MVCompensate,64>::redirect_task
PUBLIC	??0?$allocator@VMvClipInfo@MVCompensate@@@std@@QAE@XZ ; std::allocator<MVCompensate::MvClipInfo>::allocator<MVCompensate::MvClipInfo>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >
PUBLIC	?access@?$MTSlicer_Access@VMVCompensate@@V1@@@SAPAVMVCompensate@@PAV2@@Z ; MTSlicer_Access<MVCompensate,MVCompensate>::access
PUBLIC	??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z ; MTSlicer<MVCompensate,MVCompensate,64>::`scalar deleting destructor'
PUBLIC	??$_Destroy_range@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
PUBLIC	??$_Umove@PAVMvClipInfo@MVCompensate@@@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEPAVMvClipInfo@MVCompensate@@PAV23@00@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Umove<MVCompensate::MvClipInfo *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1><>
PUBLIC	??$_Uninitialized_default_fill_n@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ ; MTSlicer<MVCompensate,MVCompensate,64>::wait
PUBLIC	?start@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXHAAVMVCompensate@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MVCompensate,MVCompensate,64>::start
PUBLIC	??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ	; MTSlicer<MVCompensate,MVCompensate,64>::~MTSlicer<MVCompensate,MVCompensate,64>
PUBLIC	??0?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAE@_N@Z	; MTSlicer<MVCompensate,MVCompensate,64>::MTSlicer<MVCompensate,MVCompensate,64>
PUBLIC	?get@?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ	; SharedPtr<MVClip>::get
PUBLIC	?max_size@?$allocator@VMvClipInfo@MVCompensate@@@std@@QBEIXZ ; std::allocator<MVCompensate::MvClipInfo>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MVCompensate@@@2@@Z ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z ; std::allocator<MVCompensate::MvClipInfo>::deallocate
PUBLIC	?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ; std::allocator<MVCompensate::MvClipInfo>::allocate
PUBLIC	?capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Getal
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myend
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_second
PUBLIC	?_Unused_capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Unused_capacity
PUBLIC	?max_size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::max_size
PUBLIC	?_Destroy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXPAVMvClipInfo@MVCompensate@@0@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Destroy
PUBLIC	?_Grow_to@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEII@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Grow_to
PUBLIC	?_Reallocate@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reallocate
PUBLIC	?_Xlen@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEXXZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Xlen
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Orphan_all
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myend
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_first
PUBLIC	?_Pop_back_n@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Pop_back_n
PUBLIC	?_Buy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAE_NI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Buy
PUBLIC	?_Reserve@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reserve
PUBLIC	?_Tidy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXXZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Mylast
PUBLIC	??0?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@I@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	??1?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::~vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >
PUBLIC	?resize@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::resize
PUBLIC	?size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::size
PUBLIC	??A?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEAAVMvClipInfo@MVCompensate@@I@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::operator[]
PUBLIC	?compute_src_frame@MVCompensate@@ABE_NAAH00H@Z	; MVCompensate::compute_src_frame
PUBLIC	?compensate_slice_overlap@MVCompensate@@AAEXHH@Z ; MVCompensate::compensate_slice_overlap
PUBLIC	?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z ; MVCompensate::compensate_slice_overlap
PUBLIC	?compensate_slice_normal@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z ; MVCompensate::compensate_slice_normal
PUBLIC	?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ; MVCompensate::GetFrame
PUBLIC	??1MVCompensate@@UAE@XZ				; MVCompensate::~MVCompensate
PUBLIC	??_GMVCompensate@@UAEPAXI@Z			; MVCompensate::`scalar deleting destructor'
PUBLIC	?SetCacheHints@MVCompensate@@UAGHHH@Z		; MVCompensate::SetCacheHints
PUBLIC	??BPClip@@QBEPAXXZ				; PClip::operator void *
PUBLIC	??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z ; MVCompensate::MVCompensate
EXTRN	??_E?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z:PROC ; MTSlicer<MVCompensate,MVCompensate,64>::`vector deleting destructor'
EXTRN	??_EMVCompensate@@UAEPAXI@Z:PROC		; MVCompensate::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$10
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$12
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$14
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$15
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$17
	DD	08H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$18
	DD	02H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$43
	DD	01H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$44
	DD	00H
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$45
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$46
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MVCompensate@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1MVCompensate@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1MVCompensate@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVCompensate@@UAE@XZ$34
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVCompensate@@UAE@XZ$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1MVCompensate@@UAE@XZ$69
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$21
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7
	DD	02H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23
	DD	01H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z$0
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvclip.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\commonfunctions.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
;	COMDAT ??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__child$ = 8						; size = 4
__super$ = 12						; size = 4
_vectors$ = 16						; size = 4
_nHeightS$1$ = 20					; size = 4
$T5 = 20						; size = 4
_sc$ = 20						; size = 1
__recursionPercent$ = 24				; size = 8
_thsad$ = 32						; size = 4
$T6 = 36						; size = 4
$T7 = 36						; size = 4
__fields$ = 36						; size = 1
__time100$ = 40						; size = 8
_nSCD1$ = 48						; size = 4
_nSCD2$ = 52						; size = 4
_nSuperLevels$1$ = 56					; size = 4
tv2322 = 56						; size = 4
$T8 = 56						; size = 4
__isse2$ = 56						; size = 1
__planar$ = 60						; size = 1
_mt_flag$ = 64						; size = 1
_k$1$ = 68						; size = 4
$T9 = 68						; size = 4
_trad$ = 68						; size = 4
$T10 = 72						; size = 4
_nSuperModeYUV$1$ = 72					; size = 4
_k$1$ = 72						; size = 4
tv2323 = 72						; size = 4
$T11 = 72						; size = 4
$T12 = 72						; size = 4
$T13 = 72						; size = 4
$T14 = 72						; size = 4
$T15 = 72						; size = 4
_center_flag$ = 72					; size = 1
_cclip_sptr$ = 76					; size = 4
_thsad2$ = 80						; size = 4
_env_ptr$ = 84						; size = 4
??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z PROC ; MVCompensate::MVCompensate, COMDAT
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvcompensate.cpp

; 42   : :	GenericVideoFilter(_child)

	push	ecx
	mov	ecx, esp
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	test	eax, eax
	je	SHORT $LN79@MVCompensa
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN79@MVCompensa
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __child$[ebp]
	push	edx
	call	eax
$LN79@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 42   : :	GenericVideoFilter(_child)

	mov	ecx, ebx
	call	??0GenericVideoFilter@@QAE@VPClip@@@Z	; GenericVideoFilter::GenericVideoFilter

; 43   : ,	_mv_clip_arr (1)
; 44   : ,	MVFilter(vectors, "MCompensate", env_ptr, 1, 0)

	mov	esi, DWORD PTR _env_ptr$[ebp]
	lea	ecx, DWORD PTR _vectors$[ebp]
	push	0
	push	1
	push	esi
	push	OFFSET ??_C@_0M@NJDGAAIB@MCompensate?$AA@
	push	ecx
	lea	ecx, DWORD PTR [ebx+64]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??0MVFilter@@IAE@ABVPClip@@PBDPAVIScriptEnvironment@@HH@Z ; MVFilter::MVFilter
	lea	edi, DWORD PTR [ebx+152]

; 54   : {

	mov	DWORD PTR [ebx], OFFSET ??_7MVCompensate@@6B@
	push	ecx
	mov	ecx, edi
	call	??0?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@I@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 45   : ,	super(_super)

	lea	ecx, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN83@MVCompensa
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN83@MVCompensa
	mov	eax, DWORD PTR [eax+232]
	lea	edx, DWORD PTR __super$[ebp]
	push	edx
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN83@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 46   : ,	_trad (trad)

	mov	ecx, DWORD PTR _trad$[ebp]

; 47   : ,	_cclip_sptr ((cclip_sptr != 0) ? cclip_sptr : _child)

	lea	esi, DWORD PTR __child$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	edx, DWORD PTR _cclip_sptr$[ebp]
	cmp	DWORD PTR _cclip_sptr$[ebp], 0
	mov	DWORD PTR [ebx+292], ecx
	cmove	edx, esi
; File c:\github\mvtools\sources\include\avisynth.h

; 937  :   PClip(const PClip& x) AVS_BakedCode( AVS_LinkCall(PClip_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR _env_ptr$[ebp]
	test	eax, eax
	je	SHORT $LN89@MVCompensa
	cmp	DWORD PTR [eax], 232			; 000000e8H
	jbe	SHORT $LN89@MVCompensa
	mov	eax, DWORD PTR [eax+232]
	lea	ecx, DWORD PTR [ebx+296]
	push	edx
	call	eax
	mov	ecx, DWORD PTR _trad$[ebp]
$LN89@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 48   : ,	_multi_flag (trad > 0)

	test	ecx, ecx
	setg	al
	mov	BYTE PTR [ebx+300], al

; 49   : ,	_center_flag (center_flag)

	mov	al, BYTE PTR _center_flag$[ebp]
	mov	BYTE PTR [ebx+301], al

; 50   : ,	_mt_flag (mt_flag)

	mov	eax, DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR [ebx+302], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ebx+396], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ebx+400], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ebx+404], 0
; File c:\github\mvtools\sources\mvcompensate.cpp

; 53   : ,	_boundary_cnt_arr ()

	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 55   : 	if (trad < 0)

	test	ecx, ecx
	jns	SHORT $LN8@MVCompensa

; 56   : 	{
; 57   : 		env_ptr->ThrowError (

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0DJ@FCDPFOCD@MCompensate?3?5temporal?5radius?5mus@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN8@MVCompensa:

; 58   : 			"MCompensate: temporal radius must greater or equal to 0."
; 59   : 		);
; 60   : 	}
; 61   : 
; 62   : 	if (_trad <= 0)

	mov	eax, DWORD PTR [ebx+292]
	test	eax, eax
	jg	$LN9@MVCompensa

; 64   : 		_mv_clip_arr [0]._clip_sptr =

	push	240					; 000000f0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	push	0
	push	1
	push	esi
	push	DWORD PTR _nSCD2$[ebp]
	lea	ecx, DWORD PTR _vectors$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	DWORD PTR _nSCD1$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	DWORD PTR $T9[ebp], eax
; File c:\github\mvtools\sources\sharedptr.hpp

; 45   : :	_obj_ptr (ptr)

	mov	DWORD PTR $T2[ebp], eax

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	test	eax, eax
	je	SHORT $LN104@MVCompensa
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR [eax], 1
	jmp	SHORT $LN298@MVCompensa
$LN104@MVCompensa:
	xor	eax, eax
$LN298@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 64   : 		_mv_clip_arr [0]._clip_sptr =

	mov	ecx, DWORD PTR [edi]
; File c:\github\mvtools\sources\sharedptr.hpp

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	mov	DWORD PTR $T2[ebp+4], eax
	mov	DWORD PTR $T10[ebp], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 64   : 		_mv_clip_arr [0]._clip_sptr =

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??4?$SharedPtr@VMVClip@@@@QAEAAV0@ABV0@@Z ; SharedPtr<MVClip>::operator=
; File c:\github\mvtools\sources\sharedptr.hpp

; 284  : 	if (_obj_ptr != 0)

	mov	ecx, DWORD PTR $T9[ebp]
	test	ecx, ecx
	je	$LN10@MVCompensa
	mov	eax, DWORD PTR $T10[ebp]
	add	DWORD PTR [eax], -1

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	jne	$LN10@MVCompensa

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR $T10[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File c:\github\mvtools\sources\mvcompensate.cpp

; 67   : 	else

	jmp	$LN10@MVCompensa
$LN9@MVCompensa:

; 68   : 	{
; 69   : 		_mv_clip_arr.resize (_trad * 2);

	add	eax, eax
	mov	ecx, edi
	push	eax
	call	?resize@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::resize

; 70   : 		for (int k = 0; k < _trad * 2; ++k)

	mov	eax, DWORD PTR [ebx+292]
	xor	edi, edi
	add	eax, eax
	mov	DWORD PTR _k$1$[ebp], edi
	test	eax, eax
	jle	$LN3@MVCompensa

; 68   : 	{
; 69   : 		_mv_clip_arr.resize (_trad * 2);

	mov	DWORD PTR tv2323[ebp], edi
	npad	9
$LL4@MVCompensa:

; 72   : 			_mv_clip_arr [k]._clip_sptr = MVClipSPtr (

	push	240					; 000000f0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	push	edi
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR [ebx+292]
	add	ecx, ecx
	push	ecx
	push	esi
	push	DWORD PTR _nSCD2$[ebp]
	lea	ecx, DWORD PTR _vectors$[ebp]
	push	DWORD PTR _nSCD1$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0MVClip@@QAE@ABVPClip@@HHPAVIScriptEnvironment@@HH@Z ; MVClip::MVClip
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	DWORD PTR $T4[ebp], ecx
; File c:\github\mvtools\sources\sharedptr.hpp

; 46   : ,	_count_ptr ((ptr != 0) ? new long (1) : 0)

	test	ecx, ecx
	je	SHORT $LN130@MVCompensa
	push	4
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR $T4[ebp]
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR [edi], 1
	jmp	SHORT $LN131@MVCompensa
$LN130@MVCompensa:
	xor	edi, edi
$LN131@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 72   : 			_mv_clip_arr [k]._clip_sptr = MVClipSPtr (

	mov	esi, DWORD PTR [ebx+152]
	add	esi, DWORD PTR tv2323[ebp]
; File c:\github\mvtools\sources\sharedptr.hpp

; 81   : 	if (other._obj_ptr != _obj_ptr)

	mov	eax, DWORD PTR [esi]
	cmp	ecx, eax
	je	SHORT $LN153@MVCompensa

; 284  : 	if (_obj_ptr != 0)

	test	eax, eax
	je	SHORT $LN148@MVCompensa

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN148@MVCompensa

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN150@MVCompensa
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN150@MVCompensa:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR $T4[ebp]
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN148@MVCompensa:

; 84   : 		_obj_ptr = other._obj_ptr;

	mov	DWORD PTR [esi], ecx

; 85   : 		_count_ptr = other._count_ptr;

	mov	DWORD PTR [esi+4], edi

; 259  : 	if (_count_ptr != 0)

	test	edi, edi
	je	SHORT $LN153@MVCompensa

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [edi]
$LN153@MVCompensa:

; 284  : 	if (_obj_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN160@MVCompensa

; 285  : 	{
; 286  : 		-- *_count_ptr;

	add	DWORD PTR [edi], -1

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	jne	SHORT $LN160@MVCompensa

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN160@MVCompensa:

; 181  : 	return (*_obj_ptr);

	mov	eax, DWORD PTR [ebx+152]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 75   : 			CheckSimilarity (*(_mv_clip_arr [k]._clip_sptr), "vectors", env_ptr);

	lea	ecx, DWORD PTR [ebx+64]
	mov	esi, DWORD PTR _env_ptr$[ebp]
	mov	edi, DWORD PTR tv2323[ebp]
	push	esi
	push	OFFSET ??_C@_07JLHMJBGG@vectors?$AA@
	push	DWORD PTR [edi+eax]
	call	?CheckSimilarity@MVFilter@@IAEXABVMVClip@@PBDPAVIScriptEnvironment@@@Z ; MVFilter::CheckSimilarity
	mov	ecx, DWORD PTR _k$1$[ebp]
	add	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [ebx+292]
	inc	ecx
	add	eax, eax
	mov	DWORD PTR tv2323[ebp], edi
	mov	DWORD PTR _k$1$[ebp], ecx
	mov	edi, ecx
	cmp	ecx, eax
	jl	$LL4@MVCompensa
$LN3@MVCompensa:

; 76   : 		}
; 77   : 
; 78   : 		int				tbsize = _trad * 2;

	mov	eax, DWORD PTR [ebx+292]
	lea	edi, DWORD PTR [ebx+152]
	add	eax, eax
	cmp	BYTE PTR [ebx+301], 0
	lea	ecx, DWORD PTR [eax+1]
	cmove	ecx, eax

; 79   : 		if (_center_flag)
; 80   : 		{
; 81   : 			++ tbsize;
; 82   : 		}
; 83   : 
; 84   : 		vi.num_frames    *= tbsize;

	mov	eax, DWORD PTR [ebx+32]
	imul	eax, ecx
	mov	DWORD PTR [ebx+32], eax

; 85   : 		vi.fps_numerator *= tbsize;

	mov	eax, DWORD PTR [ebx+24]
	imul	eax, ecx
	mov	DWORD PTR [ebx+24], eax
$LN10@MVCompensa:

; 90   : 	recursion = std::max (0, std::min (256, int (_recursionPercent/100*256))); // convert to int scaled 0 to 256

	movsd	xmm0, QWORD PTR __recursionPercent$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR $T14[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 90   : 	recursion = std::max (0, std::min (256, int (_recursionPercent/100*256))); // convert to int scaled 0 to 256

	movsd	xmm2, QWORD PTR __real@4059000000000000
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	edx, DWORD PTR $T8[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 90   : 	recursion = std::max (0, std::min (256, int (_recursionPercent/100*256))); // convert to int scaled 0 to 256

	divsd	xmm0, xmm2
	mov	al, BYTE PTR __isse2$[ebp]
	mov	BYTE PTR [ebx+180], al
	mov	al, BYTE PTR _sc$[ebp]
	mov	BYTE PTR [ebx+164], al
	mov	DWORD PTR $T8[ebp], 256			; 00000100H
	mov	DWORD PTR $T5[ebp], 0

; 94   :   if (_time100 <0 || _time100 > 100)

	movsd	xmm1, QWORD PTR __time100$[ebp]
	mulsd	xmm0, QWORD PTR __real@4070000000000000
	cvttsd2si eax, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, 256				; 00000100H
; File c:\github\mvtools\sources\mvcompensate.cpp

; 90   : 	recursion = std::max (0, std::min (256, int (_recursionPercent/100*256))); // convert to int scaled 0 to 256

	mov	DWORD PTR $T14[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	eax, DWORD PTR $T5[ebp]

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovge	ecx, edx

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	DWORD PTR [ecx], 0
	cmovg	eax, ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 94   :   if (_time100 <0 || _time100 > 100)

	comisd	xmm0, xmm1
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+168], eax
	mov	al, BYTE PTR __fields$[ebp]
	mov	BYTE PTR [ebx+172], al
	mov	al, BYTE PTR __planar$[ebp]
	mov	BYTE PTR [ebx+181], al
	ja	SHORT $LN13@MVCompensa
	comisd	xmm1, xmm2
	jbe	SHORT $LN12@MVCompensa
$LN13@MVCompensa:

; 95   :     env_ptr->ThrowError("MCompensate: time must be 0.0 to 100.0");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CH@IHPLPPID@MCompensate?3?5time?5must?5be?50?40?5to@
	push	esi
	call	DWORD PTR [eax+20]
	movsd	xmm1, QWORD PTR __time100$[ebp]
	add	esp, 8
	movsd	xmm2, QWORD PTR __real@4059000000000000
$LN12@MVCompensa:

; 96   :   time256 = int(256 * _time100 / 100);
; 97   : 
; 98   : 	if (recursion>0 && nPel>1)

	cmp	DWORD PTR [ebx+168], 0
	mulsd	xmm1, QWORD PTR __real@4070000000000000
	divsd	xmm1, xmm2
	cvttsd2si eax, xmm1
	mov	DWORD PTR [ebx+184], eax
	jle	SHORT $LN14@MVCompensa
	cmp	DWORD PTR [ebx+104], 1
	jle	SHORT $LN14@MVCompensa

; 99   : 	{
; 100  : 		env_ptr->ThrowError("MCompensate: recursion is not supported for Pel>1");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0DC@HONHEKNF@MCompensate?3?5recursion?5is?5not?5su@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN14@MVCompensa:

; 103  : 	if (fields && nPel<2 && !vi.IsFieldBased())

	cmp	BYTE PTR [ebx+172], 0
	je	SHORT $LN15@MVCompensa
	cmp	DWORD PTR [ebx+104], 2
	jge	SHORT $LN15@MVCompensa
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN294@MVCompensa
	cmp	DWORD PTR [eax], 64			; 00000040H
	jbe	SHORT $LN294@MVCompensa
	mov	eax, DWORD PTR [eax+64]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 103  : 	if (fields && nPel<2 && !vi.IsFieldBased())

	lea	ecx, DWORD PTR [ebx+16]
; File c:\github\mvtools\sources\include\avisynth.h

; 637  :   bool IsFieldBased() const AVS_BakedCode(return AVS_LinkCall(IsFieldBased)())

	call	eax
	movzx	eax, al
; File c:\github\mvtools\sources\mvcompensate.cpp

; 103  : 	if (fields && nPel<2 && !vi.IsFieldBased())

	test	al, al
	jne	SHORT $LN15@MVCompensa
$LN294@MVCompensa:

; 104  : 	{
; 105  : 		env_ptr->ThrowError("MCompensate: fields option is for fieldbased video and pel > 1");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0DP@PGJIDIOH@MCompensate?3?5fields?5option?5is?5fo@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN15@MVCompensa:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [edi]
	imul	ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 109  : 	for (int k = 0; k < int (_mv_clip_arr.size ()); ++k)

	mov	DWORD PTR _k$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 109  : 	for (int k = 0; k < int (_mv_clip_arr.size ()); ++k)

	test	eax, eax
	jle	SHORT $LN6@MVCompensa
	xor	eax, eax
	mov	DWORD PTR tv2322[ebp], eax
$LL7@MVCompensa:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edi, DWORD PTR [edi]
	add	edi, eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 116  : 		c_info._thsad = ClipFnc::interpolate_thsad (thsadn, thsadn2, d, _trad); // P.F. when testing, d=0, _trad=1, will assert inside.

	push	DWORD PTR [ebx+292]
; File c:\github\mvtools\sources\sharedptr.hpp

; 171  : 	return (_obj_ptr);

	mov	eax, DWORD PTR [edi]
; File c:\github\mvtools\sources\mvclip.h

; 83   :    inline sad_t GetThSCD1() const { return nSCD1; }

	mov	ecx, DWORD PTR [eax+216]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 113  : 		const sad_t		thsadn  = thsad  * thscd1 / nSCD1; // PF check todo bits_per_pixel

	mov	eax, ecx
	imul	eax, DWORD PTR _thsad$[ebp]

; 114  : 		const sad_t		thsadn2 = thsad2 * thscd1 / nSCD1;

	imul	ecx, DWORD PTR _thsad2$[ebp]
	cdq
	idiv	DWORD PTR _nSCD1$[ebp]
	mov	esi, eax
	mov	eax, ecx
	cdq
	idiv	DWORD PTR _nSCD1$[ebp]
	mov	ecx, eax

; 115  : 		const int		d       = k / 2 + 1;

	mov	eax, DWORD PTR _k$1$[ebp]
	cdq
	sub	eax, edx

; 116  : 		c_info._thsad = ClipFnc::interpolate_thsad (thsadn, thsadn2, d, _trad); // P.F. when testing, d=0, _trad=1, will assert inside.

	mov	edx, ecx
	sar	eax, 1
	mov	ecx, esi
	inc	eax
	push	eax
	call	?interpolate_thsad@ClipFnc@@SAHHHHH@Z	; ClipFnc::interpolate_thsad
	mov	esi, DWORD PTR _k$1$[ebp]
	add	esp, 8
	add	DWORD PTR tv2322[ebp], 12		; 0000000cH
	inc	esi
	mov	DWORD PTR [edi+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	lea	edi, DWORD PTR [ebx+152]
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [edi]
	imul	ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 109  : 	for (int k = 0; k < int (_mv_clip_arr.size ()); ++k)

	mov	DWORD PTR _k$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 109  : 	for (int k = 0; k < int (_mv_clip_arr.size ()); ++k)

	cmp	esi, eax
	mov	eax, DWORD PTR tv2322[ebp]
	jl	SHORT $LL7@MVCompensa
$LN6@MVCompensa:

; 117  : 	}
; 118  : 
; 119  :     // in overlaps.h
; 120  :     // OverlapsLsbFunction
; 121  :     // OverlapsFunction
; 122  :     // in M(V)DegrainX: DenoiseXFunction
; 123  :   /*
; 124  :     arch_t arch;
; 125  :     if ((pixelsize == 1) && (((env_ptr->GetCPUFlags() & CPUF_SSE2) != 0) & isse2))
; 126  :         arch = USE_SSE2;
; 127  :     else if ((pixelsize == 1) && isse2)
; 128  :         arch = USE_MMX;
; 129  :     else
; 130  :         arch = NO_SIMD;
; 131  :         */
; 132  :   arch_t arch;
; 133  :   if ((((env_ptr->GetCPUFlags() & CPUF_AVX2) != 0) & isse_flag))

	mov	esi, DWORD PTR _env_ptr$[ebp]
	push	esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
	movzx	ecx, BYTE PTR [ebx+180]
	shr	eax, 13					; 0000000dH
	and	ecx, eax
	test	cl, 1
	je	SHORT $LN16@MVCompensa

; 134  :     arch = USE_AVX2;

	mov	edi, 6
	jmp	SHORT $LN22@MVCompensa
$LN16@MVCompensa:

; 135  :   else if ((((env_ptr->GetCPUFlags() & CPUF_AVX) != 0) & isse_flag))

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
	movzx	ecx, BYTE PTR [ebx+180]
	shr	eax, 11					; 0000000bH
	and	ecx, eax
	test	cl, 1
	je	SHORT $LN18@MVCompensa

; 136  :     arch = USE_AVX;

	mov	edi, 5
	jmp	SHORT $LN22@MVCompensa
$LN18@MVCompensa:

; 137  :   else if ((((env_ptr->GetCPUFlags() & CPUF_SSE4_1) != 0) & isse_flag))

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
	movzx	ecx, BYTE PTR [ebx+180]
	shr	eax, 10					; 0000000aH
	and	ecx, eax
	test	cl, 1
	je	SHORT $LN20@MVCompensa

; 138  :     arch = USE_SSE41;

	mov	edi, 3
	jmp	SHORT $LN22@MVCompensa
$LN20@MVCompensa:

; 139  :   else if ((((env_ptr->GetCPUFlags() & CPUF_SSE2) != 0) & isse_flag))

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
	shr	eax, 5
	movzx	edi, al
	movzx	eax, BYTE PTR [ebx+180]
	and	edi, eax
	and	edi, 1
	add	edi, edi
$LN22@MVCompensa:

; 140  :     arch = USE_SSE2;
; 141  :   /*  else if ((pixelsize == 1) && _isse_flag) // PF no MMX support
; 142  :   arch = USE_MMX;*/
; 143  :   else
; 144  :     arch = NO_SIMD;
; 145  : 
; 146  : 
; 147  :     OVERSLUMA   = get_overlaps_function(nBlkSizeX, nBlkSizeY, pixelsize, arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+76]
	push	edi
	push	DWORD PTR [ebx+136]
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 148  :     OVERSCHROMA = get_overlaps_function(nBlkSizeX >> nLogxRatioUV, nBlkSizeY >> nLogyRatioUV, pixelsize, arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+132]
	mov	DWORD PTR [ebx+208], eax
	mov	eax, DWORD PTR [ebx+76]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	edi
	push	DWORD PTR [ebx+136]
	sar	eax, cl
	mov	ecx, eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 149  :     BLITLUMA = get_copy_function(nBlkSizeX, nBlkSizeY, pixelsize, arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+76]
	push	edi
	push	DWORD PTR [ebx+136]
	mov	DWORD PTR [ebx+212], eax
	call	?get_copy_function@@YAP6AXPAEHPBEH@ZHHHW4arch_t@@@Z ; get_copy_function

; 150  :     BLITCHROMA = get_copy_function(nBlkSizeX >> nLogxRatioUV, nBlkSizeY >> nLogyRatioUV, pixelsize, arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+132]
	mov	DWORD PTR [ebx+188], eax
	mov	eax, DWORD PTR [ebx+76]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	edi
	push	DWORD PTR [ebx+136]
	sar	eax, cl
	mov	ecx, eax
	call	?get_copy_function@@YAP6AXPAEHPBEH@ZHHHW4arch_t@@@Z ; get_copy_function

; 151  :     // 161115
; 152  :     OVERSLUMA16 = get_overlaps_function(nBlkSizeX, nBlkSizeY, sizeof(uint16_t), arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+76]
	push	edi
	push	2
	mov	DWORD PTR [ebx+192], eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function

; 153  :     OVERSCHROMA16 = get_overlaps_function(nBlkSizeX >> nLogxRatioUV, nBlkSizeY >> nLogyRatioUV, sizeof(uint16_t), arch);

	mov	edx, DWORD PTR [ebx+80]
	mov	ecx, DWORD PTR [ebx+132]
	mov	DWORD PTR [ebx+216], eax
	mov	eax, DWORD PTR [ebx+76]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+128]
	sar	eax, cl
	push	edi
	push	2
	mov	ecx, eax
	call	?get_overlaps_function@@YAP6AXPAGHPBEHPAFH@ZHHHW4arch_t@@@Z ; get_overlaps_function
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 153  :     OVERSCHROMA16 = get_overlaps_function(nBlkSizeX >> nLogxRatioUV, nBlkSizeY >> nLogyRatioUV, sizeof(uint16_t), arch);

	add	esp, 48					; 00000030H
	mov	DWORD PTR [ebx+220], eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN49@MVCompensa
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN48@MVCompensa
$LN49@MVCompensa:
	push	ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 158  : 	memcpy(&params, &super->GetVideoInfo().num_audio_samples, 8);

	call	eax
$LN48@MVCompensa:
	mov	edx, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR [eax+32]

; 159  : 	int nHeightS = params.nHeight;

	movzx	eax, cx
	mov	DWORD PTR _nHeightS$1$[ebp], eax

; 160  : 	nSuperHPad = params.nHPad;

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	movzx	eax, al
	mov	DWORD PTR [ebx+252], eax

; 163  : 	int nSuperModeYUV = params.nModeYUV;

	mov	eax, edx
	shr	eax, 8
	shr	ecx, 24					; 00000018H
	movzx	eax, al
	mov	DWORD PTR [ebx+256], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 162  : 	int nSuperPel = params.nPel;

	movzx	edi, dl

; 163  : 	int nSuperModeYUV = params.nModeYUV;

	mov	DWORD PTR _nSuperModeYUV$1$[ebp], eax

; 164  : 	int nSuperLevels = params.nLevels;

	shr	edx, 16					; 00000010H
	movzx	eax, dl
	mov	DWORD PTR _nSuperLevels$1$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN51@MVCompensa
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN50@MVCompensa
$LN51@MVCompensa:
	push	ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 165  :   pixelsize_super = super->GetVideoInfo().ComponentSize();

	call	eax
$LN50@MVCompensa:
; File c:\github\mvtools\sources\include\avisynth.h

; 692  :   int ComponentSize() const AVS_BakedCode(return AVS_LinkCallOptDefault(ComponentSize, 1))

	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN236@MVCompensa
	cmp	DWORD PTR [edx], 532			; 00000214H
	jbe	SHORT $LN236@MVCompensa
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+532]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN237@MVCompensa
$LN236@MVCompensa:
	mov	eax, 1
$LN237@MVCompensa:

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 165  :   pixelsize_super = super->GetVideoInfo().ComponentSize();

	mov	DWORD PTR [ebx+388], eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN53@MVCompensa
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN52@MVCompensa
$LN53@MVCompensa:
	push	ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 166  :   bits_per_pixel_super = super->GetVideoInfo().BitsPerComponent();

	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN52@MVCompensa:
; File c:\github\mvtools\sources\include\avisynth.h

; 695  :   int BitsPerComponent() const AVS_BakedCode(return AVS_LinkCallOptDefault(BitsPerComponent, 8))

	test	edx, edx
	je	SHORT $LN244@MVCompensa
	cmp	DWORD PTR [edx], 536			; 00000218H
	jbe	SHORT $LN244@MVCompensa
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+536]
	call	eax
	jmp	SHORT $LN245@MVCompensa
$LN244@MVCompensa:
	mov	eax, 8
$LN245@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 169  : 	pRefGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse_flag, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	push	44					; 0000002cH
	mov	DWORD PTR [ebx+392], eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T7[ebp], ecx
	push	DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	push	DWORD PTR [ebx+140]
	movzx	eax, BYTE PTR [ebx+180]
	push	DWORD PTR [ebx+136]
	push	DWORD PTR [ebx+124]
	push	DWORD PTR [ebx+120]
	push	eax
	push	DWORD PTR _nSuperModeYUV$1$[ebp]
	push	DWORD PTR [ebx+256]
	push	DWORD PTR [ebx+252]
	push	edi
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	push	DWORD PTR _nSuperLevels$1$[ebp]
	call	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ; MVGroupOfFrames::MVGroupOfFrames
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 170  : 	pSrcGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse_flag, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	push	44					; 0000002cH
	mov	DWORD PTR [ebx+260], eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], ecx
	push	DWORD PTR _mt_flag$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	push	DWORD PTR [ebx+140]
	movzx	eax, BYTE PTR [ebx+180]
	push	DWORD PTR [ebx+136]
	push	DWORD PTR [ebx+124]
	push	DWORD PTR [ebx+120]
	push	eax
	push	DWORD PTR _nSuperModeYUV$1$[ebp]
	push	DWORD PTR [ebx+256]
	push	DWORD PTR [ebx+252]
	push	edi
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	push	DWORD PTR _nSuperLevels$1$[ebp]
	call	??0MVGroupOfFrames@@QAE@HHHHHHH_NHHHH0@Z ; MVGroupOfFrames::MVGroupOfFrames
	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 170  : 	pSrcGOF = new MVGroupOfFrames(nSuperLevels, nWidth, nHeight, nSuperPel, nSuperHPad, nSuperVPad, nSuperModeYUV, isse_flag, xRatioUV, yRatioUV, pixelsize, bits_per_pixel, mt_flag);

	mov	DWORD PTR [ebx+264], eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN55@MVCompensa
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN54@MVCompensa
$LN55@MVCompensa:
	push	ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 171  : 	nSuperWidth = super->GetVideoInfo().width;

	call	eax
$LN54@MVCompensa:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	ecx, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 171  : 	nSuperWidth = super->GetVideoInfo().width;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+244], eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, OFFSET ?GetVideoInfo@GenericVideoFilter@@UAGABUVideoInfo@@XZ ; GenericVideoFilter::GetVideoInfo
	jne	SHORT $LN57@MVCompensa
; File c:\github\mvtools\sources\include\avisynth.h

; 1108 :   const VideoInfo& __stdcall GetVideoInfo() { return vi; }

	lea	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN56@MVCompensa
$LN57@MVCompensa:
	push	ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 172  : 	nSuperHeight = super->GetVideoInfo().height;

	call	eax
$LN56@MVCompensa:
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+248], eax

; 173  : 
; 174  : 	if (   nHeight != nHeightS
; 175  : 	    || nHeight != vi.height
; 176  : 	    || nWidth  != nSuperWidth - nSuperHPad * 2
; 177  : 	    || nWidth  != vi.width
; 178  : 	    || nPel    != nSuperPel)

	mov	eax, DWORD PTR [ebx+96]
	cmp	eax, DWORD PTR _nHeightS$1$[ebp]
	jne	SHORT $LN25@MVCompensa
	cmp	eax, DWORD PTR [ebx+20]
	jne	SHORT $LN25@MVCompensa
	mov	ecx, DWORD PTR [ebx+252]
	mov	eax, DWORD PTR [ebx+244]
	add	ecx, ecx
	mov	edx, DWORD PTR [ebx+92]
	sub	eax, ecx
	cmp	edx, eax
	jne	SHORT $LN25@MVCompensa
	cmp	edx, DWORD PTR [ebx+16]
	jne	SHORT $LN25@MVCompensa
	cmp	DWORD PTR [ebx+104], edi
	je	SHORT $LN24@MVCompensa
$LN25@MVCompensa:

; 179  : 	{
; 180  : 		env_ptr->ThrowError("MCompensate : wrong source or super frame size");

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_0CP@GPGIFMBO@MCompensate?5?3?5wrong?5source?5or?5su@
	push	esi
	call	DWORD PTR [eax+20]
	add	esp, 8
$LN24@MVCompensa:

; 181  : 	}
; 182  : 
; 183  : 
; 184  : 	if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN26@MVCompensa
	cmp	BYTE PTR [ebx+181], 0
	jne	SHORT $LN26@MVCompensa

; 186  : 		DstPlanes =  new YUY2Planes(nWidth, nHeight);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	mov	DWORD PTR $T13[ebp], edi
	mov	eax, DWORD PTR [ebx+92]
	mov	esi, DWORD PTR [ebx+96]
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], esi
; File c:\github\mvtools\sources\yuy2planes.cpp

; 28   :   srcPitch = (nWidth + 15) & (~15);

	lea	ecx, DWORD PTR [eax+15]

; 29   :   srcPitchUV = (nWidth / 2 + 15) & (~15); //v 1.2.1

	cdq
	and	ecx, -16				; fffffff0H
	sub	eax, edx

; 30   :   pSrc = (unsigned char*)_aligned_malloc(srcPitch*nHeight, 128);   //v 1.2.1

	imul	esi, ecx
	sar	eax, 1
	add	eax, 15					; 0000000fH
	mov	DWORD PTR [edi+20], ecx

; 29   :   srcPitchUV = (nWidth / 2 + 15) & (~15); //v 1.2.1

	and	eax, -16				; fffffff0H

; 30   :   pSrc = (unsigned char*)_aligned_malloc(srcPitch*nHeight, 128);   //v 1.2.1

	push	128					; 00000080H
	push	esi
	mov	esi, DWORD PTR __imp___aligned_malloc
	mov	DWORD PTR [edi+24], eax
	call	esi
	mov	DWORD PTR [edi], eax

; 31   :   pSrcU = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [edi+24]
	imul	eax, DWORD PTR [edi+16]
	push	128					; 00000080H
	push	eax
	call	esi
	mov	DWORD PTR [edi+4], eax

; 32   :   pSrcV = (unsigned char*)_aligned_malloc(srcPitchUV*nHeight, 128);

	mov	eax, DWORD PTR [edi+24]
	imul	eax, DWORD PTR [edi+16]
	push	128					; 00000080H
	push	eax
	call	esi
	mov	DWORD PTR [edi+8], eax
	add	esp, 28					; 0000001cH
; File c:\github\mvtools\sources\mvcompensate.cpp

; 186  : 		DstPlanes =  new YUY2Planes(nWidth, nHeight);

	mov	DWORD PTR [ebx+196], edi
$LN26@MVCompensa:
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	mov	edx, DWORD PTR [ebx+92]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 190  :   dstShortPitchUV = AlignNumber(nWidth >> nLogxRatioUV, 16); //  (((nWidth >> nLogxRatioUV) + 15) / 16) * 16;

	mov	ecx, DWORD PTR [ebx+128]
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [edx+15]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 190  :   dstShortPitchUV = AlignNumber(nWidth >> nLogxRatioUV, 16); //  (((nWidth >> nLogxRatioUV) + 15) / 16) * 16;

	sar	edx, cl
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	add	edx, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	and	edx, -16				; fffffff0H
; File c:\github\mvtools\sources\mvcompensate.cpp

; 189  :   dstShortPitch = AlignNumber(nWidth, 16); // ((nWidth + 15) / 16) * 16;

	mov	DWORD PTR [ebx+236], eax

; 191  : 	if (nOverlapX > 0 || nOverlapY > 0)

	cmp	DWORD PTR [ebx+108], 0
	mov	DWORD PTR [ebx+240], edx
	jg	SHORT $LN28@MVCompensa
	cmp	DWORD PTR [ebx+112], 0
	jle	$LN29@MVCompensa
$LN28@MVCompensa:

; 192  : 	{
; 193  : 		OverWins = new OverlapWindows(nBlkSizeX, nBlkSizeY, nOverlapX, nOverlapY);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, eax
	push	DWORD PTR [ebx+112]
	push	DWORD PTR [ebx+108]
	push	DWORD PTR [ebx+80]
	push	DWORD PTR [ebx+76]
	call	??0OverlapWindows@@QAE@HHHH@Z		; OverlapWindows::OverlapWindows
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 194  : 		OverWinsUV = new OverlapWindows(nBlkSizeX >> nLogxRatioUV, nBlkSizeY >> nLogyRatioUV, nOverlapX >> nLogxRatioUV, nOverlapY >> nLogyRatioUV);

	push	48					; 00000030H
	mov	DWORD PTR [ebx+200], eax
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T11[ebp], ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+132]
	mov	ecx, esi
	mov	edx, DWORD PTR [eax+112]
	mov	edi, DWORD PTR [eax+128]
	mov	eax, DWORD PTR [eax+108]
	sar	edx, cl
	mov	ecx, edi
	sar	eax, cl
	mov	ecx, esi
	push	edx
	mov	edx, DWORD PTR _this$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+80]
	sar	eax, cl
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [edx+76]
	sar	eax, cl
	mov	ecx, ebx
	push	eax
	call	??0OverlapWindows@@QAE@HHHH@Z		; OverlapWindows::OverlapWindows
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 195  : 		DstShort = new unsigned short[dstShortPitch*nHeight*pixelsize];   // pixelsize==2 -> int instead of short

	xor	ecx, ecx
	mov	ebx, DWORD PTR _this$[ebp]
	mov	esi, 2
	mov	DWORD PTR [ebx+204], eax
	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+236]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+224], eax

; 196  : 		DstShortU = new unsigned short[dstShortPitchUV*nHeight*pixelsize];

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+240]
	imul	eax, DWORD PTR [ebx+136]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+228], eax

; 197  : 		DstShortV = new unsigned short[dstShortPitchUV*nHeight*pixelsize];

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx+96]
	imul	eax, DWORD PTR [ebx+240]
	imul	eax, DWORD PTR [ebx+136]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ebx+232], eax

; 198  : 	}
; 199  : 	if (nOverlapY > 0)

	cmp	DWORD PTR [ebx+112], 0
	jle	SHORT $LN29@MVCompensa

; 200  : 	{
; 201  : 		_boundary_cnt_arr.resize (nBlkY);

	push	DWORD PTR [ebx+68]
	lea	ecx, DWORD PTR [ebx+396]
	call	?resize@?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAEXI@Z ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::resize
$LN29@MVCompensa:

; 202  : 	}
; 203  : 
; 204  : 	if (recursion>0)

	cmp	DWORD PTR [ebx+168], 0
	jle	$LN32@MVCompensa

; 205  : 	{
; 206  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 )

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN31@MVCompensa

; 207  : 		{
; 208  :       nLoopPitches[0] = AlignNumber(nSuperWidth * 2, 16); // ((nSuperWidth * 2 + 15) / 16) * 16;

	mov	eax, DWORD PTR [ebx+244]
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	lea	ecx, DWORD PTR [eax*2+15]
	and	ecx, -16				; fffffff0H
	mov	DWORD PTR [ebx+280], ecx
	mov	DWORD PTR [ebx+284], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 210  : 			nLoopPitches[2]  = nLoopPitches[1];

	mov	DWORD PTR [ebx+288], ecx

; 211  : 			pLoop[0] = new unsigned char [nLoopPitches[0]*nSuperHeight];

	mov	eax, DWORD PTR [ebx+248]
	imul	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+268], eax
	add	esp, 4

; 212  : 			pLoop[1] = pLoop[0] + nSuperWidth;

	mov	ecx, DWORD PTR [ebx+244]
	add	ecx, eax
	mov	DWORD PTR [ebx+272], ecx

; 213  : 			pLoop[2] = pLoop[1] + nSuperWidth/2;

	mov	eax, DWORD PTR [ebx+244]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx

; 214  : 		}
; 215  : 		else

	jmp	$LN300@MVCompensa
$LN31@MVCompensa:

; 216  : 		{
; 217  :       // todo check pixelsize_super?
; 218  :       nLoopPitches[0] = AlignNumber(nSuperWidth*pixelsize_super, 16); // ((nSuperWidth + 15) / 16) * 16; // todo pixelsize?

	mov	edx, DWORD PTR [ebx+244]
	imul	edx, DWORD PTR [ebx+388]
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	add	edx, 15					; 0000000fH
	and	edx, -16				; fffffff0H
	mov	DWORD PTR [ebx+280], edx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 219  :       nLoopPitches[1] = nLoopPitches[2] = AlignNumber((nSuperWidth >> nLogxRatioUV)*pixelsize_super, 16); // (((nSuperWidth >> nLogxRatioUV) + 15)/16)*16;

	mov	eax, DWORD PTR [ebx+244]
	mov	ecx, DWORD PTR [ebx+128]
	sar	eax, cl
	imul	eax, DWORD PTR [ebx+388]
; File c:\github\mvtools\sources\commonfunctions.h

; 138  :   return ALIGN_NUMBER(n, align);

	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
; File c:\github\mvtools\sources\mvcompensate.cpp

; 219  :       nLoopPitches[1] = nLoopPitches[2] = AlignNumber((nSuperWidth >> nLogxRatioUV)*pixelsize_super, 16); // (((nSuperWidth >> nLogxRatioUV) + 15)/16)*16;

	mov	DWORD PTR [ebx+288], eax
	mov	DWORD PTR [ebx+284], eax

; 220  : 			pLoop[0] = new unsigned char [nLoopPitches[0]*nSuperHeight];

	mov	eax, DWORD PTR [ebx+248]
	imul	eax, edx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+268], eax

; 221  : 			pLoop[1] = new unsigned char [nLoopPitches[1]*nSuperHeight];

	mov	eax, DWORD PTR [ebx+248]
	imul	eax, DWORD PTR [ebx+284]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+272], eax

; 222  : 			pLoop[2] = new unsigned char [nLoopPitches[2]*nSuperHeight];

	mov	eax, DWORD PTR [ebx+288]
	imul	eax, DWORD PTR [ebx+248]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 12					; 0000000cH
$LN300@MVCompensa:
	mov	DWORD PTR [ebx+276], eax
$LN32@MVCompensa:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN268@MVCompensa
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN268@MVCompensa
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __child$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN268@MVCompensa:
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	eax, eax
	je	SHORT $LN273@MVCompensa
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN273@MVCompensa
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR __super$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN273@MVCompensa:
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN278@MVCompensa
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN278@MVCompensa
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _vectors$[ebp]
	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN278@MVCompensa:
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	test	eax, eax
	je	SHORT $LN295@MVCompensa
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN295@MVCompensa
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR _cclip_sptr$[ebp]
	call	eax
$LN295@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 226  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	80					; 00000050H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$0:
	lea	ecx, DWORD PTR _cclip_sptr$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _vectors$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR __super$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR __child$[ebp]
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GenericVideoFilter@@UAE@XZ
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	jmp	??1?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::~vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	jmp	??1PClip@@QAE@XZ			; PClip::~PClip
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	jmp	??1?$vector@V?$AtomicInt@H@conc@@V?$allocator@V?$AtomicInt@H@conc@@@std@@@std@@QAE@XZ ; std::vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >::~vector<conc::AtomicInt<int>,std::allocator<conc::AtomicInt<int> > >
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$10:
	push	240					; 000000f0H
	mov	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$12:
	push	240					; 000000f0H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$14:
	push	44					; 0000002cH
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$15:
	push	44					; 0000002cH
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$17:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$18:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$43:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$44:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$45:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z$46:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MVCompensate@@QAE@VPClip@@00_NNH1NHH111H10HPAVIScriptEnvironment@@@Z ENDP ; MVCompensate::MVCompensate
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ?ilog2@@YAHH@Z
_TEXT	SEGMENT
?ilog2@@YAHH@Z PROC					; ilog2, COMDAT
; _i$ = ecx

; 24   : {

	mov	eax, ecx

; 25   : 	int result = 0;

	xor	ecx, ecx

; 26   : 	while ( i > 1 ) { i /= 2; result++; }

	cmp	eax, 1
	jle	SHORT $LN9@ilog2
	npad	7
$LL2@ilog2:
	cdq
	inc	ecx
	sub	eax, edx
	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL2@ilog2
$LN9@ilog2:

; 27   : 	return result;

	mov	eax, ecx

; 28   : }

	ret	0
?ilog2@@YAHH@Z ENDP					; ilog2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\include\avisynth.h
;	COMDAT ??BPClip@@QBEPAXXZ
_TEXT	SEGMENT
??BPClip@@QBEPAXXZ PROC					; PClip::operator void *, COMDAT
; _this$ = ecx

; 945  :   operator void*() const { return p; }

	mov	eax, DWORD PTR [ecx]
	ret	0
??BPClip@@QBEPAXXZ ENDP					; PClip::operator void *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.h
;	COMDAT ?SetCacheHints@MVCompensate@@UAGHHH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cachehints$ = 12					; size = 4
_frame_range$ = 16					; size = 4
?SetCacheHints@MVCompensate@@UAGHHH@Z PROC		; MVCompensate::SetCacheHints, COMDAT

; 39   :     return cachehints == CACHE_GET_MTMODE ? MT_MULTI_INSTANCE : 0;

	xor	eax, eax
	mov	ecx, 2
	cmp	DWORD PTR _cachehints$[esp-4], 509	; 000001fdH
	cmove	eax, ecx

; 40   :   }

	ret	12					; 0000000cH
?SetCacheHints@MVCompensate@@UAGHHH@Z ENDP		; MVCompensate::SetCacheHints
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GMVCompensate@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GMVCompensate@@UAEPAXI@Z PROC			; MVCompensate::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1MVCompensate@@UAE@XZ			; MVCompensate::~MVCompensate
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	408					; 00000198H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMVCompensate@@UAEPAXI@Z ENDP			; MVCompensate::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
;	COMDAT ??1MVCompensate@@UAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 1
__$EHRec$ = -12						; size = 12
??1MVCompensate@@UAE@XZ PROC				; MVCompensate::~MVCompensate, COMDAT
; _this$ = ecx

; 229  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1MVCompensate@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 230  : 	if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2  && !planar)

	mov	eax, DWORD PTR [edi+116]
	and	eax, 1610612740				; 60000004H
	mov	DWORD PTR [edi], OFFSET ??_7MVCompensate@@6B@
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN19@MVCompensa
	cmp	BYTE PTR [edi+181], 0
	jne	SHORT $LN19@MVCompensa

; 231  : 	{
; 232  : 		delete DstPlanes;

	push	ebx
	mov	ebx, DWORD PTR [edi+196]
	test	ebx, ebx
	je	SHORT $LN261@MVCompensa
; File c:\github\mvtools\sources\yuy2planes.cpp

; 37   :   _aligned_free(pSrc);

	push	DWORD PTR [ebx]
	mov	esi, DWORD PTR __imp___aligned_free
	call	esi

; 38   :   _aligned_free(pSrcU);

	push	DWORD PTR [ebx+4]
	call	esi

; 39   :   _aligned_free(pSrcV);

	push	DWORD PTR [ebx+8]
	call	esi
	push	28					; 0000001cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
$LN261@MVCompensa:
	pop	ebx
$LN19@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 234  : 	if (nOverlapX >0 || nOverlapY >0)

	cmp	DWORD PTR [edi+108], 0
	jg	SHORT $LN4@MVCompensa
	cmp	DWORD PTR [edi+112], 0
	jle	SHORT $LN3@MVCompensa
$LN4@MVCompensa:

; 235  : 	{
; 236  : 		delete OverWins;

	mov	ecx, DWORD PTR [edi+200]
	test	ecx, ecx
	je	SHORT $LN10@MVCompensa
	push	ecx
	call	??_GOverlapWindows@@QAEPAXI@Z
$LN10@MVCompensa:

; 237  : 		delete OverWinsUV;

	mov	ecx, DWORD PTR [edi+204]
	test	ecx, ecx
	je	SHORT $LN12@MVCompensa
	push	ecx
	call	??_GOverlapWindows@@QAEPAXI@Z
$LN12@MVCompensa:

; 238  : 		delete [] DstShort;

	push	DWORD PTR [edi+224]
	call	??_V@YAXPAX@Z				; operator delete[]

; 239  : 		delete [] DstShortU;

	push	DWORD PTR [edi+228]
	call	??_V@YAXPAX@Z				; operator delete[]

; 240  : 		delete [] DstShortV;

	push	DWORD PTR [edi+232]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
$LN3@MVCompensa:

; 241  : 	}
; 242  : 	delete pRefGOF; // v2.0

	mov	esi, DWORD PTR [edi+260]
	test	esi, esi
	je	SHORT $LN26@MVCompensa
	mov	ecx, esi
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN26@MVCompensa:

; 243  : 	delete pSrcGOF;

	mov	esi, DWORD PTR [edi+264]
	test	esi, esi
	je	SHORT $LN30@MVCompensa
	mov	ecx, esi
	call	??1MVGroupOfFrames@@QAE@XZ		; MVGroupOfFrames::~MVGroupOfFrames
	push	44					; 0000002cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN30@MVCompensa:

; 244  : 
; 245  : 	if (recursion>0)

	cmp	DWORD PTR [edi+168], 0
	jle	SHORT $LN6@MVCompensa

; 246  : 	{
; 247  : 		delete [] pLoop[0];

	push	DWORD PTR [edi+268]
	call	??_V@YAXPAX@Z				; operator delete[]

; 248  : 		if ( (pixelType & VideoInfo::CS_YUY2) != VideoInfo::CS_YUY2 )

	mov	eax, DWORD PTR [edi+116]
	add	esp, 4
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	je	SHORT $LN6@MVCompensa

; 249  : 		{
; 250  : 			delete [] pLoop[1];

	push	DWORD PTR [edi+272]
	call	??_V@YAXPAX@Z				; operator delete[]

; 251  : 			delete [] pLoop[2];

	push	DWORD PTR [edi+276]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
$LN6@MVCompensa:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi+396]
	test	ecx, ecx
	je	SHORT $LN37@MVCompensa

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [edi+404]
	sub	edx, ecx
	sar	edx, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi+396], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+400], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+404], 0
$LN37@MVCompensa:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN132@MVCompensa
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN132@MVCompensa
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 255  : }

	lea	ecx, DWORD PTR [edi+296]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN132@MVCompensa:
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN137@MVCompensa
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN137@MVCompensa
	mov	eax, DWORD PTR [eax+248]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 255  : }

	lea	ecx, DWORD PTR [edi+176]
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	call	eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN137@MVCompensa:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi+152]
	test	ecx, ecx
	je	SHORT $LN144@MVCompensa
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [edi+156]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	esi, DWORD PTR [edi+152]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [edi+160]
	sub	ecx, esi
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	edx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1645 : 			this->_Myend() = pointer();

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi+152], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+156], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+160], 0
$LN144@MVCompensa:
; File c:\github\mvtools\sources\include\avisynth.h

; 948  :   ~PClip() AVS_BakedCode( AVS_LinkCall(PClip_DESTRUCTOR)() )

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN258@MVCompensa
	cmp	DWORD PTR [eax], 248			; 000000f8H
	jbe	SHORT $LN258@MVCompensa
	mov	eax, DWORD PTR [eax+248]
	lea	ecx, DWORD PTR [edi+8]
	call	eax
$LN258@MVCompensa:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 255  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 919  :   virtual AVSC_CC ~IClip() {}

	mov	DWORD PTR [edi], OFFSET ??_7IClip@@6B@
	pop	edi
	pop	esi
; File c:\github\mvtools\sources\mvcompensate.cpp

; 255  : }

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MVCompensate@@UAE@XZ$34:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVCompensate@@UAE@XZ$35:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??1MVCompensate@@UAE@XZ$69:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1MVCompensate@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1MVCompensate@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MVCompensate@@UAE@XZ ENDP				; MVCompensate::~MVCompensate
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.cpp
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvanalysisdata.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvclip.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvgroupofframes.cpp
; File c:\github\mvtools\sources\mvframe.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\clipfnc.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\copycode.cpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\yuy2planes.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\include\avisynth.h
; File c:\github\mvtools\sources\mvcompensate.cpp
;	COMDAT ?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
_TEXT	SEGMENT
_slicer$2 = -1168					; size = 1056
$T3 = -100						; size = 4
_nOffset$1$ = -96					; size = 4
_nRefPitches$ = -92					; size = 12
_pRef$ = -80						; size = 12
_nOffset$4$ = -68					; size = 4
$T4 = -68						; size = 4
_mvn$ = -64						; size = 4
_nDstPitchYUY2$2$ = -60					; size = 4
_pDstYUY2$1$ = -60					; size = 4
_nDstPitchYUY2$1$ = -56					; size = 4
_pDstYUY2$2$ = -56					; size = 4
_src_pitch$1$ = -52					; size = 4
_row_size$1$ = -52					; size = 4
_nsrc$ = -52						; size = 4
_dstp$1$ = -48						; size = 4
_dstp$1$ = -44						; size = 4
_height$1$ = -40					; size = 4
_height$1$ = -40					; size = 4
_row_size$1$ = -40					; size = 4
_height$1$ = -40					; size = 4
_srcp$1$ = -40						; size = 4
_nref$1$ = -40						; size = 4
_nvec$ = -40						; size = 4
_pRef$1$ = -36						; size = 4
_pPitchesMapped$1$ = -36				; size = 4
_nRefPitches$2$ = -32					; size = 4
_pSrcMapped$1$ = -32					; size = 4
_pRef$2$ = -28						; size = 4
_row_size$1$ = -28					; size = 4
_row_size$1$ = -28					; size = 4
_src$ = -24						; size = 4
_nRefPitches$3$ = -20					; size = 4
_srcp$1$ = -20						; size = 4
_srcp$1$ = -20						; size = 4
_src_pitch$1$ = -20					; size = 4
_row_size$1$ = -20					; size = 4
_height$1$ = -20					; size = 4
$T5 = -20						; size = 4
_src_pitch$1$ = -16					; size = 4
_src_pitch$1$ = -16					; size = 4
_height$1$ = -16					; size = 4
_srcp$1$ = -16						; size = 4
_dstp$1$ = -16						; size = 4
_src_pitch$1$ = -16					; size = 4
_src_pitch$1$ = -16					; size = 4
tv4052 = -16						; size = 4
_vindex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ref$6 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_dst$ = 16						; size = 4
_n$ = 16						; size = 4
_nDstPitchYUY2$ = 20					; size = 4
_pDstYUY2$ = 20						; size = 4
_nref$ = 20						; size = 4
_env_ptr$ = 20						; size = 4
?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z PROC ; MVCompensate::GetFrame, COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1156				; 00000484H
	push	esi

; 260  : 	int				nsrc;
; 261  : 	int				nvec;
; 262  : 	int				vindex;
; 263  : 	const bool		comp_flag = compute_src_frame (nsrc, nvec, vindex, n);

	push	DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR _vindex$[ebp]
	push	eax
	lea	eax, DWORD PTR _nvec$[ebp]
	mov	DWORD PTR $T3[ebp], 0
	push	eax
	lea	eax, DWORD PTR _nsrc$[ebp]
	mov	ecx, esi
	push	eax
	call	?compute_src_frame@MVCompensate@@ABE_NAAH00H@Z ; MVCompensate::compute_src_frame

; 264  : 	if (! comp_flag)

	test	al, al
	jne	SHORT $LN2@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [esi+296]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 266  : 		return (_cclip_sptr->GetFrame (nsrc, env_ptr));

	push	DWORD PTR _env_ptr$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	DWORD PTR _nsrc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	eax
	call	DWORD PTR [ecx+4]

; 585  : 
; 586  :    return dst;

	mov	eax, esi
	pop	esi

; 587  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN2@GetFrame:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR _vindex$[ebp]
	push	ebx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 281  : 	nOffset[0] = nHPadding*pixelsize + nVPadding * nLoopPitches[0];

	mov	edx, DWORD PTR [esi+136]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	ecx, DWORD PTR [eax+eax*2]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 281  : 	nOffset[0] = nHPadding*pixelsize + nVPadding * nLoopPitches[0];

	mov	edi, DWORD PTR [esi+88]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [esi+152]
; File c:\github\mvtools\sources\sharedptr.hpp

; 161  : 	return (_obj_ptr);

	mov	ebx, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 269  : 	_mv_clip_ptr = info._clip_sptr.get ();

	mov	DWORD PTR [esi+304], ebx

; 270  : 	_thsad       = info._thsad;

	mov	eax, DWORD PTR [eax+ecx*4+8]

; 271  : 
; 272  : 	int nWidth_B = nBlkX*(nBlkSizeX - nOverlapX) + nOverlapX;

	mov	ecx, DWORD PTR [esi+76]
	sub	ecx, DWORD PTR [esi+108]
	imul	ecx, DWORD PTR [esi+64]
	mov	DWORD PTR [esi+308], eax
	add	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR _dstp$1$[ebp], ecx

; 273  : 	int nHeight_B = nBlkY*(nBlkSizeY - nOverlapY) + nOverlapY;

	mov	ecx, DWORD PTR [esi+80]
	sub	ecx, DWORD PTR [esi+112]
	imul	ecx, DWORD PTR [esi+68]
	add	ecx, DWORD PTR [esi+112]

; 281  : 	nOffset[0] = nHPadding*pixelsize + nVPadding * nLoopPitches[0];

	mov	esi, DWORD PTR [esi+84]
	mov	eax, esi
	mov	DWORD PTR _dstp$1$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, edx
	mov	ecx, DWORD PTR [ecx+280]
	imul	ecx, edi
	add	ecx, eax

; 282  : 	nOffset[1] = nOffset[2] = (nHPadding >> nLogxRatioUV)*pixelsize + (nVPadding >> nLogyRatioUV) * nLoopPitches[1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _nOffset$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+128]
	sar	esi, cl
	mov	ecx, DWORD PTR [eax+132]
	sar	edi, cl
	imul	edi, DWORD PTR [eax+284]

; 283  : 
; 284  : 	int nLogPel = ilog2(nPel); //shift
; 285  : 
; 286  : 	PVideoFrame mvn = _mv_clip_ptr->GetFrame (nvec, env_ptr);

	lea	eax, DWORD PTR _mvn$[ebp]
	imul	esi, edx
	lea	ecx, DWORD PTR [esi+edi]
	mov	esi, DWORD PTR _env_ptr$[ebp]
	push	esi
	push	DWORD PTR _nvec$[ebp]
	mov	DWORD PTR _nOffset$4$[ebp], ecx
	push	eax
	mov	eax, DWORD PTR [ebx]
	push	ebx
	call	DWORD PTR [eax+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 287  : 	_mv_clip_ptr->Update(mvn, env_ptr);

	lea	eax, DWORD PTR _mvn$[ebp]
	mov	ebx, DWORD PTR _this$[ebp]
	push	esi
	push	eax
	mov	ecx, DWORD PTR [ebx+304]
	call	?Update@MVClip@@QAEXAAVPVideoFrame@@PAVIScriptEnvironment@@@Z ; MVClip::Update
; File c:\github\mvtools\sources\include\avisynth.h

; 973  :   void operator=(VideoFrame* x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN0)(x) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN80@GetFrame
	cmp	DWORD PTR [eax], 264			; 00000108H
	jbe	SHORT $LN80@GetFrame
	mov	eax, DWORD PTR [eax+264]
	lea	ecx, DWORD PTR _mvn$[ebp]
	push	0
	call	eax
$LN80@GetFrame:

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 290  : 	PVideoFrame	src = super->GetFrame(nsrc, env_ptr);

	lea	edx, DWORD PTR _src$[ebp]
	push	esi
	push	DWORD PTR _nsrc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]

; 291  : 	PVideoFrame dst = env_ptr->NewVideoFrame(vi);

	push	32					; 00000020H
	lea	eax, DWORD PTR [ebx+16]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR [esi]
	push	eax
	lea	eax, DWORD PTR _dst$[ebp]
	push	eax
	push	esi
	call	DWORD PTR [ecx+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 292  : 	bool				usable_flag = _mv_clip_ptr->IsUsable();

	mov	esi, DWORD PTR [ebx+304]
; File c:\github\mvtools\sources\fakegroupofplanes.cpp

; 119  : 	return planes[0]->IsSceneChange(nThSCD1, nThSCD2);

	push	DWORD PTR [esi+220]
	mov	ecx, DWORD PTR [esi+88]
	push	DWORD PTR [esi+216]
	mov	ecx, DWORD PTR [ecx]
	call	?IsSceneChange@FakePlaneOfBlocks@@QBE_NHH@Z ; FakePlaneOfBlocks::IsSceneChange
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	jne	SHORT $LN88@GetFrame
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 64   : 	inline bool IsValid() const { return validity; }

	mov	al, BYTE PTR [esi+68]
; File c:\github\mvtools\sources\mvclip.cpp

; 264  :    return (!FakeGroupOfPlanes::IsSceneChange(nSCD1_, nSCD2_)) && FakeGroupOfPlanes::IsValid();

	test	al, al
	je	SHORT $LN88@GetFrame
	mov	al, 1
	jmp	SHORT $LN89@GetFrame
$LN88@GetFrame:
	xor	al, al
$LN89@GetFrame:

; 229  : 	if (usable_flag)

	test	al, al
	je	$LN609@GetFrame
; File c:\github\mvtools\sources\mvanalysisdata.h

; 118  :    inline int GetDeltaFrame() const { return nDeltaFrame; }

	mov	edi, DWORD PTR [esi+140]
; File c:\github\mvtools\sources\mvclip.cpp

; 232  : 		if (off > 0)

	test	edi, edi
	jle	SHORT $LN96@GetFrame
; File c:\github\mvtools\sources\mvanalysisdata.h

; 116  :    inline bool IsBackward() const { return isBackward; }

	mov	al, BYTE PTR [esi+144]
; File c:\github\mvtools\sources\mvclip.cpp

; 234  : 			off *= (IsBackward ()) ? 1 : -1;

	xor	ecx, ecx
	test	al, al
	setne	cl
	lea	ecx, DWORD PTR [ecx*2-1]
	imul	edi, ecx

; 235  : 			ref_index = n + off;

	add	edi, DWORD PTR _nsrc$[ebp]

; 236  : 		}
; 237  : 		else

	jmp	SHORT $LN616@GetFrame
$LN96@GetFrame:

; 238  : 		{
; 239  : 			ref_index = -off;

	neg	edi
$LN616@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvclip.cpp

; 242  : 		const ::VideoInfo &vi_super = super->GetVideoInfo ();

	push	eax
	mov	DWORD PTR _nref$1$[ebp], edi
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+20]

; 243  : 		if (ref_index < 0 || ref_index >= vi_super.num_frames)

	test	edi, edi
	js	$LN3@GetFrame
	cmp	edi, DWORD PTR [eax+16]
	jge	$LN3@GetFrame
; File c:\github\mvtools\sources\mvcompensate.cpp

; 298  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 )

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN5@GetFrame

; 300  : 			if (!planar)

	cmp	BYTE PTR [ebx+181], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
; File c:\github\mvtools\sources\mvcompensate.cpp

; 300  : 			if (!planar)

	jne	$LN7@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN111@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN111@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	jmp	SHORT $LN112@GetFrame
$LN111@GetFrame:
	mov	DWORD PTR _pDstYUY2$1$[ebp], 0
$LN112@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN117@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN117@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
	jmp	SHORT $LN118@GetFrame
$LN117@GetFrame:
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], 0
$LN118@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 304  : 				pDst[0]        = DstPlanes->GetPtr();

	mov	DWORD PTR [ebx+316], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 42   :    inline unsigned char *GetPtrU() const { return pSrcU; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 305  : 				pDst[1]        = DstPlanes->GetPtrU();

	mov	DWORD PTR [ebx+320], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 43   :    inline unsigned char *GetPtrV() const { return pSrcV; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 306  : 				pDst[2]        = DstPlanes->GetPtrV();

	mov	DWORD PTR [ebx+324], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 39   :    inline int GetPitch() const { return srcPitch; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 307  : 				nDstPitches[0] = DstPlanes->GetPitch();

	mov	DWORD PTR [ebx+328], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 308  : 				nDstPitches[1] = DstPlanes->GetPitchUV();

	mov	DWORD PTR [ebx+332], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 309  : 				nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR [ebx+336], eax

; 310  : 			}
; 311  : 			else

	jmp	$LN8@GetFrame
$LN7@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN135@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN135@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN136@GetFrame
$LN135@GetFrame:
	xor	eax, eax
$LN136@GetFrame:
	mov	DWORD PTR [ebx+316], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 314  : 				pDst[1]        = pDst[0] + nWidth;

	mov	ecx, DWORD PTR [ebx+92]
	add	ecx, eax
	mov	DWORD PTR [ebx+320], ecx

; 315  : 				pDst[2]        = pDst[1] + nWidth/2;

	mov	eax, DWORD PTR [ebx+92]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [ebx+324], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN141@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN141@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN142@GetFrame
$LN141@GetFrame:
	xor	eax, eax
$LN142@GetFrame:
	mov	DWORD PTR [ebx+328], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 317  : 				nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR [ebx+332], eax

; 318  : 				nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR [ebx+336], eax
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN8@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN147@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN147@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN148@GetFrame
$LN147@GetFrame:
	xor	eax, eax
$LN148@GetFrame:
	mov	DWORD PTR [ebx+340], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 321  : 			pSrc[1]        = pSrc[0] + nSuperWidth;

	mov	ecx, DWORD PTR [ebx+244]
	add	ecx, eax
	mov	DWORD PTR [ebx+344], ecx

; 322  : 			pSrc[2]        = pSrc[1] + nSuperWidth/2;

	mov	eax, DWORD PTR [ebx+244]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [ebx+348], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN153@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN153@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	jmp	SHORT $LN154@GetFrame
$LN153@GetFrame:
	xor	eax, eax
$LN154@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 323  : 			nSrcPitches[0] = src->GetPitch();

	lea	esi, DWORD PTR [ebx+352]

; 324  : 			nSrcPitches[1] = nSrcPitches[0];

	mov	DWORD PTR [ebx+356], eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR tv4052[ebp], esi

; 325  : 			nSrcPitches[2] = nSrcPitches[0];

	mov	DWORD PTR [ebx+360], eax

; 326  : 		}
; 327  : 
; 328  : 		else

	jmp	$LN6@GetFrame
$LN5@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN159@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN159@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+220]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN160@GetFrame
$LN159@GetFrame:
	xor	ecx, ecx
$LN160@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 330  : 			pDst[0]        = YWPLAN(dst);

	mov	DWORD PTR [ebx+316], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN165@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN165@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+220]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN166@GetFrame
$LN165@GetFrame:
	xor	ecx, ecx
$LN166@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 331  : 			pDst[1]        = UWPLAN(dst);

	mov	DWORD PTR [ebx+320], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	eax, eax
	je	SHORT $LN171@GetFrame
	cmp	DWORD PTR [eax], 220			; 000000dcH
	jbe	SHORT $LN171@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+220]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN172@GetFrame
$LN171@GetFrame:
	xor	ecx, ecx
$LN172@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 332  : 			pDst[2]        = VWPLAN(dst);

	mov	DWORD PTR [ebx+324], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN177@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN177@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN178@GetFrame
$LN177@GetFrame:
	xor	ecx, ecx
$LN178@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 333  : 			nDstPitches[0] = YPITCH(dst);

	mov	DWORD PTR [ebx+328], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN183@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN183@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN184@GetFrame
$LN183@GetFrame:
	xor	ecx, ecx
$LN184@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 334  : 			nDstPitches[1] = UPITCH(dst);

	mov	DWORD PTR [ebx+332], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN189@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN189@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN190@GetFrame
$LN189@GetFrame:
	xor	ecx, ecx
$LN190@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 335  : 			nDstPitches[2] = VPITCH(dst);

	mov	DWORD PTR [ebx+336], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN195@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN195@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN196@GetFrame
$LN195@GetFrame:
	xor	ecx, ecx
$LN196@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 336  : 			pSrc[0]        = YRPLAN(src);

	mov	DWORD PTR [ebx+340], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN201@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN201@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN202@GetFrame
$LN201@GetFrame:
	xor	ecx, ecx
$LN202@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 337  : 			pSrc[1]        = URPLAN(src);

	mov	DWORD PTR [ebx+344], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN207@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN207@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	4
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN208@GetFrame
$LN207@GetFrame:
	xor	ecx, ecx
$LN208@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 338  : 			pSrc[2]        = VRPLAN(src);

	mov	DWORD PTR [ebx+348], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN213@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN213@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN214@GetFrame
$LN213@GetFrame:
	xor	ecx, ecx
$LN214@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 339  : 			nSrcPitches[0] = YPITCH(src);

	mov	DWORD PTR [ebx+352], ecx
	lea	edx, DWORD PTR [ebx+352]
	mov	DWORD PTR tv4052[ebp], edx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN219@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN219@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN220@GetFrame
$LN219@GetFrame:
	xor	ecx, ecx
$LN220@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 340  : 			nSrcPitches[1] = UPITCH(src);

	mov	DWORD PTR [ebx+356], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN225@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN225@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	jmp	SHORT $LN226@GetFrame
$LN225@GetFrame:
	xor	eax, eax
$LN226@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 341  : 			nSrcPitches[2] = VPITCH(src);

	mov	DWORD PTR [ebx+360], eax
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$1$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$1$[ebp], eax
$LN6@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 344  : 		PVideoFrame ref = super->GetFrame(nref, env_ptr);

	lea	edx, DWORD PTR _ref$6[ebp]
	push	DWORD PTR _env_ptr$[ebp]
	push	edi
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 345  : 
; 346  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 )

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN9@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN233@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN233@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	ecx, eax
	jmp	SHORT $LN617@GetFrame
$LN233@GetFrame:
	xor	ecx, ecx
$LN617@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 349  : 			pRef[1]         = pRef[0] + nSuperWidth;

	mov	eax, DWORD PTR [ebx+244]
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	DWORD PTR _pRef$1$[ebp], ecx
	mov	DWORD PTR _pRef$[ebp], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 349  : 			pRef[1]         = pRef[0] + nSuperWidth;

	add	ecx, eax

; 350  : 			pRef[2]         = pRef[1] + nSuperWidth/2; // xRatioUV YUY2

	cdq
	sub	eax, edx
	mov	DWORD PTR _pRef$2$[ebp], ecx
	mov	edi, eax
	mov	DWORD PTR _pRef$[ebp+4], ecx
	sar	edi, 1
	add	edi, ecx
	mov	DWORD PTR _pRef$[ebp+8], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN239@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN239@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 352  : 			nRefPitches[1]  = nRefPitches[0];

	mov	ecx, esi
	mov	DWORD PTR _nRefPitches$[ebp], esi
	mov	DWORD PTR _nRefPitches$2$[ebp], ecx
	mov	DWORD PTR _nRefPitches$[ebp+4], ecx

; 354  : 		}
; 355  : 		else

	jmp	$LN618@GetFrame
$LN239@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	xor	esi, esi
; File c:\github\mvtools\sources\mvcompensate.cpp

; 352  : 			nRefPitches[1]  = nRefPitches[0];

	mov	ecx, esi
	mov	DWORD PTR _nRefPitches$[ebp], esi
	mov	DWORD PTR _nRefPitches$2$[ebp], ecx

; 353  : 			nRefPitches[2]  = nRefPitches[0];

	mov	eax, esi
	mov	DWORD PTR _nRefPitches$[ebp+4], ecx

; 354  : 		}
; 355  : 		else

	jmp	$LN618@GetFrame
$LN9@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	eax, eax
	je	SHORT $LN245@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN245@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	1
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN619@GetFrame
$LN245@GetFrame:
	xor	ecx, ecx
$LN619@GetFrame:
	mov	DWORD PTR _pRef$1$[ebp], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 357  : 			pRef[0]        = YRPLAN(ref);

	mov	DWORD PTR _pRef$[ebp], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN251@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN251@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN620@GetFrame
$LN251@GetFrame:
	xor	ecx, ecx
$LN620@GetFrame:
	mov	DWORD PTR _pRef$2$[ebp], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 358  : 			pRef[1]        = URPLAN(ref);

	mov	DWORD PTR _pRef$[ebp+4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	eax, eax
	je	SHORT $LN257@GetFrame
	cmp	DWORD PTR [eax], 212			; 000000d4H
	jbe	SHORT $LN257@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [eax+212]
	push	4
	call	eax
	mov	edi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN258@GetFrame
$LN257@GetFrame:
	xor	edi, edi
$LN258@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 359  : 			pRef[2]        = VRPLAN(ref);

	mov	DWORD PTR _pRef$[ebp+8], edi
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN263@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN263@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	1
	call	eax
	mov	esi, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN264@GetFrame
$LN263@GetFrame:
	xor	esi, esi
$LN264@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 360  : 			nRefPitches[0] = YPITCH(ref);

	mov	DWORD PTR _nRefPitches$[ebp], esi
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN269@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN269@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	2
	call	eax
	mov	ecx, eax
	mov	eax, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN621@GetFrame
$LN269@GetFrame:
	xor	ecx, ecx
$LN621@GetFrame:
	mov	DWORD PTR _nRefPitches$2$[ebp], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 361  : 			nRefPitches[1] = UPITCH(ref);

	mov	DWORD PTR _nRefPitches$[ebp+4], ecx
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	eax, eax
	je	SHORT $LN275@GetFrame
	cmp	DWORD PTR [eax], 192			; 000000c0H
	jbe	SHORT $LN275@GetFrame
	mov	ecx, DWORD PTR _ref$6[ebp]
	mov	eax, DWORD PTR [eax+192]
	push	4
	call	eax
	mov	ecx, DWORD PTR _nRefPitches$2$[ebp]
	jmp	SHORT $LN618@GetFrame
$LN275@GetFrame:
	xor	eax, eax
$LN618@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 365  : 		if (recursion>0)

	cmp	DWORD PTR [ebx+168], 0
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	mov	DWORD PTR _nRefPitches$3$[ebp], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 362  : 			nRefPitches[2] = VPITCH(ref);

	mov	DWORD PTR _nRefPitches$[ebp+8], eax

; 365  : 		if (recursion>0)

	jle	$LN11@GetFrame

; 366  : 		{
; 367  : 			// const Time256ProviderCst	t256_prov_cst (256-recursion, 0, 0);
; 368  :       if (pixelsize == 1) {

	cmp	DWORD PTR [ebx+136], 1

; 369  :         Blend<uint8_t>(pLoop[0], pLoop[0], pRef[0], nSuperHeight, nSuperWidth, nLoopPitches[0], nLoopPitches[0], nRefPitches[0], time256 /*t256_prov_cst*/, isse_flag);

	mov	ecx, DWORD PTR [ebx+268]
	mov	edx, ecx
	mov	eax, DWORD PTR [ebx+280]
	push	ecx
	push	DWORD PTR [ebx+184]
	push	esi
	push	eax
	push	eax
	push	DWORD PTR [ebx+244]
	push	DWORD PTR [ebx+248]
	push	DWORD PTR _pRef$1$[ebp]
	jne	$LN13@GetFrame
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 370  :         Blend<uint8_t>(pLoop[1], pLoop[1], pRef[1], nSuperHeight >> nLogyRatioUV, nSuperWidth >> nLogxRatioUV, nLoopPitches[1], nLoopPitches[1], nRefPitches[1], time256 /*t256_prov_cst*/, isse_flag);

	mov	eax, DWORD PTR [ebx+284]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [ebx+128]
	mov	esi, DWORD PTR [ebx+272]
	mov	edx, esi
	push	DWORD PTR [ebx+184]
	push	DWORD PTR _nRefPitches$2$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebx+244]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+132]
	push	eax
	mov	eax, DWORD PTR [ebx+248]
	sar	eax, cl
	mov	ecx, esi
	push	eax
	push	DWORD PTR _pRef$2$[ebp]
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 371  :         Blend<uint8_t>(pLoop[2], pLoop[2], pRef[2], nSuperHeight >> nLogyRatioUV, nSuperWidth >> nLogxRatioUV, nLoopPitches[2], nLoopPitches[2], nRefPitches[2], time256 /*t256_prov_cst*/, isse_flag);

	mov	eax, DWORD PTR [ebx+288]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [ebx+128]
	mov	esi, DWORD PTR [ebx+276]
	mov	edx, esi
	push	DWORD PTR [ebx+184]
	push	DWORD PTR _nRefPitches$3$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebx+244]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+132]
	push	eax
	mov	eax, DWORD PTR [ebx+248]
	sar	eax, cl
	mov	ecx, esi
	push	eax
	push	edi
	call	??$Blend@E@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned char>

; 372  :       }
; 373  :       else {

	jmp	$LN622@GetFrame
$LN13@GetFrame:

; 374  :         Blend<uint16_t>(pLoop[0], pLoop[0], pRef[0], nSuperHeight, nSuperWidth, nLoopPitches[0], nLoopPitches[0], nRefPitches[0], time256 /*t256_prov_cst*/, isse_flag);

	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>

; 375  :         Blend<uint16_t>(pLoop[1], pLoop[1], pRef[1], nSuperHeight >> nLogyRatioUV, nSuperWidth >> nLogxRatioUV, nLoopPitches[1], nLoopPitches[1], nRefPitches[1], time256 /*t256_prov_cst*/, isse_flag);

	mov	eax, DWORD PTR [ebx+284]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [ebx+128]
	mov	esi, DWORD PTR [ebx+272]
	mov	edx, esi
	push	DWORD PTR [ebx+184]
	push	DWORD PTR _nRefPitches$2$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebx+244]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+132]
	push	eax
	mov	eax, DWORD PTR [ebx+248]
	sar	eax, cl
	mov	ecx, esi
	push	eax
	push	DWORD PTR _pRef$2$[ebp]
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>

; 376  :         Blend<uint16_t>(pLoop[2], pLoop[2], pRef[2], nSuperHeight >> nLogyRatioUV, nSuperWidth >> nLogxRatioUV, nLoopPitches[2], nLoopPitches[2], nRefPitches[2], time256 /*t256_prov_cst*/, isse_flag);

	mov	eax, DWORD PTR [ebx+288]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [ebx+128]
	mov	esi, DWORD PTR [ebx+276]
	mov	edx, esi
	push	DWORD PTR [ebx+184]
	push	DWORD PTR _nRefPitches$3$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebx+244]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+132]
	push	eax
	mov	eax, DWORD PTR [ebx+248]
	sar	eax, cl
	mov	ecx, esi
	push	eax
	push	edi
	call	??$Blend@G@@YAXPAEPBE1HHHHHH_N@Z	; Blend<unsigned short>
$LN622@GetFrame:
	add	esp, 32					; 00000020H

; 377  :       }
; 378  : 			pRefGOF->Update(YUVPLANES, (BYTE*)pLoop[0], nLoopPitches[0], (BYTE*)pLoop[1], nLoopPitches[1], (BYTE*)pLoop[2], nLoopPitches[2]);

	push	DWORD PTR [ebx+288]
	push	DWORD PTR [ebx+276]
	push	DWORD PTR [ebx+284]
	push	DWORD PTR [ebx+272]
	push	DWORD PTR [ebx+280]
	push	DWORD PTR [ebx+268]

; 379  : 		}
; 380  : 		else

	jmp	SHORT $LN623@GetFrame
$LN11@GetFrame:

; 381  : 		{
; 382  : 			pRefGOF->Update(YUVPLANES, (BYTE*)pRef[0], nRefPitches[0], (BYTE*)pRef[1], nRefPitches[1], (BYTE*)pRef[2], nRefPitches[2]);// v2.0

	push	eax
	push	edi
	push	ecx
	push	DWORD PTR _pRef$2$[ebp]
	push	esi
	push	DWORD PTR _pRef$1$[ebp]
$LN623@GetFrame:
	mov	ecx, DWORD PTR [ebx+260]
	push	7
	call	?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z ; MVGroupOfFrames::Update

; 383  : 		}
; 384  : 		pSrcGOF->Update(YUVPLANES, (BYTE*)pSrc[0], nSrcPitches[0], (BYTE*)pSrc[1], nSrcPitches[1], (BYTE*)pSrc[2], nSrcPitches[2]);

	push	DWORD PTR [ebx+360]
	mov	ecx, DWORD PTR [ebx+264]
	push	DWORD PTR [ebx+348]
	push	DWORD PTR [ebx+356]
	push	DWORD PTR [ebx+344]
	push	DWORD PTR [ebx+352]
	push	DWORD PTR [ebx+340]
	push	7
	call	?Update@MVGroupOfFrames@@QAEXHPAEH0H0H@Z ; MVGroupOfFrames::Update

; 387  : 		pPlanes[0] = pRefGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	eax, DWORD PTR [ebx+260]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN278@GetFrame
	xor	eax, eax
	jmp	SHORT $LN277@GetFrame
$LN278@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
$LN277@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 387  : 		pPlanes[0] = pRefGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	DWORD PTR [ebx+364], eax

; 388  : 		pPlanes[1] = pRefGOF->GetFrame(0)->GetPlane(UPLANE);

	mov	eax, DWORD PTR [ebx+260]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN287@GetFrame
	xor	eax, eax
	jmp	SHORT $LN286@GetFrame
$LN287@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
$LN286@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 388  : 		pPlanes[1] = pRefGOF->GetFrame(0)->GetPlane(UPLANE);

	mov	DWORD PTR [ebx+368], eax

; 389  : 		pPlanes[2] = pRefGOF->GetFrame(0)->GetPlane(VPLANE);

	mov	eax, DWORD PTR [ebx+260]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN296@GetFrame
	xor	eax, eax
	jmp	SHORT $LN295@GetFrame
$LN296@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
$LN295@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 389  : 		pPlanes[2] = pRefGOF->GetFrame(0)->GetPlane(VPLANE);

	mov	DWORD PTR [ebx+372], eax

; 391  : 		pSrcPlanes[0] = pSrcGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	eax, DWORD PTR [ebx+264]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN305@GetFrame
	xor	eax, eax
	jmp	SHORT $LN304@GetFrame
$LN305@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
$LN304@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 67   :          return pYPlane;

	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 391  : 		pSrcPlanes[0] = pSrcGOF->GetFrame(0)->GetPlane(YPLANE);

	mov	DWORD PTR [ebx+376], eax

; 392  : 		pSrcPlanes[1] = pSrcGOF->GetFrame(0)->GetPlane(UPLANE);

	mov	eax, DWORD PTR [ebx+264]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN314@GetFrame
	xor	eax, eax
	jmp	SHORT $LN313@GetFrame
$LN314@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
$LN313@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 70   :          return pUPlane;

	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 392  : 		pSrcPlanes[1] = pSrcGOF->GetFrame(0)->GetPlane(UPLANE);

	mov	DWORD PTR [ebx+380], eax

; 393  : 		pSrcPlanes[2] = pSrcGOF->GetFrame(0)->GetPlane(VPLANE);

	mov	eax, DWORD PTR [ebx+264]
; File c:\github\mvtools\sources\mvgroupofframes.cpp

; 82   :    if (( nLevel < 0 ) || ( nLevel >= nLevelCount )) return 0;

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN323@GetFrame
	xor	eax, eax
	jmp	SHORT $LN322@GetFrame
$LN323@GetFrame:

; 83   :    return pFrames[nLevel];

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
$LN322@GetFrame:
; File c:\github\mvtools\sources\mvframe.h

; 73   :          return pVPlane;

	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 393  : 		pSrcPlanes[2] = pSrcGOF->GetFrame(0)->GetPlane(VPLANE);

	mov	DWORD PTR [ebx+384], eax

; 405  :     fieldShift = ClipFnc::compute_fieldshift (child, fields, nPel, nsrc, nref);

	mov	al, BYTE PTR [ebx+172]
; File c:\github\mvtools\sources\clipfnc.cpp

; 55   : 	if (field_flag && npel > 1 && ((nsrc - nref) & 1) != 0)

	test	al, al
	je	SHORT $LN332@GetFrame
; File c:\github\mvtools\sources\mvcompensate.cpp

; 405  :     fieldShift = ClipFnc::compute_fieldshift (child, fields, nPel, nsrc, nref);

	push	DWORD PTR _nref$1$[ebp]
	mov	edx, DWORD PTR [ebx+104]
	lea	ecx, DWORD PTR [ebx+8]
	push	DWORD PTR _nsrc$[ebp]
	call	?compute_fieldshift@ClipFnc@@SAHAAVPClip@@_NHHH@Z ; ClipFnc::compute_fieldshift
	add	esp, 8
	jmp	SHORT $LN338@GetFrame
$LN332@GetFrame:
; File c:\github\mvtools\sources\clipfnc.cpp

; 70   : 	return (fieldshift);

	xor	eax, eax
$LN338@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 405  :     fieldShift = ClipFnc::compute_fieldshift (child, fields, nPel, nsrc, nref);

	mov	DWORD PTR [ebx+312], eax

; 406  : 
; 407  : 		PROFILE_START(MOTION_PROFILE_COMPENSATION);
; 408  : 
; 409  : 		Slicer         slicer (_mt_flag);

	lea	ecx, DWORD PTR _slicer$2[ebp]
	movzx	eax, BYTE PTR [ebx+302]
	push	eax
	call	??0?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAE@_N@Z ; MTSlicer<MVCompensate,MVCompensate,64>::MTSlicer<MVCompensate,MVCompensate,64>
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 410  : 
; 411  : 		// No overlap
; 412  : 		if (nOverlapX==0 && nOverlapY==0)

	cmp	DWORD PTR [ebx+108], 0
	jne	SHORT $LN15@GetFrame
	cmp	DWORD PTR [ebx+112], 0
	jne	SHORT $LN624@GetFrame

; 413  : 		{
; 414  : 			slicer.start (nBlkY, *this, &MVCompensate::compensate_slice_normal);

	push	1
	push	0
	push	OFFSET ?compensate_slice_normal@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z ; MVCompensate::compensate_slice_normal
	push	ebx
	push	DWORD PTR [ebx+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXHAAVMVCompensate@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MVCompensate,MVCompensate,64>::start

; 415  : 			slicer.wait ();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ ; MTSlicer<MVCompensate,MVCompensate,64>::wait

; 416  : 		}
; 417  : 
; 418  : 		// Overlap
; 419  : 		else

	mov	edi, DWORD PTR _dstp$1$[ebp]
	mov	esi, DWORD PTR _dstp$1$[ebp]
	jmp	$LN26@GetFrame
$LN15@GetFrame:

; 420  : 		{
; 421  : 			if (nOverlapY > 0)

	cmp	DWORD PTR [ebx+112], 0
$LN624@GetFrame:
	jle	SHORT $LN17@GetFrame
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+400]
	sub	eax, DWORD PTR [ebx+396]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 423  : 				memset (

	and	eax, -4					; fffffffcH
	push	eax
	push	0
	push	DWORD PTR [ebx+396]
	call	_memset
	add	esp, 12					; 0000000cH
$LN17@GetFrame:

; 424  : 					&_boundary_cnt_arr [0],
; 425  : 					0,
; 426  : 					_boundary_cnt_arr.size () * sizeof (_boundary_cnt_arr [0])
; 427  : 				);
; 428  : 			}
; 429  : 
; 430  : 			MemZoneSet(reinterpret_cast<unsigned char*>(DstShort), 0, nWidth_B*sizeof(short)*pixelsize, nHeight_B, 0, 0, dstShortPitch * sizeof(short)*pixelsize);

	mov	ecx, DWORD PTR [ebx+136]
	xor	dl, dl
	mov	eax, DWORD PTR [ebx+236]
	mov	esi, DWORD PTR _dstp$1$[ebp]
	mov	edi, DWORD PTR _dstp$1$[ebp]
	imul	eax, ecx
	imul	ecx, esi
	add	eax, eax
	push	eax
	sub	esp, 8
	add	ecx, ecx
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [ebx+224]
	call	_MemZoneSet
	add	esp, 20					; 00000014H

; 431  : 			if (pPlanes[1])

	cmp	DWORD PTR [ebx+368], 0
	je	SHORT $LN18@GetFrame

; 432  : 				MemZoneSet(reinterpret_cast<unsigned char*>(DstShortU), 0, (nWidth_B*sizeof(short)*pixelsize) >> nLogxRatioUV, nHeight_B>>nLogyRatioUV, 0, 0, dstShortPitchUV * sizeof(short)*pixelsize);

	mov	edx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+240]
	mov	ecx, DWORD PTR [ebx+132]
	imul	eax, edx
	imul	edx, esi
	add	eax, eax
	push	eax
	sub	esp, 8
	mov	eax, edi
	sar	eax, cl
	add	edx, edx
	mov	ecx, DWORD PTR [ebx+128]
	shr	edx, cl
	mov	ecx, DWORD PTR [ebx+228]
	push	eax
	push	edx
	xor	dl, dl
	call	_MemZoneSet
	add	esp, 20					; 00000014H
$LN18@GetFrame:

; 433  : 			if (pPlanes[2])

	cmp	DWORD PTR [ebx+372], 0
	je	SHORT $LN19@GetFrame

; 434  : 				MemZoneSet(reinterpret_cast<unsigned char*>(DstShortV), 0, (nWidth_B*sizeof(short)*pixelsize) >> nLogxRatioUV, nHeight_B>>nLogyRatioUV, 0, 0, dstShortPitchUV * sizeof(short)*pixelsize);

	mov	edx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+240]
	mov	ecx, DWORD PTR [ebx+132]
	imul	eax, edx
	imul	edx, esi
	add	eax, eax
	push	eax
	sub	esp, 8
	mov	eax, edi
	sar	eax, cl
	add	edx, edx
	mov	ecx, DWORD PTR [ebx+128]
	shr	edx, cl
	mov	ecx, DWORD PTR [ebx+232]
	push	eax
	push	edx
	xor	dl, dl
	call	_MemZoneSet
	add	esp, 20					; 00000014H
$LN19@GetFrame:

; 435  : 
; 436  : 			slicer.start (nBlkY, *this, &MVCompensate::compensate_slice_overlap, 2);

	push	2
	push	0
	push	OFFSET ?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z ; MVCompensate::compensate_slice_overlap
	push	ebx
	push	DWORD PTR [ebx+68]
	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?start@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXHAAVMVCompensate@@P82@AEXAAVTaskData@1@@ZH@Z ; MTSlicer<MVCompensate,MVCompensate,64>::start

; 437  : 			slicer.wait ();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ ; MTSlicer<MVCompensate,MVCompensate,64>::wait

; 438  : 
; 439  :       if (pixelsize == 1) {

	mov	eax, DWORD PTR [ebx+136]
	cmp	eax, 1
	jne	$LN20@GetFrame

; 440  :         // nWidth_B and nHeight_B, right and bottom was blended
; 441  :         Short2Bytes(pDst[0], nDstPitches[0], DstShort, dstShortPitch, nWidth_B, nHeight_B);

	mov	edx, DWORD PTR [ebx+328]
	mov	ecx, DWORD PTR [ebx+316]
	push	edi
	push	esi
	push	DWORD PTR [ebx+236]
	push	DWORD PTR [ebx+224]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes
	add	esp, 16					; 00000010H

; 442  :         if(pPlanes[1])

	cmp	DWORD PTR [ebx+368], 0
	je	SHORT $LN22@GetFrame

; 443  :           Short2Bytes(pDst[1], nDstPitches[1], DstShortU, dstShortPitchUV, nWidth_B>>nLogxRatioUV, nHeight_B>>nLogyRatioUV);

	mov	ecx, DWORD PTR [ebx+132]
	mov	eax, edi
	mov	edx, DWORD PTR [ebx+332]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, esi
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+320]
	push	eax
	push	DWORD PTR [ebx+240]
	push	DWORD PTR [ebx+228]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes
	add	esp, 16					; 00000010H
$LN22@GetFrame:

; 444  :         if(pPlanes[2])

	cmp	DWORD PTR [ebx+372], 0
	je	$LN26@GetFrame

; 445  :           Short2Bytes(pDst[2], nDstPitches[2], DstShortV, dstShortPitchUV, nWidth_B>>nLogxRatioUV, nHeight_B>>nLogyRatioUV);

	mov	ecx, DWORD PTR [ebx+132]
	mov	eax, edi
	mov	edx, DWORD PTR [ebx+336]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, esi
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+324]
	push	eax
	push	DWORD PTR [ebx+240]
	push	DWORD PTR [ebx+232]
	call	?Short2Bytes@@YAXPAEHPAGHHH@Z		; Short2Bytes
	add	esp, 16					; 00000010H

; 446  :       }

	jmp	$LN26@GetFrame
$LN20@GetFrame:

; 447  :       else if (pixelsize == 2)

	cmp	eax, 2
	jne	$LN26@GetFrame

; 448  :       {
; 449  :         Short2Bytes_Int32toWord16((uint16_t *)(pDst[0]), nDstPitches[0], (int *)DstShort, dstShortPitch, nWidth_B, nHeight_B, bits_per_pixel);

	push	DWORD PTR [ebx+140]
	mov	edx, DWORD PTR [ebx+328]
	mov	ecx, DWORD PTR [ebx+316]
	push	edi
	push	esi
	push	DWORD PTR [ebx+236]
	push	DWORD PTR [ebx+224]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16
	add	esp, 20					; 00000014H

; 450  :         if (pPlanes[1])

	cmp	DWORD PTR [ebx+368], 0
	je	SHORT $LN25@GetFrame

; 451  :           Short2Bytes_Int32toWord16((uint16_t *)(pDst[1]), nDstPitches[1], (int *)DstShortU, dstShortPitchUV, nWidth_B >> nLogxRatioUV, nHeight_B >> nLogyRatioUV, bits_per_pixel);

	push	DWORD PTR [ebx+140]
	mov	ecx, DWORD PTR [ebx+132]
	mov	eax, edi
	mov	edx, DWORD PTR [ebx+332]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, esi
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+320]
	push	eax
	push	DWORD PTR [ebx+240]
	push	DWORD PTR [ebx+228]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16
	add	esp, 20					; 00000014H
$LN25@GetFrame:

; 452  :         if (pPlanes[2])

	cmp	DWORD PTR [ebx+372], 0
	je	SHORT $LN26@GetFrame

; 453  :           Short2Bytes_Int32toWord16((uint16_t *)(pDst[2]), nDstPitches[2], (int *)DstShortV, dstShortPitchUV, nWidth_B >> nLogxRatioUV, nHeight_B >> nLogyRatioUV, bits_per_pixel);

	push	DWORD PTR [ebx+140]
	mov	ecx, DWORD PTR [ebx+132]
	mov	eax, edi
	mov	edx, DWORD PTR [ebx+336]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, esi
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+324]
	push	eax
	push	DWORD PTR [ebx+240]
	push	DWORD PTR [ebx+232]
	call	?Short2Bytes_Int32toWord16@@YAXPAGHPAHHHHH@Z ; Short2Bytes_Int32toWord16
	add	esp, 20					; 00000014H
$LN26@GetFrame:

; 454  :       }
; 455  : 		}
; 456  : 
; 457  : 		// padding of the non-covered regions
; 458  : 		const BYTE **  pSrcMapped     = (scBehavior) ? pSrc        : pRef;

	mov	al, BYTE PTR [ebx+164]
	lea	edx, DWORD PTR [ebx+340]
	test	al, al
	lea	ecx, DWORD PTR _pRef$[ebp]

; 459  : 		int *          pPitchesMapped = (scBehavior) ? nSrcPitches : nRefPitches;

	lea	eax, DWORD PTR _nRefPitches$[ebp]
	cmovne	eax, DWORD PTR tv4052[ebp]
	cmovne	ecx, edx

; 460  : 
; 461  : 		if (nWidth_B < nWidth) // Right padding

	mov	edx, DWORD PTR [ebx+92]
	mov	DWORD PTR _pSrcMapped$1$[ebp], ecx
	mov	DWORD PTR _pPitchesMapped$1$[ebp], eax
	cmp	esi, edx
	jge	$LN612@GetFrame

; 462  : 		{
; 463  : 			BitBlt(pDst[0] + nWidth_B*pixelsize, nDstPitches[0], pSrcMapped[0] + (nWidth_B + nHPadding)*pixelsize + nVPadding * pPitchesMapped[0], pPitchesMapped[0], pixelsize * (nWidth-nWidth_B), nHeight_B, isse_flag);

	mov	eax, DWORD PTR [eax]
	sub	edx, esi
	mov	esi, DWORD PTR [ebx+84]
	add	esi, DWORD PTR _dstp$1$[ebp]
	mov	ecx, DWORD PTR [ebx+136]
	mov	DWORD PTR _src_pitch$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+88]
	imul	eax, DWORD PTR _src_pitch$1$[ebp]
	imul	esi, ecx
	imul	edx, ecx
	add	esi, eax
	mov	eax, DWORD PTR _pSrcMapped$1$[ebp]
	add	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR _dstp$1$[ebp]
	imul	ecx, eax
	add	ecx, DWORD PTR [ebx+316]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	edi, edi
	je	SHORT $LN377@GetFrame
	push	edi
	push	edx
	push	DWORD PTR _src_pitch$1$[ebp]
	mov	edx, DWORD PTR [ebx+328]
	push	esi
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	mov	eax, DWORD PTR _dstp$1$[ebp]
	add	esp, 16					; 00000010H
$LN377@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 464  : 			if(pPlanes[1]) // chroma u

	cmp	DWORD PTR [ebx+368], 0
	je	$LN389@GetFrame

; 465  : 				BitBlt(pDst[1] + (nWidth_B>>nLogxRatioUV)*pixelsize, nDstPitches[1], pSrcMapped[1] + ((nWidth_B>>nLogxRatioUV) + (nHPadding>>nLogxRatioUV))*pixelsize + (nVPadding>>nLogyRatioUV) * pPitchesMapped[1], pPitchesMapped[1], pixelsize*(nWidth-nWidth_B)>>nLogxRatioUV, nHeight_B>>nLogyRatioUV, isse_flag);

	mov	edx, DWORD PTR [ebx+132]
	mov	esi, edi
	mov	edi, DWORD PTR [ebx+92]
	mov	ecx, edx
	sub	edi, eax
	sar	esi, cl
	mov	ecx, DWORD PTR [ebx+128]
	mov	DWORD PTR _height$1$[ebp], esi
	mov	esi, DWORD PTR [ebx+136]
	imul	edi, esi
	sar	edi, cl
	mov	DWORD PTR _row_size$1$[ebp], edi
	mov	edi, DWORD PTR _pPitchesMapped$1$[ebp]
	mov	edi, DWORD PTR [edi+4]
	mov	DWORD PTR _src_pitch$1$[ebp], edi
	mov	edi, eax
	mov	eax, DWORD PTR [ebx+84]
	sar	eax, cl
	sar	edi, cl
	mov	ecx, edx
	mov	edx, DWORD PTR _src_pitch$1$[ebp]
	add	eax, edi
	imul	eax, esi
	imul	edi, esi
	mov	DWORD PTR _srcp$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+88]
	add	edi, DWORD PTR [ebx+320]
	sar	eax, cl
	mov	ecx, DWORD PTR _srcp$1$[ebp]
	imul	eax, edx
	mov	DWORD PTR _dstp$1$[ebp], edi
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	edi, DWORD PTR _dstp$1$[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 465  : 				BitBlt(pDst[1] + (nWidth_B>>nLogxRatioUV)*pixelsize, nDstPitches[1], pSrcMapped[1] + ((nWidth_B>>nLogxRatioUV) + (nHPadding>>nLogxRatioUV))*pixelsize + (nVPadding>>nLogyRatioUV) * pPitchesMapped[1], pPitchesMapped[1], pixelsize*(nWidth-nWidth_B)>>nLogxRatioUV, nHeight_B>>nLogyRatioUV, isse_flag);

	add	ecx, eax
	mov	eax, DWORD PTR _pSrcMapped$1$[ebp]
	add	ecx, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	eax, DWORD PTR _height$1$[ebp]
	test	eax, eax
	je	SHORT $LN389@GetFrame
	push	eax
	push	DWORD PTR _row_size$1$[ebp]
	push	edx
	mov	edx, DWORD PTR [ebx+332]
	push	ecx
	mov	ecx, DWORD PTR _dstp$1$[ebp]
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN389@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 466  : 			if(pPlanes[2])	// chroma v

	cmp	DWORD PTR [ebx+372], 0
	je	$LN613@GetFrame

; 467  : 				BitBlt(pDst[2] + (nWidth_B>>nLogxRatioUV)*pixelsize, nDstPitches[2], pSrcMapped[2] + ((nWidth_B>>nLogxRatioUV) + (nHPadding>>nLogxRatioUV))*pixelsize + (nVPadding>>nLogyRatioUV) * pPitchesMapped[2], pPitchesMapped[2], pixelsize*(nWidth-nWidth_B)>>nLogxRatioUV, nHeight_B>>nLogyRatioUV, isse_flag);

	mov	edx, DWORD PTR [ebx+132]
	mov	eax, edi
	mov	edi, DWORD PTR [ebx+92]
	mov	ecx, edx
	mov	esi, DWORD PTR [ebx+136]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	mov	DWORD PTR _height$1$[ebp], eax
	mov	eax, DWORD PTR _dstp$1$[ebp]
	sub	edi, eax
	sar	eax, cl
	mov	DWORD PTR _dstp$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+84]
	sar	eax, cl
	add	eax, DWORD PTR _dstp$1$[ebp]
	imul	edi, esi
	imul	eax, esi
	sar	edi, cl
	mov	ecx, edx
	mov	edx, DWORD PTR _pSrcMapped$1$[ebp]
	mov	DWORD PTR _srcp$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+88]
	mov	DWORD PTR _row_size$1$[ebp], edi
	mov	edi, DWORD PTR _pPitchesMapped$1$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR _srcp$1$[ebp]
	mov	edi, DWORD PTR [edi+8]
	imul	eax, edi
	mov	DWORD PTR _src_pitch$1$[ebp], edi
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	edi, DWORD PTR _dstp$1$[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 467  : 				BitBlt(pDst[2] + (nWidth_B>>nLogxRatioUV)*pixelsize, nDstPitches[2], pSrcMapped[2] + ((nWidth_B>>nLogxRatioUV) + (nHPadding>>nLogxRatioUV))*pixelsize + (nVPadding>>nLogyRatioUV) * pPitchesMapped[2], pPitchesMapped[2], pixelsize*(nWidth-nWidth_B)>>nLogxRatioUV, nHeight_B>>nLogyRatioUV, isse_flag);

	add	ecx, eax
	mov	eax, DWORD PTR _dstp$1$[ebp]
	add	ecx, DWORD PTR [edx+8]
	imul	eax, esi
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	esi, DWORD PTR _height$1$[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 467  : 				BitBlt(pDst[2] + (nWidth_B>>nLogxRatioUV)*pixelsize, nDstPitches[2], pSrcMapped[2] + ((nWidth_B>>nLogxRatioUV) + (nHPadding>>nLogxRatioUV))*pixelsize + (nVPadding>>nLogyRatioUV) * pPitchesMapped[2], pPitchesMapped[2], pixelsize*(nWidth-nWidth_B)>>nLogxRatioUV, nHeight_B>>nLogyRatioUV, isse_flag);

	add	eax, DWORD PTR [ebx+324]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	esi, esi
	je	SHORT $LN614@GetFrame
	mov	edx, DWORD PTR [ebx+336]
	push	esi
	push	DWORD PTR _row_size$1$[ebp]
	push	DWORD PTR _src_pitch$1$[ebp]
	push	ecx
	mov	ecx, eax
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN613@GetFrame:
	mov	edx, DWORD PTR _pSrcMapped$1$[ebp]
$LN614@GetFrame:
	mov	eax, DWORD PTR _pPitchesMapped$1$[ebp]
$LN401@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 470  : 		if (nHeight_B < nHeight) // Bottom padding

	mov	ecx, DWORD PTR [ebx+96]
	cmp	edi, ecx
	jge	$LN437@GetFrame

; 472  : 			BitBlt(pDst[0] + nHeight_B*nDstPitches[0], nDstPitches[0], pSrcMapped[0] + nHPadding*pixelsize + (nHeight_B + nVPadding) * pPitchesMapped[0], pPitchesMapped[0], nWidth*pixelsize, nHeight-nHeight_B, isse_flag);

	mov	esi, DWORD PTR [ebx+92]
	sub	ecx, edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _height$1$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+136]
	imul	esi, ecx
	mov	DWORD PTR _src_pitch$1$[ebp], eax
	mov	DWORD PTR _row_size$1$[ebp], esi
	mov	esi, DWORD PTR [ebx+88]
	add	esi, edi
	imul	esi, eax
	mov	eax, DWORD PTR [ebx+84]
	imul	eax, ecx
	add	esi, eax
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	eax, DWORD PTR _height$1$[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 472  : 			BitBlt(pDst[0] + nHeight_B*nDstPitches[0], nDstPitches[0], pSrcMapped[0] + nHPadding*pixelsize + (nHeight_B + nVPadding) * pPitchesMapped[0], pPitchesMapped[0], nWidth*pixelsize, nHeight-nHeight_B, isse_flag);

	add	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+328]
	mov	ecx, edx
	imul	ecx, edi
	add	ecx, DWORD PTR [ebx+316]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	eax, eax
	je	SHORT $LN413@GetFrame
	push	eax
	push	DWORD PTR _row_size$1$[ebp]
	push	DWORD PTR _src_pitch$1$[ebp]
	push	esi
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN413@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 473  : 			if(pPlanes[1])	// chroma u

	cmp	DWORD PTR [ebx+368], 0
	je	$LN611@GetFrame

; 476  :         BitBlt(pDst[1] + (nHeight_B>>nLogyRatioUV)*nDstPitches[1], nDstPitches[1], pSrcMapped[1] + (nHPadding>>nLogxRatioUV)*pixelsize + ((nHeight_B + nVPadding)>>nLogyRatioUV) * pPitchesMapped[1], pPitchesMapped[1], pixelsize * (nWidth>>nLogxRatioUV), (nHeight-nHeight_B)>>nLogyRatioUV, isse_flag);

	mov	edi, DWORD PTR [ebx+132]
	mov	ecx, edi
	mov	edx, DWORD PTR [ebx+96]
	sub	edx, DWORD PTR _dstp$1$[ebp]
	mov	esi, DWORD PTR [ebx+136]
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+92]
	mov	DWORD PTR _row_size$1$[ebp], ecx
	mov	DWORD PTR _height$1$[ebp], edx
	mov	edx, DWORD PTR [ebx+128]
	mov	ecx, edx
	sar	DWORD PTR _row_size$1$[ebp], cl
	mov	ecx, DWORD PTR _row_size$1$[ebp]
	imul	ecx, esi
	mov	DWORD PTR _row_size$1$[ebp], ecx
	mov	ecx, DWORD PTR _pPitchesMapped$1$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR _src_pitch$1$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+88]
	add	ecx, DWORD PTR _dstp$1$[ebp]
	mov	DWORD PTR _srcp$1$[ebp], ecx
	mov	ecx, edi
	mov	eax, DWORD PTR _srcp$1$[ebp]
	sar	eax, cl
	mov	ecx, edx
	imul	eax, DWORD PTR _src_pitch$1$[ebp]
	mov	DWORD PTR _srcp$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+84]
	mov	edx, DWORD PTR _srcp$1$[ebp]
	sar	eax, cl
	mov	ecx, edi
	mov	edi, DWORD PTR [ebx+332]
	imul	eax, esi
	add	edx, eax
	mov	eax, DWORD PTR _pSrcMapped$1$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _dstp$1$[ebp]
	mov	esi, eax
	sar	esi, cl
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	ecx, DWORD PTR _height$1$[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 476  :         BitBlt(pDst[1] + (nHeight_B>>nLogyRatioUV)*nDstPitches[1], nDstPitches[1], pSrcMapped[1] + (nHPadding>>nLogxRatioUV)*pixelsize + ((nHeight_B + nVPadding)>>nLogyRatioUV) * pPitchesMapped[1], pPitchesMapped[1], pixelsize * (nWidth>>nLogxRatioUV), (nHeight-nHeight_B)>>nLogyRatioUV, isse_flag);

	imul	esi, edi
	add	esi, DWORD PTR [ebx+320]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	ecx, ecx
	je	SHORT $LN425@GetFrame
	push	ecx
	push	DWORD PTR _row_size$1$[ebp]
	mov	ecx, esi
	push	DWORD PTR _src_pitch$1$[ebp]
	push	edx
	mov	edx, edi
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN611@GetFrame:
	mov	eax, DWORD PTR _dstp$1$[ebp]
$LN425@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 477  : 			if(pPlanes[2])	// chroma v

	cmp	DWORD PTR [ebx+372], 0
	je	$LN437@GetFrame

; 478  : 				BitBlt(pDst[2] + (nHeight_B>>nLogyRatioUV)*nDstPitches[2], nDstPitches[2], pSrcMapped[2] + (nHPadding>>nLogxRatioUV)*pixelsize + ((nHeight_B + nVPadding)>>nLogyRatioUV) * pPitchesMapped[2], pPitchesMapped[2], pixelsize * (nWidth>>nLogxRatioUV), (nHeight-nHeight_B)>>nLogyRatioUV, isse_flag);

	mov	edi, DWORD PTR [ebx+132]
	mov	ecx, edi
	mov	edx, DWORD PTR [ebx+96]
	mov	esi, DWORD PTR [ebx+136]
	sub	edx, eax
	sar	edx, cl
	mov	ecx, DWORD PTR [ebx+92]
	mov	DWORD PTR _row_size$1$[ebp], ecx
	mov	DWORD PTR _height$1$[ebp], edx
	mov	edx, DWORD PTR [ebx+128]
	mov	ecx, edx
	sar	DWORD PTR _row_size$1$[ebp], cl
	mov	ecx, DWORD PTR _row_size$1$[ebp]
	imul	ecx, esi
	mov	DWORD PTR _row_size$1$[ebp], ecx
	mov	ecx, DWORD PTR _pPitchesMapped$1$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _src_pitch$1$[ebp], ecx
	mov	ecx, DWORD PTR [ebx+88]
	add	ecx, eax
	mov	DWORD PTR _srcp$1$[ebp], ecx
	mov	ecx, edi
	mov	eax, DWORD PTR _srcp$1$[ebp]
	sar	eax, cl
	mov	ecx, edx
	imul	eax, DWORD PTR _src_pitch$1$[ebp]
	mov	DWORD PTR _srcp$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+84]
	mov	edx, DWORD PTR _srcp$1$[ebp]
	sar	eax, cl
	mov	ecx, edi
	imul	eax, esi
	mov	esi, DWORD PTR [ebx+336]
	add	edx, eax
	mov	eax, DWORD PTR _pSrcMapped$1$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _dstp$1$[ebp]
	sar	eax, cl
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	mov	ecx, DWORD PTR _height$1$[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 478  : 				BitBlt(pDst[2] + (nHeight_B>>nLogyRatioUV)*nDstPitches[2], nDstPitches[2], pSrcMapped[2] + (nHPadding>>nLogxRatioUV)*pixelsize + ((nHeight_B + nVPadding)>>nLogyRatioUV) * pPitchesMapped[2], pPitchesMapped[2], pixelsize * (nWidth>>nLogxRatioUV), (nHeight-nHeight_B)>>nLogyRatioUV, isse_flag);

	imul	eax, esi
	add	eax, DWORD PTR [ebx+324]
; File c:\github\mvtools\sources\copycode.cpp

; 76   :   if ( (!height)|| (!row_size)) return;

	test	ecx, ecx
	je	SHORT $LN437@GetFrame
	push	ecx
	push	DWORD PTR _row_size$1$[ebp]
	mov	ecx, eax
	push	DWORD PTR _src_pitch$1$[ebp]
	push	edx
	mov	edx, esi
	call	?BitBlt@@YAXPAEHPBEHHH_N@Z		; BitBlt
	add	esp, 16					; 00000010H
$LN437@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 484  : 		if ( recursion>0 )

	cmp	DWORD PTR [ebx+168], 0
	jle	$LN33@GetFrame

; 485  : 		{
; 486  : 			env_ptr->BitBlt(pLoop[0] + nOffset[0], nLoopPitches[0], pDst[0], nDstPitches[0], nWidth*pixelsize, nHeight);

	push	DWORD PTR [ebx+96]
	mov	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+92]
	mov	esi, DWORD PTR _env_ptr$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	DWORD PTR [ebx+328]
	mov	eax, DWORD PTR [ebx+268]
	push	DWORD PTR [ebx+316]
	add	eax, DWORD PTR _nOffset$1$[ebp]
	push	DWORD PTR [ebx+280]
	push	eax
	push	esi
	call	DWORD PTR [ecx+64]

; 487  : 			env_ptr->BitBlt(pLoop[1] + nOffset[1], nLoopPitches[1], pDst[1], nDstPitches[1], (nWidth >> nLogxRatioUV)*pixelsize, nHeight >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+132]
	mov	edx, DWORD PTR [esi]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	sar	eax, cl
	imul	eax, DWORD PTR [ebx+136]
	push	eax
	push	DWORD PTR [ebx+332]
	mov	eax, DWORD PTR [ebx+272]
	push	DWORD PTR [ebx+320]
	add	eax, DWORD PTR _nOffset$4$[ebp]
	push	DWORD PTR [ebx+284]
	push	eax
	push	esi
	call	DWORD PTR [edx+64]

; 488  : 			env_ptr->BitBlt(pLoop[2] + nOffset[2], nLoopPitches[2], pDst[2], nDstPitches[2], (nWidth >> nLogxRatioUV)*pixelsize, nHeight >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+132]
	mov	edx, DWORD PTR [esi]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	sar	eax, cl
	imul	eax, DWORD PTR [ebx+136]
	push	eax
	push	DWORD PTR [ebx+336]
	mov	eax, DWORD PTR [ebx+276]
	push	DWORD PTR [ebx+324]
	add	eax, DWORD PTR _nOffset$4$[ebp]
	push	DWORD PTR [ebx+288]
	push	eax
	push	esi
	call	DWORD PTR [edx+64]
$LN33@GetFrame:

; 489  : 		}
; 490  : 
; 491  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN34@GetFrame
	cmp	BYTE PTR [ebx+181], 0
	jne	SHORT $LN34@GetFrame

; 492  : 		{
; 493  : 			YUY2FromPlanes(

	movzx	eax, BYTE PTR [ebx+180]
	mov	edx, DWORD PTR _nDstPitchYUY2$1$[ebp]
	mov	ecx, DWORD PTR _pDstYUY2$1$[ebp]
	push	eax
	push	DWORD PTR [ebx+332]
	push	DWORD PTR [ebx+324]
	push	DWORD PTR [ebx+320]
	push	DWORD PTR [ebx+328]
	push	DWORD PTR [ebx+316]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z	; YUY2FromPlanes
	add	esp, 32					; 00000020H
$LN34@GetFrame:
; File c:\github\mvtools\sources\mtslicer.hpp

; 86   : {

	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR _slicer$2[ebp+24], 0
	mov	DWORD PTR _slicer$2[ebp], OFFSET ??_7?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@
	je	SHORT $LN445@GetFrame

; 88   : 	{
; 89   : 		wait ();

	lea	ecx, DWORD PTR _slicer$2[ebp]
	call	?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ ; MTSlicer<MVCompensate,MVCompensate,64>::wait
$LN445@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	edx, edx
	je	SHORT $LN450@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN450@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _ref$6[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN450@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\github\mvtools\sources\mvcompensate.cpp

; 501  : 	else

	jmp	$LN42@GetFrame
$LN612@GetFrame:
	mov	edx, ecx
	jmp	$LN401@GetFrame
$LN609@GetFrame:
	mov	edi, DWORD PTR _nref$[ebp]
$LN3@GetFrame:

; 502  : 	{
; 503  : 		if ( !scBehavior && ( nref < vi.num_frames ) && ( nref >= 0 ))

	cmp	BYTE PTR [ebx+164], 0
	jne	SHORT $LN35@GetFrame
	cmp	edi, DWORD PTR [ebx+32]
	jge	SHORT $LN35@GetFrame
	test	edi, edi
	js	SHORT $LN35@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 505  : 			src = super->GetFrame (nref, env_ptr);

	lea	edx, DWORD PTR $T4[ebp]
	push	DWORD PTR _env_ptr$[ebp]
	push	edi
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+4]
	push	eax
	lea	ecx, DWORD PTR _src$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	call	??4PVideoFrame@@QAEXABV0@@Z		; PVideoFrame::operator=
	lea	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame

; 506  : 		}
; 507  : 		else

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN462@GetFrame
$LN35@GetFrame:

; 509  : 			src = super->GetFrame (nsrc, env_ptr);

	push	DWORD PTR _env_ptr$[ebp]
; File c:\github\mvtools\sources\include\avisynth.h

; 942  :   IClip* operator->() const { return p; }

	mov	eax, DWORD PTR [ebx+176]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 509  : 			src = super->GetFrame (nsrc, env_ptr);

	lea	edx, DWORD PTR $T5[ebp]
	push	DWORD PTR _nsrc$[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\github\mvtools\sources\include\avisynth.h

; 974  :   void operator=(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_OPERATOR_ASSIGN1)(x) )

	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	test	esi, esi
	je	SHORT $LN459@GetFrame
	cmp	DWORD PTR [esi], 268			; 0000010cH
	jbe	SHORT $LN459@GetFrame
	push	eax
	mov	eax, DWORD PTR [esi+268]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN459@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 9
	test	esi, esi
	je	SHORT $LN463@GetFrame
	cmp	DWORD PTR [esi], 272			; 00000110H
	jbe	SHORT $LN463@GetFrame
	mov	eax, DWORD PTR [esi+272]
	lea	ecx, DWORD PTR $T5[ebp]
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN463@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 2
$LN462@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 512  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 )

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	$LN37@GetFrame

; 513  : 		{
; 514  : 			if (!planar)

	cmp	BYTE PTR [ebx+181], 0
	jne	$LN39@GetFrame
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN470@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN470@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _pDstYUY2$2$[ebp], eax
	jmp	SHORT $LN471@GetFrame
$LN470@GetFrame:
	mov	DWORD PTR _pDstYUY2$2$[ebp], 0
$LN471@GetFrame:

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN476@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN476@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	mov	DWORD PTR _nDstPitchYUY2$2$[ebp], eax
	jmp	SHORT $LN477@GetFrame
$LN476@GetFrame:
	mov	DWORD PTR _nDstPitchYUY2$2$[ebp], 0
$LN477@GetFrame:
; File c:\github\mvtools\sources\yuy2planes.h

; 41   :    inline unsigned char *GetPtr() const { return pSrc; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 518  : 				pDst[0]        = DstPlanes->GetPtr();

	mov	DWORD PTR [ebx+316], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 42   :    inline unsigned char *GetPtrU() const { return pSrcU; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+4]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 519  : 				pDst[1]        = DstPlanes->GetPtrU();

	mov	DWORD PTR [ebx+320], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 43   :    inline unsigned char *GetPtrV() const { return pSrcV; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+8]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 520  : 				pDst[2]        = DstPlanes->GetPtrV();

	mov	DWORD PTR [ebx+324], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 39   :    inline int GetPitch() const { return srcPitch; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+20]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 521  : 				nDstPitches[0] = DstPlanes->GetPitch();

	mov	DWORD PTR [ebx+328], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 522  : 				nDstPitches[1] = DstPlanes->GetPitchUV();

	mov	DWORD PTR [ebx+332], eax
; File c:\github\mvtools\sources\yuy2planes.h

; 40   :    inline int GetPitchUV() const { return srcPitchUV; }

	mov	eax, DWORD PTR [ebx+196]
	mov	eax, DWORD PTR [eax+24]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 523  : 				nDstPitches[2] = DstPlanes->GetPitchUV();

	mov	DWORD PTR [ebx+336], eax

; 524  : 			}
; 525  : 			else

	jmp	$LN40@GetFrame
$LN39@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN494@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN494@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN495@GetFrame
$LN494@GetFrame:
	xor	eax, eax
$LN495@GetFrame:
	mov	DWORD PTR [ebx+316], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 528  : 				pDst[1]        = pDst[0] + nWidth;

	mov	ecx, DWORD PTR [ebx+92]
	add	ecx, eax
	mov	DWORD PTR [ebx+320], ecx

; 529  : 				pDst[2]        = pDst[1] + nWidth/2; // YUY2

	mov	eax, DWORD PTR [ebx+92]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [ebx+324], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN500@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN500@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN501@GetFrame
$LN500@GetFrame:
	xor	eax, eax
$LN501@GetFrame:
	mov	DWORD PTR [ebx+328], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 531  : 				nDstPitches[1] = nDstPitches[0];

	mov	DWORD PTR [ebx+332], eax

; 532  : 				nDstPitches[2] = nDstPitches[0];

	mov	DWORD PTR [ebx+336], eax
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$2$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$2$[ebp], eax
$LN40@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN506@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN506@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	0
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN507@GetFrame
$LN506@GetFrame:
	xor	eax, eax
$LN507@GetFrame:
	mov	DWORD PTR [ebx+340], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 535  : 			pSrc[1]        = pSrc[0] + nSuperWidth;

	mov	ecx, DWORD PTR [ebx+244]
	add	ecx, eax
	mov	DWORD PTR [ebx+344], ecx

; 536  : 			pSrc[2]        = pSrc[1] + nSuperWidth/2; // YUY2

	mov	eax, DWORD PTR [ebx+244]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [ebx+348], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN512@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN512@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	0
	call	eax
	jmp	SHORT $LN513@GetFrame
$LN512@GetFrame:
	xor	eax, eax
$LN513@GetFrame:
	mov	DWORD PTR [ebx+352], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 538  : 			nSrcPitches[1] = nSrcPitches[0];

	mov	DWORD PTR [ebx+356], eax

; 539  : 			nSrcPitches[2] = nSrcPitches[0];

	mov	DWORD PTR [ebx+360], eax

; 540  : 		}
; 541  : 		else

	jmp	$LN38@GetFrame
$LN37@GetFrame:
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN518@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN518@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN519@GetFrame
$LN518@GetFrame:
	xor	eax, eax
$LN519@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 543  : 			pDst[0]        = YWPLAN(dst);

	mov	DWORD PTR [ebx+316], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN524@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN524@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN525@GetFrame
$LN524@GetFrame:
	xor	eax, eax
$LN525@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 544  : 			pDst[1]        = UWPLAN(dst);

	mov	DWORD PTR [ebx+320], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 813  :   BYTE* GetWritePtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetWritePtr)(plane) )

	test	esi, esi
	je	SHORT $LN530@GetFrame
	cmp	DWORD PTR [esi], 220			; 000000dcH
	jbe	SHORT $LN530@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+220]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN531@GetFrame
$LN530@GetFrame:
	xor	eax, eax
$LN531@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 545  : 			pDst[2]        = VWPLAN(dst);

	mov	DWORD PTR [ebx+324], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN536@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN536@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN537@GetFrame
$LN536@GetFrame:
	xor	eax, eax
$LN537@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 546  : 			nDstPitches[0] = YPITCH(dst);

	mov	DWORD PTR [ebx+328], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN542@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN542@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN543@GetFrame
$LN542@GetFrame:
	xor	eax, eax
$LN543@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 547  : 			nDstPitches[1] = UPITCH(dst);

	mov	DWORD PTR [ebx+332], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN548@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN548@GetFrame
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN549@GetFrame
$LN548@GetFrame:
	xor	eax, eax
$LN549@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 548  : 			nDstPitches[2] = VPITCH(dst);

	mov	DWORD PTR [ebx+336], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN554@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN554@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN555@GetFrame
$LN554@GetFrame:
	xor	eax, eax
$LN555@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 549  : 			pSrc[0]        = YRPLAN(src);

	mov	DWORD PTR [ebx+340], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN560@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN560@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN561@GetFrame
$LN560@GetFrame:
	xor	eax, eax
$LN561@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 550  : 			pSrc[1]        = URPLAN(src);

	mov	DWORD PTR [ebx+344], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 811  :   const BYTE* GetReadPtr(int plane=0) const AVS_BakedCode( return AVS_LinkCall(VFGetReadPtr)(plane) )

	test	esi, esi
	je	SHORT $LN566@GetFrame
	cmp	DWORD PTR [esi], 212			; 000000d4H
	jbe	SHORT $LN566@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+212]
	push	4
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN567@GetFrame
$LN566@GetFrame:
	xor	eax, eax
$LN567@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 551  : 			pSrc[2]        = VRPLAN(src);

	mov	DWORD PTR [ebx+348], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN572@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN572@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	1
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN573@GetFrame
$LN572@GetFrame:
	xor	eax, eax
$LN573@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 552  : 			nSrcPitches[0] = YPITCH(src);

	mov	DWORD PTR [ebx+352], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN578@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN578@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	2
	call	eax
	mov	esi, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
	jmp	SHORT $LN579@GetFrame
$LN578@GetFrame:
	xor	eax, eax
$LN579@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 553  : 			nSrcPitches[1] = UPITCH(src);

	mov	DWORD PTR [ebx+356], eax
; File c:\github\mvtools\sources\include\avisynth.h

; 797  :   int GetPitch(int plane=0) const AVS_BakedCode( return AVS_LinkCall(GetPitch)(plane) )

	test	esi, esi
	je	SHORT $LN584@GetFrame
	cmp	DWORD PTR [esi], 192			; 000000c0H
	jbe	SHORT $LN584@GetFrame
	mov	ecx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [esi+192]
	push	4
	call	eax
	jmp	SHORT $LN585@GetFrame
$LN584@GetFrame:
	xor	eax, eax
$LN585@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 554  : 			nSrcPitches[2] = VPITCH(src);

	mov	DWORD PTR [ebx+360], eax
	mov	eax, DWORD PTR _pDstYUY2$[ebp]
	mov	DWORD PTR _pDstYUY2$2$[ebp], eax
	mov	eax, DWORD PTR _nDstPitchYUY2$[ebp]
	mov	DWORD PTR _nDstPitchYUY2$2$[ebp], eax
$LN38@GetFrame:

; 555  : 		}
; 556  : 
; 557  : 		nOffset[0] = nHPadding*pixelsize + nVPadding * nSrcPitches[0];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ebx+88]
	mov	ebx, DWORD PTR [ebx+136]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, edx
	mov	edi, DWORD PTR [ecx+352]
	imul	eax, ebx
	imul	edi, esi
	add	edi, eax

; 558  : 		nOffset[1] = nOffset[2] = (nHPadding >> nLogxRatioUV)*pixelsize + (nVPadding >> nLogyRatioUV) * nSrcPitches[1];

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+128]

; 559  : 
; 560  :         // todo row_size for pixelsize
; 561  : 		env_ptr->BitBlt(pDst[0], nDstPitches[0], pSrc[0] + nOffset[0], nSrcPitches[0], nWidth*pixelsize, nHeight);

	push	DWORD PTR [eax+96]
	sar	edx, cl
	mov	ecx, DWORD PTR [eax+132]
	sar	esi, cl
	imul	esi, DWORD PTR [eax+356]
	mov	eax, DWORD PTR [eax+92]
	mov	ecx, DWORD PTR _env_ptr$[ebp]
	imul	eax, ebx
	imul	edx, ebx
	mov	ebx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	push	DWORD PTR [ebx+352]
	mov	eax, DWORD PTR [ebx+340]
	add	esi, edx
	add	eax, edi
	mov	edi, DWORD PTR _env_ptr$[ebp]
	push	eax
	push	DWORD PTR [ebx+328]
	push	DWORD PTR [ebx+316]
	push	edi
	call	DWORD PTR [ecx+64]

; 562  : 		env_ptr->BitBlt(pDst[1], nDstPitches[1], pSrc[1] + nOffset[1], nSrcPitches[1], (nWidth >> nLogxRatioUV)*pixelsize, nHeight >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+132]
	mov	edx, DWORD PTR [edi]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	sar	eax, cl
	imul	eax, DWORD PTR [ebx+136]
	push	eax
	push	DWORD PTR [ebx+356]
	mov	eax, DWORD PTR [ebx+344]
	add	eax, esi
	push	eax
	push	DWORD PTR [ebx+332]
	push	DWORD PTR [ebx+320]
	push	edi
	call	DWORD PTR [edx+64]

; 563  : 		env_ptr->BitBlt(pDst[2], nDstPitches[2], pSrc[2] + nOffset[2], nSrcPitches[2], (nWidth >> nLogxRatioUV)*pixelsize, nHeight >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+132]
	mov	edx, DWORD PTR [edi]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	sar	eax, cl
	imul	eax, DWORD PTR [ebx+136]
	push	eax
	push	DWORD PTR [ebx+360]
	mov	eax, DWORD PTR [ebx+348]
	add	eax, esi
	push	eax
	push	DWORD PTR [ebx+336]
	push	DWORD PTR [ebx+324]
	push	edi
	call	DWORD PTR [edx+64]

; 564  : 
; 565  : 		if ( (pixelType & VideoInfo::CS_YUY2) == VideoInfo::CS_YUY2 && !planar)

	mov	eax, DWORD PTR [ebx+116]
	and	eax, 1610612740				; 60000004H
	cmp	eax, 1610612740				; 60000004H
	jne	SHORT $LN41@GetFrame
	cmp	BYTE PTR [ebx+181], 0
	jne	SHORT $LN41@GetFrame

; 566  : 		{
; 567  : 			YUY2FromPlanes(pDstYUY2, nDstPitchYUY2, nWidth, nHeight,

	movzx	eax, BYTE PTR [ebx+180]
	mov	edx, DWORD PTR _nDstPitchYUY2$2$[ebp]
	mov	ecx, DWORD PTR _pDstYUY2$2$[ebp]
	push	eax
	push	DWORD PTR [ebx+332]
	push	DWORD PTR [ebx+324]
	push	DWORD PTR [ebx+320]
	push	DWORD PTR [ebx+328]
	push	DWORD PTR [ebx+316]
	push	DWORD PTR [ebx+96]
	push	DWORD PTR [ebx+92]
	call	?YUY2FromPlanes@@YAXPAEHHH0H00H_N@Z	; YUY2FromPlanes
	add	esp, 32					; 00000020H
$LN41@GetFrame:

; 568  : 			pDst[0], nDstPitches[0], pDst[1], pDst[2], nDstPitches[1], isse_flag);
; 569  : 		}
; 570  : 
; 571  : 		if ( recursion>0 )

	cmp	DWORD PTR [ebx+168], 0
	jle	$LN610@GetFrame

; 572  : 		{ 
; 573  :             // todo row_size for pixelsize
; 574  :             env_ptr->BitBlt(pLoop[0], nLoopPitches[0], pSrc[0], nSrcPitches[0], nWidth*pixelsize, nHeight);

	push	DWORD PTR [ebx+96]
	mov	eax, DWORD PTR [ebx+136]
	imul	eax, DWORD PTR [ebx+92]
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	DWORD PTR [ebx+352]
	push	DWORD PTR [ebx+340]
	push	DWORD PTR [ebx+280]
	push	DWORD PTR [ebx+268]
	push	edi
	call	DWORD PTR [ecx+64]

; 575  : 			env_ptr->BitBlt(pLoop[1], nLoopPitches[1], pSrc[1], nSrcPitches[1], (nWidth >> nLogxRatioUV)*pixelsize, nHeight >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+132]
	mov	edx, DWORD PTR [edi]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	sar	eax, cl
	imul	eax, DWORD PTR [ebx+136]
	push	eax
	push	DWORD PTR [ebx+356]
	push	DWORD PTR [ebx+344]
	push	DWORD PTR [ebx+284]
	push	DWORD PTR [ebx+272]
	push	edi
	call	DWORD PTR [edx+64]

; 576  : 			env_ptr->BitBlt(pLoop[2], nLoopPitches[2], pSrc[2], nSrcPitches[2], (nWidth >> nLogxRatioUV)*pixelsize, nHeight >> nLogyRatioUV);

	mov	eax, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+132]
	mov	edx, DWORD PTR [edi]
	sar	eax, cl
	mov	ecx, DWORD PTR [ebx+128]
	push	eax
	mov	eax, DWORD PTR [ebx+92]
	sar	eax, cl
	imul	eax, DWORD PTR [ebx+136]
	push	eax
	push	DWORD PTR [ebx+360]
	push	DWORD PTR [ebx+348]
	push	DWORD PTR [ebx+288]
	push	DWORD PTR [ebx+276]
	push	edi
	call	DWORD PTR [edx+64]
$LN610@GetFrame:
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN42@GetFrame:

; 577  : 		}
; 578  : 	}
; 579  : 
; 580  : #ifndef _M_X64
; 581  :   _mm_empty (); // (we may use double-float somewhere) Fizick

	emms
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 584  : 	_mv_clip_ptr = 0;

	mov	DWORD PTR [ebx+304], 0
	pop	edi
	pop	ebx
; File c:\github\mvtools\sources\include\avisynth.h

; 971  :   PVideoFrame(const PVideoFrame& x) AVS_BakedCode( AVS_LinkCall(PVideoFrame_CONSTRUCTOR1)(x) )

	test	edx, edx
	je	SHORT $LN588@GetFrame
	cmp	DWORD PTR [edx], 256			; 00000100H
	jbe	SHORT $LN588@GetFrame
	lea	eax, DWORD PTR _dst$[ebp]
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [edx+256]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN588@GetFrame:

; 982  :   ~PVideoFrame() AVS_BakedCode( AVS_LinkCall(PVideoFrame_DESTRUCTOR)() )

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN592@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN592@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _dst$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN592@GetFrame:
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	edx, edx
	je	SHORT $LN597@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN597@GetFrame
	mov	eax, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _src$[ebp]
	call	eax
	mov	edx, DWORD PTR ?AVS_linkage@@3PBUAVS_Linkage@@B ; AVS_linkage
$LN597@GetFrame:
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	edx, edx
	je	SHORT $LN602@GetFrame
	cmp	DWORD PTR [edx], 272			; 00000110H
	jbe	SHORT $LN602@GetFrame
	mov	edx, DWORD PTR [edx+272]
	lea	ecx, DWORD PTR _mvn$[ebp]
	call	edx
$LN602@GetFrame:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 587  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$1:
	lea	ecx, DWORD PTR _mvn$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$2:
	lea	ecx, DWORD PTR _src$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$3:
	lea	ecx, DWORD PTR _dst$[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$4:
	lea	ecx, DWORD PTR _ref$6[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$5:
	lea	ecx, DWORD PTR _slicer$2[ebp]
	jmp	??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ ; MTSlicer<MVCompensate,MVCompensate,64>::~MTSlicer<MVCompensate,MVCompensate,64>
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$21:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$22:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$6:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$7:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1PVideoFrame@@QAE@XZ			; PVideoFrame::~PVideoFrame
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$25:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z$26:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFrame@MVCompensate@@UAG?AVPVideoFrame@@HPAVIScriptEnvironment@@@Z ENDP ; MVCompensate::GetFrame
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
;	COMDAT ?compensate_slice_normal@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_xx$1$ = -76						; size = 4
_nY$1$ = -72						; size = 4
_nY$1$ = -72						; size = 4
_nY$1$ = -72						; size = 4
_pDstCur$3$ = -68					; size = 4
_by$1$ = -64						; size = 4
_pDstCur$1$ = -60					; size = 4
_pDstCur$2$ = -56					; size = 4
$T1 = -52						; size = 4
_nY$1$ = -52						; size = 4
_bx$1$ = -48						; size = 4
_DstCurPitches$1$ = -44					; size = 4
_DstCurPitches$2$ = -40					; size = 4
_DstCurPitches$3$ = -36					; size = 4
_nY$1$ = -32						; size = 4
_nY$1$ = -32						; size = 4
$T2 = -32						; size = 4
$T3 = -32						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -28						; size = 4
$T7 = -28						; size = 4
$T8 = -24						; size = 12
$T9 = -12						; size = 12
_td$ = 8						; size = 4
?compensate_slice_normal@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z PROC ; MVCompensate::compensate_slice_normal, COMDAT
; _this$ = ecx

; 592  : {

	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 593  : 	assert (&td != 0);
; 594  : 
; 595  : 	const int		rowsize_l = nBlkSizeY;

	mov	eax, DWORD PTR [esi+80]

; 596  : 	const int		rowsize_c = rowsize_l >> nLogyRatioUV;

	mov	edx, eax
	mov	ecx, DWORD PTR [esi+132]

; 597  : 
; 598  : 	BYTE *         pDstCur[3];
; 599  : 	const BYTE *   pSrcCur[3];
; 600  :   ptrdiff_t      DstCurPitches[3];
; 601  :   ptrdiff_t      SrcCurPitches[3];
; 602  : 
; 603  : 	pDstCur[0] = pDst[0] + td._y_beg * rowsize_l * (nDstPitches[0]);

	mov	ebx, DWORD PTR [esi+328]
	sar	edx, cl
	mov	ecx, DWORD PTR _td$[esp+88]
	mov	DWORD PTR _DstCurPitches$1$[esp+92], ebx
	mov	ecx, DWORD PTR [ecx+8]
	mov	edi, ecx
	imul	edi, ebx

; 604  : 	pDstCur[1] = pDst[1] + td._y_beg * rowsize_c * (nDstPitches[1]);

	mov	ebx, DWORD PTR [esi+332]
	mov	ebp, ebx
	mov	DWORD PTR _DstCurPitches$2$[esp+92], ebx

; 605  : 	pDstCur[2] = pDst[2] + td._y_beg * rowsize_c * (nDstPitches[2]);

	mov	ebx, DWORD PTR [esi+336]
	mov	DWORD PTR _DstCurPitches$3$[esp+92], ebx
	imul	ebp, ecx
	imul	ebx, ecx
	imul	edi, eax
	mov	DWORD PTR _by$1$[esp+92], ecx

; 606  : 	pSrcCur[0] = pSrc[0] + td._y_beg * rowsize_l * (nSrcPitches[0]);
; 607  : 	pSrcCur[1] = pSrc[1] + td._y_beg * rowsize_c * (nSrcPitches[1]);
; 608  : 	pSrcCur[2] = pSrc[2] + td._y_beg * rowsize_c * (nSrcPitches[2]);
; 609  : 
; 610  :   DstCurPitches[0] = rowsize_l * nDstPitches[0];

	mov	ecx, DWORD PTR _DstCurPitches$1$[esp+92]
	imul	ecx, eax

; 611  :   DstCurPitches[1] = rowsize_c * nDstPitches[1];

	mov	eax, DWORD PTR _DstCurPitches$2$[esp+92]
	add	edi, DWORD PTR [esi+316]
	imul	eax, edx
	imul	ebp, edx
	imul	ebx, edx
	mov	DWORD PTR _pDstCur$1$[esp+92], edi
	mov	DWORD PTR _DstCurPitches$1$[esp+92], ecx
	mov	DWORD PTR _DstCurPitches$2$[esp+92], eax

; 612  :   DstCurPitches[2] = rowsize_c * nDstPitches[2];

	mov	eax, DWORD PTR _DstCurPitches$3$[esp+92]
	add	ebp, DWORD PTR [esi+320]
	add	ebx, DWORD PTR [esi+324]
	imul	eax, edx

; 613  :   SrcCurPitches[0] = rowsize_l * nSrcPitches[0];
; 614  :   SrcCurPitches[1] = rowsize_c * nSrcPitches[1];
; 615  :   SrcCurPitches[2] = rowsize_c * nSrcPitches[2];
; 616  : 
; 617  : 	for (int by = td._y_beg; by < td._y_end; ++by)

	mov	edx, DWORD PTR _by$1$[esp+92]
	mov	DWORD PTR _pDstCur$2$[esp+92], ebp
	mov	DWORD PTR _pDstCur$3$[esp+92], ebx
	mov	DWORD PTR _DstCurPitches$3$[esp+92], eax
	mov	eax, DWORD PTR _td$[esp+88]
	cmp	edx, DWORD PTR [eax+12]
	jge	$LN3@compensate
	npad	11
$LL4@compensate:

; 618  : 	{
; 619  : 		int xx = 0; // pixelsize-aware, no need to multiply inside
; 620  : 		for (int bx = 0; bx < nBlkX; ++bx)

	mov	eax, DWORD PTR [esi+64]
	xor	ecx, ecx
	mov	DWORD PTR _xx$1$[esp+92], 0
	mov	DWORD PTR _bx$1$[esp+92], ecx
	test	eax, eax
	jle	$LN6@compensate
	npad	7
$LL7@compensate:

; 621  : 		{
; 622  : 			int i = by*nBlkX + bx;
; 623  :       const FakeBlockData &block = _mv_clip_ptr->GetBlock(0, i);

	imul	eax, edx

; 628  :       const int      blx = block.GetX() * nPel + block.GetMV().x * time256 / 256; // 2.5.11.22

	mov	edi, DWORD PTR [esi+184]
	add	eax, ecx
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	ecx, DWORD PTR [eax+eax*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [esi+304]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [eax+ecx*4+8]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	ebx, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 628  :       const int      blx = block.GetX() * nPel + block.GetMV().x * time256 / 256; // 2.5.11.22

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR _nY$1$[esp+92], eax
	mov	ecx, DWORD PTR [ebx]
	imul	ecx, DWORD PTR _nY$1$[esp+92]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T8[esp+92], xmm0
	movq	xmm0, xmm0
; File c:\github\mvtools\sources\mvcompensate.cpp

; 628  :       const int      blx = block.GetX() * nPel + block.GetMV().x * time256 / 256; // 2.5.11.22

	mov	eax, DWORD PTR $T8[esp+92]
	imul	eax, edi
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T9[esp+92], xmm0
; File c:\github\mvtools\sources\mvcompensate.cpp

; 628  :       const int      blx = block.GetX() * nPel + block.GetMV().x * time256 / 256; // 2.5.11.22

	cdq
	and	edx, 255				; 000000ffH
	lea	ebp, DWORD PTR [edx+eax]

; 629  : 			const int      bly = block.GetY() * nPel + block.GetMV().y * time256 / 256 + fieldShift; // 2.5.11.22

	mov	eax, DWORD PTR $T9[esp+96]
	imul	eax, edi
	mov	edi, DWORD PTR [ebx+4]
	imul	edi, DWORD PTR _nY$1$[esp+92]
	sar	ebp, 8
	add	ebp, ecx
	mov	ecx, DWORD PTR [esi+312]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	add	eax, ecx
	add	edi, eax

; 630  : 			if (block.GetSAD() < _thsad)

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _nY$1$[esp+92], edi
	cmp	eax, DWORD PTR [esi+308]
	jge	$LN8@compensate
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [esi+364]
	mov	eax, DWORD PTR [ecx+12]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	edx, DWORD PTR [ecx+32]
	mov	ebx, DWORD PTR [ecx+28]
	add	edx, edi

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T4[esp+92], eax

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, ebp

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ecx+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+92], edx

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN36@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	ebx, cl
	mov	ecx, DWORD PTR [esi+364]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, edx
	add	ebx, eax
	mov	eax, DWORD PTR [ecx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN39@compensate
$LN36@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	eax, 2

; 68   :       nX >>= NPELL2;

	mov	edx, ebx
	mov	eax, ebx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN38@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN137@compensate
$LN38@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 2
$LN137@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	mov	edi, DWORD PTR _nY$1$[esp+92]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+364]
	add	ebx, edx
	imul	eax, DWORD PTR [ecx+12]
	add	ebx, eax
$LN39@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 633  : 				BLITLUMA (

	push	DWORD PTR $T4[esp+92]
	mov	eax, DWORD PTR _xx$1$[esp+96]
	add	eax, DWORD PTR _pDstCur$1$[esp+96]
	push	ebx
	push	DWORD PTR [esi+328]
	push	eax
	mov	eax, DWORD PTR [esi+188]
	call	eax

; 634  : 					pDstCur[0] + xx, nDstPitches[0],
; 635  : 					pPlanes[0]->GetPointer(blx, bly), pPlanes[0]->GetPitch()
; 636  : 				);
; 637  : 				// chroma u
; 638  : 				if (pPlanes[1])

	mov	eax, DWORD PTR [esi+368]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN10@compensate
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 640  : 					BLITCHROMA (

	mov	edx, edi
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T3[esp+92], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 640  : 					BLITCHROMA (

	mov	ebx, ebp
	mov	ecx, DWORD PTR [esi+132]
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edx, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 640  : 					BLITCHROMA (

	sar	ebx, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [eax+28]

; 82   :       if (nPel == 1)

	mov	ecx, DWORD PTR [eax+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+92], edx

; 82   :       if (nPel == 1)

	cmp	ecx, 1
	jne	SHORT $LN52@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+12]
	imul	eax, edx
	shl	ebx, cl
	mov	ecx, DWORD PTR [esi+368]
	add	ebx, eax
	mov	eax, DWORD PTR [ecx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN55@compensate
$LN52@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	ecx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+368]
	mov	eax, ebx
	mov	edx, ebx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN54@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN138@compensate
$LN54@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 2
$LN138@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+368]
	add	ebx, edx
	imul	eax, DWORD PTR [ecx+12]
	add	ebx, eax
$LN55@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 640  : 					BLITCHROMA (

	push	DWORD PTR $T3[esp+92]
	mov	eax, DWORD PTR _xx$1$[esp+96]
	mov	ecx, DWORD PTR [esi+128]
	push	ebx
	push	DWORD PTR [esi+332]
	sar	eax, cl
	add	eax, DWORD PTR _pDstCur$2$[esp+104]
	push	eax
	mov	eax, DWORD PTR [esi+192]
	call	eax
	add	esp, 16					; 00000010H
$LN10@compensate:

; 641  : 						pDstCur[1] + (xx>>nLogxRatioUV), nDstPitches[1],
; 642  : 						pPlanes[1]->GetPointer(blx>>nLogxRatioUV, bly>>nLogyRatioUV), pPlanes[1]->GetPitch()
; 643  : 					);
; 644  : 				}
; 645  : 				// chroma v
; 646  : 				if (pPlanes[2])

	mov	edx, DWORD PTR [esi+372]
	test	edx, edx
	je	$LN136@compensate

; 648  : 					BLITCHROMA (

	mov	ecx, DWORD PTR [esi+132]
	mov	ebx, DWORD PTR _nY$1$[esp+92]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 648  : 					BLITCHROMA (

	sar	ebx, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 648  : 					BLITCHROMA (

	sar	ebp, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebp, DWORD PTR [edx+28]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T2[esp+92], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
	cmp	eax, 1
	jne	SHORT $LN68@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebx
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edx]
	add	ebp, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN71@compensate
$LN68@compensate:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+372]

; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, ebx

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, ebp

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]

; 86   :       else if (nPel == 2)

	jne	SHORT $LN70@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebp
	sar	edx, 1
	sar	ebx, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN139@compensate
$LN70@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebp
	sar	edx, 2
	sar	ebx, 2
$LN139@compensate:
	mov	ebp, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [esi+372]
	shl	edx, cl
	add	ebp, edx
	imul	ebx, DWORD PTR [eax+12]
	add	ebp, ebx
$LN71@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 648  : 					BLITCHROMA (

	push	DWORD PTR $T2[esp+92]
	mov	eax, DWORD PTR _xx$1$[esp+96]
	mov	ecx, DWORD PTR [esi+128]
	mov	ebx, DWORD PTR _pDstCur$3$[esp+96]
	push	ebp
	push	DWORD PTR [esi+336]
	sar	eax, cl
	add	eax, ebx
	push	eax
	mov	eax, DWORD PTR [esi+192]
	call	eax
	add	esp, 16					; 00000010H

; 649  : 						pDstCur[2] + (xx>>nLogxRatioUV), nDstPitches[2],
; 650  : 						pPlanes[2]->GetPointer(blx>>nLogxRatioUV, bly>>nLogyRatioUV), pPlanes[2]->GetPitch()
; 651  : 					);
; 652  : 				}
; 653  : 			}
; 654  : 			else

	jmp	$LN13@compensate
$LN8@compensate:

; 655  : 			{
; 656  : 				int blxsrc = bx * nBlkSizeX * nPel;

	mov	ebp, DWORD PTR _nY$1$[esp+92]
	mov	ebx, DWORD PTR [esi+76]
	imul	ebx, ebp

; 657  : 				int blysrc = by * nBlkSizeY * nPel + fieldShift;

	imul	ebp, DWORD PTR _by$1$[esp+92]
	imul	ebx, DWORD PTR _bx$1$[esp+92]
	imul	ebp, DWORD PTR [esi+80]
	add	ebp, ecx
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [esi+376]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 657  : 				int blysrc = by * nBlkSizeY * nPel + fieldShift;

	mov	DWORD PTR _nY$1$[esp+92], ebp
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [ecx+12]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	edx, DWORD PTR [ecx+32]
	mov	edi, DWORD PTR [ecx+28]
	add	edx, ebp

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T7[esp+92], eax

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, ebx

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ecx+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+92], edx
	mov	DWORD PTR $T1[esp+92], edi

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN84@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [esi+376]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, edx
	add	edi, eax
	mov	eax, DWORD PTR [ecx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN87@compensate
$LN84@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	eax, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR $T1[esp+92]
	mov	eax, edx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN86@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN140@compensate
$LN86@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 2
$LN140@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+376]
	add	edi, edx
	imul	eax, DWORD PTR [ecx+12]
	add	edi, eax
$LN87@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 659  : 				BLITLUMA (

	push	DWORD PTR $T7[esp+92]
	mov	eax, DWORD PTR _xx$1$[esp+96]
	add	eax, DWORD PTR _pDstCur$1$[esp+96]
	push	edi
	push	DWORD PTR [esi+328]
	push	eax
	mov	eax, DWORD PTR [esi+188]
	call	eax

; 660  : 					pDstCur[0] + xx, nDstPitches[0],
; 661  : 					pSrcPlanes[0]->GetPointer(blxsrc, blysrc), pSrcPlanes[0]->GetPitch()
; 662  : 				);
; 663  : 				// chroma u
; 664  : 				if (pSrcPlanes[1])

	mov	edi, DWORD PTR [esi+380]
	add	esp, 16					; 00000010H
	test	edi, edi
	je	$LN12@compensate

; 666  : 					BLITCHROMA (

	mov	ecx, DWORD PTR [esi+132]
	mov	edx, ebp
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [edi+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 666  : 					BLITCHROMA (

	mov	ebp, ebx
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edx, DWORD PTR [edi+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 666  : 					BLITCHROMA (

	sar	ebp, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebp, DWORD PTR [edi+28]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T6[esp+92], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edi+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+92], edx

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN100@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+52]
	imul	eax, edx
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [edi]
	add	ebp, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN103@compensate
$LN100@compensate:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+380]

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	eax, 2

; 68   :       nX >>= NPELL2;

	mov	edx, ebp
	mov	eax, ebp

; 86   :       else if (nPel == 2)

	jne	SHORT $LN102@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebp, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN141@compensate
$LN102@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebp, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+92]
	sar	eax, 2
$LN141@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+380]
	add	ebp, edx
	imul	eax, DWORD PTR [ecx+12]
	add	ebp, eax
$LN103@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 666  : 					BLITCHROMA (

	push	DWORD PTR $T6[esp+92]
	mov	eax, DWORD PTR _xx$1$[esp+96]
	mov	ecx, DWORD PTR [esi+128]
	push	ebp
	push	DWORD PTR [esi+332]
	sar	eax, cl
	add	eax, DWORD PTR _pDstCur$2$[esp+104]
	push	eax
	mov	eax, DWORD PTR [esi+192]
	call	eax
	mov	ebp, DWORD PTR _nY$1$[esp+108]
	add	esp, 16					; 00000010H
$LN12@compensate:

; 667  : 						pDstCur[1] + (xx>>nLogxRatioUV), nDstPitches[1],
; 668  : 						pSrcPlanes[1]->GetPointer(blxsrc>>nLogxRatioUV, blysrc>>nLogyRatioUV), pSrcPlanes[1]->GetPitch()
; 669  : 					);
; 670  : 				}
; 671  : 				// chroma v
; 672  : 				if (pSrcPlanes[2])

	mov	edx, DWORD PTR [esi+384]
	test	edx, edx
	je	$LN136@compensate

; 674  : 					BLITCHROMA (

	mov	ecx, DWORD PTR [esi+132]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 674  : 					BLITCHROMA (

	sar	ebp, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebp, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 674  : 					BLITCHROMA (

	sar	ebx, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+28]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T5[esp+92], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
	cmp	eax, 1
	jne	SHORT $LN116@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebp
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN119@compensate
$LN116@compensate:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+384]

; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, ebp

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, ebx

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]

; 86   :       else if (nPel == 2)

	jne	SHORT $LN118@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebx
	sar	edx, 1
	sar	ebp, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN142@compensate
$LN118@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebx
	sar	edx, 2
	sar	ebp, 2
$LN142@compensate:
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [esi+384]
	shl	edx, cl
	add	ebx, edx
	imul	ebp, DWORD PTR [eax+12]
	add	ebx, ebp
$LN119@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 674  : 					BLITCHROMA (

	push	DWORD PTR $T5[esp+92]
	mov	eax, DWORD PTR _xx$1$[esp+96]
	mov	ecx, DWORD PTR [esi+128]
	push	ebx
	push	DWORD PTR [esi+336]
	mov	ebx, DWORD PTR _pDstCur$3$[esp+104]
	sar	eax, cl
	add	eax, ebx
	push	eax
	mov	eax, DWORD PTR [esi+192]
	call	eax
	add	esp, 16					; 00000010H
	jmp	SHORT $LN13@compensate
$LN136@compensate:
	mov	ebx, DWORD PTR _pDstCur$3$[esp+92]
$LN13@compensate:

; 675  : 						pDstCur[2] + (xx>>nLogxRatioUV), nDstPitches[2],
; 676  : 						pSrcPlanes[2]->GetPointer(blxsrc>>nLogxRatioUV, blysrc>>nLogyRatioUV), pSrcPlanes[2]->GetPitch()
; 677  : 					);
; 678  : 				}
; 679  : 			}
; 680  : 
; 681  : 			xx += nBlkSizeX << pixelsize_shift;

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+144]
	mov	edx, DWORD PTR _by$1$[esp+92]
	shl	eax, cl
	mov	ecx, DWORD PTR _bx$1$[esp+92]
	add	DWORD PTR _xx$1$[esp+92], eax
	inc	ecx
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR _bx$1$[esp+92], ecx
	cmp	ecx, eax
	jl	$LL7@compensate
	mov	edi, DWORD PTR _pDstCur$1$[esp+92]
	mov	ebp, DWORD PTR _pDstCur$2$[esp+92]
$LN6@compensate:

; 613  :   SrcCurPitches[0] = rowsize_l * nSrcPitches[0];
; 614  :   SrcCurPitches[1] = rowsize_c * nSrcPitches[1];
; 615  :   SrcCurPitches[2] = rowsize_c * nSrcPitches[2];
; 616  : 
; 617  : 	for (int by = td._y_beg; by < td._y_end; ++by)

	mov	eax, DWORD PTR _td$[esp+88]
	inc	edx

; 682  : 		}	// for bx
; 683  : 
; 684  : 		pDstCur[0] += DstCurPitches[0];

	add	edi, DWORD PTR _DstCurPitches$1$[esp+92]

; 685  : 		pDstCur[1] += DstCurPitches[1];

	add	ebp, DWORD PTR _DstCurPitches$2$[esp+92]

; 686  : 		pDstCur[2] += DstCurPitches[2];

	add	ebx, DWORD PTR _DstCurPitches$3$[esp+92]
	mov	DWORD PTR _pDstCur$1$[esp+92], edi
	mov	DWORD PTR _pDstCur$2$[esp+92], ebp
	mov	DWORD PTR _pDstCur$3$[esp+92], ebx
	mov	DWORD PTR _by$1$[esp+92], edx
	cmp	edx, DWORD PTR [eax+12]
	jl	$LL4@compensate
$LN3@compensate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 687  : 		pSrcCur[0] += SrcCurPitches[0];
; 688  : 		pSrcCur[1] += SrcCurPitches[1];
; 689  : 		pSrcCur[2] += SrcCurPitches[2];
; 690  : 	}	// for by
; 691  : }

	add	esp, 76					; 0000004cH
	ret	4
?compensate_slice_normal@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z ENDP ; MVCompensate::compensate_slice_normal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\aioadd.hpp
; File c:\github\mvtools\sources\conc\interlocked.hpp
; File c:\github\mvtools\sources\conc\atomicintop.hpp
; File c:\github\mvtools\sources\mvcompensate.cpp
;	COMDAT ?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z
_TEXT	SEGMENT
_inc_ftor$2 = -20					; size = 8
__$EHRec$ = -12						; size = 12
_td$ = 8						; size = 4
?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z PROC ; MVCompensate::compensate_slice_overlap, COMDAT
; _this$ = ecx

; 697  : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi

; 698  : 	assert (&td != 0);
; 699  : 
; 700  : 	if (   nOverlapY == 0
; 701  : 	    || (td._y_beg == 0 && td._y_end == nBlkY))

	mov	esi, DWORD PTR _td$[ebp]
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [edi+112], 0
	je	$LN4@compensate
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	jne	SHORT $LN2@compensate
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [edi+68]
	je	$LN4@compensate
$LN2@compensate:

; 704  : 	}
; 705  : 
; 706  : 	else
; 707  : 	{
; 708  : 		assert (td._y_end - td._y_beg >= 2);
; 709  : 
; 710  : 		compensate_slice_overlap (td._y_beg, td._y_end - 1);

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	push	eax
	push	ecx
	mov	ecx, edi
	call	?compensate_slice_overlap@MVCompensate@@AAEXHH@Z ; MVCompensate::compensate_slice_overlap
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 39   : {

	mov	DWORD PTR _inc_ftor$2[ebp], OFFSET ??_7?$AioAdd@H@conc@@6B@

; 38   : :	_operand (operand)

	mov	DWORD PTR _inc_ftor$2[ebp+4], 1
; File c:\github\mvtools\sources\mvcompensate.cpp

; 712  : 		const conc::AioAdd <int>	inc_ftor (+1);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+396]
	push	ebx
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	2
$LL28@compensate:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL28@compensate
; File c:\github\mvtools\sources\mvcompensate.cpp

; 718  : 		if (td._y_beg > 0 && cnt_top == 2)

	mov	esi, DWORD PTR _td$[ebp]
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	jle	SHORT $LN5@compensate
	cmp	ebx, 2
	jne	SHORT $LN5@compensate

; 719  : 		{
; 720  : 			compensate_slice_overlap (td._y_beg - 1, td._y_beg);

	push	eax
	dec	eax
	mov	ecx, edi
	push	eax
	call	?compensate_slice_overlap@MVCompensate@@AAEXHH@Z ; MVCompensate::compensate_slice_overlap
$LN5@compensate:

; 721  : 		}
; 722  : 
; 723  : 		int				cnt_bot = 2;
; 724  : 		if (td._y_end < nBlkY)

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, DWORD PTR [edi+68]
	jge	SHORT $LN77@compensate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [edi+396]
	lea	esi, DWORD PTR [eax+ecx*4]
	npad	5
$LL56@compensate:
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 90   : 		val_cur = atom;

	mov	edx, DWORD PTR [esi]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	eax, edx
; File c:\github\mvtools\sources\conc\aioadd.hpp

; 48   : 	return (old_val + _operand);

	lea	ebx, DWORD PTR [edx+1]
; File c:\github\mvtools\sources\conc\interlocked.hpp

; 60   : 	return (_InterlockedCompareExchange (

	mov	ecx, ebx
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\github\mvtools\sources\conc\atomicintop.hpp

; 94   : 	while (val_old != val_cur);

	cmp	eax, edx
	jne	SHORT $LL56@compensate
; File c:\github\mvtools\sources\mvcompensate.cpp

; 731  : 		if (cnt_bot == 2)

	mov	esi, DWORD PTR _td$[ebp]
	cmp	ebx, 2
	jne	SHORT $LN79@compensate
$LN77@compensate:

; 732  : 		{
; 733  : 			compensate_slice_overlap (td._y_end - 1, td._y_end);

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, edi
	push	eax
	dec	eax
	push	eax
	call	?compensate_slice_overlap@MVCompensate@@AAEXHH@Z ; MVCompensate::compensate_slice_overlap
$LN79@compensate:
	pop	ebx
	pop	edi
	pop	esi

; 734  : 		}
; 735  : 	}
; 736  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@compensate:

; 702  : 	{
; 703  : 		compensate_slice_overlap (td._y_beg, td._y_end);

	push	DWORD PTR [esi+12]
	mov	ecx, edi
	push	DWORD PTR [esi+8]
	call	?compensate_slice_overlap@MVCompensate@@AAEXHH@Z ; MVCompensate::compensate_slice_overlap

; 734  : 		}
; 735  : 	}
; 736  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z$0:
	lea	ecx, DWORD PTR _inc_ftor$2[ebp]
	jmp	??1?$AioAdd@H@conc@@UAE@XZ		; conc::AioAdd<int>::~AioAdd<int>
__ehhandler$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?compensate_slice_overlap@MVCompensate@@AAEXAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@@Z ENDP ; MVCompensate::compensate_slice_overlap
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\overlap.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakegroupofplanes.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\fakeplaneofblocks.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\fakeblockdata.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
; File c:\github\mvtools\sources\mvplane.h
; File c:\github\mvtools\sources\mvcompensate.cpp
;	COMDAT ?compensate_slice_overlap@MVCompensate@@AAEXHH@Z
_TEXT	SEGMENT
_nY$1$ = -100						; size = 4
_nY$1$ = -100						; size = 4
_nY$1$ = -100						; size = 4
_xx$1$ = -96						; size = 4
_pDstShortV$1$ = -92					; size = 4
_winOverUV$1$ = -88					; size = 4
_pDstShort$1$ = -84					; size = 4
_pDstShortU$1$ = -80					; size = 4
_nY$1$ = -76						; size = 4
_nY$1$ = -76						; size = 4
_winOver$1$ = -76					; size = 4
_bx$1$ = -72						; size = 4
$T1 = -68						; size = 4
$T2 = -68						; size = 4
$T3 = -68						; size = 4
$T4 = -68						; size = 4
_nY$1$ = -68						; size = 4
_nY$1$ = -68						; size = 4
_nY$1$ = -68						; size = 4
_nY$1$ = -68						; size = 4
_rowsize_l$1$ = -64					; size = 4
_pDstCur$1$ = -60					; size = 4
_pDstCur$2$ = -56					; size = 4
_pDstCur$3$ = -52					; size = 4
_pSrcCur$1$ = -48					; size = 4
_pSrcCur$2$ = -44					; size = 4
_pSrcCur$3$ = -40					; size = 4
_wby$1$ = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -32						; size = 4
$T7 = -32						; size = 4
$T8 = -32						; size = 4
$T9 = -32						; size = 4
$T10 = -32						; size = 4
$T11 = -32						; size = 4
$T12 = -32						; size = 4
$T13 = -32						; size = 4
$T14 = -32						; size = 4
$T15 = -32						; size = 4
$T16 = -32						; size = 4
_rowsize_c$1$ = -28					; size = 4
$T17 = -24						; size = 12
$T18 = -12						; size = 12
_y_beg$ = 8						; size = 4
_y_end$ = 12						; size = 4
?compensate_slice_overlap@MVCompensate@@AAEXHH@Z PROC	; MVCompensate::compensate_slice_overlap, COMDAT
; _this$ = ecx

; 741  : {

	sub	esp, 100				; 00000064H
	push	ebx

; 742  : 	const int		rowsize_l = nBlkSizeY - nOverlapY;
; 743  : 	const int		rowsize_c = rowsize_l >> nLogyRatioUV;
; 744  : 
; 745  : 	unsigned short *pDstShort;
; 746  : 	unsigned short *pDstShortU;
; 747  : 	unsigned short *pDstShortV;
; 748  : 	BYTE *         pDstCur[3];
; 749  : 	const BYTE *   pSrcCur[3];
; 750  : 	pDstShort  = DstShort  + y_beg * rowsize_l * dstShortPitch * pixelsize;

	mov	ebx, DWORD PTR _y_beg$[esp+100]
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	mov	eax, DWORD PTR [esi+80]
	sub	eax, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR [esi+132]
	mov	ebp, eax
	mov	edx, DWORD PTR [esi+136]
	sar	ebp, cl
	mov	ecx, DWORD PTR [esi+236]
	imul	ecx, edx
	mov	DWORD PTR _rowsize_l$1$[esp+116], eax

; 751  : 	pDstShortU = DstShortU + y_beg * rowsize_c * dstShortPitchUV * pixelsize;
; 752  : 	pDstShortV = DstShortV + y_beg * rowsize_c * dstShortPitchUV * pixelsize;

	mov	edi, DWORD PTR [esi+232]
	mov	DWORD PTR _rowsize_c$1$[esp+116], ebp
	imul	ecx, eax
	mov	eax, DWORD PTR [esi+224]
	imul	ecx, ebx
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, DWORD PTR [esi+228]
	mov	DWORD PTR _pDstShort$1$[esp+116], eax
	mov	eax, DWORD PTR [esi+240]
	imul	eax, edx
	imul	eax, ebp
	imul	eax, ebx
	add	eax, eax
	add	ecx, eax
	add	edi, eax
	mov	DWORD PTR _pDstShortU$1$[esp+116], ecx

; 753  : 	pDstCur[0] = pDst[0]   + y_beg * rowsize_l * nDstPitches[0];
; 754  : 	pDstCur[1] = pDst[1]   + y_beg * rowsize_c * nDstPitches[1];
; 755  : 	pDstCur[2] = pDst[2]   + y_beg * rowsize_c * nDstPitches[2];
; 756  : 	pSrcCur[0] = pSrc[0]   + y_beg * rowsize_l * nSrcPitches[0];
; 757  : 	pSrcCur[1] = pSrc[1]   + y_beg * rowsize_c * nSrcPitches[1];

	mov	eax, ebp
	mov	ecx, DWORD PTR _rowsize_l$1$[esp+116]
	imul	ecx, ebx
	imul	eax, ebx
	mov	DWORD PTR _pDstShortV$1$[esp+116], edi
	imul	ecx, DWORD PTR [esi+328]
	imul	eax, DWORD PTR [esi+356]
	add	ecx, DWORD PTR [esi+316]
	mov	DWORD PTR _pDstCur$1$[esp+116], ecx
	mov	ecx, DWORD PTR [esi+332]
	imul	ecx, ebp
	add	eax, DWORD PTR [esi+344]
	mov	DWORD PTR _pSrcCur$2$[esp+116], eax

; 758  : 	pSrcCur[2] = pSrc[2]   + y_beg * rowsize_c * nSrcPitches[2];

	mov	eax, DWORD PTR [esi+360]
	imul	eax, ebp
	imul	ecx, ebx
	imul	eax, ebx
	add	ecx, DWORD PTR [esi+320]
	mov	DWORD PTR _pDstCur$2$[esp+116], ecx
	mov	ecx, DWORD PTR [esi+336]
	imul	ecx, ebp
	add	eax, DWORD PTR [esi+348]
	mov	DWORD PTR _pSrcCur$3$[esp+116], eax
	imul	ecx, ebx
	add	ecx, DWORD PTR [esi+324]
	mov	DWORD PTR _pDstCur$3$[esp+116], ecx
	mov	ecx, DWORD PTR [esi+352]
	imul	ecx, DWORD PTR _rowsize_l$1$[esp+116]
	imul	ecx, ebx
	add	ecx, DWORD PTR [esi+340]
	mov	DWORD PTR _pSrcCur$1$[esp+116], ecx

; 759  : 
; 760  : 	for (int by = y_beg; by < y_end; ++by)

	cmp	ebx, DWORD PTR _y_end$[esp+112]
	jge	$LN3@compensate
$LL4@compensate:

; 761  : 	{
; 762  : 		int wby = ((by + nBlkY - 3) / (nBlkY - 2)) * 3;

	mov	ecx, DWORD PTR [esi+68]

; 763  : 		int xx  = 0; // xx is pixelsize-aware
; 764  : 		for (int bx = 0; bx < nBlkX; ++bx)

	xor	ebp, ebp
	mov	DWORD PTR _xx$1$[esp+116], 0
	mov	DWORD PTR _bx$1$[esp+116], ebp
	lea	eax, DWORD PTR [ecx-3]
	add	ecx, -2					; fffffffeH
	add	eax, ebx
	mov	ebx, DWORD PTR [esi+64]
	cdq
	idiv	ecx
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _wby$1$[esp+116], eax
	test	ebx, ebx
	jle	$LN6@compensate
$LL7@compensate:

; 768  : 			short *        winOver   = OverWins->GetWindow(wby + wbx);

	lea	eax, DWORD PTR [ebp-3]
	mov	edi, DWORD PTR [esi+200]
	add	eax, ebx
	lea	ecx, DWORD PTR [ebx-2]
	cdq
	idiv	ecx
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	ecx, DWORD PTR [edi+16]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 768  : 			short *        winOver   = OverWins->GetWindow(wby + wbx);

	mov	edx, DWORD PTR _wby$1$[esp+116]
	add	edx, eax

; 770  : 
; 771  : 			int            i = by*nBlkX + bx;
; 772  : 			const FakeBlockData & block = _mv_clip_ptr->GetBlock(0, i);

	imul	ebx, DWORD PTR _y_beg$[esp+112]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	eax, DWORD PTR [edi+20]
	imul	ecx, edx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 778  :       const int      blx = block.GetX() * nPel + block.GetMV().x * time256 / 256; // 2.5.11.22

	mov	edi, DWORD PTR [esi+184]
	add	ebx, ebp
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _winOver$1$[esp+116], eax
; File c:\github\mvtools\sources\mvcompensate.cpp

; 769  : 			short *        winOverUV = OverWinsUV->GetWindow(wby + wbx);

	mov	eax, DWORD PTR [esi+204]
; File c:\github\mvtools\sources\overlap.h

; 61   :    inline short *GetWindow(int i) const { return Overlap9Windows + size*i; }

	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	imul	ecx, edx
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _winOverUV$1$[esp+116], eax
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	ecx, DWORD PTR [ebx+ebx*4]
; File c:\github\mvtools\sources\fakegroupofplanes.h

; 71   : 	__forceinline const FakePlaneOfBlocks& GetPlane(int i) const { return *(planes[i]); }

	mov	eax, DWORD PTR [esi+304]
	mov	eax, DWORD PTR [eax+88]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+52]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	xmm0, QWORD PTR [eax+ecx*4+8]
; File c:\github\mvtools\sources\fakeplaneofblocks.h

; 60   : 		return (blocks[i]);

	lea	ebx, DWORD PTR [eax+ecx*4]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 778  :       const int      blx = block.GetX() * nPel + block.GetMV().x * time256 / 256; // 2.5.11.22

	mov	ecx, DWORD PTR [ebx]
	mov	eax, edi
	imul	ecx, DWORD PTR [esi+104]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T17[esp+116], xmm0
	movq	xmm0, xmm0
; File c:\github\mvtools\sources\mvcompensate.cpp

; 778  :       const int      blx = block.GetX() * nPel + block.GetMV().x * time256 / 256; // 2.5.11.22

	imul	eax, DWORD PTR $T17[esp+116]
; File c:\github\mvtools\sources\fakeblockdata.h

; 54   : 	inline VECTOR GetMV() const { return vector; }

	movq	QWORD PTR $T18[esp+116], xmm0
; File c:\github\mvtools\sources\mvcompensate.cpp

; 779  :       const int      bly = block.GetY() * nPel + block.GetMV().y * time256 / 256 + fieldShift; // 2.5.11.22

	imul	edi, DWORD PTR $T18[esp+120]
	cdq
	and	edx, 255				; 000000ffH
	lea	ebp, DWORD PTR [edx+eax]
	mov	eax, edi
	sar	ebp, 8
	add	ebp, ecx
	cdq
	mov	ecx, DWORD PTR [ebx+4]
	and	edx, 255				; 000000ffH
	imul	ecx, DWORD PTR [esi+104]
	lea	edi, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [esi+312]
	sar	edi, 8
	add	ecx, edx
	add	edi, ecx

; 780  : 
; 781  :       // todo: oversluma16, overschroma16
; 782  : 			if (block.GetSAD() < _thsad)

	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR _nY$1$[esp+116], edi
	cmp	ecx, DWORD PTR [esi+308]
	jge	$LN8@compensate
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [esi+364]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	edx, DWORD PTR [ecx+32]
	mov	ebx, DWORD PTR [ecx+28]
	add	edx, edi

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [ecx+12]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, ebp
; File c:\github\mvtools\sources\mvcompensate.cpp

; 784  :         if (pixelsize == 1) {

	cmp	DWORD PTR [esi+136], 1
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T16[esp+116], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ecx+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 784  :         if (pixelsize == 1) {

	jne	$LN10@compensate
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN48@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	ebx, cl
	mov	ecx, DWORD PTR [esi+364]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, edx
	add	ebx, eax
	mov	eax, DWORD PTR [ecx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN51@compensate
$LN48@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	eax, 2

; 68   :       nX >>= NPELL2;

	mov	edx, ebx
	mov	eax, ebx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN50@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN247@compensate
$LN50@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN247@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	mov	edi, DWORD PTR _nY$1$[esp+116]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+364]
	add	ebx, edx
	imul	eax, DWORD PTR [ecx+12]
	add	ebx, eax
$LN51@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 786  :           OVERSLUMA(

	push	DWORD PTR [esi+76]
	mov	ecx, DWORD PTR _pDstShort$1$[esp+120]
	push	DWORD PTR _winOver$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T16[esp+124]
	push	ebx
	push	DWORD PTR [esi+236]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+208]
	call	eax

; 787  :             pDstShort + xx, dstShortPitch,
; 788  :             pPlanes[0]->GetPointer(blx, bly), pPlanes[0]->GetPitch(),
; 789  :             winOver, nBlkSizeX
; 790  :           );
; 791  :           // chroma u
; 792  :           if (pPlanes[1])

	mov	eax, DWORD PTR [esi+368]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN12@compensate
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 794  :             OVERSCHROMA(

	mov	edx, edi
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T15[esp+116], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 794  :             OVERSCHROMA(

	mov	ebx, ebp
	mov	ecx, DWORD PTR [esi+132]
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edx, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 794  :             OVERSCHROMA(

	sar	ebx, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [eax+28]

; 82   :       if (nPel == 1)

	mov	ecx, DWORD PTR [eax+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edx

; 82   :       if (nPel == 1)

	cmp	ecx, 1
	jne	SHORT $LN64@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+12]
	imul	eax, edx
	shl	ebx, cl
	mov	ecx, DWORD PTR [esi+368]
	add	ebx, eax
	mov	eax, DWORD PTR [ecx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN67@compensate
$LN64@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	ecx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+368]
	mov	eax, ebx
	mov	edx, ebx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN66@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN248@compensate
$LN66@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN248@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	mov	edi, DWORD PTR _nY$1$[esp+116]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+368]
	add	ebx, edx
	imul	eax, DWORD PTR [ecx+12]
	add	ebx, eax
$LN67@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 794  :             OVERSCHROMA(

	mov	ecx, DWORD PTR [esi+128]
	mov	eax, DWORD PTR [esi+76]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T15[esp+124]
	sar	eax, cl
	mov	ecx, DWORD PTR _pDstShortU$1$[esp+128]
	push	ebx
	push	DWORD PTR [esi+240]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+212]
	call	eax
	add	esp, 24					; 00000018H
$LN12@compensate:

; 795  :               pDstShortU + (xx >> nLogxRatioUV), dstShortPitchUV,
; 796  :               pPlanes[1]->GetPointer(blx >> nLogxRatioUV, bly >> nLogyRatioUV), pPlanes[1]->GetPitch(),
; 797  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 798  :             );
; 799  :           }
; 800  :           // chroma v
; 801  :           if (pPlanes[2])

	mov	ebx, DWORD PTR [esi+372]
	test	ebx, ebx
	je	$LN246@compensate

; 803  :             OVERSCHROMA(

	mov	ecx, DWORD PTR [esi+132]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [ebx+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 803  :             OVERSCHROMA(

	sar	edi, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [ebx+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 803  :             OVERSCHROMA(

	sar	ebp, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebp, DWORD PTR [ebx+28]

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T14[esp+116], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ebx+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edi

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN80@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx+12]
	imul	eax, edi
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [ebx]
	add	ebp, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN83@compensate
$LN80@compensate:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 68   :       nX >>= NPELL2;

	mov	edx, ebp
	mov	eax, ebp

; 86   :       else if (nPel == 2)

	jne	SHORT $LN82@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ebp, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN249@compensate
$LN82@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ebp, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN249@compensate:
	imul	eax, DWORD PTR [ebx+12]
	shl	edx, cl
	add	ebp, edx
	add	ebp, eax
$LN83@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 803  :             OVERSCHROMA(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+128]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	push	DWORD PTR $T14[esp+124]
	push	ebp

; 804  :               pDstShortV + (xx >> nLogxRatioUV), dstShortPitchUV,
; 805  :               pPlanes[2]->GetPointer(blx >> nLogxRatioUV, bly >> nLogyRatioUV), pPlanes[2]->GetPitch(),
; 806  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 807  :             );
; 808  :           }
; 809  :         }
; 810  :         else {

	jmp	$LN260@compensate
$LN10@compensate:
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN96@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	ebx, cl
	mov	ecx, DWORD PTR [esi+364]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, edx
	add	ebx, eax
	mov	eax, DWORD PTR [ecx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN99@compensate
$LN96@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	eax, 2

; 68   :       nX >>= NPELL2;

	mov	edx, ebx
	mov	eax, ebx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN98@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN250@compensate
$LN98@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN250@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	mov	edi, DWORD PTR _nY$1$[esp+116]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+364]
	add	ebx, edx
	imul	eax, DWORD PTR [ecx+12]
	add	ebx, eax
$LN99@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 812  :           OVERSLUMA16( // (unsigned short *)((int *)(pDstShort)+current_xx) if current_xx is not pixelsize-aware

	push	DWORD PTR [esi+76]
	mov	ecx, DWORD PTR _pDstShort$1$[esp+120]
	push	DWORD PTR _winOver$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T13[esp+124]
	push	ebx
	push	DWORD PTR [esi+236]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	call	eax

; 813  :             pDstShort + xx, dstShortPitch,
; 814  :             pPlanes[0]->GetPointer(blx, bly), pPlanes[0]->GetPitch(),
; 815  :             winOver, nBlkSizeX
; 816  :           );
; 817  :           // chroma u
; 818  :           if (pPlanes[1])

	mov	eax, DWORD PTR [esi+368]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN14@compensate
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 820  :             OVERSCHROMA16(

	mov	edx, edi
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T12[esp+116], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 820  :             OVERSCHROMA16(

	mov	ebx, ebp
	mov	ecx, DWORD PTR [esi+132]
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edx, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 820  :             OVERSCHROMA16(

	sar	ebx, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [eax+28]

; 82   :       if (nPel == 1)

	mov	ecx, DWORD PTR [eax+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edx

; 82   :       if (nPel == 1)

	cmp	ecx, 1
	jne	SHORT $LN112@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+12]
	imul	eax, edx
	shl	ebx, cl
	mov	ecx, DWORD PTR [esi+368]
	add	ebx, eax
	mov	eax, DWORD PTR [ecx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN115@compensate
$LN112@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	ecx, 2

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+368]
	mov	eax, ebx
	mov	edx, ebx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN114@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN251@compensate
$LN114@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN251@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	mov	edi, DWORD PTR _nY$1$[esp+116]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+368]
	add	ebx, edx
	imul	eax, DWORD PTR [ecx+12]
	add	ebx, eax
$LN115@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 820  :             OVERSCHROMA16(

	mov	ecx, DWORD PTR [esi+128]
	mov	eax, DWORD PTR [esi+76]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T12[esp+124]
	sar	eax, cl
	mov	ecx, DWORD PTR _pDstShortU$1$[esp+128]
	push	ebx
	push	DWORD PTR [esi+240]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	call	eax
	add	esp, 24					; 00000018H
$LN14@compensate:

; 821  :               pDstShortU + (xx >> nLogxRatioUV), dstShortPitchUV,
; 822  :               pPlanes[1]->GetPointer(blx >> nLogxRatioUV, bly >> nLogyRatioUV), pPlanes[1]->GetPitch(),
; 823  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 824  :             );
; 825  :           }
; 826  :           // chroma v
; 827  :           if (pPlanes[2])

	mov	ebx, DWORD PTR [esi+372]
	test	ebx, ebx
	je	$LN246@compensate

; 829  :             OVERSCHROMA16(

	mov	ecx, DWORD PTR [esi+132]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [ebx+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 829  :             OVERSCHROMA16(

	sar	edi, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [ebx+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 829  :             OVERSCHROMA16(

	sar	ebp, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebp, DWORD PTR [ebx+28]

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ebx+52]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T11[esp+116], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ebx+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edi

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN128@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx+12]
	imul	eax, edi
	shl	ebp, cl
	add	ebp, eax
	mov	eax, DWORD PTR [ebx]
	add	ebp, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN131@compensate
$LN128@compensate:

; 85   : 		}
; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 68   :       nX >>= NPELL2;

	mov	edx, ebp
	mov	eax, ebp

; 86   :       else if (nPel == 2)

	jne	SHORT $LN130@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ebp, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN252@compensate
$LN130@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ebx]
	mov	ebp, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN252@compensate:
	imul	eax, DWORD PTR [ebx+12]
	shl	edx, cl
	add	ebp, edx
	add	ebp, eax
$LN131@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 829  :             OVERSCHROMA16(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+128]
	mov	edi, DWORD PTR _pDstShortV$1$[esp+116]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T11[esp+124]
	sar	eax, cl
	push	ebp
	push	DWORD PTR [esi+240]
	lea	eax, DWORD PTR [edi+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	call	eax
	add	esp, 24					; 00000018H

; 830  :               pDstShortV + (xx >> nLogxRatioUV), dstShortPitchUV,
; 831  :               pPlanes[2]->GetPointer(blx >> nLogxRatioUV, bly >> nLogyRatioUV), pPlanes[2]->GetPitch(),
; 832  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 833  :             );
; 834  :           }
; 835  :         }
; 836  : 			}
; 837  : 
; 838  : 			// bad compensation, use src
; 839  : 			else

	jmp	$LN21@compensate
$LN8@compensate:

; 842  : 				int blysrc = by * (nBlkSizeY - nOverlapY) * nPel + fieldShift;

	mov	ebp, DWORD PTR [esi+80]
	sub	ebp, DWORD PTR [esi+112]
	imul	ebp, DWORD PTR [esi+104]
	mov	ebx, DWORD PTR [esi+76]
	sub	ebx, DWORD PTR [esi+108]
	imul	ebx, DWORD PTR [esi+104]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [esi+376]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 842  : 				int blysrc = by * (nBlkSizeY - nOverlapY) * nPel + fieldShift;

	imul	ebp, DWORD PTR _y_beg$[esp+112]
	imul	ebx, DWORD PTR _bx$1$[esp+116]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	edi, DWORD PTR [ecx+28]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [ecx+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 842  : 				int blysrc = by * (nBlkSizeY - nOverlapY) * nPel + fieldShift;

	add	ebp, edx
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	edx, DWORD PTR [ecx+32]
	add	edx, ebp

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T10[esp+116], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [ecx+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, ebx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 844  :         if (pixelsize == 1) {

	cmp	DWORD PTR [esi+136], 1
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edx
	mov	DWORD PTR $T4[esp+116], edi
; File c:\github\mvtools\sources\mvcompensate.cpp

; 844  :         if (pixelsize == 1) {

	jne	$LN16@compensate
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN144@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [esi+376]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, edx
	add	edi, eax
	mov	eax, DWORD PTR [ecx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN147@compensate
$LN144@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	eax, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR $T4[esp+116]
	mov	eax, edx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN146@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN253@compensate
$LN146@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN253@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+376]
	add	edi, edx
	imul	eax, DWORD PTR [ecx+12]
	add	edi, eax
$LN147@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 845  :           OVERSLUMA(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR _pDstShort$1$[esp+116]
	push	eax
	push	DWORD PTR _winOver$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T10[esp+124]
	push	edi
	push	DWORD PTR [esi+236]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+208]
	call	eax

; 846  :             pDstShort + xx, dstShortPitch,
; 847  :             pSrcPlanes[0]->GetPointer(blxsrc, blysrc), pSrcPlanes[0]->GetPitch(),
; 848  :             winOver, nBlkSizeX
; 849  :           );
; 850  :           // chroma u
; 851  :           if (pSrcPlanes[1])

	mov	eax, DWORD PTR [esi+380]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN18@compensate
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 853  :             OVERSCHROMA(

	mov	edx, ebp
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T9[esp+116], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 853  :             OVERSCHROMA(

	mov	edi, ebx
	mov	ecx, DWORD PTR [esi+132]
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edx, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 853  :             OVERSCHROMA(

	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [eax+28]

; 82   :       if (nPel == 1)

	mov	ecx, DWORD PTR [eax+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edx
	mov	DWORD PTR $T3[esp+116], edi

; 82   :       if (nPel == 1)

	cmp	ecx, 1
	jne	SHORT $LN160@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+12]
	imul	eax, edx
	shl	edi, cl
	mov	ecx, DWORD PTR [esi+380]
	add	edi, eax
	mov	eax, DWORD PTR [ecx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN163@compensate
$LN160@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	ecx, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR $T3[esp+116]
	mov	eax, edx

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+380]

; 86   :       else if (nPel == 2)

	jne	SHORT $LN162@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN254@compensate
$LN162@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN254@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+380]
	add	edi, edx
	imul	eax, DWORD PTR [ecx+12]
	add	edi, eax
$LN163@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 853  :             OVERSCHROMA(

	mov	ecx, DWORD PTR [esi+128]
	mov	eax, DWORD PTR [esi+76]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T9[esp+124]
	sar	eax, cl
	mov	ecx, DWORD PTR _pDstShortU$1$[esp+128]
	push	edi
	push	DWORD PTR [esi+240]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+212]
	call	eax
	add	esp, 24					; 00000018H
$LN18@compensate:

; 854  :               pDstShortU + (xx >> nLogxRatioUV), dstShortPitchUV,
; 855  :               pSrcPlanes[1]->GetPointer(blxsrc >> nLogxRatioUV, blysrc >> nLogyRatioUV), pSrcPlanes[1]->GetPitch(),
; 856  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 857  :             );
; 858  :           }
; 859  :           // chroma v
; 860  :           if (pSrcPlanes[2])

	mov	edx, DWORD PTR [esi+384]
	test	edx, edx
	je	$LN246@compensate

; 862  :             OVERSCHROMA(

	mov	ecx, DWORD PTR [esi+132]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 862  :             OVERSCHROMA(

	sar	ebp, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebp, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 862  :             OVERSCHROMA(

	sar	ebx, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+28]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T8[esp+116], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
	cmp	eax, 1
	jne	SHORT $LN176@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebp
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN179@compensate
$LN176@compensate:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+384]

; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, ebp

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, ebx

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]

; 86   :       else if (nPel == 2)

	jne	SHORT $LN178@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebx
	sar	edx, 1
	sar	ebp, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN255@compensate
$LN178@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebx
	sar	edx, 2
	sar	ebp, 2
$LN255@compensate:
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [esi+384]
	shl	edx, cl
	add	ebx, edx
	imul	ebp, DWORD PTR [eax+12]
	add	ebx, ebp
$LN179@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 862  :             OVERSCHROMA(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+128]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	push	DWORD PTR $T8[esp+124]
	push	ebx
$LN260@compensate:
	mov	eax, DWORD PTR _xx$1$[esp+132]
	mov	edi, DWORD PTR _pDstShortV$1$[esp+132]
	push	DWORD PTR [esi+240]
	sar	eax, cl
	lea	eax, DWORD PTR [edi+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+212]
	call	eax
	add	esp, 24					; 00000018H

; 863  :               pDstShortV + (xx >> nLogxRatioUV), dstShortPitchUV,
; 864  :               pSrcPlanes[2]->GetPointer(blxsrc >> nLogxRatioUV, blysrc >> nLogyRatioUV), pSrcPlanes[2]->GetPitch(),
; 865  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 866  :             );
; 867  :           }
; 868  :         }
; 869  :         else {

	jmp	$LN21@compensate
$LN16@compensate:
; File c:\github\mvtools\sources\mvplane.h

; 82   :       if (nPel == 1)

	cmp	eax, 1
	jne	SHORT $LN192@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]
	shl	edi, cl
	mov	ecx, DWORD PTR [esi+376]
	mov	eax, DWORD PTR [ecx+12]
	imul	eax, edx
	add	edi, eax
	mov	eax, DWORD PTR [ecx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN195@compensate
$LN192@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	eax, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR $T2[esp+116]
	mov	eax, edx

; 86   :       else if (nPel == 2)

	jne	SHORT $LN194@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN256@compensate
$LN194@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN256@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+376]
	add	edi, edx
	imul	eax, DWORD PTR [ecx+12]
	add	edi, eax
$LN195@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 871  :           OVERSLUMA16(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR _pDstShort$1$[esp+116]
	push	eax
	push	DWORD PTR _winOver$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T7[esp+124]
	push	edi
	push	DWORD PTR [esi+236]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	call	eax

; 872  :             pDstShort + xx, dstShortPitch,
; 873  :             pSrcPlanes[0]->GetPointer(blxsrc, blysrc), pSrcPlanes[0]->GetPitch(),
; 874  :             winOver, nBlkSizeX
; 875  :           );
; 876  :           // chroma u
; 877  :           if (pSrcPlanes[1])

	mov	eax, DWORD PTR [esi+380]
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN20@compensate
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	ecx, DWORD PTR [eax+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 879  :             OVERSCHROMA16(

	mov	edx, ebp
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T6[esp+116], ecx
; File c:\github\mvtools\sources\mvcompensate.cpp

; 879  :             OVERSCHROMA16(

	mov	edi, ebx
	mov	ecx, DWORD PTR [esi+132]
	sar	edx, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edx, DWORD PTR [eax+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 879  :             OVERSCHROMA16(

	sar	edi, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	edi, DWORD PTR [eax+28]

; 82   :       if (nPel == 1)

	mov	ecx, DWORD PTR [eax+56]

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	mov	DWORD PTR _nY$1$[esp+116], edx
	mov	DWORD PTR $T1[esp+116], edi

; 82   :       if (nPel == 1)

	cmp	ecx, 1
	jne	SHORT $LN208@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+12]
	imul	eax, edx
	shl	edi, cl
	mov	ecx, DWORD PTR [esi+380]
	add	edi, eax
	mov	eax, DWORD PTR [ecx]
	add	edi, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN211@compensate
$LN208@compensate:

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, edx
	cmp	ecx, 2

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	edx, DWORD PTR $T1[esp+116]
	mov	eax, edx

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+380]

; 86   :       else if (nPel == 2)

	jne	SHORT $LN210@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 68   :       nX >>= NPELL2;

	sar	edx, 1
	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN257@compensate
$LN210@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 68   :       nX >>= NPELL2;

	sar	edx, 2
	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _nY$1$[esp+116]
	sar	eax, 2
$LN257@compensate:
	mov	ecx, DWORD PTR [ecx+52]
	shl	edx, cl
	mov	ecx, DWORD PTR [esi+380]
	add	edi, edx
	imul	eax, DWORD PTR [ecx+12]
	add	edi, eax
$LN211@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 879  :             OVERSCHROMA16(

	mov	ecx, DWORD PTR [esi+128]
	mov	eax, DWORD PTR [esi+76]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T6[esp+124]
	sar	eax, cl
	mov	ecx, DWORD PTR _pDstShortU$1$[esp+128]
	push	edi
	push	DWORD PTR [esi+240]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	call	eax
	add	esp, 24					; 00000018H
$LN20@compensate:

; 880  :               pDstShortU + (xx >> nLogxRatioUV), dstShortPitchUV,
; 881  :               pSrcPlanes[1]->GetPointer(blxsrc >> nLogxRatioUV, blysrc >> nLogyRatioUV), pSrcPlanes[1]->GetPitch(),
; 882  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 883  :             );
; 884  :           }
; 885  :           // chroma v
; 886  :           if (pSrcPlanes[2])

	mov	edx, DWORD PTR [esi+384]
	test	edx, edx
	je	$LN246@compensate

; 888  :             OVERSCHROMA16(

	mov	ecx, DWORD PTR [esi+132]
; File c:\github\mvtools\sources\mvplane.h

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	eax, DWORD PTR [edx+12]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 888  :             OVERSCHROMA16(

	sar	ebp, cl
	mov	ecx, DWORD PTR [esi+128]
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebp, DWORD PTR [edx+32]
; File c:\github\mvtools\sources\mvcompensate.cpp

; 888  :             OVERSCHROMA16(

	sar	ebx, cl
; File c:\github\mvtools\sources\mvplane.h

; 104  :       return GetAbsolutePointer(nX + nHPaddingPel, nY + nVPaddingPel);

	add	ebx, DWORD PTR [edx+28]

; 112  :    inline int GetPitch() const { return nPitch; }

	mov	DWORD PTR $T5[esp+116], eax

; 82   :       if (nPel == 1)

	mov	eax, DWORD PTR [edx+56]
	cmp	eax, 1
	jne	SHORT $LN224@compensate

; 77   :          return pPlane[0] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+52]
	imul	eax, ebp
	shl	ebx, cl
	add	ebx, eax
	mov	eax, DWORD PTR [edx]
	add	ebx, DWORD PTR [eax]

; 84   :          return GetAbsolutePointerPel <0> (nX, nY);

	jmp	SHORT $LN227@compensate
$LN224@compensate:

; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [esi+384]

; 86   :       else if (nPel == 2)

	cmp	eax, 2

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	mov	edi, ebp

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	mov	eax, ebx

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	ecx, DWORD PTR [ecx+52]

; 86   :       else if (nPel == 2)

	jne	SHORT $LN226@compensate

; 87   : 		{
; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	and	edi, 1

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 1
	add	edi, edi
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebx
	sar	edx, 1
	sar	ebp, 1

; 88   :          return GetAbsolutePointerPel <1> (nX, nY);

	jmp	SHORT $LN258@compensate
$LN226@compensate:

; 89   : 		}
; 90   :       else // nPel == 4
; 91   :       {
; 92   :          return GetAbsolutePointerPel <2> (nX, nY);

	and	edi, 3

; 66   :       int idx = (nX & MASK) | ((nY & MASK) << NPELL2);

	and	eax, 3
	shl	edi, 2
	or	edi, eax

; 69   :       nY >>= NPELL2;
; 70   : 
; 71   :       return pPlane[idx] + (nX << pixelsize_shift) + nY * nPitch;

	mov	eax, DWORD PTR [edx]
	mov	edx, ebx
	sar	edx, 2
	sar	ebp, 2
$LN258@compensate:
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [esi+384]
	shl	edx, cl
	add	ebx, edx
	imul	ebp, DWORD PTR [eax+12]
	add	ebx, ebp
$LN227@compensate:
; File c:\github\mvtools\sources\mvcompensate.cpp

; 888  :             OVERSCHROMA16(

	mov	eax, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+128]
	mov	edi, DWORD PTR _pDstShortV$1$[esp+116]
	sar	eax, cl
	push	eax
	push	DWORD PTR _winOverUV$1$[esp+120]
	mov	eax, DWORD PTR _xx$1$[esp+124]
	push	DWORD PTR $T5[esp+124]
	sar	eax, cl
	push	ebx
	push	DWORD PTR [esi+240]
	lea	eax, DWORD PTR [edi+eax*2]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	call	eax
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@compensate
$LN246@compensate:
	mov	edi, DWORD PTR _pDstShortV$1$[esp+116]
$LN21@compensate:

; 889  :               pDstShortV + (xx >> nLogxRatioUV), dstShortPitchUV,
; 890  :               pSrcPlanes[2]->GetPointer(blxsrc >> nLogxRatioUV, blysrc >> nLogyRatioUV), pSrcPlanes[2]->GetPitch(),
; 891  :               winOverUV, nBlkSizeX >> nLogxRatioUV
; 892  :             );
; 893  :           }
; 894  :         }
; 895  : 			}
; 896  : 
; 897  : 			xx += (nBlkSizeX - nOverlapX) << pixelsize_shift; // really if xx is a simple counter or byte pointer, this should be *2 (pixelsize==1) or *4 (pixelsize==2)

	mov	eax, DWORD PTR [esi+76]
	sub	eax, DWORD PTR [esi+108]
	mov	ebp, DWORD PTR _bx$1$[esp+116]
	mov	ecx, DWORD PTR [esi+144]
	inc	ebp
	mov	ebx, DWORD PTR [esi+64]
	shl	eax, cl
	add	DWORD PTR _xx$1$[esp+116], eax
	mov	DWORD PTR _bx$1$[esp+116], ebp
	cmp	ebp, ebx
	jl	$LL7@compensate
$LN6@compensate:

; 898  : 		}	// for bx
; 899  : 
; 900  : 		pDstShort  += rowsize_l * dstShortPitch * pixelsize;

	mov	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [esi+236]
	mov	ebx, DWORD PTR _rowsize_l$1$[esp+116]
	mov	edx, DWORD PTR _pDstShort$1$[esp+116]
	imul	eax, ecx
	imul	eax, ebx
	lea	edx, DWORD PTR [edx+eax*2]

; 901  : 		pDstShortU += rowsize_c * dstShortPitchUV * pixelsize;

	mov	eax, DWORD PTR [esi+240]
	imul	eax, ecx
	mov	ecx, DWORD PTR _rowsize_c$1$[esp+116]
	mov	DWORD PTR _pDstShort$1$[esp+116], edx
	imul	eax, ecx
	add	eax, eax
	add	DWORD PTR _pDstShortU$1$[esp+116], eax

; 902  : 		pDstShortV += rowsize_c * dstShortPitchUV * pixelsize;

	add	edi, eax

; 903  : 		pDstCur[0] += rowsize_l * nDstPitches[0];

	mov	eax, DWORD PTR [esi+328]
	imul	eax, ebx
	mov	DWORD PTR _pDstShortV$1$[esp+116], edi
	add	DWORD PTR _pDstCur$1$[esp+116], eax

; 904  : 		pDstCur[1] += rowsize_c * nDstPitches[1];

	mov	eax, DWORD PTR [esi+332]
	imul	eax, ecx
	add	DWORD PTR _pDstCur$2$[esp+116], eax

; 905  : 		pDstCur[2] += rowsize_c * nDstPitches[2];

	mov	eax, DWORD PTR [esi+336]
	imul	eax, ecx
	add	DWORD PTR _pDstCur$3$[esp+116], eax

; 906  : 		pSrcCur[0] += rowsize_l * nSrcPitches[0];

	mov	eax, DWORD PTR [esi+352]
	imul	eax, ebx
	mov	ebx, DWORD PTR _y_beg$[esp+112]
	inc	ebx
	mov	DWORD PTR _y_beg$[esp+112], ebx
	add	DWORD PTR _pSrcCur$1$[esp+116], eax

; 907  : 		pSrcCur[1] += rowsize_c * nSrcPitches[1];

	mov	eax, DWORD PTR [esi+356]
	imul	eax, ecx
	add	DWORD PTR _pSrcCur$2$[esp+116], eax

; 908  : 		pSrcCur[2] += rowsize_c * nSrcPitches[2];

	mov	eax, DWORD PTR [esi+360]
	imul	eax, ecx
	add	DWORD PTR _pSrcCur$3$[esp+116], eax
	cmp	ebx, DWORD PTR _y_end$[esp+112]
	jl	$LL4@compensate
$LN3@compensate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 909  : 	}	// for by
; 910  : }

	add	esp, 100				; 00000064H
	ret	8
?compensate_slice_overlap@MVCompensate@@AAEXHH@Z ENDP	; MVCompensate::compensate_slice_overlap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mvcompensate.cpp
;	COMDAT ?compute_src_frame@MVCompensate@@ABE_NAAH00H@Z
_TEXT	SEGMENT
_nsrc$ = 8						; size = 4
tv175 = 12						; size = 4
_nvec$ = 12						; size = 4
_base$1$ = 16						; size = 4
_vindex$ = 16						; size = 4
_tbsize$1$ = 20						; size = 4
_n$ = 20						; size = 4
?compute_src_frame@MVCompensate@@ABE_NAAH00H@Z PROC	; MVCompensate::compute_src_frame, COMDAT
; _this$ = ecx

; 917  : 	assert (n >= 0);
; 918  : 
; 919  : 	bool           comp_flag = true;
; 920  : 
; 921  : 	nsrc   = n;

	mov	eax, DWORD PTR _nsrc$[esp-4]
	push	ebx
	push	ebp

; 922  : 	nvec   = n;
; 923  : 	vindex = 0;

	mov	ebp, DWORD PTR _vindex$[esp+4]
	mov	bl, 1
	push	esi
	mov	esi, DWORD PTR _n$[esp+8]
	push	edi
	mov	edi, DWORD PTR _nvec$[esp+12]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [ebp], 0

; 924  : 
; 925  : 	if (_multi_flag)

	cmp	BYTE PTR [ecx+300], 0
	je	$LN8@compute_sr

; 926  : 	{
; 927  : 		int				tbsize = _trad * 2;

	mov	eax, DWORD PTR [ecx+292]
	mov	DWORD PTR tv175[esp+12], eax
	add	eax, eax

; 928  : 		if (_center_flag)

	cmp	BYTE PTR [ecx+301], 0
	mov	DWORD PTR _tbsize$1$[esp+12], eax
	je	SHORT $LN3@compute_sr

; 929  : 		{
; 930  : 			++ tbsize;

	inc	eax
	mov	DWORD PTR _tbsize$1$[esp+12], eax

; 931  : 
; 932  : 			const int		base = n / tbsize;

	mov	eax, esi
	cdq
	idiv	DWORD PTR _tbsize$1$[esp+12]

; 933  : 			const int		offset = n - base * tbsize;
; 934  : 			if (offset == _trad)

	mov	edx, DWORD PTR tv175[esp+12]
	mov	ecx, eax
	imul	eax, DWORD PTR _tbsize$1$[esp+12]
	mov	DWORD PTR _base$1$[esp+12], ecx
	sub	esi, eax
	cmp	esi, edx
	jne	SHORT $LN5@compute_sr

; 945  : 			}
; 946  : 			nsrc = base;

	mov	eax, DWORD PTR _nsrc$[esp+12]
	xor	bl, bl
	mov	DWORD PTR [ebp], 0
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [eax], ecx

; 953  : 		}
; 954  : 	}
; 955  : 
; 956  : 	return (comp_flag);

	mov	al, bl
	mov	DWORD PTR [edi], ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 957  : }

	ret	16					; 00000010H
$LN5@compute_sr:

; 935  : 			{
; 936  : 				comp_flag = false;
; 937  : 				vindex = 0;
; 938  : 				nvec   = 0;
; 939  : 			}
; 940  : 			else
; 941  : 			{
; 942  : 				const int		bf = (offset > _trad) ? 1-2 : 0-2;
; 943  : 				const int		td = abs (offset - _trad);

	mov	eax, esi
	xor	ecx, ecx
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, DWORD PTR tv175[esp+12]
	setg	cl
	add	ecx, -2					; fffffffeH

; 944  : 				vindex = td * 2 + bf;

	lea	ecx, DWORD PTR [ecx+eax*2]

; 945  : 			}
; 946  : 			nsrc = base;

	mov	eax, DWORD PTR _nsrc$[esp+12]
	mov	DWORD PTR [ebp], ecx
	mov	ecx, DWORD PTR _base$1$[esp+12]
	mov	DWORD PTR [eax], ecx

; 953  : 		}
; 954  : 	}
; 955  : 
; 956  : 	return (comp_flag);

	mov	al, bl
	mov	DWORD PTR [edi], ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 957  : }

	ret	16					; 00000010H
$LN3@compute_sr:

; 947  : 			nvec = base;
; 948  : 		}
; 949  : 		else
; 950  : 		{
; 951  : 			nsrc   = n / tbsize;

	mov	eax, esi
	mov	ecx, DWORD PTR _nsrc$[esp+12]
	cdq
	idiv	DWORD PTR _tbsize$1$[esp+12]
	mov	DWORD PTR [ecx], eax

; 952  : 			vindex = n % tbsize;

	mov	DWORD PTR [ebp], edx
$LN8@compute_sr:

; 953  : 		}
; 954  : 	}
; 955  : 
; 956  : 	return (comp_flag);

	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 957  : }

	ret	16					; 00000010H
?compute_src_frame@MVCompensate@@ABE_NAAH00H@Z ENDP	; MVCompensate::compute_src_frame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEAAVMvClipInfo@MVCompensate@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEAAVMvClipInfo@MVCompensate@@I@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::operator[], COMDAT
; _this$ = ecx

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*4]

; 1243 : 		}

	ret	4
??A?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEAAVMvClipInfo@MVCompensate@@I@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1181 : 		}

	ret	0
?size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?resize@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
$T2 = 8							; size = 1
__Newsize$ = 8						; size = 4
?resize@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::resize, COMDAT
; _this$ = ecx

; 1133 : 		{	// determine new length, padding as needed

	push	ebx

; 1134 : 		if (_Newsize < size())

	mov	ebx, DWORD PTR __Newsize$[esp]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
	push	ebp

; 1133 : 		{	// determine new length, padding as needed

	mov	ebp, ecx
	push	esi
	push	edi

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edi, DWORD PTR [ebp+4]
	mov	edx, edi
	sub	edx, DWORD PTR [ebp]
	imul	edx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1134 : 		if (_Newsize < size())

	cmp	ecx, ebx
	jbe	SHORT $LN202@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T2[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	sub	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	edx, edi
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	esi, DWORD PTR [edi+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	ecx, esi
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [ebp+4], esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1147 : 			}
; 1148 : 		}

	ret	4
$LN202@resize:

; 1135 : 			_Pop_back_n(size() - _Newsize);
; 1136 : 		else if (size() < _Newsize)

	jae	SHORT $LN4@resize

; 1137 : 			{	// pad as needed
; 1138 : 			_Reserve(_Newsize - size());

	mov	eax, ebx
	sub	eax, ecx
	mov	ecx, ebp
	push	eax
	call	?_Reserve@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reserve
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, 715827883				; 2aaaaaabH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebp+4]
	sub	ecx, DWORD PTR [ebp]
	imul	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	ecx, DWORD PTR [ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1139 : 			_TRY_BEGIN
; 1140 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),

	mov	edx, ebx
	sub	edx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	call	??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1141 : 				this->_Getal());
; 1142 : 			_CATCH_ALL
; 1143 : 			_Tidy();
; 1144 : 			_RERAISE;
; 1145 : 			_CATCH_END
; 1146 : 			this->_Mylast() += _Newsize - size();

	sub	ebx, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 2
	add	DWORD PTR [ebp+4], eax
$LN4@resize:

; 1147 : 			}
; 1148 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
?resize@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
??1?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::~vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	pop	ecx
	ret	0
??1?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::~vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Count$dead$ = 8					; size = 4
??0?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@I@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; _this$ = ecx

; 717  : 		{	// construct from _Count * value_type()

	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1562 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1563 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1564 : 		this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ; std::allocator<MVCompensate::MvClipInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	mov	edx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 729  : 		}

	mov	eax, esi
	add	DWORD PTR [esi+4], 12			; 0000000cH
	pop	esi
	pop	ecx
	ret	4
??0?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@I@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 1
?_Tidy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXXZ PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ecx
	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+8]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXXZ ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebx
	mov	ebx, ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, 715827883				; 2aaaaaabH
	push	ebp
	push	esi
	push	edi
	mov	ebp, DWORD PTR [ebx+8]
	mov	edx, ebp
	mov	esi, DWORD PTR [ebx+4]
	sub	edx, esi

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	edi, DWORD PTR __Count$[esp+12]

; 1048 : 		return (this->_Myend() - this->_Mylast());

	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, edi
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	esi, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	esi

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, 357913941				; 15555555H

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN135@Reserve:
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	ebp, DWORD PTR [ebx]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebp

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edi, ecx
	xor	ecx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 357913941				; 15555555H
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	add	eax, esi
	cmp	edx, esi
	cmovae	ecx, eax
	cmp	ecx, edi
	cmovae	edi, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, ebx
	push	edi
	call	?_Reallocate@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN134@Reserve:
?_Reserve@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$dead$ = 8					; size = 4
?_Buy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAE_NI@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1562 : 		this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1563 : 		this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1564 : 		this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ; std::allocator<MVCompensate::MvClipInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	DWORD PTR [esi], eax

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	eax, DWORD PTR [esi]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR [esi+8], eax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
	pop	esi

; 1577 : 		}

	ret	4
?_Buy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Pop_back_n@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Count$ = 8						; size = 4
?_Pop_back_n@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Pop_back_n, COMDAT
; _this$ = ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	eax, DWORD PTR __Count$[esp-4]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1527 : 		{	// erase _Count elements at end

	mov	edi, ecx

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;

	mov	edx, DWORD PTR [edi+4]
	mov	esi, edx
	sub	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	ecx, esi
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1535 : 		this->_Mylast() = _Ptr;

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi

; 1536 : 		}

	ret	4
?_Pop_back_n@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXI@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Pop_back_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z PROC ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::allocate, COMDAT
; _this$dead$ = ecx

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ; std::allocator<MVCompensate::MvClipInfo>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAPAVMvClipInfo@MVCompensate@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEXXZ PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEXXZ ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
$T2 = 8							; size = 1
__Count$ = 8						; size = 4
?_Reallocate@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ecx
	push	ebx
	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	ebp, DWORD PTR __Count$[esp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	ebp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ; std::allocator<MVCompensate::MvClipInfo>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T2[esp+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T2[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	edi
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	imul	ecx

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 1
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+16]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	edx, DWORD PTR [esi+8]
	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	imul	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, edx
	sar	eax, 1
	mov	edx, eax
	shr	edx, 31					; 0000001fH
	add	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	eax, DWORD PTR [ebp*2]
	add	eax, ebp
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [esi], edi

; 1623 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
?_Reallocate@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXI@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEII@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	push	esi
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 357913941				; 15555555H
	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[esp-4]
	cmovb	eax, DWORD PTR __Count$[esp-4]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	4
?_Grow_to@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IBEII@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXPAVMvClipInfo@MVCompensate@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
?_Destroy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXPAVMvClipInfo@MVCompensate@@0@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Destroy, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp-4]
	mov	edx, DWORD PTR __Last$[esp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1582 : 		}

	ret	8
?_Destroy@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEXPAVMvClipInfo@MVCompensate@@0@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::max_size, COMDAT
; _this$dead$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 357913941				; 15555555H

; 1186 : 		}

	ret	0
?max_size@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx+4]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 357913941				; 15555555H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABQAVMvClipInfo@MVCompensate@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, DWORD PTR [ecx]
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1044 : 		}

	ret	0
?capacity@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QBEIXZ ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z PROC ; std::allocator<MVCompensate::MvClipInfo>::allocate, COMDAT
; _this$dead$ = ecx

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	ret	4
$LN14@allocate:
?allocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEPAVMvClipInfo@MVCompensate@@I@Z ENDP ; std::allocator<MVCompensate::MvClipInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z PROC ; std::allocator<MVCompensate::MvClipInfo>::deallocate, COMDAT
; _this$dead$ = ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	push	12					; 0000000cH
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	pop	ecx

; 721  : 		}

	ret	8
?deallocate@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@I@Z ENDP ; std::allocator<MVCompensate::MvClipInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MVCompensate@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MVCompensate@@@2@@Z PROC ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 357913941				; 15555555H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAIABV?$allocator@VMvClipInfo@MVCompensate@@@2@@Z ENDP ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VMvClipInfo@MVCompensate@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VMvClipInfo@MVCompensate@@@std@@QBEIXZ PROC ; std::allocator<MVCompensate::MvClipInfo>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 750  : 		}

	ret	0
?max_size@?$allocator@VMvClipInfo@MVCompensate@@@std@@QBEIXZ ENDP ; std::allocator<MVCompensate::MvClipInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ?get@?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ
_TEXT	SEGMENT
?get@?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ PROC	; SharedPtr<MVClip>::get, COMDAT
; _this$ = ecx

; 161  : 	return (_obj_ptr);

	mov	eax, DWORD PTR [ecx]

; 162  : }

	ret	0
?get@?$SharedPtr@VMVClip@@@@QBEPAVMVClip@@XZ ENDP	; SharedPtr<MVClip>::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??0?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAE@_N@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_mt_flag$ = 8						; size = 1
??0?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAE@_N@Z PROC	; MTSlicer<MVCompensate,MVCompensate,64>::MTSlicer<MVCompensate,MVCompensate,64>, COMDAT
; _this$ = ecx

; 70   : {

	sub	esp, 8
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@

; 65   : :	_avstp (AvstpWrapper::use_instance ())

	call	?use_instance@AvstpWrapper@@SAAAV1@XZ	; AvstpWrapper::use_instance
	mov	DWORD PTR [esi+8], eax

; 66   : ,	_proc_ptr (0)

	mov	DWORD PTR $T1[esp+12], 0
	mov	eax, DWORD PTR $T1[esp+12]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR $T1[esp+16], 0
	mov	eax, DWORD PTR $T1[esp+16]
	mov	DWORD PTR [esi+20], eax

; 67   : ,	_dispatcher_ptr (0)
; 68   : ,	_task_data_arr ()

	lea	eax, DWORD PTR [esi+28]
	push	1024					; 00000400H
	push	0
	push	eax
	mov	DWORD PTR [esi+24], 0
	call	_memset

; 69   : ,	_mt_flag (mt_flag)

	mov	al, BYTE PTR _mt_flag$[esp+20]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [esi+1052], al

; 71   : 	// Nothing
; 72   : }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	4
??0?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAE@_N@Z ENDP	; MTSlicer<MVCompensate,MVCompensate,64>::MTSlicer<MVCompensate,MVCompensate,64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ PROC	; MTSlicer<MVCompensate,MVCompensate,64>::~MTSlicer<MVCompensate,MVCompensate,64>, COMDAT
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx], OFFSET ??_7?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@
	je	SHORT $LN2@MTSlicer

; 88   : 	{
; 89   : 		wait ();

	call	?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ ; MTSlicer<MVCompensate,MVCompensate,64>::wait
$LN2@MTSlicer:

; 90   : 	}
; 91   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAE@XZ ENDP	; MTSlicer<MVCompensate,MVCompensate,64>::~MTSlicer<MVCompensate,MVCompensate,64>
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?start@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXHAAVMVCompensate@@P82@AEXAAVTaskData@1@@ZH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_nbr_threads$4 = -20					; size = 4
_task_data$5 = -16					; size = 16
_height$ = 8						; size = 4
_glob_data$ = 12					; size = 4
_proc_ptr$ = 16						; size = 8
_y_beg$1$ = 24						; size = 4
_min_slice_h$ = 24					; size = 4
?start@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXHAAVMVCompensate@@P82@AEXAAVTaskData@1@@ZH@Z PROC ; MTSlicer<MVCompensate,MVCompensate,64>::start, COMDAT
; _this$ = ecx

; 145  : 	assert (height > 0);
; 146  : 	assert (&glob_data != 0);
; 147  : 	assert (proc_ptr != 0);
; 148  : 	assert (min_slice_h > 0);
; 149  : 
; 150  : 	_proc_ptr = proc_ptr;

	mov	edx, DWORD PTR _proc_ptr$[esp-4]
	sub	esp, 32					; 00000020H
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _proc_ptr$[esp+40]

; 151  : 
; 152  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1052], 0
	mov	DWORD PTR [esi+16], edx
	mov	DWORD PTR [esi+20], edi
	je	$LN8@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	mov	eax, DWORD PTR [esi+8]
	push	ebx
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 132  : 	return (_avstp_get_nbr_threads_ptr ());

	mov	eax, DWORD PTR [eax+16]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	ecx, DWORD PTR _height$[esp+40]
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, 64					; 00000040H
; File c:\github\mvtools\sources\mtslicer.hpp

; 155  : 		nbr_threads = std::min (nbr_threads, int (MAXT));

	mov	DWORD PTR $T1[esp+44], 64		; 00000040H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR $T3[esp+44], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovg	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	eax, ecx
	cdq
	idiv	DWORD PTR _min_slice_h$[esp+40]

; 158  : 
; 159  : 		int				y_beg = 0;

	mov	DWORD PTR _y_beg$1$[esp+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	eax, edi
; File c:\github\mvtools\sources\mtslicer.hpp

; 156  : 		nbr_threads = std::min (nbr_threads, height / min_slice_h);

	mov	DWORD PTR $T2[esp+44], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm

; 3649 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovl	edi, eax

; 3612 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 1
	cmp	edi, eax
	cmovl	edi, eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 157  : 		nbr_threads = std::max (nbr_threads, 1);

	mov	DWORD PTR _nbr_threads$4[esp+44], edi

; 160  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN3@start

; 153  : 	{
; 154  : 		int				nbr_threads = _avstp.get_nbr_threads ();

	push	ebp
	mov	ebx, ecx
	mov	ebp, edi
	lea	ecx, DWORD PTR [esi+36]
	npad	3
$LL4@start:

; 161  : 		{
; 162  : 			const int		y_end = (t_cnt + 1) * height / nbr_threads;

	mov	eax, ebx

; 163  : 			TaskData &		task_data = _task_data_arr [t_cnt];
; 164  : 			task_data._glob_data_ptr = &glob_data;
; 165  : 			task_data._slicer_ptr    = this;

	mov	DWORD PTR [ecx-4], esi
	cdq
	lea	ecx, DWORD PTR [ecx+16]
	idiv	edi
	mov	edx, DWORD PTR _glob_data$[esp+44]
	add	ebx, DWORD PTR _height$[esp+44]
	mov	DWORD PTR [ecx-24], edx

; 166  : 			task_data._y_beg         = y_beg;

	mov	edx, DWORD PTR _y_beg$1$[esp+44]
	mov	DWORD PTR [ecx-16], edx

; 167  : 			task_data._y_end         = y_end;

	mov	DWORD PTR [ecx-12], eax

; 168  : 			y_beg = y_end;

	mov	DWORD PTR _y_beg$1$[esp+44], eax
	sub	ebp, 1
	jne	SHORT $LL4@start
	pop	ebp
$LN3@start:

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	eax, DWORD PTR [esi+8]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 118  : 	return (_avstp_create_dispatcher_ptr ());

	mov	eax, DWORD PTR [eax+8]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	mov	DWORD PTR [esi+24], eax

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	test	edi, edi
	jle	SHORT $LN40@start

; 172  : 		_dispatcher_ptr = _avstp.create_dispatcher ();

	lea	ebx, DWORD PTR [esi+28]
	npad	4
$LL7@start:

; 175  : 		{
; 176  : 			_avstp.enqueue_task (

	mov	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 139  : 	return (_avstp_enqueue_task_ptr (td_ptr, task_ptr, user_data_ptr));

	mov	ecx, DWORD PTR [esi+8]
	push	ebx
	push	OFFSET ?redirect_task@?$MTSlicer@VMVCompensate@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ; MTSlicer<MVCompensate,MVCompensate,64>::redirect_task
	push	eax
	mov	eax, DWORD PTR [ecx+20]
	call	eax
	add	esp, 12					; 0000000cH
; File c:\github\mvtools\sources\mtslicer.hpp

; 174  : 		for (int t_cnt = 0; t_cnt < nbr_threads; ++t_cnt)

	add	ebx, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL7@start
$LN40@start:
	pop	ebx
	pop	edi
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 32					; 00000020H
	ret	20					; 00000014H
$LN8@start:

; 177  : 				_dispatcher_ptr,
; 178  : 				&redirect_task,
; 179  : 				&_task_data_arr [t_cnt]
; 180  : 			);
; 181  : 		}
; 182  : 	}
; 183  : 
; 184  : 	// Multi-threading disabled
; 185  : 	else
; 186  : 	{
; 187  : 		TaskData			task_data;
; 188  : 		task_data._glob_data_ptr = &glob_data;
; 189  : 		task_data._slicer_ptr    = this;
; 190  : 		task_data._y_beg         = 0;
; 191  : 		task_data._y_end         = height;

	mov	eax, DWORD PTR _height$[esp+36]
	mov	ecx, DWORD PTR _glob_data$[esp+36]
	mov	DWORD PTR _task_data$5[esp+52], eax

; 192  : 
; 193  : 		T *				this_ptr =
; 194  : 			MTSlicer_Access <T, GD>::access (&glob_data);
; 195  : 		((*this_ptr).*(proc_ptr)) (task_data);

	lea	eax, DWORD PTR _task_data$5[esp+40]
	mov	DWORD PTR _task_data$5[esp+40], ecx
	add	ecx, edi
	push	eax
	mov	DWORD PTR _task_data$5[esp+48], esi
	mov	DWORD PTR _task_data$5[esp+52], 0
	call	edx
	pop	edi
	pop	esi

; 196  : 	}
; 197  : }

	add	esp, 32					; 00000020H
	ret	20					; 00000014H
?start@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXHAAVMVCompensate@@P82@AEXAAVTaskData@1@@ZH@Z ENDP ; MTSlicer<MVCompensate,MVCompensate,64>::start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
; File c:\github\mvtools\sources\avstpwrapper.cpp
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ PROC	; MTSlicer<MVCompensate,MVCompensate,64>::wait, COMDAT
; _this$ = ecx

; 214  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 215  : 	assert (_proc_ptr != 0);
; 216  : 
; 217  : 	if (_mt_flag)

	cmp	BYTE PTR [esi+1052], 0
	je	SHORT $LN2@wait

; 218  : 	{
; 219  : 		assert (_dispatcher_ptr != 0);
; 220  : 
; 221  : 		_avstp.wait_completion (_dispatcher_ptr);

	mov	edx, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 146  : 	return (_avstp_wait_completion_ptr (td_ptr));

	mov	eax, DWORD PTR [esi+8]
	push	edx
	mov	eax, DWORD PTR [eax+24]
	call	eax
; File c:\github\mvtools\sources\mtslicer.hpp

; 222  : 		_avstp.destroy_dispatcher (_dispatcher_ptr);

	mov	eax, DWORD PTR [esi+24]
; File c:\github\mvtools\sources\avstpwrapper.cpp

; 125  : 	_avstp_destroy_dispatcher_ptr (td_ptr);

	mov	ecx, DWORD PTR [esi+8]
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	add	esp, 8
$LN2@wait:
; File c:\github\mvtools\sources\mtslicer.hpp

; 225  : 	_proc_ptr = 0;

	mov	DWORD PTR $T1[esp+12], 0
	mov	eax, DWORD PTR $T1[esp+12]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR $T1[esp+16], 0
	mov	eax, DWORD PTR $T1[esp+16]
	mov	DWORD PTR [esi+20], eax

; 226  : 	_dispatcher_ptr = 0;

	mov	DWORD PTR [esi+24], 0
	pop	esi

; 227  : }

	add	esp, 8
	ret	0
?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ ENDP	; MTSlicer<MVCompensate,MVCompensate,64>::wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\commonfunctions.h
;	COMDAT ??$AlignNumber@H@@YAHHH@Z
_TEXT	SEGMENT
??$AlignNumber@H@@YAHHH@Z PROC				; AlignNumber<int>, COMDAT
; _n$ = ecx
; _align$dead$ = edx

; 137  :   assert(IS_POWER2(align));
; 138  :   return ALIGN_NUMBER(n, align);

	lea	eax, DWORD PTR [ecx+15]
	and	eax, -16				; fffffff0H

; 139  : }

	ret	0
??$AlignNumber@H@@YAHHH@Z ENDP				; AlignNumber<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 479  : 	{	// value-initialize _Count objects to raw _First, using _Al

	push	ecx

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >

; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Uninitialized_default_fill_n@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >,std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAVMvClipInfo@MVCompensate@@@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEPAVMvClipInfo@MVCompensate@@PAV23@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVMvClipInfo@MVCompensate@@@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEPAVMvClipInfo@MVCompensate@@PAV23@00@Z PROC ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Umove<MVCompensate::MvClipInfo *>, COMDAT
; _this$dead$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	edx, DWORD PTR __Last$[esp+4]
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Ptr$[esp+16]
	mov	ecx, DWORD PTR __First$[esp+20]
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
??$_Umove@PAVMvClipInfo@MVCompensate@@@?$vector@VMvClipInfo@MVCompensate@@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@IAEPAVMvClipInfo@MVCompensate@@PAV23@00@Z ENDP ; std::vector<MVCompensate::MvClipInfo,std::allocator<MVCompensate::MvClipInfo> >::_Umove<MVCompensate::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	ecx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T1[esp+4]
	push	ecx
	call	??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	add	esp, 12					; 0000000cH
	ret	0
??$_Destroy_range@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z PROC	; MTSlicer<MVCompensate,MVCompensate,64>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 86   : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 87   : 	if (_dispatcher_ptr != 0)

	cmp	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$MTSlicer@VMVCompensate@@V1@$0EA@@@6B@
	je	SHORT $LN5@scalar

; 88   : 	{
; 89   : 		wait ();

	call	?wait@?$MTSlicer@VMVCompensate@@V1@$0EA@@@QAEXXZ ; MTSlicer<MVCompensate,MVCompensate,64>::wait
$LN5@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	push	1056					; 00000420H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_G?$MTSlicer@VMVCompensate@@V1@$0EA@@@UAEPAXI@Z ENDP	; MTSlicer<MVCompensate,MVCompensate,64>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?access@?$MTSlicer_Access@VMVCompensate@@V1@@@SAPAVMVCompensate@@PAV2@@Z
_TEXT	SEGMENT
?access@?$MTSlicer_Access@VMVCompensate@@V1@@@SAPAVMVCompensate@@PAV2@@Z PROC ; MTSlicer_Access<MVCompensate,MVCompensate>::access, COMDAT
; _ptr$ = ecx

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	eax, ecx
	ret	0
?access@?$MTSlicer_Access@VMVCompensate@@V1@@@SAPAVMVCompensate@@PAV2@@Z ENDP ; MTSlicer_Access<MVCompensate,MVCompensate>::access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >::_Vector_val<std::_Simple_types<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VMvClipInfo@MVCompensate@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VMvClipInfo@MVCompensate@@@std@@QAE@XZ PROC ; std::allocator<MVCompensate::MvClipInfo>::allocator<MVCompensate::MvClipInfo>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@VMvClipInfo@MVCompensate@@@std@@QAE@XZ ENDP ; std::allocator<MVCompensate::MvClipInfo>::allocator<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\mtslicer.hpp
;	COMDAT ?redirect_task@?$MTSlicer@VMVCompensate@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z
_TEXT	SEGMENT
_dispatcher_ptr$ = 8					; size = 4
_data_ptr$ = 12						; size = 4
?redirect_task@?$MTSlicer@VMVCompensate@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z PROC ; MTSlicer<MVCompensate,MVCompensate,64>::redirect_task, COMDAT

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	ecx, DWORD PTR _data_ptr$[esp-4]
	push	esi

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	push	ecx
	mov	eax, DWORD PTR [ecx+4]

; 44   : 	static inline T *	access (T *ptr) { return (ptr); }

	mov	edx, DWORD PTR [ecx]

; 268  : 	TaskData *		td_ptr   = reinterpret_cast <TaskData *> (data_ptr);
; 269  : 	assert (td_ptr != 0);
; 270  : 	assert (td_ptr->_glob_data_ptr != 0);
; 271  : 	assert (td_ptr->_slicer_ptr != 0);
; 272  : 
; 273  : 	T *				this_ptr =
; 274  : 		MTSlicer_Access <T, GD>::access (td_ptr->_glob_data_ptr);
; 275  : 	assert (this_ptr != 0);
; 276  : 
; 277  : 	ProcPtr			proc_ptr = td_ptr->_slicer_ptr->_proc_ptr;

	mov	esi, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]

; 278  : 	assert (proc_ptr != 0);
; 279  : 
; 280  : 	((*this_ptr).*(proc_ptr)) (*td_ptr);

	lea	ecx, DWORD PTR [eax+edx]
	call	esi
	pop	esi

; 281  : }

	ret	0
?redirect_task@?$MTSlicer@VMVCompensate@@V1@$0EA@@@CAXPAVTaskDispatcher@avstp@@PAX@Z ENDP ; MTSlicer<MVCompensate,MVCompensate,64>::redirect_task
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\conc\array.hpp
;	COMDAT ??A?$Array@VTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@J@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
??A?$Array@VTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@J@Z PROC ; conc::Array<MTSlicer<MVCompensate,MVCompensate,64>::TaskData,64>::operator[], COMDAT
; _this$ = ecx

; 52   : 	assert (pos >= 0);
; 53   : 	assert (pos < LENGTH);
; 54   : 
; 55   : 	return (_data [pos]);

	mov	eax, DWORD PTR _pos$[esp-4]
	shl	eax, 4
	add	eax, ecx

; 56   : }

	ret	4
??A?$Array@VTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@$0EA@@conc@@QAEAAVTaskData@?$MTSlicer@VMVCompensate@@V1@$0EA@@@J@Z ENDP ; conc::Array<MTSlicer<MVCompensate,MVCompensate,64>::TaskData,64>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	test	edx, edx
	je	SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN19@Uninitiali
	xorps	xmm0, xmm0
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], 0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [ecx+4], 0
$LN19@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 457  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	ecx, 12					; 0000000cH
	sub	edx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 458  : 		_Al.construct(_Unfancy(_First));
; 459  : 	_CATCH_ALL
; 460  : 	_Destroy_range(_Next, _First, _Al);
; 461  : 	_RERAISE;
; 462  : 	_CATCH_END
; 463  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAVMvClipInfo@MVCompensate@@IV?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAXPAVMvClipInfo@MVCompensate@@IAAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<MVCompensate::MvClipInfo *,unsigned int,std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z PROC ; std::_Uninitialized_move<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	push	edi
	mov	edi, edx

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	ecx, edi
	je	SHORT $LN3@Destroy_ra
	push	esi
	lea	esi, DWORD PTR [ecx+4]
	npad	5
$LL4@Destroy_ra:
; File c:\github\mvtools\sources\sharedptr.hpp

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi-4], 0
	je	SHORT $LN26@Destroy_ra

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN26@Destroy_ra

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi-4]
	test	ecx, ecx
	je	SHORT $LN28@Destroy_ra
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN28@Destroy_ra:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi]
	mov	DWORD PTR [esi-4], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi], 0
$LN26@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	add	esi, 12					; 0000000cH
	lea	eax, DWORD PTR [esi-4]
	cmp	eax, edi
	jne	SHORT $LL4@Destroy_ra
	pop	esi
$LN3@Destroy_ra:
	pop	edi

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@VMvClipInfo@MVCompensate@@@std@@PAVMvClipInfo@MVCompensate@@@std@@YAXPAVMvClipInfo@MVCompensate@@0AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<MVCompensate::MvClipInfo>,MVCompensate::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@VMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z PROC ; std::_Unfancy<MVCompensate::MvClipInfo>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@VMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z ENDP ; std::_Unfancy<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MVCompensate@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VMvClipInfo@MVCompensate@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z PROC ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN7@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [eax], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [eax+4], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	4
??$construct@VMvClipInfo@MVCompensate@@$$V@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAVMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAVMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z PROC ; std::_Unchecked<MVCompensate::MvClipInfo *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAVMvClipInfo@MVCompensate@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@@Z ENDP ; std::_Unchecked<MVCompensate::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	sub	esp, 8

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	mov	BYTE PTR $T1[esp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	push	DWORD PTR $T1[esp+12]
	push	ecx
	push	DWORD PTR __Dest$[esp+16]
	call	??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_move_al_unchecked@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAVMvClipInfo@MVCompensate@@PAV12@@std@@YAAAPAVMvClipInfo@MVCompensate@@AAPAV12@PAV12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAVMvClipInfo@MVCompensate@@PAV12@@std@@YAAAPAVMvClipInfo@MVCompensate@@AAPAV12@PAV12@@Z PROC ; std::_Rechecked<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAVMvClipInfo@MVCompensate@@PAV12@@std@@YAAAPAVMvClipInfo@MVCompensate@@AAPAV12@PAV12@@Z ENDP ; std::_Rechecked<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VMvClipInfo@MVCompensate@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VMvClipInfo@MVCompensate@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z PROC ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::destroy<MVCompensate::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	esi
; File c:\github\mvtools\sources\sharedptr.hpp

; 284  : 	if (_obj_ptr != 0)

	mov	esi, DWORD PTR __Ptr$[esp]
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN19@destroy

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN19@destroy

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN21@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN21@destroy:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN19@destroy:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	ret	4
??$destroy@VMvClipInfo@MVCompensate@@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::destroy<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z
_TEXT	SEGMENT
??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z PROC ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN5@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], 0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [edx], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [edx+4], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z ENDP ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@VMvClipInfo@MVCompensate@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MVCompensate@@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@VMvClipInfo@MVCompensate@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MVCompensate@@0@Z PROC ; std::_Ptr_move_cat<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 810  : 	return {};

	xor	al, al

; 811  : 	}

	ret	0
??$_Ptr_move_cat@VMvClipInfo@MVCompensate@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAVMvClipInfo@MVCompensate@@0@Z ENDP ; std::_Ptr_move_cat<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[esp-4]
	push	esi
	mov	esi, ecx
	cmp	esi, edx
	je	SHORT $LN3@Uninitiali
	npad	5
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN28@Uninitiali
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 56   : ,	_count_ptr (other._count_ptr)

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx

; 259  : 	if (_count_ptr != 0)

	test	ecx, ecx
	je	SHORT $LN40@Uninitiali

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [ecx]
$LN40@Uninitiali:
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
$LN28@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	esi, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	esi, edx
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	esi

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);
; 285  : 	}

	ret	0
??$_Uninitialized_move_al_unchecked1@PAVMvClipInfo@MVCompensate@@PAV12@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@YAPAVMvClipInfo@MVCompensate@@PAV12@00AAU?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<MVCompensate::MvClipInfo *,MVCompensate::MvClipInfo *,std::allocator<MVCompensate::MvClipInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VMvClipInfo@MVCompensate@@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z
_TEXT	SEGMENT
??$destroy@VMvClipInfo@MVCompensate@@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z PROC ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::destroy<MVCompensate::MvClipInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 863  : 		{	// destroy object at _Ptr

	push	esi
	mov	esi, edx
; File c:\github\mvtools\sources\sharedptr.hpp

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN17@destroy

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@destroy

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN19@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN19@destroy:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN17@destroy:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	ret	0
??$destroy@VMvClipInfo@MVCompensate@@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@@Z ENDP ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::destroy<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAVMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z
_TEXT	SEGMENT
??$move@AAVMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z PROC ; std::move<MVCompensate::MvClipInfo &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAVMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z ENDP ; std::move<MVCompensate::MvClipInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z PROC ; std::allocator<MVCompensate::MvClipInfo>::construct<MVCompensate::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@construct
	xorps	xmm0, xmm0
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], 0
; File c:\github\mvtools\sources\sharedptr.hpp

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [eax], 0

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [eax+4], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	4
??$construct@VMvClipInfo@MVCompensate@@$$V@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ENDP ; std::allocator<MVCompensate::MvClipInfo>::construct<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MVCompensate@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VMvClipInfo@MVCompensate@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN13@construct
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN25@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN25@construct:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	8
??$construct@VMvClipInfo@MVCompensate@@V12@@?$_Wrap_alloc@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VMvClipInfo@MVCompensate@@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VMvClipInfo@MVCompensate@@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z PROC ; std::allocator<MVCompensate::MvClipInfo>::destroy<MVCompensate::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	esi
; File c:\github\mvtools\sources\sharedptr.hpp

; 284  : 	if (_obj_ptr != 0)

	mov	esi, DWORD PTR __Ptr$[esp]
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN15@destroy

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN15@destroy

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN17@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN17@destroy:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN15@destroy:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	ret	4
??$destroy@VMvClipInfo@MVCompensate@@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@@Z ENDP ; std::allocator<MVCompensate::MvClipInfo>::destroy<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0MvClipInfo@MVCompensate@@QAE@XZ
_TEXT	SEGMENT
??0MvClipInfo@MVCompensate@@QAE@XZ PROC			; MVCompensate::MvClipInfo::MvClipInfo, COMDAT
; _this$ = ecx

; 35   : :	_obj_ptr (0)

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx

; 36   : ,	_count_ptr (0)

	mov	DWORD PTR [ecx+4], 0
	ret	0
??0MvClipInfo@MVCompensate@@QAE@XZ ENDP			; MVCompensate::MvClipInfo::MvClipInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??_GMvClipInfo@MVCompensate@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GMvClipInfo@MVCompensate@@QAEPAXI@Z PROC		; MVCompensate::MvClipInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN17@scalar

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@scalar

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN14@scalar
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN14@scalar:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN17@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GMvClipInfo@MVCompensate@@QAEPAXI@Z ENDP		; MVCompensate::MvClipInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??1MvClipInfo@MVCompensate@@QAE@XZ
_TEXT	SEGMENT
??1MvClipInfo@MVCompensate@@QAE@XZ PROC			; MVCompensate::MvClipInfo::~MvClipInfo, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 284  : 	if (_obj_ptr != 0)

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN8@MvClipInfo

; 285  : 	{
; 286  : 		-- *_count_ptr;

	mov	eax, DWORD PTR [esi+4]
	dec	DWORD PTR [eax]

; 287  : 		
; 288  : 		if (*_count_ptr == 0)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@MvClipInfo

; 289  : 		{
; 290  : 			delete _obj_ptr;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN10@MvClipInfo
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+24]
$LN10@MvClipInfo:

; 291  : 			_obj_ptr = 0;
; 292  : 
; 293  : 			delete _count_ptr;

	push	4
	push	DWORD PTR [esi+4]
	mov	DWORD PTR [esi], 0
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 294  : 			_count_ptr = 0;

	mov	DWORD PTR [esi+4], 0
$LN8@MvClipInfo:
	pop	esi
	ret	0
??1MvClipInfo@MVCompensate@@QAE@XZ ENDP			; MVCompensate::MvClipInfo::~MvClipInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@VMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z
_TEXT	SEGMENT
??$forward@VMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z PROC ; std::forward<MVCompensate::MvClipInfo>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@VMvClipInfo@MVCompensate@@@std@@YA$$QAVMvClipInfo@MVCompensate@@AAV12@@Z ENDP ; std::forward<MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@$$QAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@$$QAV34@@Z PROC ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN20@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN20@construct:
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator_traits@V?$allocator@VMvClipInfo@MVCompensate@@@std@@@std@@SAXAAV?$allocator@VMvClipInfo@MVCompensate@@@1@PAVMvClipInfo@MVCompensate@@$$QAV34@@Z ENDP ; std::allocator_traits<std::allocator<MVCompensate::MvClipInfo> >::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\github\mvtools\sources\sharedptr.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z PROC ; std::allocator<MVCompensate::MvClipInfo>::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>, COMDAT
; _this$dead$ = ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@construct
; File c:\github\mvtools\sources\sharedptr.hpp

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR _<_Args_0>$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN15@construct

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN15@construct:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	8
??$construct@VMvClipInfo@MVCompensate@@V12@@?$allocator@VMvClipInfo@MVCompensate@@@std@@QAEXPAVMvClipInfo@MVCompensate@@$$QAV23@@Z ENDP ; std::allocator<MVCompensate::MvClipInfo>::construct<MVCompensate::MvClipInfo,MVCompensate::MvClipInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\github\mvtools\sources\sharedptr.hpp
;	COMDAT ??0MvClipInfo@MVCompensate@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0MvClipInfo@MVCompensate@@QAE@$$QAV01@@Z PROC		; MVCompensate::MvClipInfo::MvClipInfo, COMDAT
; _this$ = ecx

; 55   : :	_obj_ptr (other._obj_ptr)

	mov	edx, DWORD PTR ___that$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 56   : ,	_count_ptr (other._count_ptr)

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 259  : 	if (_count_ptr != 0)

	test	eax, eax
	je	SHORT $LN6@MvClipInfo

; 260  : 	{
; 261  : 		++ *_count_ptr;

	inc	DWORD PTR [eax]
$LN6@MvClipInfo:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	4
??0MvClipInfo@MVCompensate@@QAE@$$QAV01@@Z ENDP		; MVCompensate::MvClipInfo::MvClipInfo
_TEXT	ENDS
END
